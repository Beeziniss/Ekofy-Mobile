import 'dart:core';

class Input$AddToPlaylistRequestInput {
  factory Input$AddToPlaylistRequestInput({
    required String trackId,
    String? playlistId,
    String? playlistName,
  }) => Input$AddToPlaylistRequestInput._({
    r'trackId': trackId,
    if (playlistId != null) r'playlistId': playlistId,
    if (playlistName != null) r'playlistName': playlistName,
  });

  Input$AddToPlaylistRequestInput._(this._$data);

  factory Input$AddToPlaylistRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$trackId = data['trackId'];
    result$data['trackId'] = (l$trackId as String);
    if (data.containsKey('playlistId')) {
      final l$playlistId = data['playlistId'];
      result$data['playlistId'] = (l$playlistId as String?);
    }
    if (data.containsKey('playlistName')) {
      final l$playlistName = data['playlistName'];
      result$data['playlistName'] = (l$playlistName as String?);
    }
    return Input$AddToPlaylistRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get trackId => (_$data['trackId'] as String);

  String? get playlistId => (_$data['playlistId'] as String?);

  String? get playlistName => (_$data['playlistName'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$trackId = trackId;
    result$data['trackId'] = l$trackId;
    if (_$data.containsKey('playlistId')) {
      final l$playlistId = playlistId;
      result$data['playlistId'] = l$playlistId;
    }
    if (_$data.containsKey('playlistName')) {
      final l$playlistName = playlistName;
      result$data['playlistName'] = l$playlistName;
    }
    return result$data;
  }

  CopyWith$Input$AddToPlaylistRequestInput<Input$AddToPlaylistRequestInput>
  get copyWith => CopyWith$Input$AddToPlaylistRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddToPlaylistRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$playlistId = playlistId;
    final lOther$playlistId = other.playlistId;
    if (_$data.containsKey('playlistId') !=
        other._$data.containsKey('playlistId')) {
      return false;
    }
    if (l$playlistId != lOther$playlistId) {
      return false;
    }
    final l$playlistName = playlistName;
    final lOther$playlistName = other.playlistName;
    if (_$data.containsKey('playlistName') !=
        other._$data.containsKey('playlistName')) {
      return false;
    }
    if (l$playlistName != lOther$playlistName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$trackId = trackId;
    final l$playlistId = playlistId;
    final l$playlistName = playlistName;
    return Object.hashAll([
      l$trackId,
      _$data.containsKey('playlistId') ? l$playlistId : const {},
      _$data.containsKey('playlistName') ? l$playlistName : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddToPlaylistRequestInput<TRes> {
  factory CopyWith$Input$AddToPlaylistRequestInput(
    Input$AddToPlaylistRequestInput instance,
    TRes Function(Input$AddToPlaylistRequestInput) then,
  ) = _CopyWithImpl$Input$AddToPlaylistRequestInput;

  factory CopyWith$Input$AddToPlaylistRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddToPlaylistRequestInput;

  TRes call({String? trackId, String? playlistId, String? playlistName});
}

class _CopyWithImpl$Input$AddToPlaylistRequestInput<TRes>
    implements CopyWith$Input$AddToPlaylistRequestInput<TRes> {
  _CopyWithImpl$Input$AddToPlaylistRequestInput(this._instance, this._then);

  final Input$AddToPlaylistRequestInput _instance;

  final TRes Function(Input$AddToPlaylistRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? trackId = _undefined,
    Object? playlistId = _undefined,
    Object? playlistName = _undefined,
  }) => _then(
    Input$AddToPlaylistRequestInput._({
      ..._instance._$data,
      if (trackId != _undefined && trackId != null)
        'trackId': (trackId as String),
      if (playlistId != _undefined) 'playlistId': (playlistId as String?),
      if (playlistName != _undefined) 'playlistName': (playlistName as String?),
    }),
  );
}

class _CopyWithStubImpl$Input$AddToPlaylistRequestInput<TRes>
    implements CopyWith$Input$AddToPlaylistRequestInput<TRes> {
  _CopyWithStubImpl$Input$AddToPlaylistRequestInput(this._res);

  TRes _res;

  call({String? trackId, String? playlistId, String? playlistName}) => _res;
}

class Input$AddTrackToAlbumRequestInput {
  factory Input$AddTrackToAlbumRequestInput({
    required String trackId,
    String? albumId,
    String? albumName,
  }) => Input$AddTrackToAlbumRequestInput._({
    r'trackId': trackId,
    if (albumId != null) r'albumId': albumId,
    if (albumName != null) r'albumName': albumName,
  });

  Input$AddTrackToAlbumRequestInput._(this._$data);

  factory Input$AddTrackToAlbumRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$trackId = data['trackId'];
    result$data['trackId'] = (l$trackId as String);
    if (data.containsKey('albumId')) {
      final l$albumId = data['albumId'];
      result$data['albumId'] = (l$albumId as String?);
    }
    if (data.containsKey('albumName')) {
      final l$albumName = data['albumName'];
      result$data['albumName'] = (l$albumName as String?);
    }
    return Input$AddTrackToAlbumRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get trackId => (_$data['trackId'] as String);

  String? get albumId => (_$data['albumId'] as String?);

  String? get albumName => (_$data['albumName'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$trackId = trackId;
    result$data['trackId'] = l$trackId;
    if (_$data.containsKey('albumId')) {
      final l$albumId = albumId;
      result$data['albumId'] = l$albumId;
    }
    if (_$data.containsKey('albumName')) {
      final l$albumName = albumName;
      result$data['albumName'] = l$albumName;
    }
    return result$data;
  }

  CopyWith$Input$AddTrackToAlbumRequestInput<Input$AddTrackToAlbumRequestInput>
  get copyWith => CopyWith$Input$AddTrackToAlbumRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddTrackToAlbumRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$albumId = albumId;
    final lOther$albumId = other.albumId;
    if (_$data.containsKey('albumId') != other._$data.containsKey('albumId')) {
      return false;
    }
    if (l$albumId != lOther$albumId) {
      return false;
    }
    final l$albumName = albumName;
    final lOther$albumName = other.albumName;
    if (_$data.containsKey('albumName') !=
        other._$data.containsKey('albumName')) {
      return false;
    }
    if (l$albumName != lOther$albumName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$trackId = trackId;
    final l$albumId = albumId;
    final l$albumName = albumName;
    return Object.hashAll([
      l$trackId,
      _$data.containsKey('albumId') ? l$albumId : const {},
      _$data.containsKey('albumName') ? l$albumName : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddTrackToAlbumRequestInput<TRes> {
  factory CopyWith$Input$AddTrackToAlbumRequestInput(
    Input$AddTrackToAlbumRequestInput instance,
    TRes Function(Input$AddTrackToAlbumRequestInput) then,
  ) = _CopyWithImpl$Input$AddTrackToAlbumRequestInput;

  factory CopyWith$Input$AddTrackToAlbumRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddTrackToAlbumRequestInput;

  TRes call({String? trackId, String? albumId, String? albumName});
}

class _CopyWithImpl$Input$AddTrackToAlbumRequestInput<TRes>
    implements CopyWith$Input$AddTrackToAlbumRequestInput<TRes> {
  _CopyWithImpl$Input$AddTrackToAlbumRequestInput(this._instance, this._then);

  final Input$AddTrackToAlbumRequestInput _instance;

  final TRes Function(Input$AddTrackToAlbumRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? trackId = _undefined,
    Object? albumId = _undefined,
    Object? albumName = _undefined,
  }) => _then(
    Input$AddTrackToAlbumRequestInput._({
      ..._instance._$data,
      if (trackId != _undefined && trackId != null)
        'trackId': (trackId as String),
      if (albumId != _undefined) 'albumId': (albumId as String?),
      if (albumName != _undefined) 'albumName': (albumName as String?),
    }),
  );
}

class _CopyWithStubImpl$Input$AddTrackToAlbumRequestInput<TRes>
    implements CopyWith$Input$AddTrackToAlbumRequestInput<TRes> {
  _CopyWithStubImpl$Input$AddTrackToAlbumRequestInput(this._res);

  TRes _res;

  call({String? trackId, String? albumId, String? albumName}) => _res;
}

class Input$AddressFilterInput {
  factory Input$AddressFilterInput({
    List<Input$AddressFilterInput>? and,
    List<Input$AddressFilterInput>? or,
    Input$StringOperationFilterInput? street,
    Input$StringOperationFilterInput? ward,
    Input$StringOperationFilterInput? province,
    Input$StringOperationFilterInput? oldDistrict,
    Input$StringOperationFilterInput? oldWard,
    Input$StringOperationFilterInput? oldProvince,
    Input$StringOperationFilterInput? addressLine,
  }) => Input$AddressFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (street != null) r'street': street,
    if (ward != null) r'ward': ward,
    if (province != null) r'province': province,
    if (oldDistrict != null) r'oldDistrict': oldDistrict,
    if (oldWard != null) r'oldWard': oldWard,
    if (oldProvince != null) r'oldProvince': oldProvince,
    if (addressLine != null) r'addressLine': addressLine,
  });

  Input$AddressFilterInput._(this._$data);

  factory Input$AddressFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$AddressFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$AddressFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('street')) {
      final l$street = data['street'];
      result$data['street'] = l$street == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$street as Map<String, dynamic>),
            );
    }
    if (data.containsKey('ward')) {
      final l$ward = data['ward'];
      result$data['ward'] = l$ward == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$ward as Map<String, dynamic>),
            );
    }
    if (data.containsKey('province')) {
      final l$province = data['province'];
      result$data['province'] = l$province == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$province as Map<String, dynamic>),
            );
    }
    if (data.containsKey('oldDistrict')) {
      final l$oldDistrict = data['oldDistrict'];
      result$data['oldDistrict'] = l$oldDistrict == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$oldDistrict as Map<String, dynamic>),
            );
    }
    if (data.containsKey('oldWard')) {
      final l$oldWard = data['oldWard'];
      result$data['oldWard'] = l$oldWard == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$oldWard as Map<String, dynamic>),
            );
    }
    if (data.containsKey('oldProvince')) {
      final l$oldProvince = data['oldProvince'];
      result$data['oldProvince'] = l$oldProvince == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$oldProvince as Map<String, dynamic>),
            );
    }
    if (data.containsKey('addressLine')) {
      final l$addressLine = data['addressLine'];
      result$data['addressLine'] = l$addressLine == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$addressLine as Map<String, dynamic>),
            );
    }
    return Input$AddressFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$AddressFilterInput>? get and =>
      (_$data['and'] as List<Input$AddressFilterInput>?);

  List<Input$AddressFilterInput>? get or =>
      (_$data['or'] as List<Input$AddressFilterInput>?);

  Input$StringOperationFilterInput? get street =>
      (_$data['street'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get ward =>
      (_$data['ward'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get province =>
      (_$data['province'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get oldDistrict =>
      (_$data['oldDistrict'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get oldWard =>
      (_$data['oldWard'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get oldProvince =>
      (_$data['oldProvince'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get addressLine =>
      (_$data['addressLine'] as Input$StringOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('street')) {
      final l$street = street;
      result$data['street'] = l$street?.toJson();
    }
    if (_$data.containsKey('ward')) {
      final l$ward = ward;
      result$data['ward'] = l$ward?.toJson();
    }
    if (_$data.containsKey('province')) {
      final l$province = province;
      result$data['province'] = l$province?.toJson();
    }
    if (_$data.containsKey('oldDistrict')) {
      final l$oldDistrict = oldDistrict;
      result$data['oldDistrict'] = l$oldDistrict?.toJson();
    }
    if (_$data.containsKey('oldWard')) {
      final l$oldWard = oldWard;
      result$data['oldWard'] = l$oldWard?.toJson();
    }
    if (_$data.containsKey('oldProvince')) {
      final l$oldProvince = oldProvince;
      result$data['oldProvince'] = l$oldProvince?.toJson();
    }
    if (_$data.containsKey('addressLine')) {
      final l$addressLine = addressLine;
      result$data['addressLine'] = l$addressLine?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AddressFilterInput<Input$AddressFilterInput> get copyWith =>
      CopyWith$Input$AddressFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddressFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$street = street;
    final lOther$street = other.street;
    if (_$data.containsKey('street') != other._$data.containsKey('street')) {
      return false;
    }
    if (l$street != lOther$street) {
      return false;
    }
    final l$ward = ward;
    final lOther$ward = other.ward;
    if (_$data.containsKey('ward') != other._$data.containsKey('ward')) {
      return false;
    }
    if (l$ward != lOther$ward) {
      return false;
    }
    final l$province = province;
    final lOther$province = other.province;
    if (_$data.containsKey('province') !=
        other._$data.containsKey('province')) {
      return false;
    }
    if (l$province != lOther$province) {
      return false;
    }
    final l$oldDistrict = oldDistrict;
    final lOther$oldDistrict = other.oldDistrict;
    if (_$data.containsKey('oldDistrict') !=
        other._$data.containsKey('oldDistrict')) {
      return false;
    }
    if (l$oldDistrict != lOther$oldDistrict) {
      return false;
    }
    final l$oldWard = oldWard;
    final lOther$oldWard = other.oldWard;
    if (_$data.containsKey('oldWard') != other._$data.containsKey('oldWard')) {
      return false;
    }
    if (l$oldWard != lOther$oldWard) {
      return false;
    }
    final l$oldProvince = oldProvince;
    final lOther$oldProvince = other.oldProvince;
    if (_$data.containsKey('oldProvince') !=
        other._$data.containsKey('oldProvince')) {
      return false;
    }
    if (l$oldProvince != lOther$oldProvince) {
      return false;
    }
    final l$addressLine = addressLine;
    final lOther$addressLine = other.addressLine;
    if (_$data.containsKey('addressLine') !=
        other._$data.containsKey('addressLine')) {
      return false;
    }
    if (l$addressLine != lOther$addressLine) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$street = street;
    final l$ward = ward;
    final l$province = province;
    final l$oldDistrict = oldDistrict;
    final l$oldWard = oldWard;
    final l$oldProvince = oldProvince;
    final l$addressLine = addressLine;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('street') ? l$street : const {},
      _$data.containsKey('ward') ? l$ward : const {},
      _$data.containsKey('province') ? l$province : const {},
      _$data.containsKey('oldDistrict') ? l$oldDistrict : const {},
      _$data.containsKey('oldWard') ? l$oldWard : const {},
      _$data.containsKey('oldProvince') ? l$oldProvince : const {},
      _$data.containsKey('addressLine') ? l$addressLine : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddressFilterInput<TRes> {
  factory CopyWith$Input$AddressFilterInput(
    Input$AddressFilterInput instance,
    TRes Function(Input$AddressFilterInput) then,
  ) = _CopyWithImpl$Input$AddressFilterInput;

  factory CopyWith$Input$AddressFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddressFilterInput;

  TRes call({
    List<Input$AddressFilterInput>? and,
    List<Input$AddressFilterInput>? or,
    Input$StringOperationFilterInput? street,
    Input$StringOperationFilterInput? ward,
    Input$StringOperationFilterInput? province,
    Input$StringOperationFilterInput? oldDistrict,
    Input$StringOperationFilterInput? oldWard,
    Input$StringOperationFilterInput? oldProvince,
    Input$StringOperationFilterInput? addressLine,
  });
  TRes and(
    Iterable<Input$AddressFilterInput>? Function(
      Iterable<CopyWith$Input$AddressFilterInput<Input$AddressFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$AddressFilterInput>? Function(
      Iterable<CopyWith$Input$AddressFilterInput<Input$AddressFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get street;
  CopyWith$Input$StringOperationFilterInput<TRes> get ward;
  CopyWith$Input$StringOperationFilterInput<TRes> get province;
  CopyWith$Input$StringOperationFilterInput<TRes> get oldDistrict;
  CopyWith$Input$StringOperationFilterInput<TRes> get oldWard;
  CopyWith$Input$StringOperationFilterInput<TRes> get oldProvince;
  CopyWith$Input$StringOperationFilterInput<TRes> get addressLine;
}

class _CopyWithImpl$Input$AddressFilterInput<TRes>
    implements CopyWith$Input$AddressFilterInput<TRes> {
  _CopyWithImpl$Input$AddressFilterInput(this._instance, this._then);

  final Input$AddressFilterInput _instance;

  final TRes Function(Input$AddressFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? street = _undefined,
    Object? ward = _undefined,
    Object? province = _undefined,
    Object? oldDistrict = _undefined,
    Object? oldWard = _undefined,
    Object? oldProvince = _undefined,
    Object? addressLine = _undefined,
  }) => _then(
    Input$AddressFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$AddressFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$AddressFilterInput>?),
      if (street != _undefined)
        'street': (street as Input$StringOperationFilterInput?),
      if (ward != _undefined)
        'ward': (ward as Input$StringOperationFilterInput?),
      if (province != _undefined)
        'province': (province as Input$StringOperationFilterInput?),
      if (oldDistrict != _undefined)
        'oldDistrict': (oldDistrict as Input$StringOperationFilterInput?),
      if (oldWard != _undefined)
        'oldWard': (oldWard as Input$StringOperationFilterInput?),
      if (oldProvince != _undefined)
        'oldProvince': (oldProvince as Input$StringOperationFilterInput?),
      if (addressLine != _undefined)
        'addressLine': (addressLine as Input$StringOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$AddressFilterInput>? Function(
      Iterable<CopyWith$Input$AddressFilterInput<Input$AddressFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$AddressFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$AddressFilterInput>? Function(
      Iterable<CopyWith$Input$AddressFilterInput<Input$AddressFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$AddressFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get street {
    final local$street = _instance.street;
    return local$street == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$street,
            (e) => call(street: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get ward {
    final local$ward = _instance.ward;
    return local$ward == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$ward,
            (e) => call(ward: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get province {
    final local$province = _instance.province;
    return local$province == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$province,
            (e) => call(province: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get oldDistrict {
    final local$oldDistrict = _instance.oldDistrict;
    return local$oldDistrict == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$oldDistrict,
            (e) => call(oldDistrict: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get oldWard {
    final local$oldWard = _instance.oldWard;
    return local$oldWard == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$oldWard,
            (e) => call(oldWard: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get oldProvince {
    final local$oldProvince = _instance.oldProvince;
    return local$oldProvince == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$oldProvince,
            (e) => call(oldProvince: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get addressLine {
    final local$addressLine = _instance.addressLine;
    return local$addressLine == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$addressLine,
            (e) => call(addressLine: e),
          );
  }
}

class _CopyWithStubImpl$Input$AddressFilterInput<TRes>
    implements CopyWith$Input$AddressFilterInput<TRes> {
  _CopyWithStubImpl$Input$AddressFilterInput(this._res);

  TRes _res;

  call({
    List<Input$AddressFilterInput>? and,
    List<Input$AddressFilterInput>? or,
    Input$StringOperationFilterInput? street,
    Input$StringOperationFilterInput? ward,
    Input$StringOperationFilterInput? province,
    Input$StringOperationFilterInput? oldDistrict,
    Input$StringOperationFilterInput? oldWard,
    Input$StringOperationFilterInput? oldProvince,
    Input$StringOperationFilterInput? addressLine,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get street =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get ward =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get province =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get oldDistrict =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get oldWard =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get oldProvince =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get addressLine =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
}

class Input$AddressInput {
  factory Input$AddressInput({
    String? street,
    String? ward,
    String? province,
    String? oldDistrict,
    String? oldWard,
    String? oldProvince,
    String? addressLine,
  }) => Input$AddressInput._({
    if (street != null) r'street': street,
    if (ward != null) r'ward': ward,
    if (province != null) r'province': province,
    if (oldDistrict != null) r'oldDistrict': oldDistrict,
    if (oldWard != null) r'oldWard': oldWard,
    if (oldProvince != null) r'oldProvince': oldProvince,
    if (addressLine != null) r'addressLine': addressLine,
  });

  Input$AddressInput._(this._$data);

  factory Input$AddressInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('street')) {
      final l$street = data['street'];
      result$data['street'] = (l$street as String?);
    }
    if (data.containsKey('ward')) {
      final l$ward = data['ward'];
      result$data['ward'] = (l$ward as String?);
    }
    if (data.containsKey('province')) {
      final l$province = data['province'];
      result$data['province'] = (l$province as String?);
    }
    if (data.containsKey('oldDistrict')) {
      final l$oldDistrict = data['oldDistrict'];
      result$data['oldDistrict'] = (l$oldDistrict as String?);
    }
    if (data.containsKey('oldWard')) {
      final l$oldWard = data['oldWard'];
      result$data['oldWard'] = (l$oldWard as String?);
    }
    if (data.containsKey('oldProvince')) {
      final l$oldProvince = data['oldProvince'];
      result$data['oldProvince'] = (l$oldProvince as String?);
    }
    if (data.containsKey('addressLine')) {
      final l$addressLine = data['addressLine'];
      result$data['addressLine'] = (l$addressLine as String?);
    }
    return Input$AddressInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get street => (_$data['street'] as String?);

  String? get ward => (_$data['ward'] as String?);

  String? get province => (_$data['province'] as String?);

  String? get oldDistrict => (_$data['oldDistrict'] as String?);

  String? get oldWard => (_$data['oldWard'] as String?);

  String? get oldProvince => (_$data['oldProvince'] as String?);

  String? get addressLine => (_$data['addressLine'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('street')) {
      final l$street = street;
      result$data['street'] = l$street;
    }
    if (_$data.containsKey('ward')) {
      final l$ward = ward;
      result$data['ward'] = l$ward;
    }
    if (_$data.containsKey('province')) {
      final l$province = province;
      result$data['province'] = l$province;
    }
    if (_$data.containsKey('oldDistrict')) {
      final l$oldDistrict = oldDistrict;
      result$data['oldDistrict'] = l$oldDistrict;
    }
    if (_$data.containsKey('oldWard')) {
      final l$oldWard = oldWard;
      result$data['oldWard'] = l$oldWard;
    }
    if (_$data.containsKey('oldProvince')) {
      final l$oldProvince = oldProvince;
      result$data['oldProvince'] = l$oldProvince;
    }
    if (_$data.containsKey('addressLine')) {
      final l$addressLine = addressLine;
      result$data['addressLine'] = l$addressLine;
    }
    return result$data;
  }

  CopyWith$Input$AddressInput<Input$AddressInput> get copyWith =>
      CopyWith$Input$AddressInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddressInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$street = street;
    final lOther$street = other.street;
    if (_$data.containsKey('street') != other._$data.containsKey('street')) {
      return false;
    }
    if (l$street != lOther$street) {
      return false;
    }
    final l$ward = ward;
    final lOther$ward = other.ward;
    if (_$data.containsKey('ward') != other._$data.containsKey('ward')) {
      return false;
    }
    if (l$ward != lOther$ward) {
      return false;
    }
    final l$province = province;
    final lOther$province = other.province;
    if (_$data.containsKey('province') !=
        other._$data.containsKey('province')) {
      return false;
    }
    if (l$province != lOther$province) {
      return false;
    }
    final l$oldDistrict = oldDistrict;
    final lOther$oldDistrict = other.oldDistrict;
    if (_$data.containsKey('oldDistrict') !=
        other._$data.containsKey('oldDistrict')) {
      return false;
    }
    if (l$oldDistrict != lOther$oldDistrict) {
      return false;
    }
    final l$oldWard = oldWard;
    final lOther$oldWard = other.oldWard;
    if (_$data.containsKey('oldWard') != other._$data.containsKey('oldWard')) {
      return false;
    }
    if (l$oldWard != lOther$oldWard) {
      return false;
    }
    final l$oldProvince = oldProvince;
    final lOther$oldProvince = other.oldProvince;
    if (_$data.containsKey('oldProvince') !=
        other._$data.containsKey('oldProvince')) {
      return false;
    }
    if (l$oldProvince != lOther$oldProvince) {
      return false;
    }
    final l$addressLine = addressLine;
    final lOther$addressLine = other.addressLine;
    if (_$data.containsKey('addressLine') !=
        other._$data.containsKey('addressLine')) {
      return false;
    }
    if (l$addressLine != lOther$addressLine) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$street = street;
    final l$ward = ward;
    final l$province = province;
    final l$oldDistrict = oldDistrict;
    final l$oldWard = oldWard;
    final l$oldProvince = oldProvince;
    final l$addressLine = addressLine;
    return Object.hashAll([
      _$data.containsKey('street') ? l$street : const {},
      _$data.containsKey('ward') ? l$ward : const {},
      _$data.containsKey('province') ? l$province : const {},
      _$data.containsKey('oldDistrict') ? l$oldDistrict : const {},
      _$data.containsKey('oldWard') ? l$oldWard : const {},
      _$data.containsKey('oldProvince') ? l$oldProvince : const {},
      _$data.containsKey('addressLine') ? l$addressLine : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddressInput<TRes> {
  factory CopyWith$Input$AddressInput(
    Input$AddressInput instance,
    TRes Function(Input$AddressInput) then,
  ) = _CopyWithImpl$Input$AddressInput;

  factory CopyWith$Input$AddressInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddressInput;

  TRes call({
    String? street,
    String? ward,
    String? province,
    String? oldDistrict,
    String? oldWard,
    String? oldProvince,
    String? addressLine,
  });
}

class _CopyWithImpl$Input$AddressInput<TRes>
    implements CopyWith$Input$AddressInput<TRes> {
  _CopyWithImpl$Input$AddressInput(this._instance, this._then);

  final Input$AddressInput _instance;

  final TRes Function(Input$AddressInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? street = _undefined,
    Object? ward = _undefined,
    Object? province = _undefined,
    Object? oldDistrict = _undefined,
    Object? oldWard = _undefined,
    Object? oldProvince = _undefined,
    Object? addressLine = _undefined,
  }) => _then(
    Input$AddressInput._({
      ..._instance._$data,
      if (street != _undefined) 'street': (street as String?),
      if (ward != _undefined) 'ward': (ward as String?),
      if (province != _undefined) 'province': (province as String?),
      if (oldDistrict != _undefined) 'oldDistrict': (oldDistrict as String?),
      if (oldWard != _undefined) 'oldWard': (oldWard as String?),
      if (oldProvince != _undefined) 'oldProvince': (oldProvince as String?),
      if (addressLine != _undefined) 'addressLine': (addressLine as String?),
    }),
  );
}

class _CopyWithStubImpl$Input$AddressInput<TRes>
    implements CopyWith$Input$AddressInput<TRes> {
  _CopyWithStubImpl$Input$AddressInput(this._res);

  TRes _res;

  call({
    String? street,
    String? ward,
    String? province,
    String? oldDistrict,
    String? oldWard,
    String? oldProvince,
    String? addressLine,
  }) => _res;
}

class Input$AddressSortInput {
  factory Input$AddressSortInput({
    Enum$SortEnumType? street,
    Enum$SortEnumType? ward,
    Enum$SortEnumType? province,
    Enum$SortEnumType? oldDistrict,
    Enum$SortEnumType? oldWard,
    Enum$SortEnumType? oldProvince,
    Enum$SortEnumType? addressLine,
  }) => Input$AddressSortInput._({
    if (street != null) r'street': street,
    if (ward != null) r'ward': ward,
    if (province != null) r'province': province,
    if (oldDistrict != null) r'oldDistrict': oldDistrict,
    if (oldWard != null) r'oldWard': oldWard,
    if (oldProvince != null) r'oldProvince': oldProvince,
    if (addressLine != null) r'addressLine': addressLine,
  });

  Input$AddressSortInput._(this._$data);

  factory Input$AddressSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('street')) {
      final l$street = data['street'];
      result$data['street'] = l$street == null
          ? null
          : fromJson$Enum$SortEnumType((l$street as String));
    }
    if (data.containsKey('ward')) {
      final l$ward = data['ward'];
      result$data['ward'] = l$ward == null
          ? null
          : fromJson$Enum$SortEnumType((l$ward as String));
    }
    if (data.containsKey('province')) {
      final l$province = data['province'];
      result$data['province'] = l$province == null
          ? null
          : fromJson$Enum$SortEnumType((l$province as String));
    }
    if (data.containsKey('oldDistrict')) {
      final l$oldDistrict = data['oldDistrict'];
      result$data['oldDistrict'] = l$oldDistrict == null
          ? null
          : fromJson$Enum$SortEnumType((l$oldDistrict as String));
    }
    if (data.containsKey('oldWard')) {
      final l$oldWard = data['oldWard'];
      result$data['oldWard'] = l$oldWard == null
          ? null
          : fromJson$Enum$SortEnumType((l$oldWard as String));
    }
    if (data.containsKey('oldProvince')) {
      final l$oldProvince = data['oldProvince'];
      result$data['oldProvince'] = l$oldProvince == null
          ? null
          : fromJson$Enum$SortEnumType((l$oldProvince as String));
    }
    if (data.containsKey('addressLine')) {
      final l$addressLine = data['addressLine'];
      result$data['addressLine'] = l$addressLine == null
          ? null
          : fromJson$Enum$SortEnumType((l$addressLine as String));
    }
    return Input$AddressSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get street => (_$data['street'] as Enum$SortEnumType?);

  Enum$SortEnumType? get ward => (_$data['ward'] as Enum$SortEnumType?);

  Enum$SortEnumType? get province => (_$data['province'] as Enum$SortEnumType?);

  Enum$SortEnumType? get oldDistrict =>
      (_$data['oldDistrict'] as Enum$SortEnumType?);

  Enum$SortEnumType? get oldWard => (_$data['oldWard'] as Enum$SortEnumType?);

  Enum$SortEnumType? get oldProvince =>
      (_$data['oldProvince'] as Enum$SortEnumType?);

  Enum$SortEnumType? get addressLine =>
      (_$data['addressLine'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('street')) {
      final l$street = street;
      result$data['street'] = l$street == null
          ? null
          : toJson$Enum$SortEnumType(l$street);
    }
    if (_$data.containsKey('ward')) {
      final l$ward = ward;
      result$data['ward'] = l$ward == null
          ? null
          : toJson$Enum$SortEnumType(l$ward);
    }
    if (_$data.containsKey('province')) {
      final l$province = province;
      result$data['province'] = l$province == null
          ? null
          : toJson$Enum$SortEnumType(l$province);
    }
    if (_$data.containsKey('oldDistrict')) {
      final l$oldDistrict = oldDistrict;
      result$data['oldDistrict'] = l$oldDistrict == null
          ? null
          : toJson$Enum$SortEnumType(l$oldDistrict);
    }
    if (_$data.containsKey('oldWard')) {
      final l$oldWard = oldWard;
      result$data['oldWard'] = l$oldWard == null
          ? null
          : toJson$Enum$SortEnumType(l$oldWard);
    }
    if (_$data.containsKey('oldProvince')) {
      final l$oldProvince = oldProvince;
      result$data['oldProvince'] = l$oldProvince == null
          ? null
          : toJson$Enum$SortEnumType(l$oldProvince);
    }
    if (_$data.containsKey('addressLine')) {
      final l$addressLine = addressLine;
      result$data['addressLine'] = l$addressLine == null
          ? null
          : toJson$Enum$SortEnumType(l$addressLine);
    }
    return result$data;
  }

  CopyWith$Input$AddressSortInput<Input$AddressSortInput> get copyWith =>
      CopyWith$Input$AddressSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddressSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$street = street;
    final lOther$street = other.street;
    if (_$data.containsKey('street') != other._$data.containsKey('street')) {
      return false;
    }
    if (l$street != lOther$street) {
      return false;
    }
    final l$ward = ward;
    final lOther$ward = other.ward;
    if (_$data.containsKey('ward') != other._$data.containsKey('ward')) {
      return false;
    }
    if (l$ward != lOther$ward) {
      return false;
    }
    final l$province = province;
    final lOther$province = other.province;
    if (_$data.containsKey('province') !=
        other._$data.containsKey('province')) {
      return false;
    }
    if (l$province != lOther$province) {
      return false;
    }
    final l$oldDistrict = oldDistrict;
    final lOther$oldDistrict = other.oldDistrict;
    if (_$data.containsKey('oldDistrict') !=
        other._$data.containsKey('oldDistrict')) {
      return false;
    }
    if (l$oldDistrict != lOther$oldDistrict) {
      return false;
    }
    final l$oldWard = oldWard;
    final lOther$oldWard = other.oldWard;
    if (_$data.containsKey('oldWard') != other._$data.containsKey('oldWard')) {
      return false;
    }
    if (l$oldWard != lOther$oldWard) {
      return false;
    }
    final l$oldProvince = oldProvince;
    final lOther$oldProvince = other.oldProvince;
    if (_$data.containsKey('oldProvince') !=
        other._$data.containsKey('oldProvince')) {
      return false;
    }
    if (l$oldProvince != lOther$oldProvince) {
      return false;
    }
    final l$addressLine = addressLine;
    final lOther$addressLine = other.addressLine;
    if (_$data.containsKey('addressLine') !=
        other._$data.containsKey('addressLine')) {
      return false;
    }
    if (l$addressLine != lOther$addressLine) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$street = street;
    final l$ward = ward;
    final l$province = province;
    final l$oldDistrict = oldDistrict;
    final l$oldWard = oldWard;
    final l$oldProvince = oldProvince;
    final l$addressLine = addressLine;
    return Object.hashAll([
      _$data.containsKey('street') ? l$street : const {},
      _$data.containsKey('ward') ? l$ward : const {},
      _$data.containsKey('province') ? l$province : const {},
      _$data.containsKey('oldDistrict') ? l$oldDistrict : const {},
      _$data.containsKey('oldWard') ? l$oldWard : const {},
      _$data.containsKey('oldProvince') ? l$oldProvince : const {},
      _$data.containsKey('addressLine') ? l$addressLine : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddressSortInput<TRes> {
  factory CopyWith$Input$AddressSortInput(
    Input$AddressSortInput instance,
    TRes Function(Input$AddressSortInput) then,
  ) = _CopyWithImpl$Input$AddressSortInput;

  factory CopyWith$Input$AddressSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddressSortInput;

  TRes call({
    Enum$SortEnumType? street,
    Enum$SortEnumType? ward,
    Enum$SortEnumType? province,
    Enum$SortEnumType? oldDistrict,
    Enum$SortEnumType? oldWard,
    Enum$SortEnumType? oldProvince,
    Enum$SortEnumType? addressLine,
  });
}

class _CopyWithImpl$Input$AddressSortInput<TRes>
    implements CopyWith$Input$AddressSortInput<TRes> {
  _CopyWithImpl$Input$AddressSortInput(this._instance, this._then);

  final Input$AddressSortInput _instance;

  final TRes Function(Input$AddressSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? street = _undefined,
    Object? ward = _undefined,
    Object? province = _undefined,
    Object? oldDistrict = _undefined,
    Object? oldWard = _undefined,
    Object? oldProvince = _undefined,
    Object? addressLine = _undefined,
  }) => _then(
    Input$AddressSortInput._({
      ..._instance._$data,
      if (street != _undefined) 'street': (street as Enum$SortEnumType?),
      if (ward != _undefined) 'ward': (ward as Enum$SortEnumType?),
      if (province != _undefined) 'province': (province as Enum$SortEnumType?),
      if (oldDistrict != _undefined)
        'oldDistrict': (oldDistrict as Enum$SortEnumType?),
      if (oldWard != _undefined) 'oldWard': (oldWard as Enum$SortEnumType?),
      if (oldProvince != _undefined)
        'oldProvince': (oldProvince as Enum$SortEnumType?),
      if (addressLine != _undefined)
        'addressLine': (addressLine as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$AddressSortInput<TRes>
    implements CopyWith$Input$AddressSortInput<TRes> {
  _CopyWithStubImpl$Input$AddressSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? street,
    Enum$SortEnumType? ward,
    Enum$SortEnumType? province,
    Enum$SortEnumType? oldDistrict,
    Enum$SortEnumType? oldWard,
    Enum$SortEnumType? oldProvince,
    Enum$SortEnumType? addressLine,
  }) => _res;
}

class Input$AggregationLevelOperationFilterInput {
  factory Input$AggregationLevelOperationFilterInput({
    Enum$AggregationLevel? eq,
    Enum$AggregationLevel? neq,
    List<Enum$AggregationLevel>? $in,
    List<Enum$AggregationLevel>? nin,
  }) => Input$AggregationLevelOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$AggregationLevelOperationFilterInput._(this._$data);

  factory Input$AggregationLevelOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$AggregationLevel((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$AggregationLevel((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$AggregationLevel((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$AggregationLevel((e as String)))
          .toList();
    }
    return Input$AggregationLevelOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$AggregationLevel? get eq => (_$data['eq'] as Enum$AggregationLevel?);

  Enum$AggregationLevel? get neq => (_$data['neq'] as Enum$AggregationLevel?);

  List<Enum$AggregationLevel>? get $in =>
      (_$data['in'] as List<Enum$AggregationLevel>?);

  List<Enum$AggregationLevel>? get nin =>
      (_$data['nin'] as List<Enum$AggregationLevel>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$AggregationLevel(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$AggregationLevel(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$AggregationLevel(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$AggregationLevel(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$AggregationLevelOperationFilterInput<
    Input$AggregationLevelOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$AggregationLevelOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AggregationLevelOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AggregationLevelOperationFilterInput<TRes> {
  factory CopyWith$Input$AggregationLevelOperationFilterInput(
    Input$AggregationLevelOperationFilterInput instance,
    TRes Function(Input$AggregationLevelOperationFilterInput) then,
  ) = _CopyWithImpl$Input$AggregationLevelOperationFilterInput;

  factory CopyWith$Input$AggregationLevelOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AggregationLevelOperationFilterInput;

  TRes call({
    Enum$AggregationLevel? eq,
    Enum$AggregationLevel? neq,
    List<Enum$AggregationLevel>? $in,
    List<Enum$AggregationLevel>? nin,
  });
}

class _CopyWithImpl$Input$AggregationLevelOperationFilterInput<TRes>
    implements CopyWith$Input$AggregationLevelOperationFilterInput<TRes> {
  _CopyWithImpl$Input$AggregationLevelOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$AggregationLevelOperationFilterInput _instance;

  final TRes Function(Input$AggregationLevelOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$AggregationLevelOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$AggregationLevel?),
      if (neq != _undefined) 'neq': (neq as Enum$AggregationLevel?),
      if ($in != _undefined) 'in': ($in as List<Enum$AggregationLevel>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$AggregationLevel>?),
    }),
  );
}

class _CopyWithStubImpl$Input$AggregationLevelOperationFilterInput<TRes>
    implements CopyWith$Input$AggregationLevelOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$AggregationLevelOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$AggregationLevel? eq,
    Enum$AggregationLevel? neq,
    List<Enum$AggregationLevel>? $in,
    List<Enum$AggregationLevel>? nin,
  }) => _res;
}

class Input$AlbumFilterInput {
  factory Input$AlbumFilterInput({
    List<Input$AlbumFilterInput>? and,
    List<Input$AlbumFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? nameUnsigned,
    Input$StringOperationFilterInput? description,
    Input$AlbumTypeOperationFilterInput? type,
    Input$ListStringOperationFilterInput? trackIds,
    Input$ListFilterInputTypeOfContributingArtistFilterInput?
    contributingArtists,
    Input$StringOperationFilterInput? coverImage,
    Input$StringOperationFilterInput? thumbnailImage,
    Input$ReleaseInfoFilterInput? releaseInfo,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$AlbumFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (nameUnsigned != null) r'nameUnsigned': nameUnsigned,
    if (description != null) r'description': description,
    if (type != null) r'type': type,
    if (trackIds != null) r'trackIds': trackIds,
    if (contributingArtists != null)
      r'contributingArtists': contributingArtists,
    if (coverImage != null) r'coverImage': coverImage,
    if (thumbnailImage != null) r'thumbnailImage': thumbnailImage,
    if (releaseInfo != null) r'releaseInfo': releaseInfo,
    if (isVisible != null) r'isVisible': isVisible,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$AlbumFilterInput._(this._$data);

  factory Input$AlbumFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$AlbumFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$AlbumFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>),
            );
    }
    if (data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = data['nameUnsigned'];
      result$data['nameUnsigned'] = l$nameUnsigned == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$nameUnsigned as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : Input$AlbumTypeOperationFilterInput.fromJson(
              (l$type as Map<String, dynamic>),
            );
    }
    if (data.containsKey('trackIds')) {
      final l$trackIds = data['trackIds'];
      result$data['trackIds'] = l$trackIds == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$trackIds as Map<String, dynamic>),
            );
    }
    if (data.containsKey('contributingArtists')) {
      final l$contributingArtists = data['contributingArtists'];
      result$data['contributingArtists'] = l$contributingArtists == null
          ? null
          : Input$ListFilterInputTypeOfContributingArtistFilterInput.fromJson(
              (l$contributingArtists as Map<String, dynamic>),
            );
    }
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = l$coverImage == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$coverImage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('thumbnailImage')) {
      final l$thumbnailImage = data['thumbnailImage'];
      result$data['thumbnailImage'] = l$thumbnailImage == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$thumbnailImage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('releaseInfo')) {
      final l$releaseInfo = data['releaseInfo'];
      result$data['releaseInfo'] = l$releaseInfo == null
          ? null
          : Input$ReleaseInfoFilterInput.fromJson(
              (l$releaseInfo as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isVisible as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$AlbumFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$AlbumFilterInput>? get and =>
      (_$data['and'] as List<Input$AlbumFilterInput>?);

  List<Input$AlbumFilterInput>? get or =>
      (_$data['or'] as List<Input$AlbumFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get nameUnsigned =>
      (_$data['nameUnsigned'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$AlbumTypeOperationFilterInput? get type =>
      (_$data['type'] as Input$AlbumTypeOperationFilterInput?);

  Input$ListStringOperationFilterInput? get trackIds =>
      (_$data['trackIds'] as Input$ListStringOperationFilterInput?);

  Input$ListFilterInputTypeOfContributingArtistFilterInput?
  get contributingArtists =>
      (_$data['contributingArtists']
          as Input$ListFilterInputTypeOfContributingArtistFilterInput?);

  Input$StringOperationFilterInput? get coverImage =>
      (_$data['coverImage'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get thumbnailImage =>
      (_$data['thumbnailImage'] as Input$StringOperationFilterInput?);

  Input$ReleaseInfoFilterInput? get releaseInfo =>
      (_$data['releaseInfo'] as Input$ReleaseInfoFilterInput?);

  Input$BooleanOperationFilterInput? get isVisible =>
      (_$data['isVisible'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = nameUnsigned;
      result$data['nameUnsigned'] = l$nameUnsigned?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.toJson();
    }
    if (_$data.containsKey('trackIds')) {
      final l$trackIds = trackIds;
      result$data['trackIds'] = l$trackIds?.toJson();
    }
    if (_$data.containsKey('contributingArtists')) {
      final l$contributingArtists = contributingArtists;
      result$data['contributingArtists'] = l$contributingArtists?.toJson();
    }
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage?.toJson();
    }
    if (_$data.containsKey('thumbnailImage')) {
      final l$thumbnailImage = thumbnailImage;
      result$data['thumbnailImage'] = l$thumbnailImage?.toJson();
    }
    if (_$data.containsKey('releaseInfo')) {
      final l$releaseInfo = releaseInfo;
      result$data['releaseInfo'] = l$releaseInfo?.toJson();
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AlbumFilterInput<Input$AlbumFilterInput> get copyWith =>
      CopyWith$Input$AlbumFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AlbumFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$nameUnsigned = nameUnsigned;
    final lOther$nameUnsigned = other.nameUnsigned;
    if (_$data.containsKey('nameUnsigned') !=
        other._$data.containsKey('nameUnsigned')) {
      return false;
    }
    if (l$nameUnsigned != lOther$nameUnsigned) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$trackIds = trackIds;
    final lOther$trackIds = other.trackIds;
    if (_$data.containsKey('trackIds') !=
        other._$data.containsKey('trackIds')) {
      return false;
    }
    if (l$trackIds != lOther$trackIds) {
      return false;
    }
    final l$contributingArtists = contributingArtists;
    final lOther$contributingArtists = other.contributingArtists;
    if (_$data.containsKey('contributingArtists') !=
        other._$data.containsKey('contributingArtists')) {
      return false;
    }
    if (l$contributingArtists != lOther$contributingArtists) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$thumbnailImage = thumbnailImage;
    final lOther$thumbnailImage = other.thumbnailImage;
    if (_$data.containsKey('thumbnailImage') !=
        other._$data.containsKey('thumbnailImage')) {
      return false;
    }
    if (l$thumbnailImage != lOther$thumbnailImage) {
      return false;
    }
    final l$releaseInfo = releaseInfo;
    final lOther$releaseInfo = other.releaseInfo;
    if (_$data.containsKey('releaseInfo') !=
        other._$data.containsKey('releaseInfo')) {
      return false;
    }
    if (l$releaseInfo != lOther$releaseInfo) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$name = name;
    final l$nameUnsigned = nameUnsigned;
    final l$description = description;
    final l$type = type;
    final l$trackIds = trackIds;
    final l$contributingArtists = contributingArtists;
    final l$coverImage = coverImage;
    final l$thumbnailImage = thumbnailImage;
    final l$releaseInfo = releaseInfo;
    final l$isVisible = isVisible;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('nameUnsigned') ? l$nameUnsigned : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('trackIds') ? l$trackIds : const {},
      _$data.containsKey('contributingArtists')
          ? l$contributingArtists
          : const {},
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('thumbnailImage') ? l$thumbnailImage : const {},
      _$data.containsKey('releaseInfo') ? l$releaseInfo : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AlbumFilterInput<TRes> {
  factory CopyWith$Input$AlbumFilterInput(
    Input$AlbumFilterInput instance,
    TRes Function(Input$AlbumFilterInput) then,
  ) = _CopyWithImpl$Input$AlbumFilterInput;

  factory CopyWith$Input$AlbumFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AlbumFilterInput;

  TRes call({
    List<Input$AlbumFilterInput>? and,
    List<Input$AlbumFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? nameUnsigned,
    Input$StringOperationFilterInput? description,
    Input$AlbumTypeOperationFilterInput? type,
    Input$ListStringOperationFilterInput? trackIds,
    Input$ListFilterInputTypeOfContributingArtistFilterInput?
    contributingArtists,
    Input$StringOperationFilterInput? coverImage,
    Input$StringOperationFilterInput? thumbnailImage,
    Input$ReleaseInfoFilterInput? releaseInfo,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$AlbumFilterInput>? Function(
      Iterable<CopyWith$Input$AlbumFilterInput<Input$AlbumFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$AlbumFilterInput>? Function(
      Iterable<CopyWith$Input$AlbumFilterInput<Input$AlbumFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  CopyWith$Input$StringOperationFilterInput<TRes> get nameUnsigned;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$AlbumTypeOperationFilterInput<TRes> get type;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get trackIds;
  CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput<TRes>
  get contributingArtists;
  CopyWith$Input$StringOperationFilterInput<TRes> get coverImage;
  CopyWith$Input$StringOperationFilterInput<TRes> get thumbnailImage;
  CopyWith$Input$ReleaseInfoFilterInput<TRes> get releaseInfo;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$AlbumFilterInput<TRes>
    implements CopyWith$Input$AlbumFilterInput<TRes> {
  _CopyWithImpl$Input$AlbumFilterInput(this._instance, this._then);

  final Input$AlbumFilterInput _instance;

  final TRes Function(Input$AlbumFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? nameUnsigned = _undefined,
    Object? description = _undefined,
    Object? type = _undefined,
    Object? trackIds = _undefined,
    Object? contributingArtists = _undefined,
    Object? coverImage = _undefined,
    Object? thumbnailImage = _undefined,
    Object? releaseInfo = _undefined,
    Object? isVisible = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$AlbumFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$AlbumFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$AlbumFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (name != _undefined)
        'name': (name as Input$StringOperationFilterInput?),
      if (nameUnsigned != _undefined)
        'nameUnsigned': (nameUnsigned as Input$StringOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (type != _undefined)
        'type': (type as Input$AlbumTypeOperationFilterInput?),
      if (trackIds != _undefined)
        'trackIds': (trackIds as Input$ListStringOperationFilterInput?),
      if (contributingArtists != _undefined)
        'contributingArtists':
            (contributingArtists
                as Input$ListFilterInputTypeOfContributingArtistFilterInput?),
      if (coverImage != _undefined)
        'coverImage': (coverImage as Input$StringOperationFilterInput?),
      if (thumbnailImage != _undefined)
        'thumbnailImage': (thumbnailImage as Input$StringOperationFilterInput?),
      if (releaseInfo != _undefined)
        'releaseInfo': (releaseInfo as Input$ReleaseInfoFilterInput?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Input$BooleanOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$AlbumFilterInput>? Function(
      Iterable<CopyWith$Input$AlbumFilterInput<Input$AlbumFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$AlbumFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$AlbumFilterInput>? Function(
      Iterable<CopyWith$Input$AlbumFilterInput<Input$AlbumFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$AlbumFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name,
            (e) => call(name: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get nameUnsigned {
    final local$nameUnsigned = _instance.nameUnsigned;
    return local$nameUnsigned == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$nameUnsigned,
            (e) => call(nameUnsigned: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$AlbumTypeOperationFilterInput<TRes> get type {
    final local$type = _instance.type;
    return local$type == null
        ? CopyWith$Input$AlbumTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$AlbumTypeOperationFilterInput(
            local$type,
            (e) => call(type: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get trackIds {
    final local$trackIds = _instance.trackIds;
    return local$trackIds == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$trackIds,
            (e) => call(trackIds: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput<TRes>
  get contributingArtists {
    final local$contributingArtists = _instance.contributingArtists;
    return local$contributingArtists == null
        ? CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput(
            local$contributingArtists,
            (e) => call(contributingArtists: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get coverImage {
    final local$coverImage = _instance.coverImage;
    return local$coverImage == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$coverImage,
            (e) => call(coverImage: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get thumbnailImage {
    final local$thumbnailImage = _instance.thumbnailImage;
    return local$thumbnailImage == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$thumbnailImage,
            (e) => call(thumbnailImage: e),
          );
  }

  CopyWith$Input$ReleaseInfoFilterInput<TRes> get releaseInfo {
    final local$releaseInfo = _instance.releaseInfo;
    return local$releaseInfo == null
        ? CopyWith$Input$ReleaseInfoFilterInput.stub(_then(_instance))
        : CopyWith$Input$ReleaseInfoFilterInput(
            local$releaseInfo,
            (e) => call(releaseInfo: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible {
    final local$isVisible = _instance.isVisible;
    return local$isVisible == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isVisible,
            (e) => call(isVisible: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$AlbumFilterInput<TRes>
    implements CopyWith$Input$AlbumFilterInput<TRes> {
  _CopyWithStubImpl$Input$AlbumFilterInput(this._res);

  TRes _res;

  call({
    List<Input$AlbumFilterInput>? and,
    List<Input$AlbumFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? nameUnsigned,
    Input$StringOperationFilterInput? description,
    Input$AlbumTypeOperationFilterInput? type,
    Input$ListStringOperationFilterInput? trackIds,
    Input$ListFilterInputTypeOfContributingArtistFilterInput?
    contributingArtists,
    Input$StringOperationFilterInput? coverImage,
    Input$StringOperationFilterInput? thumbnailImage,
    Input$ReleaseInfoFilterInput? releaseInfo,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get nameUnsigned =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$AlbumTypeOperationFilterInput<TRes> get type =>
      CopyWith$Input$AlbumTypeOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get trackIds =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput<TRes>
  get contributingArtists =>
      CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput.stub(
        _res,
      );

  CopyWith$Input$StringOperationFilterInput<TRes> get coverImage =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get thumbnailImage =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ReleaseInfoFilterInput<TRes> get releaseInfo =>
      CopyWith$Input$ReleaseInfoFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$AlbumSortInput {
  factory Input$AlbumSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? nameUnsigned,
    Enum$SortEnumType? description,
    Enum$SortEnumType? type,
    Enum$SortEnumType? coverImage,
    Enum$SortEnumType? thumbnailImage,
    Input$ReleaseInfoSortInput? releaseInfo,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$AlbumSortInput._({
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (nameUnsigned != null) r'nameUnsigned': nameUnsigned,
    if (description != null) r'description': description,
    if (type != null) r'type': type,
    if (coverImage != null) r'coverImage': coverImage,
    if (thumbnailImage != null) r'thumbnailImage': thumbnailImage,
    if (releaseInfo != null) r'releaseInfo': releaseInfo,
    if (isVisible != null) r'isVisible': isVisible,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$AlbumSortInput._(this._$data);

  factory Input$AlbumSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = data['nameUnsigned'];
      result$data['nameUnsigned'] = l$nameUnsigned == null
          ? null
          : fromJson$Enum$SortEnumType((l$nameUnsigned as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : fromJson$Enum$SortEnumType((l$type as String));
    }
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = l$coverImage == null
          ? null
          : fromJson$Enum$SortEnumType((l$coverImage as String));
    }
    if (data.containsKey('thumbnailImage')) {
      final l$thumbnailImage = data['thumbnailImage'];
      result$data['thumbnailImage'] = l$thumbnailImage == null
          ? null
          : fromJson$Enum$SortEnumType((l$thumbnailImage as String));
    }
    if (data.containsKey('releaseInfo')) {
      final l$releaseInfo = data['releaseInfo'];
      result$data['releaseInfo'] = l$releaseInfo == null
          ? null
          : Input$ReleaseInfoSortInput.fromJson(
              (l$releaseInfo as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : fromJson$Enum$SortEnumType((l$isVisible as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$AlbumSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);

  Enum$SortEnumType? get nameUnsigned =>
      (_$data['nameUnsigned'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get type => (_$data['type'] as Enum$SortEnumType?);

  Enum$SortEnumType? get coverImage =>
      (_$data['coverImage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get thumbnailImage =>
      (_$data['thumbnailImage'] as Enum$SortEnumType?);

  Input$ReleaseInfoSortInput? get releaseInfo =>
      (_$data['releaseInfo'] as Input$ReleaseInfoSortInput?);

  Enum$SortEnumType? get isVisible =>
      (_$data['isVisible'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null
          ? null
          : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = nameUnsigned;
      result$data['nameUnsigned'] = l$nameUnsigned == null
          ? null
          : toJson$Enum$SortEnumType(l$nameUnsigned);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type == null
          ? null
          : toJson$Enum$SortEnumType(l$type);
    }
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage == null
          ? null
          : toJson$Enum$SortEnumType(l$coverImage);
    }
    if (_$data.containsKey('thumbnailImage')) {
      final l$thumbnailImage = thumbnailImage;
      result$data['thumbnailImage'] = l$thumbnailImage == null
          ? null
          : toJson$Enum$SortEnumType(l$thumbnailImage);
    }
    if (_$data.containsKey('releaseInfo')) {
      final l$releaseInfo = releaseInfo;
      result$data['releaseInfo'] = l$releaseInfo?.toJson();
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible == null
          ? null
          : toJson$Enum$SortEnumType(l$isVisible);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$AlbumSortInput<Input$AlbumSortInput> get copyWith =>
      CopyWith$Input$AlbumSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AlbumSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$nameUnsigned = nameUnsigned;
    final lOther$nameUnsigned = other.nameUnsigned;
    if (_$data.containsKey('nameUnsigned') !=
        other._$data.containsKey('nameUnsigned')) {
      return false;
    }
    if (l$nameUnsigned != lOther$nameUnsigned) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$thumbnailImage = thumbnailImage;
    final lOther$thumbnailImage = other.thumbnailImage;
    if (_$data.containsKey('thumbnailImage') !=
        other._$data.containsKey('thumbnailImage')) {
      return false;
    }
    if (l$thumbnailImage != lOther$thumbnailImage) {
      return false;
    }
    final l$releaseInfo = releaseInfo;
    final lOther$releaseInfo = other.releaseInfo;
    if (_$data.containsKey('releaseInfo') !=
        other._$data.containsKey('releaseInfo')) {
      return false;
    }
    if (l$releaseInfo != lOther$releaseInfo) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$nameUnsigned = nameUnsigned;
    final l$description = description;
    final l$type = type;
    final l$coverImage = coverImage;
    final l$thumbnailImage = thumbnailImage;
    final l$releaseInfo = releaseInfo;
    final l$isVisible = isVisible;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('nameUnsigned') ? l$nameUnsigned : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('thumbnailImage') ? l$thumbnailImage : const {},
      _$data.containsKey('releaseInfo') ? l$releaseInfo : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AlbumSortInput<TRes> {
  factory CopyWith$Input$AlbumSortInput(
    Input$AlbumSortInput instance,
    TRes Function(Input$AlbumSortInput) then,
  ) = _CopyWithImpl$Input$AlbumSortInput;

  factory CopyWith$Input$AlbumSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AlbumSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? nameUnsigned,
    Enum$SortEnumType? description,
    Enum$SortEnumType? type,
    Enum$SortEnumType? coverImage,
    Enum$SortEnumType? thumbnailImage,
    Input$ReleaseInfoSortInput? releaseInfo,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
  CopyWith$Input$ReleaseInfoSortInput<TRes> get releaseInfo;
}

class _CopyWithImpl$Input$AlbumSortInput<TRes>
    implements CopyWith$Input$AlbumSortInput<TRes> {
  _CopyWithImpl$Input$AlbumSortInput(this._instance, this._then);

  final Input$AlbumSortInput _instance;

  final TRes Function(Input$AlbumSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? nameUnsigned = _undefined,
    Object? description = _undefined,
    Object? type = _undefined,
    Object? coverImage = _undefined,
    Object? thumbnailImage = _undefined,
    Object? releaseInfo = _undefined,
    Object? isVisible = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$AlbumSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      if (nameUnsigned != _undefined)
        'nameUnsigned': (nameUnsigned as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (type != _undefined) 'type': (type as Enum$SortEnumType?),
      if (coverImage != _undefined)
        'coverImage': (coverImage as Enum$SortEnumType?),
      if (thumbnailImage != _undefined)
        'thumbnailImage': (thumbnailImage as Enum$SortEnumType?),
      if (releaseInfo != _undefined)
        'releaseInfo': (releaseInfo as Input$ReleaseInfoSortInput?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );

  CopyWith$Input$ReleaseInfoSortInput<TRes> get releaseInfo {
    final local$releaseInfo = _instance.releaseInfo;
    return local$releaseInfo == null
        ? CopyWith$Input$ReleaseInfoSortInput.stub(_then(_instance))
        : CopyWith$Input$ReleaseInfoSortInput(
            local$releaseInfo,
            (e) => call(releaseInfo: e),
          );
  }
}

class _CopyWithStubImpl$Input$AlbumSortInput<TRes>
    implements CopyWith$Input$AlbumSortInput<TRes> {
  _CopyWithStubImpl$Input$AlbumSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? nameUnsigned,
    Enum$SortEnumType? description,
    Enum$SortEnumType? type,
    Enum$SortEnumType? coverImage,
    Enum$SortEnumType? thumbnailImage,
    Input$ReleaseInfoSortInput? releaseInfo,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;

  CopyWith$Input$ReleaseInfoSortInput<TRes> get releaseInfo =>
      CopyWith$Input$ReleaseInfoSortInput.stub(_res);
}

class Input$AlbumTypeOperationFilterInput {
  factory Input$AlbumTypeOperationFilterInput({
    Enum$AlbumType? eq,
    Enum$AlbumType? neq,
    List<Enum$AlbumType>? $in,
    List<Enum$AlbumType>? nin,
  }) => Input$AlbumTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$AlbumTypeOperationFilterInput._(this._$data);

  factory Input$AlbumTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$AlbumType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$AlbumType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$AlbumType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$AlbumType((e as String)))
          .toList();
    }
    return Input$AlbumTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$AlbumType? get eq => (_$data['eq'] as Enum$AlbumType?);

  Enum$AlbumType? get neq => (_$data['neq'] as Enum$AlbumType?);

  List<Enum$AlbumType>? get $in => (_$data['in'] as List<Enum$AlbumType>?);

  List<Enum$AlbumType>? get nin => (_$data['nin'] as List<Enum$AlbumType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$AlbumType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$AlbumType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$AlbumType(e)).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => toJson$Enum$AlbumType(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$AlbumTypeOperationFilterInput<
    Input$AlbumTypeOperationFilterInput
  >
  get copyWith => CopyWith$Input$AlbumTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AlbumTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AlbumTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$AlbumTypeOperationFilterInput(
    Input$AlbumTypeOperationFilterInput instance,
    TRes Function(Input$AlbumTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$AlbumTypeOperationFilterInput;

  factory CopyWith$Input$AlbumTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AlbumTypeOperationFilterInput;

  TRes call({
    Enum$AlbumType? eq,
    Enum$AlbumType? neq,
    List<Enum$AlbumType>? $in,
    List<Enum$AlbumType>? nin,
  });
}

class _CopyWithImpl$Input$AlbumTypeOperationFilterInput<TRes>
    implements CopyWith$Input$AlbumTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$AlbumTypeOperationFilterInput(this._instance, this._then);

  final Input$AlbumTypeOperationFilterInput _instance;

  final TRes Function(Input$AlbumTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$AlbumTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$AlbumType?),
      if (neq != _undefined) 'neq': (neq as Enum$AlbumType?),
      if ($in != _undefined) 'in': ($in as List<Enum$AlbumType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$AlbumType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$AlbumTypeOperationFilterInput<TRes>
    implements CopyWith$Input$AlbumTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$AlbumTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$AlbumType? eq,
    Enum$AlbumType? neq,
    List<Enum$AlbumType>? $in,
    List<Enum$AlbumType>? nin,
  }) => _res;
}

class Input$ApprovalHistoryFilterInput {
  factory Input$ApprovalHistoryFilterInput({
    List<Input$ApprovalHistoryFilterInput>? and,
    List<Input$ApprovalHistoryFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? targetOwnerId,
    Input$StringOperationFilterInput? targetId,
    Input$ApprovalTypeOperationFilterInput? approvalType,
    Input$StringOperationFilterInput? approvedByUserId,
    Input$DateTimeOperationFilterInput? actionAt,
    Input$HistoryActionTypeOperationFilterInput? action,
    Input$StringOperationFilterInput? notes,
    Input$StringOperationFilterInput? snapshot,
  }) => Input$ApprovalHistoryFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (targetOwnerId != null) r'targetOwnerId': targetOwnerId,
    if (targetId != null) r'targetId': targetId,
    if (approvalType != null) r'approvalType': approvalType,
    if (approvedByUserId != null) r'approvedByUserId': approvedByUserId,
    if (actionAt != null) r'actionAt': actionAt,
    if (action != null) r'action': action,
    if (notes != null) r'notes': notes,
    if (snapshot != null) r'snapshot': snapshot,
  });

  Input$ApprovalHistoryFilterInput._(this._$data);

  factory Input$ApprovalHistoryFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$ApprovalHistoryFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$ApprovalHistoryFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('targetOwnerId')) {
      final l$targetOwnerId = data['targetOwnerId'];
      result$data['targetOwnerId'] = l$targetOwnerId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$targetOwnerId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('targetId')) {
      final l$targetId = data['targetId'];
      result$data['targetId'] = l$targetId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$targetId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('approvalType')) {
      final l$approvalType = data['approvalType'];
      result$data['approvalType'] = l$approvalType == null
          ? null
          : Input$ApprovalTypeOperationFilterInput.fromJson(
              (l$approvalType as Map<String, dynamic>),
            );
    }
    if (data.containsKey('approvedByUserId')) {
      final l$approvedByUserId = data['approvedByUserId'];
      result$data['approvedByUserId'] = l$approvedByUserId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$approvedByUserId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('actionAt')) {
      final l$actionAt = data['actionAt'];
      result$data['actionAt'] = l$actionAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$actionAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('action')) {
      final l$action = data['action'];
      result$data['action'] = l$action == null
          ? null
          : Input$HistoryActionTypeOperationFilterInput.fromJson(
              (l$action as Map<String, dynamic>),
            );
    }
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = l$notes == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$notes as Map<String, dynamic>),
            );
    }
    if (data.containsKey('snapshot')) {
      final l$snapshot = data['snapshot'];
      result$data['snapshot'] = l$snapshot == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$snapshot as Map<String, dynamic>),
            );
    }
    return Input$ApprovalHistoryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ApprovalHistoryFilterInput>? get and =>
      (_$data['and'] as List<Input$ApprovalHistoryFilterInput>?);

  List<Input$ApprovalHistoryFilterInput>? get or =>
      (_$data['or'] as List<Input$ApprovalHistoryFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get targetOwnerId =>
      (_$data['targetOwnerId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get targetId =>
      (_$data['targetId'] as Input$StringOperationFilterInput?);

  Input$ApprovalTypeOperationFilterInput? get approvalType =>
      (_$data['approvalType'] as Input$ApprovalTypeOperationFilterInput?);

  Input$StringOperationFilterInput? get approvedByUserId =>
      (_$data['approvedByUserId'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get actionAt =>
      (_$data['actionAt'] as Input$DateTimeOperationFilterInput?);

  Input$HistoryActionTypeOperationFilterInput? get action =>
      (_$data['action'] as Input$HistoryActionTypeOperationFilterInput?);

  Input$StringOperationFilterInput? get notes =>
      (_$data['notes'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get snapshot =>
      (_$data['snapshot'] as Input$StringOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('targetOwnerId')) {
      final l$targetOwnerId = targetOwnerId;
      result$data['targetOwnerId'] = l$targetOwnerId?.toJson();
    }
    if (_$data.containsKey('targetId')) {
      final l$targetId = targetId;
      result$data['targetId'] = l$targetId?.toJson();
    }
    if (_$data.containsKey('approvalType')) {
      final l$approvalType = approvalType;
      result$data['approvalType'] = l$approvalType?.toJson();
    }
    if (_$data.containsKey('approvedByUserId')) {
      final l$approvedByUserId = approvedByUserId;
      result$data['approvedByUserId'] = l$approvedByUserId?.toJson();
    }
    if (_$data.containsKey('actionAt')) {
      final l$actionAt = actionAt;
      result$data['actionAt'] = l$actionAt?.toJson();
    }
    if (_$data.containsKey('action')) {
      final l$action = action;
      result$data['action'] = l$action?.toJson();
    }
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] = l$notes?.toJson();
    }
    if (_$data.containsKey('snapshot')) {
      final l$snapshot = snapshot;
      result$data['snapshot'] = l$snapshot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ApprovalHistoryFilterInput<Input$ApprovalHistoryFilterInput>
  get copyWith => CopyWith$Input$ApprovalHistoryFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ApprovalHistoryFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$targetOwnerId = targetOwnerId;
    final lOther$targetOwnerId = other.targetOwnerId;
    if (_$data.containsKey('targetOwnerId') !=
        other._$data.containsKey('targetOwnerId')) {
      return false;
    }
    if (l$targetOwnerId != lOther$targetOwnerId) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (_$data.containsKey('targetId') !=
        other._$data.containsKey('targetId')) {
      return false;
    }
    if (l$targetId != lOther$targetId) {
      return false;
    }
    final l$approvalType = approvalType;
    final lOther$approvalType = other.approvalType;
    if (_$data.containsKey('approvalType') !=
        other._$data.containsKey('approvalType')) {
      return false;
    }
    if (l$approvalType != lOther$approvalType) {
      return false;
    }
    final l$approvedByUserId = approvedByUserId;
    final lOther$approvedByUserId = other.approvedByUserId;
    if (_$data.containsKey('approvedByUserId') !=
        other._$data.containsKey('approvedByUserId')) {
      return false;
    }
    if (l$approvedByUserId != lOther$approvedByUserId) {
      return false;
    }
    final l$actionAt = actionAt;
    final lOther$actionAt = other.actionAt;
    if (_$data.containsKey('actionAt') !=
        other._$data.containsKey('actionAt')) {
      return false;
    }
    if (l$actionAt != lOther$actionAt) {
      return false;
    }
    final l$action = action;
    final lOther$action = other.action;
    if (_$data.containsKey('action') != other._$data.containsKey('action')) {
      return false;
    }
    if (l$action != lOther$action) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != lOther$notes) {
      return false;
    }
    final l$snapshot = snapshot;
    final lOther$snapshot = other.snapshot;
    if (_$data.containsKey('snapshot') !=
        other._$data.containsKey('snapshot')) {
      return false;
    }
    if (l$snapshot != lOther$snapshot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$targetOwnerId = targetOwnerId;
    final l$targetId = targetId;
    final l$approvalType = approvalType;
    final l$approvedByUserId = approvedByUserId;
    final l$actionAt = actionAt;
    final l$action = action;
    final l$notes = notes;
    final l$snapshot = snapshot;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('targetOwnerId') ? l$targetOwnerId : const {},
      _$data.containsKey('targetId') ? l$targetId : const {},
      _$data.containsKey('approvalType') ? l$approvalType : const {},
      _$data.containsKey('approvedByUserId') ? l$approvedByUserId : const {},
      _$data.containsKey('actionAt') ? l$actionAt : const {},
      _$data.containsKey('action') ? l$action : const {},
      _$data.containsKey('notes') ? l$notes : const {},
      _$data.containsKey('snapshot') ? l$snapshot : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApprovalHistoryFilterInput<TRes> {
  factory CopyWith$Input$ApprovalHistoryFilterInput(
    Input$ApprovalHistoryFilterInput instance,
    TRes Function(Input$ApprovalHistoryFilterInput) then,
  ) = _CopyWithImpl$Input$ApprovalHistoryFilterInput;

  factory CopyWith$Input$ApprovalHistoryFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApprovalHistoryFilterInput;

  TRes call({
    List<Input$ApprovalHistoryFilterInput>? and,
    List<Input$ApprovalHistoryFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? targetOwnerId,
    Input$StringOperationFilterInput? targetId,
    Input$ApprovalTypeOperationFilterInput? approvalType,
    Input$StringOperationFilterInput? approvedByUserId,
    Input$DateTimeOperationFilterInput? actionAt,
    Input$HistoryActionTypeOperationFilterInput? action,
    Input$StringOperationFilterInput? notes,
    Input$StringOperationFilterInput? snapshot,
  });
  TRes and(
    Iterable<Input$ApprovalHistoryFilterInput>? Function(
      Iterable<
        CopyWith$Input$ApprovalHistoryFilterInput<
          Input$ApprovalHistoryFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$ApprovalHistoryFilterInput>? Function(
      Iterable<
        CopyWith$Input$ApprovalHistoryFilterInput<
          Input$ApprovalHistoryFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get targetOwnerId;
  CopyWith$Input$StringOperationFilterInput<TRes> get targetId;
  CopyWith$Input$ApprovalTypeOperationFilterInput<TRes> get approvalType;
  CopyWith$Input$StringOperationFilterInput<TRes> get approvedByUserId;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get actionAt;
  CopyWith$Input$HistoryActionTypeOperationFilterInput<TRes> get action;
  CopyWith$Input$StringOperationFilterInput<TRes> get notes;
  CopyWith$Input$StringOperationFilterInput<TRes> get snapshot;
}

class _CopyWithImpl$Input$ApprovalHistoryFilterInput<TRes>
    implements CopyWith$Input$ApprovalHistoryFilterInput<TRes> {
  _CopyWithImpl$Input$ApprovalHistoryFilterInput(this._instance, this._then);

  final Input$ApprovalHistoryFilterInput _instance;

  final TRes Function(Input$ApprovalHistoryFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? targetOwnerId = _undefined,
    Object? targetId = _undefined,
    Object? approvalType = _undefined,
    Object? approvedByUserId = _undefined,
    Object? actionAt = _undefined,
    Object? action = _undefined,
    Object? notes = _undefined,
    Object? snapshot = _undefined,
  }) => _then(
    Input$ApprovalHistoryFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$ApprovalHistoryFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$ApprovalHistoryFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (targetOwnerId != _undefined)
        'targetOwnerId': (targetOwnerId as Input$StringOperationFilterInput?),
      if (targetId != _undefined)
        'targetId': (targetId as Input$StringOperationFilterInput?),
      if (approvalType != _undefined)
        'approvalType':
            (approvalType as Input$ApprovalTypeOperationFilterInput?),
      if (approvedByUserId != _undefined)
        'approvedByUserId':
            (approvedByUserId as Input$StringOperationFilterInput?),
      if (actionAt != _undefined)
        'actionAt': (actionAt as Input$DateTimeOperationFilterInput?),
      if (action != _undefined)
        'action': (action as Input$HistoryActionTypeOperationFilterInput?),
      if (notes != _undefined)
        'notes': (notes as Input$StringOperationFilterInput?),
      if (snapshot != _undefined)
        'snapshot': (snapshot as Input$StringOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$ApprovalHistoryFilterInput>? Function(
      Iterable<
        CopyWith$Input$ApprovalHistoryFilterInput<
          Input$ApprovalHistoryFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$ApprovalHistoryFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$ApprovalHistoryFilterInput>? Function(
      Iterable<
        CopyWith$Input$ApprovalHistoryFilterInput<
          Input$ApprovalHistoryFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$ApprovalHistoryFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get targetOwnerId {
    final local$targetOwnerId = _instance.targetOwnerId;
    return local$targetOwnerId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$targetOwnerId,
            (e) => call(targetOwnerId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get targetId {
    final local$targetId = _instance.targetId;
    return local$targetId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$targetId,
            (e) => call(targetId: e),
          );
  }

  CopyWith$Input$ApprovalTypeOperationFilterInput<TRes> get approvalType {
    final local$approvalType = _instance.approvalType;
    return local$approvalType == null
        ? CopyWith$Input$ApprovalTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ApprovalTypeOperationFilterInput(
            local$approvalType,
            (e) => call(approvalType: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get approvedByUserId {
    final local$approvedByUserId = _instance.approvedByUserId;
    return local$approvedByUserId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$approvedByUserId,
            (e) => call(approvedByUserId: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get actionAt {
    final local$actionAt = _instance.actionAt;
    return local$actionAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$actionAt,
            (e) => call(actionAt: e),
          );
  }

  CopyWith$Input$HistoryActionTypeOperationFilterInput<TRes> get action {
    final local$action = _instance.action;
    return local$action == null
        ? CopyWith$Input$HistoryActionTypeOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$HistoryActionTypeOperationFilterInput(
            local$action,
            (e) => call(action: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get notes {
    final local$notes = _instance.notes;
    return local$notes == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$notes,
            (e) => call(notes: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get snapshot {
    final local$snapshot = _instance.snapshot;
    return local$snapshot == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$snapshot,
            (e) => call(snapshot: e),
          );
  }
}

class _CopyWithStubImpl$Input$ApprovalHistoryFilterInput<TRes>
    implements CopyWith$Input$ApprovalHistoryFilterInput<TRes> {
  _CopyWithStubImpl$Input$ApprovalHistoryFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ApprovalHistoryFilterInput>? and,
    List<Input$ApprovalHistoryFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? targetOwnerId,
    Input$StringOperationFilterInput? targetId,
    Input$ApprovalTypeOperationFilterInput? approvalType,
    Input$StringOperationFilterInput? approvedByUserId,
    Input$DateTimeOperationFilterInput? actionAt,
    Input$HistoryActionTypeOperationFilterInput? action,
    Input$StringOperationFilterInput? notes,
    Input$StringOperationFilterInput? snapshot,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get targetOwnerId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get targetId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ApprovalTypeOperationFilterInput<TRes> get approvalType =>
      CopyWith$Input$ApprovalTypeOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get approvedByUserId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get actionAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$HistoryActionTypeOperationFilterInput<TRes> get action =>
      CopyWith$Input$HistoryActionTypeOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get notes =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get snapshot =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
}

class Input$ApprovalHistorySortInput {
  factory Input$ApprovalHistorySortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? targetOwnerId,
    Enum$SortEnumType? targetId,
    Enum$SortEnumType? approvalType,
    Enum$SortEnumType? approvedByUserId,
    Enum$SortEnumType? actionAt,
    Enum$SortEnumType? action,
    Enum$SortEnumType? notes,
    Enum$SortEnumType? snapshot,
  }) => Input$ApprovalHistorySortInput._({
    if (id != null) r'id': id,
    if (targetOwnerId != null) r'targetOwnerId': targetOwnerId,
    if (targetId != null) r'targetId': targetId,
    if (approvalType != null) r'approvalType': approvalType,
    if (approvedByUserId != null) r'approvedByUserId': approvedByUserId,
    if (actionAt != null) r'actionAt': actionAt,
    if (action != null) r'action': action,
    if (notes != null) r'notes': notes,
    if (snapshot != null) r'snapshot': snapshot,
  });

  Input$ApprovalHistorySortInput._(this._$data);

  factory Input$ApprovalHistorySortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('targetOwnerId')) {
      final l$targetOwnerId = data['targetOwnerId'];
      result$data['targetOwnerId'] = l$targetOwnerId == null
          ? null
          : fromJson$Enum$SortEnumType((l$targetOwnerId as String));
    }
    if (data.containsKey('targetId')) {
      final l$targetId = data['targetId'];
      result$data['targetId'] = l$targetId == null
          ? null
          : fromJson$Enum$SortEnumType((l$targetId as String));
    }
    if (data.containsKey('approvalType')) {
      final l$approvalType = data['approvalType'];
      result$data['approvalType'] = l$approvalType == null
          ? null
          : fromJson$Enum$SortEnumType((l$approvalType as String));
    }
    if (data.containsKey('approvedByUserId')) {
      final l$approvedByUserId = data['approvedByUserId'];
      result$data['approvedByUserId'] = l$approvedByUserId == null
          ? null
          : fromJson$Enum$SortEnumType((l$approvedByUserId as String));
    }
    if (data.containsKey('actionAt')) {
      final l$actionAt = data['actionAt'];
      result$data['actionAt'] = l$actionAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$actionAt as String));
    }
    if (data.containsKey('action')) {
      final l$action = data['action'];
      result$data['action'] = l$action == null
          ? null
          : fromJson$Enum$SortEnumType((l$action as String));
    }
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = l$notes == null
          ? null
          : fromJson$Enum$SortEnumType((l$notes as String));
    }
    if (data.containsKey('snapshot')) {
      final l$snapshot = data['snapshot'];
      result$data['snapshot'] = l$snapshot == null
          ? null
          : fromJson$Enum$SortEnumType((l$snapshot as String));
    }
    return Input$ApprovalHistorySortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get targetOwnerId =>
      (_$data['targetOwnerId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get targetId => (_$data['targetId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get approvalType =>
      (_$data['approvalType'] as Enum$SortEnumType?);

  Enum$SortEnumType? get approvedByUserId =>
      (_$data['approvedByUserId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get actionAt => (_$data['actionAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get action => (_$data['action'] as Enum$SortEnumType?);

  Enum$SortEnumType? get notes => (_$data['notes'] as Enum$SortEnumType?);

  Enum$SortEnumType? get snapshot => (_$data['snapshot'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('targetOwnerId')) {
      final l$targetOwnerId = targetOwnerId;
      result$data['targetOwnerId'] = l$targetOwnerId == null
          ? null
          : toJson$Enum$SortEnumType(l$targetOwnerId);
    }
    if (_$data.containsKey('targetId')) {
      final l$targetId = targetId;
      result$data['targetId'] = l$targetId == null
          ? null
          : toJson$Enum$SortEnumType(l$targetId);
    }
    if (_$data.containsKey('approvalType')) {
      final l$approvalType = approvalType;
      result$data['approvalType'] = l$approvalType == null
          ? null
          : toJson$Enum$SortEnumType(l$approvalType);
    }
    if (_$data.containsKey('approvedByUserId')) {
      final l$approvedByUserId = approvedByUserId;
      result$data['approvedByUserId'] = l$approvedByUserId == null
          ? null
          : toJson$Enum$SortEnumType(l$approvedByUserId);
    }
    if (_$data.containsKey('actionAt')) {
      final l$actionAt = actionAt;
      result$data['actionAt'] = l$actionAt == null
          ? null
          : toJson$Enum$SortEnumType(l$actionAt);
    }
    if (_$data.containsKey('action')) {
      final l$action = action;
      result$data['action'] = l$action == null
          ? null
          : toJson$Enum$SortEnumType(l$action);
    }
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] = l$notes == null
          ? null
          : toJson$Enum$SortEnumType(l$notes);
    }
    if (_$data.containsKey('snapshot')) {
      final l$snapshot = snapshot;
      result$data['snapshot'] = l$snapshot == null
          ? null
          : toJson$Enum$SortEnumType(l$snapshot);
    }
    return result$data;
  }

  CopyWith$Input$ApprovalHistorySortInput<Input$ApprovalHistorySortInput>
  get copyWith => CopyWith$Input$ApprovalHistorySortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ApprovalHistorySortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$targetOwnerId = targetOwnerId;
    final lOther$targetOwnerId = other.targetOwnerId;
    if (_$data.containsKey('targetOwnerId') !=
        other._$data.containsKey('targetOwnerId')) {
      return false;
    }
    if (l$targetOwnerId != lOther$targetOwnerId) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (_$data.containsKey('targetId') !=
        other._$data.containsKey('targetId')) {
      return false;
    }
    if (l$targetId != lOther$targetId) {
      return false;
    }
    final l$approvalType = approvalType;
    final lOther$approvalType = other.approvalType;
    if (_$data.containsKey('approvalType') !=
        other._$data.containsKey('approvalType')) {
      return false;
    }
    if (l$approvalType != lOther$approvalType) {
      return false;
    }
    final l$approvedByUserId = approvedByUserId;
    final lOther$approvedByUserId = other.approvedByUserId;
    if (_$data.containsKey('approvedByUserId') !=
        other._$data.containsKey('approvedByUserId')) {
      return false;
    }
    if (l$approvedByUserId != lOther$approvedByUserId) {
      return false;
    }
    final l$actionAt = actionAt;
    final lOther$actionAt = other.actionAt;
    if (_$data.containsKey('actionAt') !=
        other._$data.containsKey('actionAt')) {
      return false;
    }
    if (l$actionAt != lOther$actionAt) {
      return false;
    }
    final l$action = action;
    final lOther$action = other.action;
    if (_$data.containsKey('action') != other._$data.containsKey('action')) {
      return false;
    }
    if (l$action != lOther$action) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != lOther$notes) {
      return false;
    }
    final l$snapshot = snapshot;
    final lOther$snapshot = other.snapshot;
    if (_$data.containsKey('snapshot') !=
        other._$data.containsKey('snapshot')) {
      return false;
    }
    if (l$snapshot != lOther$snapshot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$targetOwnerId = targetOwnerId;
    final l$targetId = targetId;
    final l$approvalType = approvalType;
    final l$approvedByUserId = approvedByUserId;
    final l$actionAt = actionAt;
    final l$action = action;
    final l$notes = notes;
    final l$snapshot = snapshot;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('targetOwnerId') ? l$targetOwnerId : const {},
      _$data.containsKey('targetId') ? l$targetId : const {},
      _$data.containsKey('approvalType') ? l$approvalType : const {},
      _$data.containsKey('approvedByUserId') ? l$approvedByUserId : const {},
      _$data.containsKey('actionAt') ? l$actionAt : const {},
      _$data.containsKey('action') ? l$action : const {},
      _$data.containsKey('notes') ? l$notes : const {},
      _$data.containsKey('snapshot') ? l$snapshot : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApprovalHistorySortInput<TRes> {
  factory CopyWith$Input$ApprovalHistorySortInput(
    Input$ApprovalHistorySortInput instance,
    TRes Function(Input$ApprovalHistorySortInput) then,
  ) = _CopyWithImpl$Input$ApprovalHistorySortInput;

  factory CopyWith$Input$ApprovalHistorySortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApprovalHistorySortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? targetOwnerId,
    Enum$SortEnumType? targetId,
    Enum$SortEnumType? approvalType,
    Enum$SortEnumType? approvedByUserId,
    Enum$SortEnumType? actionAt,
    Enum$SortEnumType? action,
    Enum$SortEnumType? notes,
    Enum$SortEnumType? snapshot,
  });
}

class _CopyWithImpl$Input$ApprovalHistorySortInput<TRes>
    implements CopyWith$Input$ApprovalHistorySortInput<TRes> {
  _CopyWithImpl$Input$ApprovalHistorySortInput(this._instance, this._then);

  final Input$ApprovalHistorySortInput _instance;

  final TRes Function(Input$ApprovalHistorySortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? targetOwnerId = _undefined,
    Object? targetId = _undefined,
    Object? approvalType = _undefined,
    Object? approvedByUserId = _undefined,
    Object? actionAt = _undefined,
    Object? action = _undefined,
    Object? notes = _undefined,
    Object? snapshot = _undefined,
  }) => _then(
    Input$ApprovalHistorySortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (targetOwnerId != _undefined)
        'targetOwnerId': (targetOwnerId as Enum$SortEnumType?),
      if (targetId != _undefined) 'targetId': (targetId as Enum$SortEnumType?),
      if (approvalType != _undefined)
        'approvalType': (approvalType as Enum$SortEnumType?),
      if (approvedByUserId != _undefined)
        'approvedByUserId': (approvedByUserId as Enum$SortEnumType?),
      if (actionAt != _undefined) 'actionAt': (actionAt as Enum$SortEnumType?),
      if (action != _undefined) 'action': (action as Enum$SortEnumType?),
      if (notes != _undefined) 'notes': (notes as Enum$SortEnumType?),
      if (snapshot != _undefined) 'snapshot': (snapshot as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$ApprovalHistorySortInput<TRes>
    implements CopyWith$Input$ApprovalHistorySortInput<TRes> {
  _CopyWithStubImpl$Input$ApprovalHistorySortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? targetOwnerId,
    Enum$SortEnumType? targetId,
    Enum$SortEnumType? approvalType,
    Enum$SortEnumType? approvedByUserId,
    Enum$SortEnumType? actionAt,
    Enum$SortEnumType? action,
    Enum$SortEnumType? notes,
    Enum$SortEnumType? snapshot,
  }) => _res;
}

class Input$ApprovalTypeOperationFilterInput {
  factory Input$ApprovalTypeOperationFilterInput({
    Enum$ApprovalType? eq,
    Enum$ApprovalType? neq,
    List<Enum$ApprovalType>? $in,
    List<Enum$ApprovalType>? nin,
  }) => Input$ApprovalTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$ApprovalTypeOperationFilterInput._(this._$data);

  factory Input$ApprovalTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$ApprovalType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$ApprovalType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ApprovalType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ApprovalType((e as String)))
          .toList();
    }
    return Input$ApprovalTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ApprovalType? get eq => (_$data['eq'] as Enum$ApprovalType?);

  Enum$ApprovalType? get neq => (_$data['neq'] as Enum$ApprovalType?);

  List<Enum$ApprovalType>? get $in =>
      (_$data['in'] as List<Enum$ApprovalType>?);

  List<Enum$ApprovalType>? get nin =>
      (_$data['nin'] as List<Enum$ApprovalType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$ApprovalType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$ApprovalType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$ApprovalType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$ApprovalType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$ApprovalTypeOperationFilterInput<
    Input$ApprovalTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$ApprovalTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ApprovalTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApprovalTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$ApprovalTypeOperationFilterInput(
    Input$ApprovalTypeOperationFilterInput instance,
    TRes Function(Input$ApprovalTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ApprovalTypeOperationFilterInput;

  factory CopyWith$Input$ApprovalTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApprovalTypeOperationFilterInput;

  TRes call({
    Enum$ApprovalType? eq,
    Enum$ApprovalType? neq,
    List<Enum$ApprovalType>? $in,
    List<Enum$ApprovalType>? nin,
  });
}

class _CopyWithImpl$Input$ApprovalTypeOperationFilterInput<TRes>
    implements CopyWith$Input$ApprovalTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ApprovalTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ApprovalTypeOperationFilterInput _instance;

  final TRes Function(Input$ApprovalTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$ApprovalTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$ApprovalType?),
      if (neq != _undefined) 'neq': (neq as Enum$ApprovalType?),
      if ($in != _undefined) 'in': ($in as List<Enum$ApprovalType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$ApprovalType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$ApprovalTypeOperationFilterInput<TRes>
    implements CopyWith$Input$ApprovalTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ApprovalTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$ApprovalType? eq,
    Enum$ApprovalType? neq,
    List<Enum$ApprovalType>? $in,
    List<Enum$ApprovalType>? nin,
  }) => _res;
}

class Input$ArtistFilterInput {
  factory Input$ArtistFilterInput({
    List<Input$ArtistFilterInput>? and,
    List<Input$ArtistFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? stageName,
    Input$StringOperationFilterInput? stageNameUnsigned,
    Input$StringOperationFilterInput? email,
    Input$ArtistTypeOperationFilterInput? artistType,
    Input$ListFilterInputTypeOfArtistMemberFilterInput? members,
    Input$ListStringOperationFilterInput? categoryIds,
    Input$StringOperationFilterInput? biography,
    Input$LongOperationFilterInput? followerCount,
    Input$DecimalOperationFilterInput? popularity,
    Input$StringOperationFilterInput? avatarImage,
    Input$StringOperationFilterInput? bannerImage,
    Input$BooleanOperationFilterInput? isVerified,
    Input$DateTimeOperationFilterInput? verifiedAt,
    Input$IdentityCardFilterInput? identityCard,
    Input$ListFilterInputTypeOfLegalDocumentFilterInput? legalDocuments,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DecimalOperationFilterInput? royaltyEarnings,
    Input$DecimalOperationFilterInput? serviceRevenue,
    Input$DecimalOperationFilterInput? grossRevenue,
    Input$DecimalOperationFilterInput? refundAmount,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$ArtistFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (stageName != null) r'stageName': stageName,
    if (stageNameUnsigned != null) r'stageNameUnsigned': stageNameUnsigned,
    if (email != null) r'email': email,
    if (artistType != null) r'artistType': artistType,
    if (members != null) r'members': members,
    if (categoryIds != null) r'categoryIds': categoryIds,
    if (biography != null) r'biography': biography,
    if (followerCount != null) r'followerCount': followerCount,
    if (popularity != null) r'popularity': popularity,
    if (avatarImage != null) r'avatarImage': avatarImage,
    if (bannerImage != null) r'bannerImage': bannerImage,
    if (isVerified != null) r'isVerified': isVerified,
    if (verifiedAt != null) r'verifiedAt': verifiedAt,
    if (identityCard != null) r'identityCard': identityCard,
    if (legalDocuments != null) r'legalDocuments': legalDocuments,
    if (isVisible != null) r'isVisible': isVisible,
    if (royaltyEarnings != null) r'royaltyEarnings': royaltyEarnings,
    if (serviceRevenue != null) r'serviceRevenue': serviceRevenue,
    if (grossRevenue != null) r'grossRevenue': grossRevenue,
    if (refundAmount != null) r'refundAmount': refundAmount,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ArtistFilterInput._(this._$data);

  factory Input$ArtistFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$ArtistFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$ArtistFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stageName')) {
      final l$stageName = data['stageName'];
      result$data['stageName'] = l$stageName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stageName as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stageNameUnsigned')) {
      final l$stageNameUnsigned = data['stageNameUnsigned'];
      result$data['stageNameUnsigned'] = l$stageNameUnsigned == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stageNameUnsigned as Map<String, dynamic>),
            );
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$email as Map<String, dynamic>),
            );
    }
    if (data.containsKey('artistType')) {
      final l$artistType = data['artistType'];
      result$data['artistType'] = l$artistType == null
          ? null
          : Input$ArtistTypeOperationFilterInput.fromJson(
              (l$artistType as Map<String, dynamic>),
            );
    }
    if (data.containsKey('members')) {
      final l$members = data['members'];
      result$data['members'] = l$members == null
          ? null
          : Input$ListFilterInputTypeOfArtistMemberFilterInput.fromJson(
              (l$members as Map<String, dynamic>),
            );
    }
    if (data.containsKey('categoryIds')) {
      final l$categoryIds = data['categoryIds'];
      result$data['categoryIds'] = l$categoryIds == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$categoryIds as Map<String, dynamic>),
            );
    }
    if (data.containsKey('biography')) {
      final l$biography = data['biography'];
      result$data['biography'] = l$biography == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$biography as Map<String, dynamic>),
            );
    }
    if (data.containsKey('followerCount')) {
      final l$followerCount = data['followerCount'];
      result$data['followerCount'] = l$followerCount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$followerCount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('popularity')) {
      final l$popularity = data['popularity'];
      result$data['popularity'] = l$popularity == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$popularity as Map<String, dynamic>),
            );
    }
    if (data.containsKey('avatarImage')) {
      final l$avatarImage = data['avatarImage'];
      result$data['avatarImage'] = l$avatarImage == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$avatarImage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('bannerImage')) {
      final l$bannerImage = data['bannerImage'];
      result$data['bannerImage'] = l$bannerImage == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$bannerImage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isVerified')) {
      final l$isVerified = data['isVerified'];
      result$data['isVerified'] = l$isVerified == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isVerified as Map<String, dynamic>),
            );
    }
    if (data.containsKey('verifiedAt')) {
      final l$verifiedAt = data['verifiedAt'];
      result$data['verifiedAt'] = l$verifiedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$verifiedAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('identityCard')) {
      final l$identityCard = data['identityCard'];
      result$data['identityCard'] = l$identityCard == null
          ? null
          : Input$IdentityCardFilterInput.fromJson(
              (l$identityCard as Map<String, dynamic>),
            );
    }
    if (data.containsKey('legalDocuments')) {
      final l$legalDocuments = data['legalDocuments'];
      result$data['legalDocuments'] = l$legalDocuments == null
          ? null
          : Input$ListFilterInputTypeOfLegalDocumentFilterInput.fromJson(
              (l$legalDocuments as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isVisible as Map<String, dynamic>),
            );
    }
    if (data.containsKey('royaltyEarnings')) {
      final l$royaltyEarnings = data['royaltyEarnings'];
      result$data['royaltyEarnings'] = l$royaltyEarnings == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$royaltyEarnings as Map<String, dynamic>),
            );
    }
    if (data.containsKey('serviceRevenue')) {
      final l$serviceRevenue = data['serviceRevenue'];
      result$data['serviceRevenue'] = l$serviceRevenue == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$serviceRevenue as Map<String, dynamic>),
            );
    }
    if (data.containsKey('grossRevenue')) {
      final l$grossRevenue = data['grossRevenue'];
      result$data['grossRevenue'] = l$grossRevenue == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$grossRevenue as Map<String, dynamic>),
            );
    }
    if (data.containsKey('refundAmount')) {
      final l$refundAmount = data['refundAmount'];
      result$data['refundAmount'] = l$refundAmount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$refundAmount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$ArtistFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ArtistFilterInput>? get and =>
      (_$data['and'] as List<Input$ArtistFilterInput>?);

  List<Input$ArtistFilterInput>? get or =>
      (_$data['or'] as List<Input$ArtistFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get userId =>
      (_$data['userId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stageName =>
      (_$data['stageName'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stageNameUnsigned =>
      (_$data['stageNameUnsigned'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get email =>
      (_$data['email'] as Input$StringOperationFilterInput?);

  Input$ArtistTypeOperationFilterInput? get artistType =>
      (_$data['artistType'] as Input$ArtistTypeOperationFilterInput?);

  Input$ListFilterInputTypeOfArtistMemberFilterInput? get members =>
      (_$data['members']
          as Input$ListFilterInputTypeOfArtistMemberFilterInput?);

  Input$ListStringOperationFilterInput? get categoryIds =>
      (_$data['categoryIds'] as Input$ListStringOperationFilterInput?);

  Input$StringOperationFilterInput? get biography =>
      (_$data['biography'] as Input$StringOperationFilterInput?);

  Input$LongOperationFilterInput? get followerCount =>
      (_$data['followerCount'] as Input$LongOperationFilterInput?);

  Input$DecimalOperationFilterInput? get popularity =>
      (_$data['popularity'] as Input$DecimalOperationFilterInput?);

  Input$StringOperationFilterInput? get avatarImage =>
      (_$data['avatarImage'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get bannerImage =>
      (_$data['bannerImage'] as Input$StringOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isVerified =>
      (_$data['isVerified'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get verifiedAt =>
      (_$data['verifiedAt'] as Input$DateTimeOperationFilterInput?);

  Input$IdentityCardFilterInput? get identityCard =>
      (_$data['identityCard'] as Input$IdentityCardFilterInput?);

  Input$ListFilterInputTypeOfLegalDocumentFilterInput? get legalDocuments =>
      (_$data['legalDocuments']
          as Input$ListFilterInputTypeOfLegalDocumentFilterInput?);

  Input$BooleanOperationFilterInput? get isVisible =>
      (_$data['isVisible'] as Input$BooleanOperationFilterInput?);

  Input$DecimalOperationFilterInput? get royaltyEarnings =>
      (_$data['royaltyEarnings'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get serviceRevenue =>
      (_$data['serviceRevenue'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get grossRevenue =>
      (_$data['grossRevenue'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get refundAmount =>
      (_$data['refundAmount'] as Input$DecimalOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('stageName')) {
      final l$stageName = stageName;
      result$data['stageName'] = l$stageName?.toJson();
    }
    if (_$data.containsKey('stageNameUnsigned')) {
      final l$stageNameUnsigned = stageNameUnsigned;
      result$data['stageNameUnsigned'] = l$stageNameUnsigned?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('artistType')) {
      final l$artistType = artistType;
      result$data['artistType'] = l$artistType?.toJson();
    }
    if (_$data.containsKey('members')) {
      final l$members = members;
      result$data['members'] = l$members?.toJson();
    }
    if (_$data.containsKey('categoryIds')) {
      final l$categoryIds = categoryIds;
      result$data['categoryIds'] = l$categoryIds?.toJson();
    }
    if (_$data.containsKey('biography')) {
      final l$biography = biography;
      result$data['biography'] = l$biography?.toJson();
    }
    if (_$data.containsKey('followerCount')) {
      final l$followerCount = followerCount;
      result$data['followerCount'] = l$followerCount?.toJson();
    }
    if (_$data.containsKey('popularity')) {
      final l$popularity = popularity;
      result$data['popularity'] = l$popularity?.toJson();
    }
    if (_$data.containsKey('avatarImage')) {
      final l$avatarImage = avatarImage;
      result$data['avatarImage'] = l$avatarImage?.toJson();
    }
    if (_$data.containsKey('bannerImage')) {
      final l$bannerImage = bannerImage;
      result$data['bannerImage'] = l$bannerImage?.toJson();
    }
    if (_$data.containsKey('isVerified')) {
      final l$isVerified = isVerified;
      result$data['isVerified'] = l$isVerified?.toJson();
    }
    if (_$data.containsKey('verifiedAt')) {
      final l$verifiedAt = verifiedAt;
      result$data['verifiedAt'] = l$verifiedAt?.toJson();
    }
    if (_$data.containsKey('identityCard')) {
      final l$identityCard = identityCard;
      result$data['identityCard'] = l$identityCard?.toJson();
    }
    if (_$data.containsKey('legalDocuments')) {
      final l$legalDocuments = legalDocuments;
      result$data['legalDocuments'] = l$legalDocuments?.toJson();
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible?.toJson();
    }
    if (_$data.containsKey('royaltyEarnings')) {
      final l$royaltyEarnings = royaltyEarnings;
      result$data['royaltyEarnings'] = l$royaltyEarnings?.toJson();
    }
    if (_$data.containsKey('serviceRevenue')) {
      final l$serviceRevenue = serviceRevenue;
      result$data['serviceRevenue'] = l$serviceRevenue?.toJson();
    }
    if (_$data.containsKey('grossRevenue')) {
      final l$grossRevenue = grossRevenue;
      result$data['grossRevenue'] = l$grossRevenue?.toJson();
    }
    if (_$data.containsKey('refundAmount')) {
      final l$refundAmount = refundAmount;
      result$data['refundAmount'] = l$refundAmount?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ArtistFilterInput<Input$ArtistFilterInput> get copyWith =>
      CopyWith$Input$ArtistFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ArtistFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$stageName = stageName;
    final lOther$stageName = other.stageName;
    if (_$data.containsKey('stageName') !=
        other._$data.containsKey('stageName')) {
      return false;
    }
    if (l$stageName != lOther$stageName) {
      return false;
    }
    final l$stageNameUnsigned = stageNameUnsigned;
    final lOther$stageNameUnsigned = other.stageNameUnsigned;
    if (_$data.containsKey('stageNameUnsigned') !=
        other._$data.containsKey('stageNameUnsigned')) {
      return false;
    }
    if (l$stageNameUnsigned != lOther$stageNameUnsigned) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$artistType = artistType;
    final lOther$artistType = other.artistType;
    if (_$data.containsKey('artistType') !=
        other._$data.containsKey('artistType')) {
      return false;
    }
    if (l$artistType != lOther$artistType) {
      return false;
    }
    final l$members = members;
    final lOther$members = other.members;
    if (_$data.containsKey('members') != other._$data.containsKey('members')) {
      return false;
    }
    if (l$members != lOther$members) {
      return false;
    }
    final l$categoryIds = categoryIds;
    final lOther$categoryIds = other.categoryIds;
    if (_$data.containsKey('categoryIds') !=
        other._$data.containsKey('categoryIds')) {
      return false;
    }
    if (l$categoryIds != lOther$categoryIds) {
      return false;
    }
    final l$biography = biography;
    final lOther$biography = other.biography;
    if (_$data.containsKey('biography') !=
        other._$data.containsKey('biography')) {
      return false;
    }
    if (l$biography != lOther$biography) {
      return false;
    }
    final l$followerCount = followerCount;
    final lOther$followerCount = other.followerCount;
    if (_$data.containsKey('followerCount') !=
        other._$data.containsKey('followerCount')) {
      return false;
    }
    if (l$followerCount != lOther$followerCount) {
      return false;
    }
    final l$popularity = popularity;
    final lOther$popularity = other.popularity;
    if (_$data.containsKey('popularity') !=
        other._$data.containsKey('popularity')) {
      return false;
    }
    if (l$popularity != lOther$popularity) {
      return false;
    }
    final l$avatarImage = avatarImage;
    final lOther$avatarImage = other.avatarImage;
    if (_$data.containsKey('avatarImage') !=
        other._$data.containsKey('avatarImage')) {
      return false;
    }
    if (l$avatarImage != lOther$avatarImage) {
      return false;
    }
    final l$bannerImage = bannerImage;
    final lOther$bannerImage = other.bannerImage;
    if (_$data.containsKey('bannerImage') !=
        other._$data.containsKey('bannerImage')) {
      return false;
    }
    if (l$bannerImage != lOther$bannerImage) {
      return false;
    }
    final l$isVerified = isVerified;
    final lOther$isVerified = other.isVerified;
    if (_$data.containsKey('isVerified') !=
        other._$data.containsKey('isVerified')) {
      return false;
    }
    if (l$isVerified != lOther$isVerified) {
      return false;
    }
    final l$verifiedAt = verifiedAt;
    final lOther$verifiedAt = other.verifiedAt;
    if (_$data.containsKey('verifiedAt') !=
        other._$data.containsKey('verifiedAt')) {
      return false;
    }
    if (l$verifiedAt != lOther$verifiedAt) {
      return false;
    }
    final l$identityCard = identityCard;
    final lOther$identityCard = other.identityCard;
    if (_$data.containsKey('identityCard') !=
        other._$data.containsKey('identityCard')) {
      return false;
    }
    if (l$identityCard != lOther$identityCard) {
      return false;
    }
    final l$legalDocuments = legalDocuments;
    final lOther$legalDocuments = other.legalDocuments;
    if (_$data.containsKey('legalDocuments') !=
        other._$data.containsKey('legalDocuments')) {
      return false;
    }
    if (l$legalDocuments != lOther$legalDocuments) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$royaltyEarnings = royaltyEarnings;
    final lOther$royaltyEarnings = other.royaltyEarnings;
    if (_$data.containsKey('royaltyEarnings') !=
        other._$data.containsKey('royaltyEarnings')) {
      return false;
    }
    if (l$royaltyEarnings != lOther$royaltyEarnings) {
      return false;
    }
    final l$serviceRevenue = serviceRevenue;
    final lOther$serviceRevenue = other.serviceRevenue;
    if (_$data.containsKey('serviceRevenue') !=
        other._$data.containsKey('serviceRevenue')) {
      return false;
    }
    if (l$serviceRevenue != lOther$serviceRevenue) {
      return false;
    }
    final l$grossRevenue = grossRevenue;
    final lOther$grossRevenue = other.grossRevenue;
    if (_$data.containsKey('grossRevenue') !=
        other._$data.containsKey('grossRevenue')) {
      return false;
    }
    if (l$grossRevenue != lOther$grossRevenue) {
      return false;
    }
    final l$refundAmount = refundAmount;
    final lOther$refundAmount = other.refundAmount;
    if (_$data.containsKey('refundAmount') !=
        other._$data.containsKey('refundAmount')) {
      return false;
    }
    if (l$refundAmount != lOther$refundAmount) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$userId = userId;
    final l$stageName = stageName;
    final l$stageNameUnsigned = stageNameUnsigned;
    final l$email = email;
    final l$artistType = artistType;
    final l$members = members;
    final l$categoryIds = categoryIds;
    final l$biography = biography;
    final l$followerCount = followerCount;
    final l$popularity = popularity;
    final l$avatarImage = avatarImage;
    final l$bannerImage = bannerImage;
    final l$isVerified = isVerified;
    final l$verifiedAt = verifiedAt;
    final l$identityCard = identityCard;
    final l$legalDocuments = legalDocuments;
    final l$isVisible = isVisible;
    final l$royaltyEarnings = royaltyEarnings;
    final l$serviceRevenue = serviceRevenue;
    final l$grossRevenue = grossRevenue;
    final l$refundAmount = refundAmount;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('stageName') ? l$stageName : const {},
      _$data.containsKey('stageNameUnsigned') ? l$stageNameUnsigned : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('artistType') ? l$artistType : const {},
      _$data.containsKey('members') ? l$members : const {},
      _$data.containsKey('categoryIds') ? l$categoryIds : const {},
      _$data.containsKey('biography') ? l$biography : const {},
      _$data.containsKey('followerCount') ? l$followerCount : const {},
      _$data.containsKey('popularity') ? l$popularity : const {},
      _$data.containsKey('avatarImage') ? l$avatarImage : const {},
      _$data.containsKey('bannerImage') ? l$bannerImage : const {},
      _$data.containsKey('isVerified') ? l$isVerified : const {},
      _$data.containsKey('verifiedAt') ? l$verifiedAt : const {},
      _$data.containsKey('identityCard') ? l$identityCard : const {},
      _$data.containsKey('legalDocuments') ? l$legalDocuments : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('royaltyEarnings') ? l$royaltyEarnings : const {},
      _$data.containsKey('serviceRevenue') ? l$serviceRevenue : const {},
      _$data.containsKey('grossRevenue') ? l$grossRevenue : const {},
      _$data.containsKey('refundAmount') ? l$refundAmount : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ArtistFilterInput<TRes> {
  factory CopyWith$Input$ArtistFilterInput(
    Input$ArtistFilterInput instance,
    TRes Function(Input$ArtistFilterInput) then,
  ) = _CopyWithImpl$Input$ArtistFilterInput;

  factory CopyWith$Input$ArtistFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArtistFilterInput;

  TRes call({
    List<Input$ArtistFilterInput>? and,
    List<Input$ArtistFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? stageName,
    Input$StringOperationFilterInput? stageNameUnsigned,
    Input$StringOperationFilterInput? email,
    Input$ArtistTypeOperationFilterInput? artistType,
    Input$ListFilterInputTypeOfArtistMemberFilterInput? members,
    Input$ListStringOperationFilterInput? categoryIds,
    Input$StringOperationFilterInput? biography,
    Input$LongOperationFilterInput? followerCount,
    Input$DecimalOperationFilterInput? popularity,
    Input$StringOperationFilterInput? avatarImage,
    Input$StringOperationFilterInput? bannerImage,
    Input$BooleanOperationFilterInput? isVerified,
    Input$DateTimeOperationFilterInput? verifiedAt,
    Input$IdentityCardFilterInput? identityCard,
    Input$ListFilterInputTypeOfLegalDocumentFilterInput? legalDocuments,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DecimalOperationFilterInput? royaltyEarnings,
    Input$DecimalOperationFilterInput? serviceRevenue,
    Input$DecimalOperationFilterInput? grossRevenue,
    Input$DecimalOperationFilterInput? refundAmount,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$ArtistFilterInput>? Function(
      Iterable<CopyWith$Input$ArtistFilterInput<Input$ArtistFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$ArtistFilterInput>? Function(
      Iterable<CopyWith$Input$ArtistFilterInput<Input$ArtistFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get userId;
  CopyWith$Input$StringOperationFilterInput<TRes> get stageName;
  CopyWith$Input$StringOperationFilterInput<TRes> get stageNameUnsigned;
  CopyWith$Input$StringOperationFilterInput<TRes> get email;
  CopyWith$Input$ArtistTypeOperationFilterInput<TRes> get artistType;
  CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput<TRes> get members;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get categoryIds;
  CopyWith$Input$StringOperationFilterInput<TRes> get biography;
  CopyWith$Input$LongOperationFilterInput<TRes> get followerCount;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get popularity;
  CopyWith$Input$StringOperationFilterInput<TRes> get avatarImage;
  CopyWith$Input$StringOperationFilterInput<TRes> get bannerImage;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVerified;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get verifiedAt;
  CopyWith$Input$IdentityCardFilterInput<TRes> get identityCard;
  CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput<TRes>
  get legalDocuments;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get royaltyEarnings;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get serviceRevenue;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get grossRevenue;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get refundAmount;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$ArtistFilterInput<TRes>
    implements CopyWith$Input$ArtistFilterInput<TRes> {
  _CopyWithImpl$Input$ArtistFilterInput(this._instance, this._then);

  final Input$ArtistFilterInput _instance;

  final TRes Function(Input$ArtistFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? stageName = _undefined,
    Object? stageNameUnsigned = _undefined,
    Object? email = _undefined,
    Object? artistType = _undefined,
    Object? members = _undefined,
    Object? categoryIds = _undefined,
    Object? biography = _undefined,
    Object? followerCount = _undefined,
    Object? popularity = _undefined,
    Object? avatarImage = _undefined,
    Object? bannerImage = _undefined,
    Object? isVerified = _undefined,
    Object? verifiedAt = _undefined,
    Object? identityCard = _undefined,
    Object? legalDocuments = _undefined,
    Object? isVisible = _undefined,
    Object? royaltyEarnings = _undefined,
    Object? serviceRevenue = _undefined,
    Object? grossRevenue = _undefined,
    Object? refundAmount = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ArtistFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$ArtistFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$ArtistFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (userId != _undefined)
        'userId': (userId as Input$StringOperationFilterInput?),
      if (stageName != _undefined)
        'stageName': (stageName as Input$StringOperationFilterInput?),
      if (stageNameUnsigned != _undefined)
        'stageNameUnsigned':
            (stageNameUnsigned as Input$StringOperationFilterInput?),
      if (email != _undefined)
        'email': (email as Input$StringOperationFilterInput?),
      if (artistType != _undefined)
        'artistType': (artistType as Input$ArtistTypeOperationFilterInput?),
      if (members != _undefined)
        'members':
            (members as Input$ListFilterInputTypeOfArtistMemberFilterInput?),
      if (categoryIds != _undefined)
        'categoryIds': (categoryIds as Input$ListStringOperationFilterInput?),
      if (biography != _undefined)
        'biography': (biography as Input$StringOperationFilterInput?),
      if (followerCount != _undefined)
        'followerCount': (followerCount as Input$LongOperationFilterInput?),
      if (popularity != _undefined)
        'popularity': (popularity as Input$DecimalOperationFilterInput?),
      if (avatarImage != _undefined)
        'avatarImage': (avatarImage as Input$StringOperationFilterInput?),
      if (bannerImage != _undefined)
        'bannerImage': (bannerImage as Input$StringOperationFilterInput?),
      if (isVerified != _undefined)
        'isVerified': (isVerified as Input$BooleanOperationFilterInput?),
      if (verifiedAt != _undefined)
        'verifiedAt': (verifiedAt as Input$DateTimeOperationFilterInput?),
      if (identityCard != _undefined)
        'identityCard': (identityCard as Input$IdentityCardFilterInput?),
      if (legalDocuments != _undefined)
        'legalDocuments':
            (legalDocuments
                as Input$ListFilterInputTypeOfLegalDocumentFilterInput?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Input$BooleanOperationFilterInput?),
      if (royaltyEarnings != _undefined)
        'royaltyEarnings':
            (royaltyEarnings as Input$DecimalOperationFilterInput?),
      if (serviceRevenue != _undefined)
        'serviceRevenue':
            (serviceRevenue as Input$DecimalOperationFilterInput?),
      if (grossRevenue != _undefined)
        'grossRevenue': (grossRevenue as Input$DecimalOperationFilterInput?),
      if (refundAmount != _undefined)
        'refundAmount': (refundAmount as Input$DecimalOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$ArtistFilterInput>? Function(
      Iterable<CopyWith$Input$ArtistFilterInput<Input$ArtistFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$ArtistFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$ArtistFilterInput>? Function(
      Iterable<CopyWith$Input$ArtistFilterInput<Input$ArtistFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$ArtistFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userId,
            (e) => call(userId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stageName {
    final local$stageName = _instance.stageName;
    return local$stageName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stageName,
            (e) => call(stageName: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stageNameUnsigned {
    final local$stageNameUnsigned = _instance.stageNameUnsigned;
    return local$stageNameUnsigned == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stageNameUnsigned,
            (e) => call(stageNameUnsigned: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$email,
            (e) => call(email: e),
          );
  }

  CopyWith$Input$ArtistTypeOperationFilterInput<TRes> get artistType {
    final local$artistType = _instance.artistType;
    return local$artistType == null
        ? CopyWith$Input$ArtistTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ArtistTypeOperationFilterInput(
            local$artistType,
            (e) => call(artistType: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput<TRes>
  get members {
    final local$members = _instance.members;
    return local$members == null
        ? CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput(
            local$members,
            (e) => call(members: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get categoryIds {
    final local$categoryIds = _instance.categoryIds;
    return local$categoryIds == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$categoryIds,
            (e) => call(categoryIds: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get biography {
    final local$biography = _instance.biography;
    return local$biography == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$biography,
            (e) => call(biography: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get followerCount {
    final local$followerCount = _instance.followerCount;
    return local$followerCount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$followerCount,
            (e) => call(followerCount: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get popularity {
    final local$popularity = _instance.popularity;
    return local$popularity == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$popularity,
            (e) => call(popularity: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get avatarImage {
    final local$avatarImage = _instance.avatarImage;
    return local$avatarImage == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$avatarImage,
            (e) => call(avatarImage: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get bannerImage {
    final local$bannerImage = _instance.bannerImage;
    return local$bannerImage == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$bannerImage,
            (e) => call(bannerImage: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVerified {
    final local$isVerified = _instance.isVerified;
    return local$isVerified == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isVerified,
            (e) => call(isVerified: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get verifiedAt {
    final local$verifiedAt = _instance.verifiedAt;
    return local$verifiedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$verifiedAt,
            (e) => call(verifiedAt: e),
          );
  }

  CopyWith$Input$IdentityCardFilterInput<TRes> get identityCard {
    final local$identityCard = _instance.identityCard;
    return local$identityCard == null
        ? CopyWith$Input$IdentityCardFilterInput.stub(_then(_instance))
        : CopyWith$Input$IdentityCardFilterInput(
            local$identityCard,
            (e) => call(identityCard: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput<TRes>
  get legalDocuments {
    final local$legalDocuments = _instance.legalDocuments;
    return local$legalDocuments == null
        ? CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput(
            local$legalDocuments,
            (e) => call(legalDocuments: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible {
    final local$isVisible = _instance.isVisible;
    return local$isVisible == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isVisible,
            (e) => call(isVisible: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get royaltyEarnings {
    final local$royaltyEarnings = _instance.royaltyEarnings;
    return local$royaltyEarnings == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$royaltyEarnings,
            (e) => call(royaltyEarnings: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get serviceRevenue {
    final local$serviceRevenue = _instance.serviceRevenue;
    return local$serviceRevenue == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$serviceRevenue,
            (e) => call(serviceRevenue: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get grossRevenue {
    final local$grossRevenue = _instance.grossRevenue;
    return local$grossRevenue == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$grossRevenue,
            (e) => call(grossRevenue: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get refundAmount {
    final local$refundAmount = _instance.refundAmount;
    return local$refundAmount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$refundAmount,
            (e) => call(refundAmount: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$ArtistFilterInput<TRes>
    implements CopyWith$Input$ArtistFilterInput<TRes> {
  _CopyWithStubImpl$Input$ArtistFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ArtistFilterInput>? and,
    List<Input$ArtistFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? stageName,
    Input$StringOperationFilterInput? stageNameUnsigned,
    Input$StringOperationFilterInput? email,
    Input$ArtistTypeOperationFilterInput? artistType,
    Input$ListFilterInputTypeOfArtistMemberFilterInput? members,
    Input$ListStringOperationFilterInput? categoryIds,
    Input$StringOperationFilterInput? biography,
    Input$LongOperationFilterInput? followerCount,
    Input$DecimalOperationFilterInput? popularity,
    Input$StringOperationFilterInput? avatarImage,
    Input$StringOperationFilterInput? bannerImage,
    Input$BooleanOperationFilterInput? isVerified,
    Input$DateTimeOperationFilterInput? verifiedAt,
    Input$IdentityCardFilterInput? identityCard,
    Input$ListFilterInputTypeOfLegalDocumentFilterInput? legalDocuments,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DecimalOperationFilterInput? royaltyEarnings,
    Input$DecimalOperationFilterInput? serviceRevenue,
    Input$DecimalOperationFilterInput? grossRevenue,
    Input$DecimalOperationFilterInput? refundAmount,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get userId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stageName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stageNameUnsigned =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get email =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ArtistTypeOperationFilterInput<TRes> get artistType =>
      CopyWith$Input$ArtistTypeOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput<TRes>
  get members =>
      CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get categoryIds =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get biography =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get followerCount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get popularity =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get avatarImage =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get bannerImage =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVerified =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get verifiedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$IdentityCardFilterInput<TRes> get identityCard =>
      CopyWith$Input$IdentityCardFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput<TRes>
  get legalDocuments =>
      CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get royaltyEarnings =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get serviceRevenue =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get grossRevenue =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get refundAmount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$ArtistMemberFilterInput {
  factory Input$ArtistMemberFilterInput({
    List<Input$ArtistMemberFilterInput>? and,
    List<Input$ArtistMemberFilterInput>? or,
    Input$StringOperationFilterInput? fullName,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? phoneNumber,
    Input$BooleanOperationFilterInput? isLeader,
    Input$UserGenderOperationFilterInput? gender,
  }) => Input$ArtistMemberFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (fullName != null) r'fullName': fullName,
    if (email != null) r'email': email,
    if (phoneNumber != null) r'phoneNumber': phoneNumber,
    if (isLeader != null) r'isLeader': isLeader,
    if (gender != null) r'gender': gender,
  });

  Input$ArtistMemberFilterInput._(this._$data);

  factory Input$ArtistMemberFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$ArtistMemberFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$ArtistMemberFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$fullName as Map<String, dynamic>),
            );
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$email as Map<String, dynamic>),
            );
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = l$phoneNumber == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$phoneNumber as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isLeader')) {
      final l$isLeader = data['isLeader'];
      result$data['isLeader'] = l$isLeader == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isLeader as Map<String, dynamic>),
            );
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = l$gender == null
          ? null
          : Input$UserGenderOperationFilterInput.fromJson(
              (l$gender as Map<String, dynamic>),
            );
    }
    return Input$ArtistMemberFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ArtistMemberFilterInput>? get and =>
      (_$data['and'] as List<Input$ArtistMemberFilterInput>?);

  List<Input$ArtistMemberFilterInput>? get or =>
      (_$data['or'] as List<Input$ArtistMemberFilterInput>?);

  Input$StringOperationFilterInput? get fullName =>
      (_$data['fullName'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get email =>
      (_$data['email'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get phoneNumber =>
      (_$data['phoneNumber'] as Input$StringOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isLeader =>
      (_$data['isLeader'] as Input$BooleanOperationFilterInput?);

  Input$UserGenderOperationFilterInput? get gender =>
      (_$data['gender'] as Input$UserGenderOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] = l$phoneNumber?.toJson();
    }
    if (_$data.containsKey('isLeader')) {
      final l$isLeader = isLeader;
      result$data['isLeader'] = l$isLeader?.toJson();
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ArtistMemberFilterInput<Input$ArtistMemberFilterInput>
  get copyWith => CopyWith$Input$ArtistMemberFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ArtistMemberFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$isLeader = isLeader;
    final lOther$isLeader = other.isLeader;
    if (_$data.containsKey('isLeader') !=
        other._$data.containsKey('isLeader')) {
      return false;
    }
    if (l$isLeader != lOther$isLeader) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$fullName = fullName;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$isLeader = isLeader;
    final l$gender = gender;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('isLeader') ? l$isLeader : const {},
      _$data.containsKey('gender') ? l$gender : const {},
    ]);
  }
}

abstract class CopyWith$Input$ArtistMemberFilterInput<TRes> {
  factory CopyWith$Input$ArtistMemberFilterInput(
    Input$ArtistMemberFilterInput instance,
    TRes Function(Input$ArtistMemberFilterInput) then,
  ) = _CopyWithImpl$Input$ArtistMemberFilterInput;

  factory CopyWith$Input$ArtistMemberFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArtistMemberFilterInput;

  TRes call({
    List<Input$ArtistMemberFilterInput>? and,
    List<Input$ArtistMemberFilterInput>? or,
    Input$StringOperationFilterInput? fullName,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? phoneNumber,
    Input$BooleanOperationFilterInput? isLeader,
    Input$UserGenderOperationFilterInput? gender,
  });
  TRes and(
    Iterable<Input$ArtistMemberFilterInput>? Function(
      Iterable<
        CopyWith$Input$ArtistMemberFilterInput<Input$ArtistMemberFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$ArtistMemberFilterInput>? Function(
      Iterable<
        CopyWith$Input$ArtistMemberFilterInput<Input$ArtistMemberFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get fullName;
  CopyWith$Input$StringOperationFilterInput<TRes> get email;
  CopyWith$Input$StringOperationFilterInput<TRes> get phoneNumber;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isLeader;
  CopyWith$Input$UserGenderOperationFilterInput<TRes> get gender;
}

class _CopyWithImpl$Input$ArtistMemberFilterInput<TRes>
    implements CopyWith$Input$ArtistMemberFilterInput<TRes> {
  _CopyWithImpl$Input$ArtistMemberFilterInput(this._instance, this._then);

  final Input$ArtistMemberFilterInput _instance;

  final TRes Function(Input$ArtistMemberFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? phoneNumber = _undefined,
    Object? isLeader = _undefined,
    Object? gender = _undefined,
  }) => _then(
    Input$ArtistMemberFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$ArtistMemberFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$ArtistMemberFilterInput>?),
      if (fullName != _undefined)
        'fullName': (fullName as Input$StringOperationFilterInput?),
      if (email != _undefined)
        'email': (email as Input$StringOperationFilterInput?),
      if (phoneNumber != _undefined)
        'phoneNumber': (phoneNumber as Input$StringOperationFilterInput?),
      if (isLeader != _undefined)
        'isLeader': (isLeader as Input$BooleanOperationFilterInput?),
      if (gender != _undefined)
        'gender': (gender as Input$UserGenderOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$ArtistMemberFilterInput>? Function(
      Iterable<
        CopyWith$Input$ArtistMemberFilterInput<Input$ArtistMemberFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$ArtistMemberFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$ArtistMemberFilterInput>? Function(
      Iterable<
        CopyWith$Input$ArtistMemberFilterInput<Input$ArtistMemberFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$ArtistMemberFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$fullName,
            (e) => call(fullName: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$email,
            (e) => call(email: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get phoneNumber {
    final local$phoneNumber = _instance.phoneNumber;
    return local$phoneNumber == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$phoneNumber,
            (e) => call(phoneNumber: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isLeader {
    final local$isLeader = _instance.isLeader;
    return local$isLeader == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isLeader,
            (e) => call(isLeader: e),
          );
  }

  CopyWith$Input$UserGenderOperationFilterInput<TRes> get gender {
    final local$gender = _instance.gender;
    return local$gender == null
        ? CopyWith$Input$UserGenderOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserGenderOperationFilterInput(
            local$gender,
            (e) => call(gender: e),
          );
  }
}

class _CopyWithStubImpl$Input$ArtistMemberFilterInput<TRes>
    implements CopyWith$Input$ArtistMemberFilterInput<TRes> {
  _CopyWithStubImpl$Input$ArtistMemberFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ArtistMemberFilterInput>? and,
    List<Input$ArtistMemberFilterInput>? or,
    Input$StringOperationFilterInput? fullName,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? phoneNumber,
    Input$BooleanOperationFilterInput? isLeader,
    Input$UserGenderOperationFilterInput? gender,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get fullName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get email =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get phoneNumber =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isLeader =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$UserGenderOperationFilterInput<TRes> get gender =>
      CopyWith$Input$UserGenderOperationFilterInput.stub(_res);
}

class Input$ArtistPackageFilterInput {
  factory Input$ArtistPackageFilterInput({
    List<Input$ArtistPackageFilterInput>? and,
    List<Input$ArtistPackageFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? artistId,
    Input$StringOperationFilterInput? packageName,
    Input$DecimalOperationFilterInput? amount,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$IntOperationFilterInput? estimateDeliveryDays,
    Input$StringOperationFilterInput? description,
    Input$IntOperationFilterInput? maxRevision,
    Input$ListFilterInputTypeOfMetadataFilterInput? serviceDetails,
    Input$ArtistPackageStatusOperationFilterInput? status,
    Input$BooleanOperationFilterInput? isDelete,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$ArtistPackageFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (artistId != null) r'artistId': artistId,
    if (packageName != null) r'packageName': packageName,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (estimateDeliveryDays != null)
      r'estimateDeliveryDays': estimateDeliveryDays,
    if (description != null) r'description': description,
    if (maxRevision != null) r'maxRevision': maxRevision,
    if (serviceDetails != null) r'serviceDetails': serviceDetails,
    if (status != null) r'status': status,
    if (isDelete != null) r'isDelete': isDelete,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ArtistPackageFilterInput._(this._$data);

  factory Input$ArtistPackageFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$ArtistPackageFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$ArtistPackageFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('artistId')) {
      final l$artistId = data['artistId'];
      result$data['artistId'] = l$artistId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$artistId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('packageName')) {
      final l$packageName = data['packageName'];
      result$data['packageName'] = l$packageName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$packageName as Map<String, dynamic>),
            );
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$amount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : Input$CurrencyTypeOperationFilterInput.fromJson(
              (l$currency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('estimateDeliveryDays')) {
      final l$estimateDeliveryDays = data['estimateDeliveryDays'];
      result$data['estimateDeliveryDays'] = l$estimateDeliveryDays == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$estimateDeliveryDays as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('maxRevision')) {
      final l$maxRevision = data['maxRevision'];
      result$data['maxRevision'] = l$maxRevision == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$maxRevision as Map<String, dynamic>),
            );
    }
    if (data.containsKey('serviceDetails')) {
      final l$serviceDetails = data['serviceDetails'];
      result$data['serviceDetails'] = l$serviceDetails == null
          ? null
          : Input$ListFilterInputTypeOfMetadataFilterInput.fromJson(
              (l$serviceDetails as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$ArtistPackageStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isDelete')) {
      final l$isDelete = data['isDelete'];
      result$data['isDelete'] = l$isDelete == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isDelete as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$ArtistPackageFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ArtistPackageFilterInput>? get and =>
      (_$data['and'] as List<Input$ArtistPackageFilterInput>?);

  List<Input$ArtistPackageFilterInput>? get or =>
      (_$data['or'] as List<Input$ArtistPackageFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get artistId =>
      (_$data['artistId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get packageName =>
      (_$data['packageName'] as Input$StringOperationFilterInput?);

  Input$DecimalOperationFilterInput? get amount =>
      (_$data['amount'] as Input$DecimalOperationFilterInput?);

  Input$CurrencyTypeOperationFilterInput? get currency =>
      (_$data['currency'] as Input$CurrencyTypeOperationFilterInput?);

  Input$IntOperationFilterInput? get estimateDeliveryDays =>
      (_$data['estimateDeliveryDays'] as Input$IntOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$IntOperationFilterInput? get maxRevision =>
      (_$data['maxRevision'] as Input$IntOperationFilterInput?);

  Input$ListFilterInputTypeOfMetadataFilterInput? get serviceDetails =>
      (_$data['serviceDetails']
          as Input$ListFilterInputTypeOfMetadataFilterInput?);

  Input$ArtistPackageStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$ArtistPackageStatusOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isDelete =>
      (_$data['isDelete'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('artistId')) {
      final l$artistId = artistId;
      result$data['artistId'] = l$artistId?.toJson();
    }
    if (_$data.containsKey('packageName')) {
      final l$packageName = packageName;
      result$data['packageName'] = l$packageName?.toJson();
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount?.toJson();
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency?.toJson();
    }
    if (_$data.containsKey('estimateDeliveryDays')) {
      final l$estimateDeliveryDays = estimateDeliveryDays;
      result$data['estimateDeliveryDays'] = l$estimateDeliveryDays?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('maxRevision')) {
      final l$maxRevision = maxRevision;
      result$data['maxRevision'] = l$maxRevision?.toJson();
    }
    if (_$data.containsKey('serviceDetails')) {
      final l$serviceDetails = serviceDetails;
      result$data['serviceDetails'] = l$serviceDetails?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('isDelete')) {
      final l$isDelete = isDelete;
      result$data['isDelete'] = l$isDelete?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ArtistPackageFilterInput<Input$ArtistPackageFilterInput>
  get copyWith => CopyWith$Input$ArtistPackageFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ArtistPackageFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$artistId = artistId;
    final lOther$artistId = other.artistId;
    if (_$data.containsKey('artistId') !=
        other._$data.containsKey('artistId')) {
      return false;
    }
    if (l$artistId != lOther$artistId) {
      return false;
    }
    final l$packageName = packageName;
    final lOther$packageName = other.packageName;
    if (_$data.containsKey('packageName') !=
        other._$data.containsKey('packageName')) {
      return false;
    }
    if (l$packageName != lOther$packageName) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$estimateDeliveryDays = estimateDeliveryDays;
    final lOther$estimateDeliveryDays = other.estimateDeliveryDays;
    if (_$data.containsKey('estimateDeliveryDays') !=
        other._$data.containsKey('estimateDeliveryDays')) {
      return false;
    }
    if (l$estimateDeliveryDays != lOther$estimateDeliveryDays) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$maxRevision = maxRevision;
    final lOther$maxRevision = other.maxRevision;
    if (_$data.containsKey('maxRevision') !=
        other._$data.containsKey('maxRevision')) {
      return false;
    }
    if (l$maxRevision != lOther$maxRevision) {
      return false;
    }
    final l$serviceDetails = serviceDetails;
    final lOther$serviceDetails = other.serviceDetails;
    if (_$data.containsKey('serviceDetails') !=
        other._$data.containsKey('serviceDetails')) {
      return false;
    }
    if (l$serviceDetails != lOther$serviceDetails) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$isDelete = isDelete;
    final lOther$isDelete = other.isDelete;
    if (_$data.containsKey('isDelete') !=
        other._$data.containsKey('isDelete')) {
      return false;
    }
    if (l$isDelete != lOther$isDelete) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$artistId = artistId;
    final l$packageName = packageName;
    final l$amount = amount;
    final l$currency = currency;
    final l$estimateDeliveryDays = estimateDeliveryDays;
    final l$description = description;
    final l$maxRevision = maxRevision;
    final l$serviceDetails = serviceDetails;
    final l$status = status;
    final l$isDelete = isDelete;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('artistId') ? l$artistId : const {},
      _$data.containsKey('packageName') ? l$packageName : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('estimateDeliveryDays')
          ? l$estimateDeliveryDays
          : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('maxRevision') ? l$maxRevision : const {},
      _$data.containsKey('serviceDetails') ? l$serviceDetails : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('isDelete') ? l$isDelete : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ArtistPackageFilterInput<TRes> {
  factory CopyWith$Input$ArtistPackageFilterInput(
    Input$ArtistPackageFilterInput instance,
    TRes Function(Input$ArtistPackageFilterInput) then,
  ) = _CopyWithImpl$Input$ArtistPackageFilterInput;

  factory CopyWith$Input$ArtistPackageFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArtistPackageFilterInput;

  TRes call({
    List<Input$ArtistPackageFilterInput>? and,
    List<Input$ArtistPackageFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? artistId,
    Input$StringOperationFilterInput? packageName,
    Input$DecimalOperationFilterInput? amount,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$IntOperationFilterInput? estimateDeliveryDays,
    Input$StringOperationFilterInput? description,
    Input$IntOperationFilterInput? maxRevision,
    Input$ListFilterInputTypeOfMetadataFilterInput? serviceDetails,
    Input$ArtistPackageStatusOperationFilterInput? status,
    Input$BooleanOperationFilterInput? isDelete,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$ArtistPackageFilterInput>? Function(
      Iterable<
        CopyWith$Input$ArtistPackageFilterInput<Input$ArtistPackageFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$ArtistPackageFilterInput>? Function(
      Iterable<
        CopyWith$Input$ArtistPackageFilterInput<Input$ArtistPackageFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get artistId;
  CopyWith$Input$StringOperationFilterInput<TRes> get packageName;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount;
  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency;
  CopyWith$Input$IntOperationFilterInput<TRes> get estimateDeliveryDays;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$IntOperationFilterInput<TRes> get maxRevision;
  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get serviceDetails;
  CopyWith$Input$ArtistPackageStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDelete;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$ArtistPackageFilterInput<TRes>
    implements CopyWith$Input$ArtistPackageFilterInput<TRes> {
  _CopyWithImpl$Input$ArtistPackageFilterInput(this._instance, this._then);

  final Input$ArtistPackageFilterInput _instance;

  final TRes Function(Input$ArtistPackageFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? artistId = _undefined,
    Object? packageName = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? estimateDeliveryDays = _undefined,
    Object? description = _undefined,
    Object? maxRevision = _undefined,
    Object? serviceDetails = _undefined,
    Object? status = _undefined,
    Object? isDelete = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ArtistPackageFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$ArtistPackageFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$ArtistPackageFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (artistId != _undefined)
        'artistId': (artistId as Input$StringOperationFilterInput?),
      if (packageName != _undefined)
        'packageName': (packageName as Input$StringOperationFilterInput?),
      if (amount != _undefined)
        'amount': (amount as Input$DecimalOperationFilterInput?),
      if (currency != _undefined)
        'currency': (currency as Input$CurrencyTypeOperationFilterInput?),
      if (estimateDeliveryDays != _undefined)
        'estimateDeliveryDays':
            (estimateDeliveryDays as Input$IntOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (maxRevision != _undefined)
        'maxRevision': (maxRevision as Input$IntOperationFilterInput?),
      if (serviceDetails != _undefined)
        'serviceDetails':
            (serviceDetails as Input$ListFilterInputTypeOfMetadataFilterInput?),
      if (status != _undefined)
        'status': (status as Input$ArtistPackageStatusOperationFilterInput?),
      if (isDelete != _undefined)
        'isDelete': (isDelete as Input$BooleanOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$ArtistPackageFilterInput>? Function(
      Iterable<
        CopyWith$Input$ArtistPackageFilterInput<Input$ArtistPackageFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$ArtistPackageFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$ArtistPackageFilterInput>? Function(
      Iterable<
        CopyWith$Input$ArtistPackageFilterInput<Input$ArtistPackageFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$ArtistPackageFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get artistId {
    final local$artistId = _instance.artistId;
    return local$artistId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$artistId,
            (e) => call(artistId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get packageName {
    final local$packageName = _instance.packageName;
    return local$packageName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$packageName,
            (e) => call(packageName: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount {
    final local$amount = _instance.amount;
    return local$amount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$amount,
            (e) => call(amount: e),
          );
  }

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency {
    final local$currency = _instance.currency;
    return local$currency == null
        ? CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CurrencyTypeOperationFilterInput(
            local$currency,
            (e) => call(currency: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get estimateDeliveryDays {
    final local$estimateDeliveryDays = _instance.estimateDeliveryDays;
    return local$estimateDeliveryDays == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$estimateDeliveryDays,
            (e) => call(estimateDeliveryDays: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get maxRevision {
    final local$maxRevision = _instance.maxRevision;
    return local$maxRevision == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$maxRevision,
            (e) => call(maxRevision: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get serviceDetails {
    final local$serviceDetails = _instance.serviceDetails;
    return local$serviceDetails == null
        ? CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput(
            local$serviceDetails,
            (e) => call(serviceDetails: e),
          );
  }

  CopyWith$Input$ArtistPackageStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$ArtistPackageStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ArtistPackageStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDelete {
    final local$isDelete = _instance.isDelete;
    return local$isDelete == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isDelete,
            (e) => call(isDelete: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$ArtistPackageFilterInput<TRes>
    implements CopyWith$Input$ArtistPackageFilterInput<TRes> {
  _CopyWithStubImpl$Input$ArtistPackageFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ArtistPackageFilterInput>? and,
    List<Input$ArtistPackageFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? artistId,
    Input$StringOperationFilterInput? packageName,
    Input$DecimalOperationFilterInput? amount,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$IntOperationFilterInput? estimateDeliveryDays,
    Input$StringOperationFilterInput? description,
    Input$IntOperationFilterInput? maxRevision,
    Input$ListFilterInputTypeOfMetadataFilterInput? serviceDetails,
    Input$ArtistPackageStatusOperationFilterInput? status,
    Input$BooleanOperationFilterInput? isDelete,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get artistId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get packageName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency =>
      CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get estimateDeliveryDays =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get maxRevision =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get serviceDetails =>
      CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput.stub(_res);

  CopyWith$Input$ArtistPackageStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$ArtistPackageStatusOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDelete =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$ArtistPackageSortInput {
  factory Input$ArtistPackageSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? artistId,
    Enum$SortEnumType? packageName,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? estimateDeliveryDays,
    Enum$SortEnumType? description,
    Enum$SortEnumType? maxRevision,
    Enum$SortEnumType? status,
    Enum$SortEnumType? isDelete,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$ArtistPackageSortInput._({
    if (id != null) r'id': id,
    if (artistId != null) r'artistId': artistId,
    if (packageName != null) r'packageName': packageName,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (estimateDeliveryDays != null)
      r'estimateDeliveryDays': estimateDeliveryDays,
    if (description != null) r'description': description,
    if (maxRevision != null) r'maxRevision': maxRevision,
    if (status != null) r'status': status,
    if (isDelete != null) r'isDelete': isDelete,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ArtistPackageSortInput._(this._$data);

  factory Input$ArtistPackageSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('artistId')) {
      final l$artistId = data['artistId'];
      result$data['artistId'] = l$artistId == null
          ? null
          : fromJson$Enum$SortEnumType((l$artistId as String));
    }
    if (data.containsKey('packageName')) {
      final l$packageName = data['packageName'];
      result$data['packageName'] = l$packageName == null
          ? null
          : fromJson$Enum$SortEnumType((l$packageName as String));
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : fromJson$Enum$SortEnumType((l$amount as String));
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$SortEnumType((l$currency as String));
    }
    if (data.containsKey('estimateDeliveryDays')) {
      final l$estimateDeliveryDays = data['estimateDeliveryDays'];
      result$data['estimateDeliveryDays'] = l$estimateDeliveryDays == null
          ? null
          : fromJson$Enum$SortEnumType((l$estimateDeliveryDays as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('maxRevision')) {
      final l$maxRevision = data['maxRevision'];
      result$data['maxRevision'] = l$maxRevision == null
          ? null
          : fromJson$Enum$SortEnumType((l$maxRevision as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('isDelete')) {
      final l$isDelete = data['isDelete'];
      result$data['isDelete'] = l$isDelete == null
          ? null
          : fromJson$Enum$SortEnumType((l$isDelete as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$ArtistPackageSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get artistId => (_$data['artistId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get packageName =>
      (_$data['packageName'] as Enum$SortEnumType?);

  Enum$SortEnumType? get amount => (_$data['amount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get currency => (_$data['currency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get estimateDeliveryDays =>
      (_$data['estimateDeliveryDays'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get maxRevision =>
      (_$data['maxRevision'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isDelete => (_$data['isDelete'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('artistId')) {
      final l$artistId = artistId;
      result$data['artistId'] = l$artistId == null
          ? null
          : toJson$Enum$SortEnumType(l$artistId);
    }
    if (_$data.containsKey('packageName')) {
      final l$packageName = packageName;
      result$data['packageName'] = l$packageName == null
          ? null
          : toJson$Enum$SortEnumType(l$packageName);
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount == null
          ? null
          : toJson$Enum$SortEnumType(l$amount);
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$SortEnumType(l$currency);
    }
    if (_$data.containsKey('estimateDeliveryDays')) {
      final l$estimateDeliveryDays = estimateDeliveryDays;
      result$data['estimateDeliveryDays'] = l$estimateDeliveryDays == null
          ? null
          : toJson$Enum$SortEnumType(l$estimateDeliveryDays);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('maxRevision')) {
      final l$maxRevision = maxRevision;
      result$data['maxRevision'] = l$maxRevision == null
          ? null
          : toJson$Enum$SortEnumType(l$maxRevision);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('isDelete')) {
      final l$isDelete = isDelete;
      result$data['isDelete'] = l$isDelete == null
          ? null
          : toJson$Enum$SortEnumType(l$isDelete);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$ArtistPackageSortInput<Input$ArtistPackageSortInput>
  get copyWith => CopyWith$Input$ArtistPackageSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ArtistPackageSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$artistId = artistId;
    final lOther$artistId = other.artistId;
    if (_$data.containsKey('artistId') !=
        other._$data.containsKey('artistId')) {
      return false;
    }
    if (l$artistId != lOther$artistId) {
      return false;
    }
    final l$packageName = packageName;
    final lOther$packageName = other.packageName;
    if (_$data.containsKey('packageName') !=
        other._$data.containsKey('packageName')) {
      return false;
    }
    if (l$packageName != lOther$packageName) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$estimateDeliveryDays = estimateDeliveryDays;
    final lOther$estimateDeliveryDays = other.estimateDeliveryDays;
    if (_$data.containsKey('estimateDeliveryDays') !=
        other._$data.containsKey('estimateDeliveryDays')) {
      return false;
    }
    if (l$estimateDeliveryDays != lOther$estimateDeliveryDays) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$maxRevision = maxRevision;
    final lOther$maxRevision = other.maxRevision;
    if (_$data.containsKey('maxRevision') !=
        other._$data.containsKey('maxRevision')) {
      return false;
    }
    if (l$maxRevision != lOther$maxRevision) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$isDelete = isDelete;
    final lOther$isDelete = other.isDelete;
    if (_$data.containsKey('isDelete') !=
        other._$data.containsKey('isDelete')) {
      return false;
    }
    if (l$isDelete != lOther$isDelete) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$artistId = artistId;
    final l$packageName = packageName;
    final l$amount = amount;
    final l$currency = currency;
    final l$estimateDeliveryDays = estimateDeliveryDays;
    final l$description = description;
    final l$maxRevision = maxRevision;
    final l$status = status;
    final l$isDelete = isDelete;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('artistId') ? l$artistId : const {},
      _$data.containsKey('packageName') ? l$packageName : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('estimateDeliveryDays')
          ? l$estimateDeliveryDays
          : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('maxRevision') ? l$maxRevision : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('isDelete') ? l$isDelete : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ArtistPackageSortInput<TRes> {
  factory CopyWith$Input$ArtistPackageSortInput(
    Input$ArtistPackageSortInput instance,
    TRes Function(Input$ArtistPackageSortInput) then,
  ) = _CopyWithImpl$Input$ArtistPackageSortInput;

  factory CopyWith$Input$ArtistPackageSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArtistPackageSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? artistId,
    Enum$SortEnumType? packageName,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? estimateDeliveryDays,
    Enum$SortEnumType? description,
    Enum$SortEnumType? maxRevision,
    Enum$SortEnumType? status,
    Enum$SortEnumType? isDelete,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$ArtistPackageSortInput<TRes>
    implements CopyWith$Input$ArtistPackageSortInput<TRes> {
  _CopyWithImpl$Input$ArtistPackageSortInput(this._instance, this._then);

  final Input$ArtistPackageSortInput _instance;

  final TRes Function(Input$ArtistPackageSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? artistId = _undefined,
    Object? packageName = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? estimateDeliveryDays = _undefined,
    Object? description = _undefined,
    Object? maxRevision = _undefined,
    Object? status = _undefined,
    Object? isDelete = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ArtistPackageSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (artistId != _undefined) 'artistId': (artistId as Enum$SortEnumType?),
      if (packageName != _undefined)
        'packageName': (packageName as Enum$SortEnumType?),
      if (amount != _undefined) 'amount': (amount as Enum$SortEnumType?),
      if (currency != _undefined) 'currency': (currency as Enum$SortEnumType?),
      if (estimateDeliveryDays != _undefined)
        'estimateDeliveryDays': (estimateDeliveryDays as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (maxRevision != _undefined)
        'maxRevision': (maxRevision as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (isDelete != _undefined) 'isDelete': (isDelete as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$ArtistPackageSortInput<TRes>
    implements CopyWith$Input$ArtistPackageSortInput<TRes> {
  _CopyWithStubImpl$Input$ArtistPackageSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? artistId,
    Enum$SortEnumType? packageName,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? estimateDeliveryDays,
    Enum$SortEnumType? description,
    Enum$SortEnumType? maxRevision,
    Enum$SortEnumType? status,
    Enum$SortEnumType? isDelete,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$ArtistPackageStatusOperationFilterInput {
  factory Input$ArtistPackageStatusOperationFilterInput({
    Enum$ArtistPackageStatus? eq,
    Enum$ArtistPackageStatus? neq,
    List<Enum$ArtistPackageStatus>? $in,
    List<Enum$ArtistPackageStatus>? nin,
  }) => Input$ArtistPackageStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$ArtistPackageStatusOperationFilterInput._(this._$data);

  factory Input$ArtistPackageStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$ArtistPackageStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$ArtistPackageStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ArtistPackageStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ArtistPackageStatus((e as String)))
          .toList();
    }
    return Input$ArtistPackageStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ArtistPackageStatus? get eq =>
      (_$data['eq'] as Enum$ArtistPackageStatus?);

  Enum$ArtistPackageStatus? get neq =>
      (_$data['neq'] as Enum$ArtistPackageStatus?);

  List<Enum$ArtistPackageStatus>? get $in =>
      (_$data['in'] as List<Enum$ArtistPackageStatus>?);

  List<Enum$ArtistPackageStatus>? get nin =>
      (_$data['nin'] as List<Enum$ArtistPackageStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$ArtistPackageStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$ArtistPackageStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$ArtistPackageStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$ArtistPackageStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$ArtistPackageStatusOperationFilterInput<
    Input$ArtistPackageStatusOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$ArtistPackageStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ArtistPackageStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ArtistPackageStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$ArtistPackageStatusOperationFilterInput(
    Input$ArtistPackageStatusOperationFilterInput instance,
    TRes Function(Input$ArtistPackageStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ArtistPackageStatusOperationFilterInput;

  factory CopyWith$Input$ArtistPackageStatusOperationFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ArtistPackageStatusOperationFilterInput;

  TRes call({
    Enum$ArtistPackageStatus? eq,
    Enum$ArtistPackageStatus? neq,
    List<Enum$ArtistPackageStatus>? $in,
    List<Enum$ArtistPackageStatus>? nin,
  });
}

class _CopyWithImpl$Input$ArtistPackageStatusOperationFilterInput<TRes>
    implements CopyWith$Input$ArtistPackageStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ArtistPackageStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ArtistPackageStatusOperationFilterInput _instance;

  final TRes Function(Input$ArtistPackageStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$ArtistPackageStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$ArtistPackageStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$ArtistPackageStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$ArtistPackageStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$ArtistPackageStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$ArtistPackageStatusOperationFilterInput<TRes>
    implements CopyWith$Input$ArtistPackageStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ArtistPackageStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$ArtistPackageStatus? eq,
    Enum$ArtistPackageStatus? neq,
    List<Enum$ArtistPackageStatus>? $in,
    List<Enum$ArtistPackageStatus>? nin,
  }) => _res;
}

class Input$ArtistRegistrationApprovalRequestInput {
  factory Input$ArtistRegistrationApprovalRequestInput({
    required String userId,
    required String email,
    required String fullName,
    String? rejectionReason,
  }) => Input$ArtistRegistrationApprovalRequestInput._({
    r'userId': userId,
    r'email': email,
    r'fullName': fullName,
    if (rejectionReason != null) r'rejectionReason': rejectionReason,
  });

  Input$ArtistRegistrationApprovalRequestInput._(this._$data);

  factory Input$ArtistRegistrationApprovalRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    final l$email = data['email'];
    result$data['email'] = (l$email as String);
    final l$fullName = data['fullName'];
    result$data['fullName'] = (l$fullName as String);
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    return Input$ArtistRegistrationApprovalRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get userId => (_$data['userId'] as String);

  String get email => (_$data['email'] as String);

  String get fullName => (_$data['fullName'] as String);

  String? get rejectionReason => (_$data['rejectionReason'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$userId = userId;
    result$data['userId'] = l$userId;
    final l$email = email;
    result$data['email'] = l$email;
    final l$fullName = fullName;
    result$data['fullName'] = l$fullName;
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    return result$data;
  }

  CopyWith$Input$ArtistRegistrationApprovalRequestInput<
    Input$ArtistRegistrationApprovalRequestInput
  >
  get copyWith =>
      CopyWith$Input$ArtistRegistrationApprovalRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ArtistRegistrationApprovalRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$email = email;
    final l$fullName = fullName;
    final l$rejectionReason = rejectionReason;
    return Object.hashAll([
      l$userId,
      l$email,
      l$fullName,
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
    ]);
  }
}

abstract class CopyWith$Input$ArtistRegistrationApprovalRequestInput<TRes> {
  factory CopyWith$Input$ArtistRegistrationApprovalRequestInput(
    Input$ArtistRegistrationApprovalRequestInput instance,
    TRes Function(Input$ArtistRegistrationApprovalRequestInput) then,
  ) = _CopyWithImpl$Input$ArtistRegistrationApprovalRequestInput;

  factory CopyWith$Input$ArtistRegistrationApprovalRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArtistRegistrationApprovalRequestInput;

  TRes call({
    String? userId,
    String? email,
    String? fullName,
    String? rejectionReason,
  });
}

class _CopyWithImpl$Input$ArtistRegistrationApprovalRequestInput<TRes>
    implements CopyWith$Input$ArtistRegistrationApprovalRequestInput<TRes> {
  _CopyWithImpl$Input$ArtistRegistrationApprovalRequestInput(
    this._instance,
    this._then,
  );

  final Input$ArtistRegistrationApprovalRequestInput _instance;

  final TRes Function(Input$ArtistRegistrationApprovalRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? userId = _undefined,
    Object? email = _undefined,
    Object? fullName = _undefined,
    Object? rejectionReason = _undefined,
  }) => _then(
    Input$ArtistRegistrationApprovalRequestInput._({
      ..._instance._$data,
      if (userId != _undefined && userId != null) 'userId': (userId as String),
      if (email != _undefined && email != null) 'email': (email as String),
      if (fullName != _undefined && fullName != null)
        'fullName': (fullName as String),
      if (rejectionReason != _undefined)
        'rejectionReason': (rejectionReason as String?),
    }),
  );
}

class _CopyWithStubImpl$Input$ArtistRegistrationApprovalRequestInput<TRes>
    implements CopyWith$Input$ArtistRegistrationApprovalRequestInput<TRes> {
  _CopyWithStubImpl$Input$ArtistRegistrationApprovalRequestInput(this._res);

  TRes _res;

  call({
    String? userId,
    String? email,
    String? fullName,
    String? rejectionReason,
  }) => _res;
}

class Input$ArtistRoleOperationFilterInput {
  factory Input$ArtistRoleOperationFilterInput({
    Enum$ArtistRole? eq,
    Enum$ArtistRole? neq,
    List<Enum$ArtistRole>? $in,
    List<Enum$ArtistRole>? nin,
  }) => Input$ArtistRoleOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$ArtistRoleOperationFilterInput._(this._$data);

  factory Input$ArtistRoleOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$ArtistRole((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$ArtistRole((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ArtistRole((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ArtistRole((e as String)))
          .toList();
    }
    return Input$ArtistRoleOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ArtistRole? get eq => (_$data['eq'] as Enum$ArtistRole?);

  Enum$ArtistRole? get neq => (_$data['neq'] as Enum$ArtistRole?);

  List<Enum$ArtistRole>? get $in => (_$data['in'] as List<Enum$ArtistRole>?);

  List<Enum$ArtistRole>? get nin => (_$data['nin'] as List<Enum$ArtistRole>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$ArtistRole(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$ArtistRole(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$ArtistRole(e)).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$ArtistRole(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$ArtistRoleOperationFilterInput<
    Input$ArtistRoleOperationFilterInput
  >
  get copyWith => CopyWith$Input$ArtistRoleOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ArtistRoleOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ArtistRoleOperationFilterInput<TRes> {
  factory CopyWith$Input$ArtistRoleOperationFilterInput(
    Input$ArtistRoleOperationFilterInput instance,
    TRes Function(Input$ArtistRoleOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ArtistRoleOperationFilterInput;

  factory CopyWith$Input$ArtistRoleOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArtistRoleOperationFilterInput;

  TRes call({
    Enum$ArtistRole? eq,
    Enum$ArtistRole? neq,
    List<Enum$ArtistRole>? $in,
    List<Enum$ArtistRole>? nin,
  });
}

class _CopyWithImpl$Input$ArtistRoleOperationFilterInput<TRes>
    implements CopyWith$Input$ArtistRoleOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ArtistRoleOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ArtistRoleOperationFilterInput _instance;

  final TRes Function(Input$ArtistRoleOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$ArtistRoleOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$ArtistRole?),
      if (neq != _undefined) 'neq': (neq as Enum$ArtistRole?),
      if ($in != _undefined) 'in': ($in as List<Enum$ArtistRole>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$ArtistRole>?),
    }),
  );
}

class _CopyWithStubImpl$Input$ArtistRoleOperationFilterInput<TRes>
    implements CopyWith$Input$ArtistRoleOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ArtistRoleOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$ArtistRole? eq,
    Enum$ArtistRole? neq,
    List<Enum$ArtistRole>? $in,
    List<Enum$ArtistRole>? nin,
  }) => _res;
}

class Input$ArtistSortInput {
  factory Input$ArtistSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? stageName,
    Enum$SortEnumType? stageNameUnsigned,
    Enum$SortEnumType? email,
    Enum$SortEnumType? artistType,
    Enum$SortEnumType? biography,
    Enum$SortEnumType? followerCount,
    Enum$SortEnumType? popularity,
    Enum$SortEnumType? avatarImage,
    Enum$SortEnumType? bannerImage,
    Enum$SortEnumType? isVerified,
    Enum$SortEnumType? verifiedAt,
    Input$IdentityCardSortInput? identityCard,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? royaltyEarnings,
    Enum$SortEnumType? serviceRevenue,
    Enum$SortEnumType? grossRevenue,
    Enum$SortEnumType? refundAmount,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$ArtistSortInput._({
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (stageName != null) r'stageName': stageName,
    if (stageNameUnsigned != null) r'stageNameUnsigned': stageNameUnsigned,
    if (email != null) r'email': email,
    if (artistType != null) r'artistType': artistType,
    if (biography != null) r'biography': biography,
    if (followerCount != null) r'followerCount': followerCount,
    if (popularity != null) r'popularity': popularity,
    if (avatarImage != null) r'avatarImage': avatarImage,
    if (bannerImage != null) r'bannerImage': bannerImage,
    if (isVerified != null) r'isVerified': isVerified,
    if (verifiedAt != null) r'verifiedAt': verifiedAt,
    if (identityCard != null) r'identityCard': identityCard,
    if (isVisible != null) r'isVisible': isVisible,
    if (royaltyEarnings != null) r'royaltyEarnings': royaltyEarnings,
    if (serviceRevenue != null) r'serviceRevenue': serviceRevenue,
    if (grossRevenue != null) r'grossRevenue': grossRevenue,
    if (refundAmount != null) r'refundAmount': refundAmount,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ArtistSortInput._(this._$data);

  factory Input$ArtistSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$SortEnumType((l$userId as String));
    }
    if (data.containsKey('stageName')) {
      final l$stageName = data['stageName'];
      result$data['stageName'] = l$stageName == null
          ? null
          : fromJson$Enum$SortEnumType((l$stageName as String));
    }
    if (data.containsKey('stageNameUnsigned')) {
      final l$stageNameUnsigned = data['stageNameUnsigned'];
      result$data['stageNameUnsigned'] = l$stageNameUnsigned == null
          ? null
          : fromJson$Enum$SortEnumType((l$stageNameUnsigned as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : fromJson$Enum$SortEnumType((l$email as String));
    }
    if (data.containsKey('artistType')) {
      final l$artistType = data['artistType'];
      result$data['artistType'] = l$artistType == null
          ? null
          : fromJson$Enum$SortEnumType((l$artistType as String));
    }
    if (data.containsKey('biography')) {
      final l$biography = data['biography'];
      result$data['biography'] = l$biography == null
          ? null
          : fromJson$Enum$SortEnumType((l$biography as String));
    }
    if (data.containsKey('followerCount')) {
      final l$followerCount = data['followerCount'];
      result$data['followerCount'] = l$followerCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$followerCount as String));
    }
    if (data.containsKey('popularity')) {
      final l$popularity = data['popularity'];
      result$data['popularity'] = l$popularity == null
          ? null
          : fromJson$Enum$SortEnumType((l$popularity as String));
    }
    if (data.containsKey('avatarImage')) {
      final l$avatarImage = data['avatarImage'];
      result$data['avatarImage'] = l$avatarImage == null
          ? null
          : fromJson$Enum$SortEnumType((l$avatarImage as String));
    }
    if (data.containsKey('bannerImage')) {
      final l$bannerImage = data['bannerImage'];
      result$data['bannerImage'] = l$bannerImage == null
          ? null
          : fromJson$Enum$SortEnumType((l$bannerImage as String));
    }
    if (data.containsKey('isVerified')) {
      final l$isVerified = data['isVerified'];
      result$data['isVerified'] = l$isVerified == null
          ? null
          : fromJson$Enum$SortEnumType((l$isVerified as String));
    }
    if (data.containsKey('verifiedAt')) {
      final l$verifiedAt = data['verifiedAt'];
      result$data['verifiedAt'] = l$verifiedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$verifiedAt as String));
    }
    if (data.containsKey('identityCard')) {
      final l$identityCard = data['identityCard'];
      result$data['identityCard'] = l$identityCard == null
          ? null
          : Input$IdentityCardSortInput.fromJson(
              (l$identityCard as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : fromJson$Enum$SortEnumType((l$isVisible as String));
    }
    if (data.containsKey('royaltyEarnings')) {
      final l$royaltyEarnings = data['royaltyEarnings'];
      result$data['royaltyEarnings'] = l$royaltyEarnings == null
          ? null
          : fromJson$Enum$SortEnumType((l$royaltyEarnings as String));
    }
    if (data.containsKey('serviceRevenue')) {
      final l$serviceRevenue = data['serviceRevenue'];
      result$data['serviceRevenue'] = l$serviceRevenue == null
          ? null
          : fromJson$Enum$SortEnumType((l$serviceRevenue as String));
    }
    if (data.containsKey('grossRevenue')) {
      final l$grossRevenue = data['grossRevenue'];
      result$data['grossRevenue'] = l$grossRevenue == null
          ? null
          : fromJson$Enum$SortEnumType((l$grossRevenue as String));
    }
    if (data.containsKey('refundAmount')) {
      final l$refundAmount = data['refundAmount'];
      result$data['refundAmount'] = l$refundAmount == null
          ? null
          : fromJson$Enum$SortEnumType((l$refundAmount as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$ArtistSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get userId => (_$data['userId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stageName =>
      (_$data['stageName'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stageNameUnsigned =>
      (_$data['stageNameUnsigned'] as Enum$SortEnumType?);

  Enum$SortEnumType? get email => (_$data['email'] as Enum$SortEnumType?);

  Enum$SortEnumType? get artistType =>
      (_$data['artistType'] as Enum$SortEnumType?);

  Enum$SortEnumType? get biography =>
      (_$data['biography'] as Enum$SortEnumType?);

  Enum$SortEnumType? get followerCount =>
      (_$data['followerCount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get popularity =>
      (_$data['popularity'] as Enum$SortEnumType?);

  Enum$SortEnumType? get avatarImage =>
      (_$data['avatarImage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get bannerImage =>
      (_$data['bannerImage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isVerified =>
      (_$data['isVerified'] as Enum$SortEnumType?);

  Enum$SortEnumType? get verifiedAt =>
      (_$data['verifiedAt'] as Enum$SortEnumType?);

  Input$IdentityCardSortInput? get identityCard =>
      (_$data['identityCard'] as Input$IdentityCardSortInput?);

  Enum$SortEnumType? get isVisible =>
      (_$data['isVisible'] as Enum$SortEnumType?);

  Enum$SortEnumType? get royaltyEarnings =>
      (_$data['royaltyEarnings'] as Enum$SortEnumType?);

  Enum$SortEnumType? get serviceRevenue =>
      (_$data['serviceRevenue'] as Enum$SortEnumType?);

  Enum$SortEnumType? get grossRevenue =>
      (_$data['grossRevenue'] as Enum$SortEnumType?);

  Enum$SortEnumType? get refundAmount =>
      (_$data['refundAmount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId == null
          ? null
          : toJson$Enum$SortEnumType(l$userId);
    }
    if (_$data.containsKey('stageName')) {
      final l$stageName = stageName;
      result$data['stageName'] = l$stageName == null
          ? null
          : toJson$Enum$SortEnumType(l$stageName);
    }
    if (_$data.containsKey('stageNameUnsigned')) {
      final l$stageNameUnsigned = stageNameUnsigned;
      result$data['stageNameUnsigned'] = l$stageNameUnsigned == null
          ? null
          : toJson$Enum$SortEnumType(l$stageNameUnsigned);
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email == null
          ? null
          : toJson$Enum$SortEnumType(l$email);
    }
    if (_$data.containsKey('artistType')) {
      final l$artistType = artistType;
      result$data['artistType'] = l$artistType == null
          ? null
          : toJson$Enum$SortEnumType(l$artistType);
    }
    if (_$data.containsKey('biography')) {
      final l$biography = biography;
      result$data['biography'] = l$biography == null
          ? null
          : toJson$Enum$SortEnumType(l$biography);
    }
    if (_$data.containsKey('followerCount')) {
      final l$followerCount = followerCount;
      result$data['followerCount'] = l$followerCount == null
          ? null
          : toJson$Enum$SortEnumType(l$followerCount);
    }
    if (_$data.containsKey('popularity')) {
      final l$popularity = popularity;
      result$data['popularity'] = l$popularity == null
          ? null
          : toJson$Enum$SortEnumType(l$popularity);
    }
    if (_$data.containsKey('avatarImage')) {
      final l$avatarImage = avatarImage;
      result$data['avatarImage'] = l$avatarImage == null
          ? null
          : toJson$Enum$SortEnumType(l$avatarImage);
    }
    if (_$data.containsKey('bannerImage')) {
      final l$bannerImage = bannerImage;
      result$data['bannerImage'] = l$bannerImage == null
          ? null
          : toJson$Enum$SortEnumType(l$bannerImage);
    }
    if (_$data.containsKey('isVerified')) {
      final l$isVerified = isVerified;
      result$data['isVerified'] = l$isVerified == null
          ? null
          : toJson$Enum$SortEnumType(l$isVerified);
    }
    if (_$data.containsKey('verifiedAt')) {
      final l$verifiedAt = verifiedAt;
      result$data['verifiedAt'] = l$verifiedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$verifiedAt);
    }
    if (_$data.containsKey('identityCard')) {
      final l$identityCard = identityCard;
      result$data['identityCard'] = l$identityCard?.toJson();
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible == null
          ? null
          : toJson$Enum$SortEnumType(l$isVisible);
    }
    if (_$data.containsKey('royaltyEarnings')) {
      final l$royaltyEarnings = royaltyEarnings;
      result$data['royaltyEarnings'] = l$royaltyEarnings == null
          ? null
          : toJson$Enum$SortEnumType(l$royaltyEarnings);
    }
    if (_$data.containsKey('serviceRevenue')) {
      final l$serviceRevenue = serviceRevenue;
      result$data['serviceRevenue'] = l$serviceRevenue == null
          ? null
          : toJson$Enum$SortEnumType(l$serviceRevenue);
    }
    if (_$data.containsKey('grossRevenue')) {
      final l$grossRevenue = grossRevenue;
      result$data['grossRevenue'] = l$grossRevenue == null
          ? null
          : toJson$Enum$SortEnumType(l$grossRevenue);
    }
    if (_$data.containsKey('refundAmount')) {
      final l$refundAmount = refundAmount;
      result$data['refundAmount'] = l$refundAmount == null
          ? null
          : toJson$Enum$SortEnumType(l$refundAmount);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$ArtistSortInput<Input$ArtistSortInput> get copyWith =>
      CopyWith$Input$ArtistSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ArtistSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$stageName = stageName;
    final lOther$stageName = other.stageName;
    if (_$data.containsKey('stageName') !=
        other._$data.containsKey('stageName')) {
      return false;
    }
    if (l$stageName != lOther$stageName) {
      return false;
    }
    final l$stageNameUnsigned = stageNameUnsigned;
    final lOther$stageNameUnsigned = other.stageNameUnsigned;
    if (_$data.containsKey('stageNameUnsigned') !=
        other._$data.containsKey('stageNameUnsigned')) {
      return false;
    }
    if (l$stageNameUnsigned != lOther$stageNameUnsigned) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$artistType = artistType;
    final lOther$artistType = other.artistType;
    if (_$data.containsKey('artistType') !=
        other._$data.containsKey('artistType')) {
      return false;
    }
    if (l$artistType != lOther$artistType) {
      return false;
    }
    final l$biography = biography;
    final lOther$biography = other.biography;
    if (_$data.containsKey('biography') !=
        other._$data.containsKey('biography')) {
      return false;
    }
    if (l$biography != lOther$biography) {
      return false;
    }
    final l$followerCount = followerCount;
    final lOther$followerCount = other.followerCount;
    if (_$data.containsKey('followerCount') !=
        other._$data.containsKey('followerCount')) {
      return false;
    }
    if (l$followerCount != lOther$followerCount) {
      return false;
    }
    final l$popularity = popularity;
    final lOther$popularity = other.popularity;
    if (_$data.containsKey('popularity') !=
        other._$data.containsKey('popularity')) {
      return false;
    }
    if (l$popularity != lOther$popularity) {
      return false;
    }
    final l$avatarImage = avatarImage;
    final lOther$avatarImage = other.avatarImage;
    if (_$data.containsKey('avatarImage') !=
        other._$data.containsKey('avatarImage')) {
      return false;
    }
    if (l$avatarImage != lOther$avatarImage) {
      return false;
    }
    final l$bannerImage = bannerImage;
    final lOther$bannerImage = other.bannerImage;
    if (_$data.containsKey('bannerImage') !=
        other._$data.containsKey('bannerImage')) {
      return false;
    }
    if (l$bannerImage != lOther$bannerImage) {
      return false;
    }
    final l$isVerified = isVerified;
    final lOther$isVerified = other.isVerified;
    if (_$data.containsKey('isVerified') !=
        other._$data.containsKey('isVerified')) {
      return false;
    }
    if (l$isVerified != lOther$isVerified) {
      return false;
    }
    final l$verifiedAt = verifiedAt;
    final lOther$verifiedAt = other.verifiedAt;
    if (_$data.containsKey('verifiedAt') !=
        other._$data.containsKey('verifiedAt')) {
      return false;
    }
    if (l$verifiedAt != lOther$verifiedAt) {
      return false;
    }
    final l$identityCard = identityCard;
    final lOther$identityCard = other.identityCard;
    if (_$data.containsKey('identityCard') !=
        other._$data.containsKey('identityCard')) {
      return false;
    }
    if (l$identityCard != lOther$identityCard) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$royaltyEarnings = royaltyEarnings;
    final lOther$royaltyEarnings = other.royaltyEarnings;
    if (_$data.containsKey('royaltyEarnings') !=
        other._$data.containsKey('royaltyEarnings')) {
      return false;
    }
    if (l$royaltyEarnings != lOther$royaltyEarnings) {
      return false;
    }
    final l$serviceRevenue = serviceRevenue;
    final lOther$serviceRevenue = other.serviceRevenue;
    if (_$data.containsKey('serviceRevenue') !=
        other._$data.containsKey('serviceRevenue')) {
      return false;
    }
    if (l$serviceRevenue != lOther$serviceRevenue) {
      return false;
    }
    final l$grossRevenue = grossRevenue;
    final lOther$grossRevenue = other.grossRevenue;
    if (_$data.containsKey('grossRevenue') !=
        other._$data.containsKey('grossRevenue')) {
      return false;
    }
    if (l$grossRevenue != lOther$grossRevenue) {
      return false;
    }
    final l$refundAmount = refundAmount;
    final lOther$refundAmount = other.refundAmount;
    if (_$data.containsKey('refundAmount') !=
        other._$data.containsKey('refundAmount')) {
      return false;
    }
    if (l$refundAmount != lOther$refundAmount) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$stageName = stageName;
    final l$stageNameUnsigned = stageNameUnsigned;
    final l$email = email;
    final l$artistType = artistType;
    final l$biography = biography;
    final l$followerCount = followerCount;
    final l$popularity = popularity;
    final l$avatarImage = avatarImage;
    final l$bannerImage = bannerImage;
    final l$isVerified = isVerified;
    final l$verifiedAt = verifiedAt;
    final l$identityCard = identityCard;
    final l$isVisible = isVisible;
    final l$royaltyEarnings = royaltyEarnings;
    final l$serviceRevenue = serviceRevenue;
    final l$grossRevenue = grossRevenue;
    final l$refundAmount = refundAmount;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('stageName') ? l$stageName : const {},
      _$data.containsKey('stageNameUnsigned') ? l$stageNameUnsigned : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('artistType') ? l$artistType : const {},
      _$data.containsKey('biography') ? l$biography : const {},
      _$data.containsKey('followerCount') ? l$followerCount : const {},
      _$data.containsKey('popularity') ? l$popularity : const {},
      _$data.containsKey('avatarImage') ? l$avatarImage : const {},
      _$data.containsKey('bannerImage') ? l$bannerImage : const {},
      _$data.containsKey('isVerified') ? l$isVerified : const {},
      _$data.containsKey('verifiedAt') ? l$verifiedAt : const {},
      _$data.containsKey('identityCard') ? l$identityCard : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('royaltyEarnings') ? l$royaltyEarnings : const {},
      _$data.containsKey('serviceRevenue') ? l$serviceRevenue : const {},
      _$data.containsKey('grossRevenue') ? l$grossRevenue : const {},
      _$data.containsKey('refundAmount') ? l$refundAmount : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ArtistSortInput<TRes> {
  factory CopyWith$Input$ArtistSortInput(
    Input$ArtistSortInput instance,
    TRes Function(Input$ArtistSortInput) then,
  ) = _CopyWithImpl$Input$ArtistSortInput;

  factory CopyWith$Input$ArtistSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArtistSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? stageName,
    Enum$SortEnumType? stageNameUnsigned,
    Enum$SortEnumType? email,
    Enum$SortEnumType? artistType,
    Enum$SortEnumType? biography,
    Enum$SortEnumType? followerCount,
    Enum$SortEnumType? popularity,
    Enum$SortEnumType? avatarImage,
    Enum$SortEnumType? bannerImage,
    Enum$SortEnumType? isVerified,
    Enum$SortEnumType? verifiedAt,
    Input$IdentityCardSortInput? identityCard,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? royaltyEarnings,
    Enum$SortEnumType? serviceRevenue,
    Enum$SortEnumType? grossRevenue,
    Enum$SortEnumType? refundAmount,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
  CopyWith$Input$IdentityCardSortInput<TRes> get identityCard;
}

class _CopyWithImpl$Input$ArtistSortInput<TRes>
    implements CopyWith$Input$ArtistSortInput<TRes> {
  _CopyWithImpl$Input$ArtistSortInput(this._instance, this._then);

  final Input$ArtistSortInput _instance;

  final TRes Function(Input$ArtistSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? stageName = _undefined,
    Object? stageNameUnsigned = _undefined,
    Object? email = _undefined,
    Object? artistType = _undefined,
    Object? biography = _undefined,
    Object? followerCount = _undefined,
    Object? popularity = _undefined,
    Object? avatarImage = _undefined,
    Object? bannerImage = _undefined,
    Object? isVerified = _undefined,
    Object? verifiedAt = _undefined,
    Object? identityCard = _undefined,
    Object? isVisible = _undefined,
    Object? royaltyEarnings = _undefined,
    Object? serviceRevenue = _undefined,
    Object? grossRevenue = _undefined,
    Object? refundAmount = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ArtistSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (userId != _undefined) 'userId': (userId as Enum$SortEnumType?),
      if (stageName != _undefined)
        'stageName': (stageName as Enum$SortEnumType?),
      if (stageNameUnsigned != _undefined)
        'stageNameUnsigned': (stageNameUnsigned as Enum$SortEnumType?),
      if (email != _undefined) 'email': (email as Enum$SortEnumType?),
      if (artistType != _undefined)
        'artistType': (artistType as Enum$SortEnumType?),
      if (biography != _undefined)
        'biography': (biography as Enum$SortEnumType?),
      if (followerCount != _undefined)
        'followerCount': (followerCount as Enum$SortEnumType?),
      if (popularity != _undefined)
        'popularity': (popularity as Enum$SortEnumType?),
      if (avatarImage != _undefined)
        'avatarImage': (avatarImage as Enum$SortEnumType?),
      if (bannerImage != _undefined)
        'bannerImage': (bannerImage as Enum$SortEnumType?),
      if (isVerified != _undefined)
        'isVerified': (isVerified as Enum$SortEnumType?),
      if (verifiedAt != _undefined)
        'verifiedAt': (verifiedAt as Enum$SortEnumType?),
      if (identityCard != _undefined)
        'identityCard': (identityCard as Input$IdentityCardSortInput?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Enum$SortEnumType?),
      if (royaltyEarnings != _undefined)
        'royaltyEarnings': (royaltyEarnings as Enum$SortEnumType?),
      if (serviceRevenue != _undefined)
        'serviceRevenue': (serviceRevenue as Enum$SortEnumType?),
      if (grossRevenue != _undefined)
        'grossRevenue': (grossRevenue as Enum$SortEnumType?),
      if (refundAmount != _undefined)
        'refundAmount': (refundAmount as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );

  CopyWith$Input$IdentityCardSortInput<TRes> get identityCard {
    final local$identityCard = _instance.identityCard;
    return local$identityCard == null
        ? CopyWith$Input$IdentityCardSortInput.stub(_then(_instance))
        : CopyWith$Input$IdentityCardSortInput(
            local$identityCard,
            (e) => call(identityCard: e),
          );
  }
}

class _CopyWithStubImpl$Input$ArtistSortInput<TRes>
    implements CopyWith$Input$ArtistSortInput<TRes> {
  _CopyWithStubImpl$Input$ArtistSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? stageName,
    Enum$SortEnumType? stageNameUnsigned,
    Enum$SortEnumType? email,
    Enum$SortEnumType? artistType,
    Enum$SortEnumType? biography,
    Enum$SortEnumType? followerCount,
    Enum$SortEnumType? popularity,
    Enum$SortEnumType? avatarImage,
    Enum$SortEnumType? bannerImage,
    Enum$SortEnumType? isVerified,
    Enum$SortEnumType? verifiedAt,
    Input$IdentityCardSortInput? identityCard,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? royaltyEarnings,
    Enum$SortEnumType? serviceRevenue,
    Enum$SortEnumType? grossRevenue,
    Enum$SortEnumType? refundAmount,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;

  CopyWith$Input$IdentityCardSortInput<TRes> get identityCard =>
      CopyWith$Input$IdentityCardSortInput.stub(_res);
}

class Input$ArtistTypeOperationFilterInput {
  factory Input$ArtistTypeOperationFilterInput({
    Enum$ArtistType? eq,
    Enum$ArtistType? neq,
    List<Enum$ArtistType>? $in,
    List<Enum$ArtistType>? nin,
  }) => Input$ArtistTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$ArtistTypeOperationFilterInput._(this._$data);

  factory Input$ArtistTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$ArtistType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$ArtistType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ArtistType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ArtistType((e as String)))
          .toList();
    }
    return Input$ArtistTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ArtistType? get eq => (_$data['eq'] as Enum$ArtistType?);

  Enum$ArtistType? get neq => (_$data['neq'] as Enum$ArtistType?);

  List<Enum$ArtistType>? get $in => (_$data['in'] as List<Enum$ArtistType>?);

  List<Enum$ArtistType>? get nin => (_$data['nin'] as List<Enum$ArtistType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$ArtistType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$ArtistType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$ArtistType(e)).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$ArtistType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$ArtistTypeOperationFilterInput<
    Input$ArtistTypeOperationFilterInput
  >
  get copyWith => CopyWith$Input$ArtistTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ArtistTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ArtistTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$ArtistTypeOperationFilterInput(
    Input$ArtistTypeOperationFilterInput instance,
    TRes Function(Input$ArtistTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ArtistTypeOperationFilterInput;

  factory CopyWith$Input$ArtistTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArtistTypeOperationFilterInput;

  TRes call({
    Enum$ArtistType? eq,
    Enum$ArtistType? neq,
    List<Enum$ArtistType>? $in,
    List<Enum$ArtistType>? nin,
  });
}

class _CopyWithImpl$Input$ArtistTypeOperationFilterInput<TRes>
    implements CopyWith$Input$ArtistTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ArtistTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ArtistTypeOperationFilterInput _instance;

  final TRes Function(Input$ArtistTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$ArtistTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$ArtistType?),
      if (neq != _undefined) 'neq': (neq as Enum$ArtistType?),
      if ($in != _undefined) 'in': ($in as List<Enum$ArtistType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$ArtistType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$ArtistTypeOperationFilterInput<TRes>
    implements CopyWith$Input$ArtistTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ArtistTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$ArtistType? eq,
    Enum$ArtistType? neq,
    List<Enum$ArtistType>? $in,
    List<Enum$ArtistType>? nin,
  }) => _res;
}

class Input$AudioFeatureFilterInput {
  factory Input$AudioFeatureFilterInput({
    List<Input$AudioFeatureFilterInput>? and,
    List<Input$AudioFeatureFilterInput>? or,
    Input$FloatOperationFilterInput? tempo,
    Input$StringOperationFilterInput? key,
    Input$IntOperationFilterInput? keyNumber,
    Input$StringOperationFilterInput? mode,
    Input$IntOperationFilterInput? modeNumber,
    Input$FloatOperationFilterInput? energy,
    Input$FloatOperationFilterInput? danceability,
    Input$FloatOperationFilterInput? acousticness,
    Input$FloatOperationFilterInput? spectralCentroid,
    Input$FloatOperationFilterInput? zeroCrossingRate,
    Input$FloatOperationFilterInput? duration,
    Input$ListFloatOperationFilterInput? chromaMean,
    Input$ListFloatOperationFilterInput? mfccMean,
  }) => Input$AudioFeatureFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (tempo != null) r'tempo': tempo,
    if (key != null) r'key': key,
    if (keyNumber != null) r'keyNumber': keyNumber,
    if (mode != null) r'mode': mode,
    if (modeNumber != null) r'modeNumber': modeNumber,
    if (energy != null) r'energy': energy,
    if (danceability != null) r'danceability': danceability,
    if (acousticness != null) r'acousticness': acousticness,
    if (spectralCentroid != null) r'spectralCentroid': spectralCentroid,
    if (zeroCrossingRate != null) r'zeroCrossingRate': zeroCrossingRate,
    if (duration != null) r'duration': duration,
    if (chromaMean != null) r'chromaMean': chromaMean,
    if (mfccMean != null) r'mfccMean': mfccMean,
  });

  Input$AudioFeatureFilterInput._(this._$data);

  factory Input$AudioFeatureFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$AudioFeatureFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$AudioFeatureFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('tempo')) {
      final l$tempo = data['tempo'];
      result$data['tempo'] = l$tempo == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$tempo as Map<String, dynamic>),
            );
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$key as Map<String, dynamic>),
            );
    }
    if (data.containsKey('keyNumber')) {
      final l$keyNumber = data['keyNumber'];
      result$data['keyNumber'] = l$keyNumber == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$keyNumber as Map<String, dynamic>),
            );
    }
    if (data.containsKey('mode')) {
      final l$mode = data['mode'];
      result$data['mode'] = l$mode == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$mode as Map<String, dynamic>),
            );
    }
    if (data.containsKey('modeNumber')) {
      final l$modeNumber = data['modeNumber'];
      result$data['modeNumber'] = l$modeNumber == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$modeNumber as Map<String, dynamic>),
            );
    }
    if (data.containsKey('energy')) {
      final l$energy = data['energy'];
      result$data['energy'] = l$energy == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$energy as Map<String, dynamic>),
            );
    }
    if (data.containsKey('danceability')) {
      final l$danceability = data['danceability'];
      result$data['danceability'] = l$danceability == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$danceability as Map<String, dynamic>),
            );
    }
    if (data.containsKey('acousticness')) {
      final l$acousticness = data['acousticness'];
      result$data['acousticness'] = l$acousticness == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$acousticness as Map<String, dynamic>),
            );
    }
    if (data.containsKey('spectralCentroid')) {
      final l$spectralCentroid = data['spectralCentroid'];
      result$data['spectralCentroid'] = l$spectralCentroid == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$spectralCentroid as Map<String, dynamic>),
            );
    }
    if (data.containsKey('zeroCrossingRate')) {
      final l$zeroCrossingRate = data['zeroCrossingRate'];
      result$data['zeroCrossingRate'] = l$zeroCrossingRate == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$zeroCrossingRate as Map<String, dynamic>),
            );
    }
    if (data.containsKey('duration')) {
      final l$duration = data['duration'];
      result$data['duration'] = l$duration == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$duration as Map<String, dynamic>),
            );
    }
    if (data.containsKey('chromaMean')) {
      final l$chromaMean = data['chromaMean'];
      result$data['chromaMean'] = l$chromaMean == null
          ? null
          : Input$ListFloatOperationFilterInput.fromJson(
              (l$chromaMean as Map<String, dynamic>),
            );
    }
    if (data.containsKey('mfccMean')) {
      final l$mfccMean = data['mfccMean'];
      result$data['mfccMean'] = l$mfccMean == null
          ? null
          : Input$ListFloatOperationFilterInput.fromJson(
              (l$mfccMean as Map<String, dynamic>),
            );
    }
    return Input$AudioFeatureFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$AudioFeatureFilterInput>? get and =>
      (_$data['and'] as List<Input$AudioFeatureFilterInput>?);

  List<Input$AudioFeatureFilterInput>? get or =>
      (_$data['or'] as List<Input$AudioFeatureFilterInput>?);

  Input$FloatOperationFilterInput? get tempo =>
      (_$data['tempo'] as Input$FloatOperationFilterInput?);

  Input$StringOperationFilterInput? get key =>
      (_$data['key'] as Input$StringOperationFilterInput?);

  Input$IntOperationFilterInput? get keyNumber =>
      (_$data['keyNumber'] as Input$IntOperationFilterInput?);

  Input$StringOperationFilterInput? get mode =>
      (_$data['mode'] as Input$StringOperationFilterInput?);

  Input$IntOperationFilterInput? get modeNumber =>
      (_$data['modeNumber'] as Input$IntOperationFilterInput?);

  Input$FloatOperationFilterInput? get energy =>
      (_$data['energy'] as Input$FloatOperationFilterInput?);

  Input$FloatOperationFilterInput? get danceability =>
      (_$data['danceability'] as Input$FloatOperationFilterInput?);

  Input$FloatOperationFilterInput? get acousticness =>
      (_$data['acousticness'] as Input$FloatOperationFilterInput?);

  Input$FloatOperationFilterInput? get spectralCentroid =>
      (_$data['spectralCentroid'] as Input$FloatOperationFilterInput?);

  Input$FloatOperationFilterInput? get zeroCrossingRate =>
      (_$data['zeroCrossingRate'] as Input$FloatOperationFilterInput?);

  Input$FloatOperationFilterInput? get duration =>
      (_$data['duration'] as Input$FloatOperationFilterInput?);

  Input$ListFloatOperationFilterInput? get chromaMean =>
      (_$data['chromaMean'] as Input$ListFloatOperationFilterInput?);

  Input$ListFloatOperationFilterInput? get mfccMean =>
      (_$data['mfccMean'] as Input$ListFloatOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('tempo')) {
      final l$tempo = tempo;
      result$data['tempo'] = l$tempo?.toJson();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('keyNumber')) {
      final l$keyNumber = keyNumber;
      result$data['keyNumber'] = l$keyNumber?.toJson();
    }
    if (_$data.containsKey('mode')) {
      final l$mode = mode;
      result$data['mode'] = l$mode?.toJson();
    }
    if (_$data.containsKey('modeNumber')) {
      final l$modeNumber = modeNumber;
      result$data['modeNumber'] = l$modeNumber?.toJson();
    }
    if (_$data.containsKey('energy')) {
      final l$energy = energy;
      result$data['energy'] = l$energy?.toJson();
    }
    if (_$data.containsKey('danceability')) {
      final l$danceability = danceability;
      result$data['danceability'] = l$danceability?.toJson();
    }
    if (_$data.containsKey('acousticness')) {
      final l$acousticness = acousticness;
      result$data['acousticness'] = l$acousticness?.toJson();
    }
    if (_$data.containsKey('spectralCentroid')) {
      final l$spectralCentroid = spectralCentroid;
      result$data['spectralCentroid'] = l$spectralCentroid?.toJson();
    }
    if (_$data.containsKey('zeroCrossingRate')) {
      final l$zeroCrossingRate = zeroCrossingRate;
      result$data['zeroCrossingRate'] = l$zeroCrossingRate?.toJson();
    }
    if (_$data.containsKey('duration')) {
      final l$duration = duration;
      result$data['duration'] = l$duration?.toJson();
    }
    if (_$data.containsKey('chromaMean')) {
      final l$chromaMean = chromaMean;
      result$data['chromaMean'] = l$chromaMean?.toJson();
    }
    if (_$data.containsKey('mfccMean')) {
      final l$mfccMean = mfccMean;
      result$data['mfccMean'] = l$mfccMean?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AudioFeatureFilterInput<Input$AudioFeatureFilterInput>
  get copyWith => CopyWith$Input$AudioFeatureFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AudioFeatureFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$tempo = tempo;
    final lOther$tempo = other.tempo;
    if (_$data.containsKey('tempo') != other._$data.containsKey('tempo')) {
      return false;
    }
    if (l$tempo != lOther$tempo) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$keyNumber = keyNumber;
    final lOther$keyNumber = other.keyNumber;
    if (_$data.containsKey('keyNumber') !=
        other._$data.containsKey('keyNumber')) {
      return false;
    }
    if (l$keyNumber != lOther$keyNumber) {
      return false;
    }
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (_$data.containsKey('mode') != other._$data.containsKey('mode')) {
      return false;
    }
    if (l$mode != lOther$mode) {
      return false;
    }
    final l$modeNumber = modeNumber;
    final lOther$modeNumber = other.modeNumber;
    if (_$data.containsKey('modeNumber') !=
        other._$data.containsKey('modeNumber')) {
      return false;
    }
    if (l$modeNumber != lOther$modeNumber) {
      return false;
    }
    final l$energy = energy;
    final lOther$energy = other.energy;
    if (_$data.containsKey('energy') != other._$data.containsKey('energy')) {
      return false;
    }
    if (l$energy != lOther$energy) {
      return false;
    }
    final l$danceability = danceability;
    final lOther$danceability = other.danceability;
    if (_$data.containsKey('danceability') !=
        other._$data.containsKey('danceability')) {
      return false;
    }
    if (l$danceability != lOther$danceability) {
      return false;
    }
    final l$acousticness = acousticness;
    final lOther$acousticness = other.acousticness;
    if (_$data.containsKey('acousticness') !=
        other._$data.containsKey('acousticness')) {
      return false;
    }
    if (l$acousticness != lOther$acousticness) {
      return false;
    }
    final l$spectralCentroid = spectralCentroid;
    final lOther$spectralCentroid = other.spectralCentroid;
    if (_$data.containsKey('spectralCentroid') !=
        other._$data.containsKey('spectralCentroid')) {
      return false;
    }
    if (l$spectralCentroid != lOther$spectralCentroid) {
      return false;
    }
    final l$zeroCrossingRate = zeroCrossingRate;
    final lOther$zeroCrossingRate = other.zeroCrossingRate;
    if (_$data.containsKey('zeroCrossingRate') !=
        other._$data.containsKey('zeroCrossingRate')) {
      return false;
    }
    if (l$zeroCrossingRate != lOther$zeroCrossingRate) {
      return false;
    }
    final l$duration = duration;
    final lOther$duration = other.duration;
    if (_$data.containsKey('duration') !=
        other._$data.containsKey('duration')) {
      return false;
    }
    if (l$duration != lOther$duration) {
      return false;
    }
    final l$chromaMean = chromaMean;
    final lOther$chromaMean = other.chromaMean;
    if (_$data.containsKey('chromaMean') !=
        other._$data.containsKey('chromaMean')) {
      return false;
    }
    if (l$chromaMean != lOther$chromaMean) {
      return false;
    }
    final l$mfccMean = mfccMean;
    final lOther$mfccMean = other.mfccMean;
    if (_$data.containsKey('mfccMean') !=
        other._$data.containsKey('mfccMean')) {
      return false;
    }
    if (l$mfccMean != lOther$mfccMean) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$tempo = tempo;
    final l$key = key;
    final l$keyNumber = keyNumber;
    final l$mode = mode;
    final l$modeNumber = modeNumber;
    final l$energy = energy;
    final l$danceability = danceability;
    final l$acousticness = acousticness;
    final l$spectralCentroid = spectralCentroid;
    final l$zeroCrossingRate = zeroCrossingRate;
    final l$duration = duration;
    final l$chromaMean = chromaMean;
    final l$mfccMean = mfccMean;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('tempo') ? l$tempo : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('keyNumber') ? l$keyNumber : const {},
      _$data.containsKey('mode') ? l$mode : const {},
      _$data.containsKey('modeNumber') ? l$modeNumber : const {},
      _$data.containsKey('energy') ? l$energy : const {},
      _$data.containsKey('danceability') ? l$danceability : const {},
      _$data.containsKey('acousticness') ? l$acousticness : const {},
      _$data.containsKey('spectralCentroid') ? l$spectralCentroid : const {},
      _$data.containsKey('zeroCrossingRate') ? l$zeroCrossingRate : const {},
      _$data.containsKey('duration') ? l$duration : const {},
      _$data.containsKey('chromaMean') ? l$chromaMean : const {},
      _$data.containsKey('mfccMean') ? l$mfccMean : const {},
    ]);
  }
}

abstract class CopyWith$Input$AudioFeatureFilterInput<TRes> {
  factory CopyWith$Input$AudioFeatureFilterInput(
    Input$AudioFeatureFilterInput instance,
    TRes Function(Input$AudioFeatureFilterInput) then,
  ) = _CopyWithImpl$Input$AudioFeatureFilterInput;

  factory CopyWith$Input$AudioFeatureFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AudioFeatureFilterInput;

  TRes call({
    List<Input$AudioFeatureFilterInput>? and,
    List<Input$AudioFeatureFilterInput>? or,
    Input$FloatOperationFilterInput? tempo,
    Input$StringOperationFilterInput? key,
    Input$IntOperationFilterInput? keyNumber,
    Input$StringOperationFilterInput? mode,
    Input$IntOperationFilterInput? modeNumber,
    Input$FloatOperationFilterInput? energy,
    Input$FloatOperationFilterInput? danceability,
    Input$FloatOperationFilterInput? acousticness,
    Input$FloatOperationFilterInput? spectralCentroid,
    Input$FloatOperationFilterInput? zeroCrossingRate,
    Input$FloatOperationFilterInput? duration,
    Input$ListFloatOperationFilterInput? chromaMean,
    Input$ListFloatOperationFilterInput? mfccMean,
  });
  TRes and(
    Iterable<Input$AudioFeatureFilterInput>? Function(
      Iterable<
        CopyWith$Input$AudioFeatureFilterInput<Input$AudioFeatureFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$AudioFeatureFilterInput>? Function(
      Iterable<
        CopyWith$Input$AudioFeatureFilterInput<Input$AudioFeatureFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$FloatOperationFilterInput<TRes> get tempo;
  CopyWith$Input$StringOperationFilterInput<TRes> get key;
  CopyWith$Input$IntOperationFilterInput<TRes> get keyNumber;
  CopyWith$Input$StringOperationFilterInput<TRes> get mode;
  CopyWith$Input$IntOperationFilterInput<TRes> get modeNumber;
  CopyWith$Input$FloatOperationFilterInput<TRes> get energy;
  CopyWith$Input$FloatOperationFilterInput<TRes> get danceability;
  CopyWith$Input$FloatOperationFilterInput<TRes> get acousticness;
  CopyWith$Input$FloatOperationFilterInput<TRes> get spectralCentroid;
  CopyWith$Input$FloatOperationFilterInput<TRes> get zeroCrossingRate;
  CopyWith$Input$FloatOperationFilterInput<TRes> get duration;
  CopyWith$Input$ListFloatOperationFilterInput<TRes> get chromaMean;
  CopyWith$Input$ListFloatOperationFilterInput<TRes> get mfccMean;
}

class _CopyWithImpl$Input$AudioFeatureFilterInput<TRes>
    implements CopyWith$Input$AudioFeatureFilterInput<TRes> {
  _CopyWithImpl$Input$AudioFeatureFilterInput(this._instance, this._then);

  final Input$AudioFeatureFilterInput _instance;

  final TRes Function(Input$AudioFeatureFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? tempo = _undefined,
    Object? key = _undefined,
    Object? keyNumber = _undefined,
    Object? mode = _undefined,
    Object? modeNumber = _undefined,
    Object? energy = _undefined,
    Object? danceability = _undefined,
    Object? acousticness = _undefined,
    Object? spectralCentroid = _undefined,
    Object? zeroCrossingRate = _undefined,
    Object? duration = _undefined,
    Object? chromaMean = _undefined,
    Object? mfccMean = _undefined,
  }) => _then(
    Input$AudioFeatureFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$AudioFeatureFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$AudioFeatureFilterInput>?),
      if (tempo != _undefined)
        'tempo': (tempo as Input$FloatOperationFilterInput?),
      if (key != _undefined) 'key': (key as Input$StringOperationFilterInput?),
      if (keyNumber != _undefined)
        'keyNumber': (keyNumber as Input$IntOperationFilterInput?),
      if (mode != _undefined)
        'mode': (mode as Input$StringOperationFilterInput?),
      if (modeNumber != _undefined)
        'modeNumber': (modeNumber as Input$IntOperationFilterInput?),
      if (energy != _undefined)
        'energy': (energy as Input$FloatOperationFilterInput?),
      if (danceability != _undefined)
        'danceability': (danceability as Input$FloatOperationFilterInput?),
      if (acousticness != _undefined)
        'acousticness': (acousticness as Input$FloatOperationFilterInput?),
      if (spectralCentroid != _undefined)
        'spectralCentroid':
            (spectralCentroid as Input$FloatOperationFilterInput?),
      if (zeroCrossingRate != _undefined)
        'zeroCrossingRate':
            (zeroCrossingRate as Input$FloatOperationFilterInput?),
      if (duration != _undefined)
        'duration': (duration as Input$FloatOperationFilterInput?),
      if (chromaMean != _undefined)
        'chromaMean': (chromaMean as Input$ListFloatOperationFilterInput?),
      if (mfccMean != _undefined)
        'mfccMean': (mfccMean as Input$ListFloatOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$AudioFeatureFilterInput>? Function(
      Iterable<
        CopyWith$Input$AudioFeatureFilterInput<Input$AudioFeatureFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$AudioFeatureFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$AudioFeatureFilterInput>? Function(
      Iterable<
        CopyWith$Input$AudioFeatureFilterInput<Input$AudioFeatureFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$AudioFeatureFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$FloatOperationFilterInput<TRes> get tempo {
    final local$tempo = _instance.tempo;
    return local$tempo == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$tempo,
            (e) => call(tempo: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$key,
            (e) => call(key: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get keyNumber {
    final local$keyNumber = _instance.keyNumber;
    return local$keyNumber == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$keyNumber,
            (e) => call(keyNumber: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get mode {
    final local$mode = _instance.mode;
    return local$mode == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$mode,
            (e) => call(mode: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get modeNumber {
    final local$modeNumber = _instance.modeNumber;
    return local$modeNumber == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$modeNumber,
            (e) => call(modeNumber: e),
          );
  }

  CopyWith$Input$FloatOperationFilterInput<TRes> get energy {
    final local$energy = _instance.energy;
    return local$energy == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$energy,
            (e) => call(energy: e),
          );
  }

  CopyWith$Input$FloatOperationFilterInput<TRes> get danceability {
    final local$danceability = _instance.danceability;
    return local$danceability == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$danceability,
            (e) => call(danceability: e),
          );
  }

  CopyWith$Input$FloatOperationFilterInput<TRes> get acousticness {
    final local$acousticness = _instance.acousticness;
    return local$acousticness == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$acousticness,
            (e) => call(acousticness: e),
          );
  }

  CopyWith$Input$FloatOperationFilterInput<TRes> get spectralCentroid {
    final local$spectralCentroid = _instance.spectralCentroid;
    return local$spectralCentroid == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$spectralCentroid,
            (e) => call(spectralCentroid: e),
          );
  }

  CopyWith$Input$FloatOperationFilterInput<TRes> get zeroCrossingRate {
    final local$zeroCrossingRate = _instance.zeroCrossingRate;
    return local$zeroCrossingRate == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$zeroCrossingRate,
            (e) => call(zeroCrossingRate: e),
          );
  }

  CopyWith$Input$FloatOperationFilterInput<TRes> get duration {
    final local$duration = _instance.duration;
    return local$duration == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$duration,
            (e) => call(duration: e),
          );
  }

  CopyWith$Input$ListFloatOperationFilterInput<TRes> get chromaMean {
    final local$chromaMean = _instance.chromaMean;
    return local$chromaMean == null
        ? CopyWith$Input$ListFloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListFloatOperationFilterInput(
            local$chromaMean,
            (e) => call(chromaMean: e),
          );
  }

  CopyWith$Input$ListFloatOperationFilterInput<TRes> get mfccMean {
    final local$mfccMean = _instance.mfccMean;
    return local$mfccMean == null
        ? CopyWith$Input$ListFloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListFloatOperationFilterInput(
            local$mfccMean,
            (e) => call(mfccMean: e),
          );
  }
}

class _CopyWithStubImpl$Input$AudioFeatureFilterInput<TRes>
    implements CopyWith$Input$AudioFeatureFilterInput<TRes> {
  _CopyWithStubImpl$Input$AudioFeatureFilterInput(this._res);

  TRes _res;

  call({
    List<Input$AudioFeatureFilterInput>? and,
    List<Input$AudioFeatureFilterInput>? or,
    Input$FloatOperationFilterInput? tempo,
    Input$StringOperationFilterInput? key,
    Input$IntOperationFilterInput? keyNumber,
    Input$StringOperationFilterInput? mode,
    Input$IntOperationFilterInput? modeNumber,
    Input$FloatOperationFilterInput? energy,
    Input$FloatOperationFilterInput? danceability,
    Input$FloatOperationFilterInput? acousticness,
    Input$FloatOperationFilterInput? spectralCentroid,
    Input$FloatOperationFilterInput? zeroCrossingRate,
    Input$FloatOperationFilterInput? duration,
    Input$ListFloatOperationFilterInput? chromaMean,
    Input$ListFloatOperationFilterInput? mfccMean,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$FloatOperationFilterInput<TRes> get tempo =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get key =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get keyNumber =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get mode =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get modeNumber =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$FloatOperationFilterInput<TRes> get energy =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);

  CopyWith$Input$FloatOperationFilterInput<TRes> get danceability =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);

  CopyWith$Input$FloatOperationFilterInput<TRes> get acousticness =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);

  CopyWith$Input$FloatOperationFilterInput<TRes> get spectralCentroid =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);

  CopyWith$Input$FloatOperationFilterInput<TRes> get zeroCrossingRate =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);

  CopyWith$Input$FloatOperationFilterInput<TRes> get duration =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);

  CopyWith$Input$ListFloatOperationFilterInput<TRes> get chromaMean =>
      CopyWith$Input$ListFloatOperationFilterInput.stub(_res);

  CopyWith$Input$ListFloatOperationFilterInput<TRes> get mfccMean =>
      CopyWith$Input$ListFloatOperationFilterInput.stub(_res);
}

class Input$AudioFeatureSortInput {
  factory Input$AudioFeatureSortInput({
    Enum$SortEnumType? tempo,
    Enum$SortEnumType? key,
    Enum$SortEnumType? keyNumber,
    Enum$SortEnumType? mode,
    Enum$SortEnumType? modeNumber,
    Enum$SortEnumType? energy,
    Enum$SortEnumType? danceability,
    Enum$SortEnumType? acousticness,
    Enum$SortEnumType? spectralCentroid,
    Enum$SortEnumType? zeroCrossingRate,
    Enum$SortEnumType? duration,
  }) => Input$AudioFeatureSortInput._({
    if (tempo != null) r'tempo': tempo,
    if (key != null) r'key': key,
    if (keyNumber != null) r'keyNumber': keyNumber,
    if (mode != null) r'mode': mode,
    if (modeNumber != null) r'modeNumber': modeNumber,
    if (energy != null) r'energy': energy,
    if (danceability != null) r'danceability': danceability,
    if (acousticness != null) r'acousticness': acousticness,
    if (spectralCentroid != null) r'spectralCentroid': spectralCentroid,
    if (zeroCrossingRate != null) r'zeroCrossingRate': zeroCrossingRate,
    if (duration != null) r'duration': duration,
  });

  Input$AudioFeatureSortInput._(this._$data);

  factory Input$AudioFeatureSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('tempo')) {
      final l$tempo = data['tempo'];
      result$data['tempo'] = l$tempo == null
          ? null
          : fromJson$Enum$SortEnumType((l$tempo as String));
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : fromJson$Enum$SortEnumType((l$key as String));
    }
    if (data.containsKey('keyNumber')) {
      final l$keyNumber = data['keyNumber'];
      result$data['keyNumber'] = l$keyNumber == null
          ? null
          : fromJson$Enum$SortEnumType((l$keyNumber as String));
    }
    if (data.containsKey('mode')) {
      final l$mode = data['mode'];
      result$data['mode'] = l$mode == null
          ? null
          : fromJson$Enum$SortEnumType((l$mode as String));
    }
    if (data.containsKey('modeNumber')) {
      final l$modeNumber = data['modeNumber'];
      result$data['modeNumber'] = l$modeNumber == null
          ? null
          : fromJson$Enum$SortEnumType((l$modeNumber as String));
    }
    if (data.containsKey('energy')) {
      final l$energy = data['energy'];
      result$data['energy'] = l$energy == null
          ? null
          : fromJson$Enum$SortEnumType((l$energy as String));
    }
    if (data.containsKey('danceability')) {
      final l$danceability = data['danceability'];
      result$data['danceability'] = l$danceability == null
          ? null
          : fromJson$Enum$SortEnumType((l$danceability as String));
    }
    if (data.containsKey('acousticness')) {
      final l$acousticness = data['acousticness'];
      result$data['acousticness'] = l$acousticness == null
          ? null
          : fromJson$Enum$SortEnumType((l$acousticness as String));
    }
    if (data.containsKey('spectralCentroid')) {
      final l$spectralCentroid = data['spectralCentroid'];
      result$data['spectralCentroid'] = l$spectralCentroid == null
          ? null
          : fromJson$Enum$SortEnumType((l$spectralCentroid as String));
    }
    if (data.containsKey('zeroCrossingRate')) {
      final l$zeroCrossingRate = data['zeroCrossingRate'];
      result$data['zeroCrossingRate'] = l$zeroCrossingRate == null
          ? null
          : fromJson$Enum$SortEnumType((l$zeroCrossingRate as String));
    }
    if (data.containsKey('duration')) {
      final l$duration = data['duration'];
      result$data['duration'] = l$duration == null
          ? null
          : fromJson$Enum$SortEnumType((l$duration as String));
    }
    return Input$AudioFeatureSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get tempo => (_$data['tempo'] as Enum$SortEnumType?);

  Enum$SortEnumType? get key => (_$data['key'] as Enum$SortEnumType?);

  Enum$SortEnumType? get keyNumber =>
      (_$data['keyNumber'] as Enum$SortEnumType?);

  Enum$SortEnumType? get mode => (_$data['mode'] as Enum$SortEnumType?);

  Enum$SortEnumType? get modeNumber =>
      (_$data['modeNumber'] as Enum$SortEnumType?);

  Enum$SortEnumType? get energy => (_$data['energy'] as Enum$SortEnumType?);

  Enum$SortEnumType? get danceability =>
      (_$data['danceability'] as Enum$SortEnumType?);

  Enum$SortEnumType? get acousticness =>
      (_$data['acousticness'] as Enum$SortEnumType?);

  Enum$SortEnumType? get spectralCentroid =>
      (_$data['spectralCentroid'] as Enum$SortEnumType?);

  Enum$SortEnumType? get zeroCrossingRate =>
      (_$data['zeroCrossingRate'] as Enum$SortEnumType?);

  Enum$SortEnumType? get duration => (_$data['duration'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('tempo')) {
      final l$tempo = tempo;
      result$data['tempo'] = l$tempo == null
          ? null
          : toJson$Enum$SortEnumType(l$tempo);
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key == null
          ? null
          : toJson$Enum$SortEnumType(l$key);
    }
    if (_$data.containsKey('keyNumber')) {
      final l$keyNumber = keyNumber;
      result$data['keyNumber'] = l$keyNumber == null
          ? null
          : toJson$Enum$SortEnumType(l$keyNumber);
    }
    if (_$data.containsKey('mode')) {
      final l$mode = mode;
      result$data['mode'] = l$mode == null
          ? null
          : toJson$Enum$SortEnumType(l$mode);
    }
    if (_$data.containsKey('modeNumber')) {
      final l$modeNumber = modeNumber;
      result$data['modeNumber'] = l$modeNumber == null
          ? null
          : toJson$Enum$SortEnumType(l$modeNumber);
    }
    if (_$data.containsKey('energy')) {
      final l$energy = energy;
      result$data['energy'] = l$energy == null
          ? null
          : toJson$Enum$SortEnumType(l$energy);
    }
    if (_$data.containsKey('danceability')) {
      final l$danceability = danceability;
      result$data['danceability'] = l$danceability == null
          ? null
          : toJson$Enum$SortEnumType(l$danceability);
    }
    if (_$data.containsKey('acousticness')) {
      final l$acousticness = acousticness;
      result$data['acousticness'] = l$acousticness == null
          ? null
          : toJson$Enum$SortEnumType(l$acousticness);
    }
    if (_$data.containsKey('spectralCentroid')) {
      final l$spectralCentroid = spectralCentroid;
      result$data['spectralCentroid'] = l$spectralCentroid == null
          ? null
          : toJson$Enum$SortEnumType(l$spectralCentroid);
    }
    if (_$data.containsKey('zeroCrossingRate')) {
      final l$zeroCrossingRate = zeroCrossingRate;
      result$data['zeroCrossingRate'] = l$zeroCrossingRate == null
          ? null
          : toJson$Enum$SortEnumType(l$zeroCrossingRate);
    }
    if (_$data.containsKey('duration')) {
      final l$duration = duration;
      result$data['duration'] = l$duration == null
          ? null
          : toJson$Enum$SortEnumType(l$duration);
    }
    return result$data;
  }

  CopyWith$Input$AudioFeatureSortInput<Input$AudioFeatureSortInput>
  get copyWith => CopyWith$Input$AudioFeatureSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AudioFeatureSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$tempo = tempo;
    final lOther$tempo = other.tempo;
    if (_$data.containsKey('tempo') != other._$data.containsKey('tempo')) {
      return false;
    }
    if (l$tempo != lOther$tempo) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$keyNumber = keyNumber;
    final lOther$keyNumber = other.keyNumber;
    if (_$data.containsKey('keyNumber') !=
        other._$data.containsKey('keyNumber')) {
      return false;
    }
    if (l$keyNumber != lOther$keyNumber) {
      return false;
    }
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (_$data.containsKey('mode') != other._$data.containsKey('mode')) {
      return false;
    }
    if (l$mode != lOther$mode) {
      return false;
    }
    final l$modeNumber = modeNumber;
    final lOther$modeNumber = other.modeNumber;
    if (_$data.containsKey('modeNumber') !=
        other._$data.containsKey('modeNumber')) {
      return false;
    }
    if (l$modeNumber != lOther$modeNumber) {
      return false;
    }
    final l$energy = energy;
    final lOther$energy = other.energy;
    if (_$data.containsKey('energy') != other._$data.containsKey('energy')) {
      return false;
    }
    if (l$energy != lOther$energy) {
      return false;
    }
    final l$danceability = danceability;
    final lOther$danceability = other.danceability;
    if (_$data.containsKey('danceability') !=
        other._$data.containsKey('danceability')) {
      return false;
    }
    if (l$danceability != lOther$danceability) {
      return false;
    }
    final l$acousticness = acousticness;
    final lOther$acousticness = other.acousticness;
    if (_$data.containsKey('acousticness') !=
        other._$data.containsKey('acousticness')) {
      return false;
    }
    if (l$acousticness != lOther$acousticness) {
      return false;
    }
    final l$spectralCentroid = spectralCentroid;
    final lOther$spectralCentroid = other.spectralCentroid;
    if (_$data.containsKey('spectralCentroid') !=
        other._$data.containsKey('spectralCentroid')) {
      return false;
    }
    if (l$spectralCentroid != lOther$spectralCentroid) {
      return false;
    }
    final l$zeroCrossingRate = zeroCrossingRate;
    final lOther$zeroCrossingRate = other.zeroCrossingRate;
    if (_$data.containsKey('zeroCrossingRate') !=
        other._$data.containsKey('zeroCrossingRate')) {
      return false;
    }
    if (l$zeroCrossingRate != lOther$zeroCrossingRate) {
      return false;
    }
    final l$duration = duration;
    final lOther$duration = other.duration;
    if (_$data.containsKey('duration') !=
        other._$data.containsKey('duration')) {
      return false;
    }
    if (l$duration != lOther$duration) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$tempo = tempo;
    final l$key = key;
    final l$keyNumber = keyNumber;
    final l$mode = mode;
    final l$modeNumber = modeNumber;
    final l$energy = energy;
    final l$danceability = danceability;
    final l$acousticness = acousticness;
    final l$spectralCentroid = spectralCentroid;
    final l$zeroCrossingRate = zeroCrossingRate;
    final l$duration = duration;
    return Object.hashAll([
      _$data.containsKey('tempo') ? l$tempo : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('keyNumber') ? l$keyNumber : const {},
      _$data.containsKey('mode') ? l$mode : const {},
      _$data.containsKey('modeNumber') ? l$modeNumber : const {},
      _$data.containsKey('energy') ? l$energy : const {},
      _$data.containsKey('danceability') ? l$danceability : const {},
      _$data.containsKey('acousticness') ? l$acousticness : const {},
      _$data.containsKey('spectralCentroid') ? l$spectralCentroid : const {},
      _$data.containsKey('zeroCrossingRate') ? l$zeroCrossingRate : const {},
      _$data.containsKey('duration') ? l$duration : const {},
    ]);
  }
}

abstract class CopyWith$Input$AudioFeatureSortInput<TRes> {
  factory CopyWith$Input$AudioFeatureSortInput(
    Input$AudioFeatureSortInput instance,
    TRes Function(Input$AudioFeatureSortInput) then,
  ) = _CopyWithImpl$Input$AudioFeatureSortInput;

  factory CopyWith$Input$AudioFeatureSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AudioFeatureSortInput;

  TRes call({
    Enum$SortEnumType? tempo,
    Enum$SortEnumType? key,
    Enum$SortEnumType? keyNumber,
    Enum$SortEnumType? mode,
    Enum$SortEnumType? modeNumber,
    Enum$SortEnumType? energy,
    Enum$SortEnumType? danceability,
    Enum$SortEnumType? acousticness,
    Enum$SortEnumType? spectralCentroid,
    Enum$SortEnumType? zeroCrossingRate,
    Enum$SortEnumType? duration,
  });
}

class _CopyWithImpl$Input$AudioFeatureSortInput<TRes>
    implements CopyWith$Input$AudioFeatureSortInput<TRes> {
  _CopyWithImpl$Input$AudioFeatureSortInput(this._instance, this._then);

  final Input$AudioFeatureSortInput _instance;

  final TRes Function(Input$AudioFeatureSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? tempo = _undefined,
    Object? key = _undefined,
    Object? keyNumber = _undefined,
    Object? mode = _undefined,
    Object? modeNumber = _undefined,
    Object? energy = _undefined,
    Object? danceability = _undefined,
    Object? acousticness = _undefined,
    Object? spectralCentroid = _undefined,
    Object? zeroCrossingRate = _undefined,
    Object? duration = _undefined,
  }) => _then(
    Input$AudioFeatureSortInput._({
      ..._instance._$data,
      if (tempo != _undefined) 'tempo': (tempo as Enum$SortEnumType?),
      if (key != _undefined) 'key': (key as Enum$SortEnumType?),
      if (keyNumber != _undefined)
        'keyNumber': (keyNumber as Enum$SortEnumType?),
      if (mode != _undefined) 'mode': (mode as Enum$SortEnumType?),
      if (modeNumber != _undefined)
        'modeNumber': (modeNumber as Enum$SortEnumType?),
      if (energy != _undefined) 'energy': (energy as Enum$SortEnumType?),
      if (danceability != _undefined)
        'danceability': (danceability as Enum$SortEnumType?),
      if (acousticness != _undefined)
        'acousticness': (acousticness as Enum$SortEnumType?),
      if (spectralCentroid != _undefined)
        'spectralCentroid': (spectralCentroid as Enum$SortEnumType?),
      if (zeroCrossingRate != _undefined)
        'zeroCrossingRate': (zeroCrossingRate as Enum$SortEnumType?),
      if (duration != _undefined) 'duration': (duration as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$AudioFeatureSortInput<TRes>
    implements CopyWith$Input$AudioFeatureSortInput<TRes> {
  _CopyWithStubImpl$Input$AudioFeatureSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? tempo,
    Enum$SortEnumType? key,
    Enum$SortEnumType? keyNumber,
    Enum$SortEnumType? mode,
    Enum$SortEnumType? modeNumber,
    Enum$SortEnumType? energy,
    Enum$SortEnumType? danceability,
    Enum$SortEnumType? acousticness,
    Enum$SortEnumType? spectralCentroid,
    Enum$SortEnumType? zeroCrossingRate,
    Enum$SortEnumType? duration,
  }) => _res;
}

class Input$AudioFeatureWeightInput {
  factory Input$AudioFeatureWeightInput({
    double? tempo,
    double? energy,
    double? danceability,
    double? acousticness,
  }) => Input$AudioFeatureWeightInput._({
    if (tempo != null) r'tempo': tempo,
    if (energy != null) r'energy': energy,
    if (danceability != null) r'danceability': danceability,
    if (acousticness != null) r'acousticness': acousticness,
  });

  Input$AudioFeatureWeightInput._(this._$data);

  factory Input$AudioFeatureWeightInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('tempo')) {
      final l$tempo = data['tempo'];
      result$data['tempo'] = (l$tempo as num?)?.toDouble();
    }
    if (data.containsKey('energy')) {
      final l$energy = data['energy'];
      result$data['energy'] = (l$energy as num?)?.toDouble();
    }
    if (data.containsKey('danceability')) {
      final l$danceability = data['danceability'];
      result$data['danceability'] = (l$danceability as num?)?.toDouble();
    }
    if (data.containsKey('acousticness')) {
      final l$acousticness = data['acousticness'];
      result$data['acousticness'] = (l$acousticness as num?)?.toDouble();
    }
    return Input$AudioFeatureWeightInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get tempo => (_$data['tempo'] as double?);

  double? get energy => (_$data['energy'] as double?);

  double? get danceability => (_$data['danceability'] as double?);

  double? get acousticness => (_$data['acousticness'] as double?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('tempo')) {
      final l$tempo = tempo;
      result$data['tempo'] = l$tempo;
    }
    if (_$data.containsKey('energy')) {
      final l$energy = energy;
      result$data['energy'] = l$energy;
    }
    if (_$data.containsKey('danceability')) {
      final l$danceability = danceability;
      result$data['danceability'] = l$danceability;
    }
    if (_$data.containsKey('acousticness')) {
      final l$acousticness = acousticness;
      result$data['acousticness'] = l$acousticness;
    }
    return result$data;
  }

  CopyWith$Input$AudioFeatureWeightInput<Input$AudioFeatureWeightInput>
  get copyWith => CopyWith$Input$AudioFeatureWeightInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AudioFeatureWeightInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$tempo = tempo;
    final lOther$tempo = other.tempo;
    if (_$data.containsKey('tempo') != other._$data.containsKey('tempo')) {
      return false;
    }
    if (l$tempo != lOther$tempo) {
      return false;
    }
    final l$energy = energy;
    final lOther$energy = other.energy;
    if (_$data.containsKey('energy') != other._$data.containsKey('energy')) {
      return false;
    }
    if (l$energy != lOther$energy) {
      return false;
    }
    final l$danceability = danceability;
    final lOther$danceability = other.danceability;
    if (_$data.containsKey('danceability') !=
        other._$data.containsKey('danceability')) {
      return false;
    }
    if (l$danceability != lOther$danceability) {
      return false;
    }
    final l$acousticness = acousticness;
    final lOther$acousticness = other.acousticness;
    if (_$data.containsKey('acousticness') !=
        other._$data.containsKey('acousticness')) {
      return false;
    }
    if (l$acousticness != lOther$acousticness) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$tempo = tempo;
    final l$energy = energy;
    final l$danceability = danceability;
    final l$acousticness = acousticness;
    return Object.hashAll([
      _$data.containsKey('tempo') ? l$tempo : const {},
      _$data.containsKey('energy') ? l$energy : const {},
      _$data.containsKey('danceability') ? l$danceability : const {},
      _$data.containsKey('acousticness') ? l$acousticness : const {},
    ]);
  }
}

abstract class CopyWith$Input$AudioFeatureWeightInput<TRes> {
  factory CopyWith$Input$AudioFeatureWeightInput(
    Input$AudioFeatureWeightInput instance,
    TRes Function(Input$AudioFeatureWeightInput) then,
  ) = _CopyWithImpl$Input$AudioFeatureWeightInput;

  factory CopyWith$Input$AudioFeatureWeightInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AudioFeatureWeightInput;

  TRes call({
    double? tempo,
    double? energy,
    double? danceability,
    double? acousticness,
  });
}

class _CopyWithImpl$Input$AudioFeatureWeightInput<TRes>
    implements CopyWith$Input$AudioFeatureWeightInput<TRes> {
  _CopyWithImpl$Input$AudioFeatureWeightInput(this._instance, this._then);

  final Input$AudioFeatureWeightInput _instance;

  final TRes Function(Input$AudioFeatureWeightInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? tempo = _undefined,
    Object? energy = _undefined,
    Object? danceability = _undefined,
    Object? acousticness = _undefined,
  }) => _then(
    Input$AudioFeatureWeightInput._({
      ..._instance._$data,
      if (tempo != _undefined) 'tempo': (tempo as double?),
      if (energy != _undefined) 'energy': (energy as double?),
      if (danceability != _undefined) 'danceability': (danceability as double?),
      if (acousticness != _undefined) 'acousticness': (acousticness as double?),
    }),
  );
}

class _CopyWithStubImpl$Input$AudioFeatureWeightInput<TRes>
    implements CopyWith$Input$AudioFeatureWeightInput<TRes> {
  _CopyWithStubImpl$Input$AudioFeatureWeightInput(this._res);

  TRes _res;

  call({
    double? tempo,
    double? energy,
    double? danceability,
    double? acousticness,
  }) => _res;
}

class Input$AudioFingerprintFilterInput {
  factory Input$AudioFingerprintFilterInput({
    List<Input$AudioFingerprintFilterInput>? and,
    List<Input$AudioFingerprintFilterInput>? or,
    Input$ListListByteOperationFilterInput? compressedFingerprints,
    Input$ListOfUInt32FilterInput? sequenceNumbers,
    Input$ListFloatOperationFilterInput? startsAt,
    Input$ListListByteOperationFilterInput? originalPoints,
    Input$FloatOperationFilterInput? duration,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$AudioFingerprintFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (compressedFingerprints != null)
      r'compressedFingerprints': compressedFingerprints,
    if (sequenceNumbers != null) r'sequenceNumbers': sequenceNumbers,
    if (startsAt != null) r'startsAt': startsAt,
    if (originalPoints != null) r'originalPoints': originalPoints,
    if (duration != null) r'duration': duration,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$AudioFingerprintFilterInput._(this._$data);

  factory Input$AudioFingerprintFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$AudioFingerprintFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$AudioFingerprintFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('compressedFingerprints')) {
      final l$compressedFingerprints = data['compressedFingerprints'];
      result$data['compressedFingerprints'] = l$compressedFingerprints == null
          ? null
          : Input$ListListByteOperationFilterInput.fromJson(
              (l$compressedFingerprints as Map<String, dynamic>),
            );
    }
    if (data.containsKey('sequenceNumbers')) {
      final l$sequenceNumbers = data['sequenceNumbers'];
      result$data['sequenceNumbers'] = l$sequenceNumbers == null
          ? null
          : Input$ListOfUInt32FilterInput.fromJson(
              (l$sequenceNumbers as Map<String, dynamic>),
            );
    }
    if (data.containsKey('startsAt')) {
      final l$startsAt = data['startsAt'];
      result$data['startsAt'] = l$startsAt == null
          ? null
          : Input$ListFloatOperationFilterInput.fromJson(
              (l$startsAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('originalPoints')) {
      final l$originalPoints = data['originalPoints'];
      result$data['originalPoints'] = l$originalPoints == null
          ? null
          : Input$ListListByteOperationFilterInput.fromJson(
              (l$originalPoints as Map<String, dynamic>),
            );
    }
    if (data.containsKey('duration')) {
      final l$duration = data['duration'];
      result$data['duration'] = l$duration == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$duration as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$AudioFingerprintFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$AudioFingerprintFilterInput>? get and =>
      (_$data['and'] as List<Input$AudioFingerprintFilterInput>?);

  List<Input$AudioFingerprintFilterInput>? get or =>
      (_$data['or'] as List<Input$AudioFingerprintFilterInput>?);

  Input$ListListByteOperationFilterInput? get compressedFingerprints =>
      (_$data['compressedFingerprints']
          as Input$ListListByteOperationFilterInput?);

  Input$ListOfUInt32FilterInput? get sequenceNumbers =>
      (_$data['sequenceNumbers'] as Input$ListOfUInt32FilterInput?);

  Input$ListFloatOperationFilterInput? get startsAt =>
      (_$data['startsAt'] as Input$ListFloatOperationFilterInput?);

  Input$ListListByteOperationFilterInput? get originalPoints =>
      (_$data['originalPoints'] as Input$ListListByteOperationFilterInput?);

  Input$FloatOperationFilterInput? get duration =>
      (_$data['duration'] as Input$FloatOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('compressedFingerprints')) {
      final l$compressedFingerprints = compressedFingerprints;
      result$data['compressedFingerprints'] = l$compressedFingerprints
          ?.toJson();
    }
    if (_$data.containsKey('sequenceNumbers')) {
      final l$sequenceNumbers = sequenceNumbers;
      result$data['sequenceNumbers'] = l$sequenceNumbers?.toJson();
    }
    if (_$data.containsKey('startsAt')) {
      final l$startsAt = startsAt;
      result$data['startsAt'] = l$startsAt?.toJson();
    }
    if (_$data.containsKey('originalPoints')) {
      final l$originalPoints = originalPoints;
      result$data['originalPoints'] = l$originalPoints?.toJson();
    }
    if (_$data.containsKey('duration')) {
      final l$duration = duration;
      result$data['duration'] = l$duration?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$AudioFingerprintFilterInput<Input$AudioFingerprintFilterInput>
  get copyWith => CopyWith$Input$AudioFingerprintFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AudioFingerprintFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$compressedFingerprints = compressedFingerprints;
    final lOther$compressedFingerprints = other.compressedFingerprints;
    if (_$data.containsKey('compressedFingerprints') !=
        other._$data.containsKey('compressedFingerprints')) {
      return false;
    }
    if (l$compressedFingerprints != lOther$compressedFingerprints) {
      return false;
    }
    final l$sequenceNumbers = sequenceNumbers;
    final lOther$sequenceNumbers = other.sequenceNumbers;
    if (_$data.containsKey('sequenceNumbers') !=
        other._$data.containsKey('sequenceNumbers')) {
      return false;
    }
    if (l$sequenceNumbers != lOther$sequenceNumbers) {
      return false;
    }
    final l$startsAt = startsAt;
    final lOther$startsAt = other.startsAt;
    if (_$data.containsKey('startsAt') !=
        other._$data.containsKey('startsAt')) {
      return false;
    }
    if (l$startsAt != lOther$startsAt) {
      return false;
    }
    final l$originalPoints = originalPoints;
    final lOther$originalPoints = other.originalPoints;
    if (_$data.containsKey('originalPoints') !=
        other._$data.containsKey('originalPoints')) {
      return false;
    }
    if (l$originalPoints != lOther$originalPoints) {
      return false;
    }
    final l$duration = duration;
    final lOther$duration = other.duration;
    if (_$data.containsKey('duration') !=
        other._$data.containsKey('duration')) {
      return false;
    }
    if (l$duration != lOther$duration) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$compressedFingerprints = compressedFingerprints;
    final l$sequenceNumbers = sequenceNumbers;
    final l$startsAt = startsAt;
    final l$originalPoints = originalPoints;
    final l$duration = duration;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('compressedFingerprints')
          ? l$compressedFingerprints
          : const {},
      _$data.containsKey('sequenceNumbers') ? l$sequenceNumbers : const {},
      _$data.containsKey('startsAt') ? l$startsAt : const {},
      _$data.containsKey('originalPoints') ? l$originalPoints : const {},
      _$data.containsKey('duration') ? l$duration : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AudioFingerprintFilterInput<TRes> {
  factory CopyWith$Input$AudioFingerprintFilterInput(
    Input$AudioFingerprintFilterInput instance,
    TRes Function(Input$AudioFingerprintFilterInput) then,
  ) = _CopyWithImpl$Input$AudioFingerprintFilterInput;

  factory CopyWith$Input$AudioFingerprintFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AudioFingerprintFilterInput;

  TRes call({
    List<Input$AudioFingerprintFilterInput>? and,
    List<Input$AudioFingerprintFilterInput>? or,
    Input$ListListByteOperationFilterInput? compressedFingerprints,
    Input$ListOfUInt32FilterInput? sequenceNumbers,
    Input$ListFloatOperationFilterInput? startsAt,
    Input$ListListByteOperationFilterInput? originalPoints,
    Input$FloatOperationFilterInput? duration,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$AudioFingerprintFilterInput>? Function(
      Iterable<
        CopyWith$Input$AudioFingerprintFilterInput<
          Input$AudioFingerprintFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$AudioFingerprintFilterInput>? Function(
      Iterable<
        CopyWith$Input$AudioFingerprintFilterInput<
          Input$AudioFingerprintFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$ListListByteOperationFilterInput<TRes>
  get compressedFingerprints;
  CopyWith$Input$ListOfUInt32FilterInput<TRes> get sequenceNumbers;
  CopyWith$Input$ListFloatOperationFilterInput<TRes> get startsAt;
  CopyWith$Input$ListListByteOperationFilterInput<TRes> get originalPoints;
  CopyWith$Input$FloatOperationFilterInput<TRes> get duration;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$AudioFingerprintFilterInput<TRes>
    implements CopyWith$Input$AudioFingerprintFilterInput<TRes> {
  _CopyWithImpl$Input$AudioFingerprintFilterInput(this._instance, this._then);

  final Input$AudioFingerprintFilterInput _instance;

  final TRes Function(Input$AudioFingerprintFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? compressedFingerprints = _undefined,
    Object? sequenceNumbers = _undefined,
    Object? startsAt = _undefined,
    Object? originalPoints = _undefined,
    Object? duration = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$AudioFingerprintFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$AudioFingerprintFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$AudioFingerprintFilterInput>?),
      if (compressedFingerprints != _undefined)
        'compressedFingerprints':
            (compressedFingerprints as Input$ListListByteOperationFilterInput?),
      if (sequenceNumbers != _undefined)
        'sequenceNumbers': (sequenceNumbers as Input$ListOfUInt32FilterInput?),
      if (startsAt != _undefined)
        'startsAt': (startsAt as Input$ListFloatOperationFilterInput?),
      if (originalPoints != _undefined)
        'originalPoints':
            (originalPoints as Input$ListListByteOperationFilterInput?),
      if (duration != _undefined)
        'duration': (duration as Input$FloatOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$AudioFingerprintFilterInput>? Function(
      Iterable<
        CopyWith$Input$AudioFingerprintFilterInput<
          Input$AudioFingerprintFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$AudioFingerprintFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$AudioFingerprintFilterInput>? Function(
      Iterable<
        CopyWith$Input$AudioFingerprintFilterInput<
          Input$AudioFingerprintFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$AudioFingerprintFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$ListListByteOperationFilterInput<TRes>
  get compressedFingerprints {
    final local$compressedFingerprints = _instance.compressedFingerprints;
    return local$compressedFingerprints == null
        ? CopyWith$Input$ListListByteOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListListByteOperationFilterInput(
            local$compressedFingerprints,
            (e) => call(compressedFingerprints: e),
          );
  }

  CopyWith$Input$ListOfUInt32FilterInput<TRes> get sequenceNumbers {
    final local$sequenceNumbers = _instance.sequenceNumbers;
    return local$sequenceNumbers == null
        ? CopyWith$Input$ListOfUInt32FilterInput.stub(_then(_instance))
        : CopyWith$Input$ListOfUInt32FilterInput(
            local$sequenceNumbers,
            (e) => call(sequenceNumbers: e),
          );
  }

  CopyWith$Input$ListFloatOperationFilterInput<TRes> get startsAt {
    final local$startsAt = _instance.startsAt;
    return local$startsAt == null
        ? CopyWith$Input$ListFloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListFloatOperationFilterInput(
            local$startsAt,
            (e) => call(startsAt: e),
          );
  }

  CopyWith$Input$ListListByteOperationFilterInput<TRes> get originalPoints {
    final local$originalPoints = _instance.originalPoints;
    return local$originalPoints == null
        ? CopyWith$Input$ListListByteOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListListByteOperationFilterInput(
            local$originalPoints,
            (e) => call(originalPoints: e),
          );
  }

  CopyWith$Input$FloatOperationFilterInput<TRes> get duration {
    final local$duration = _instance.duration;
    return local$duration == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$duration,
            (e) => call(duration: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$AudioFingerprintFilterInput<TRes>
    implements CopyWith$Input$AudioFingerprintFilterInput<TRes> {
  _CopyWithStubImpl$Input$AudioFingerprintFilterInput(this._res);

  TRes _res;

  call({
    List<Input$AudioFingerprintFilterInput>? and,
    List<Input$AudioFingerprintFilterInput>? or,
    Input$ListListByteOperationFilterInput? compressedFingerprints,
    Input$ListOfUInt32FilterInput? sequenceNumbers,
    Input$ListFloatOperationFilterInput? startsAt,
    Input$ListListByteOperationFilterInput? originalPoints,
    Input$FloatOperationFilterInput? duration,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$ListListByteOperationFilterInput<TRes>
  get compressedFingerprints =>
      CopyWith$Input$ListListByteOperationFilterInput.stub(_res);

  CopyWith$Input$ListOfUInt32FilterInput<TRes> get sequenceNumbers =>
      CopyWith$Input$ListOfUInt32FilterInput.stub(_res);

  CopyWith$Input$ListFloatOperationFilterInput<TRes> get startsAt =>
      CopyWith$Input$ListFloatOperationFilterInput.stub(_res);

  CopyWith$Input$ListListByteOperationFilterInput<TRes> get originalPoints =>
      CopyWith$Input$ListListByteOperationFilterInput.stub(_res);

  CopyWith$Input$FloatOperationFilterInput<TRes> get duration =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$AudioFingerprintSortInput {
  factory Input$AudioFingerprintSortInput({
    Enum$SortEnumType? duration,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$AudioFingerprintSortInput._({
    if (duration != null) r'duration': duration,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$AudioFingerprintSortInput._(this._$data);

  factory Input$AudioFingerprintSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('duration')) {
      final l$duration = data['duration'];
      result$data['duration'] = l$duration == null
          ? null
          : fromJson$Enum$SortEnumType((l$duration as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$AudioFingerprintSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get duration => (_$data['duration'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('duration')) {
      final l$duration = duration;
      result$data['duration'] = l$duration == null
          ? null
          : toJson$Enum$SortEnumType(l$duration);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$AudioFingerprintSortInput<Input$AudioFingerprintSortInput>
  get copyWith => CopyWith$Input$AudioFingerprintSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AudioFingerprintSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$duration = duration;
    final lOther$duration = other.duration;
    if (_$data.containsKey('duration') !=
        other._$data.containsKey('duration')) {
      return false;
    }
    if (l$duration != lOther$duration) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$duration = duration;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('duration') ? l$duration : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$AudioFingerprintSortInput<TRes> {
  factory CopyWith$Input$AudioFingerprintSortInput(
    Input$AudioFingerprintSortInput instance,
    TRes Function(Input$AudioFingerprintSortInput) then,
  ) = _CopyWithImpl$Input$AudioFingerprintSortInput;

  factory CopyWith$Input$AudioFingerprintSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AudioFingerprintSortInput;

  TRes call({
    Enum$SortEnumType? duration,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$AudioFingerprintSortInput<TRes>
    implements CopyWith$Input$AudioFingerprintSortInput<TRes> {
  _CopyWithImpl$Input$AudioFingerprintSortInput(this._instance, this._then);

  final Input$AudioFingerprintSortInput _instance;

  final TRes Function(Input$AudioFingerprintSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? duration = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$AudioFingerprintSortInput._({
      ..._instance._$data,
      if (duration != _undefined) 'duration': (duration as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$AudioFingerprintSortInput<TRes>
    implements CopyWith$Input$AudioFingerprintSortInput<TRes> {
  _CopyWithStubImpl$Input$AudioFingerprintSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? duration,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$BooleanOperationFilterInput {
  factory Input$BooleanOperationFilterInput({bool? eq, bool? neq}) =>
      Input$BooleanOperationFilterInput._({
        if (eq != null) r'eq': eq,
        if (neq != null) r'neq': neq,
      });

  Input$BooleanOperationFilterInput._(this._$data);

  factory Input$BooleanOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as bool?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as bool?);
    }
    return Input$BooleanOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get eq => (_$data['eq'] as bool?);

  bool? get neq => (_$data['neq'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    return result$data;
  }

  CopyWith$Input$BooleanOperationFilterInput<Input$BooleanOperationFilterInput>
  get copyWith => CopyWith$Input$BooleanOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$BooleanOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
    ]);
  }
}

abstract class CopyWith$Input$BooleanOperationFilterInput<TRes> {
  factory CopyWith$Input$BooleanOperationFilterInput(
    Input$BooleanOperationFilterInput instance,
    TRes Function(Input$BooleanOperationFilterInput) then,
  ) = _CopyWithImpl$Input$BooleanOperationFilterInput;

  factory CopyWith$Input$BooleanOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BooleanOperationFilterInput;

  TRes call({bool? eq, bool? neq});
}

class _CopyWithImpl$Input$BooleanOperationFilterInput<TRes>
    implements CopyWith$Input$BooleanOperationFilterInput<TRes> {
  _CopyWithImpl$Input$BooleanOperationFilterInput(this._instance, this._then);

  final Input$BooleanOperationFilterInput _instance;

  final TRes Function(Input$BooleanOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? eq = _undefined, Object? neq = _undefined}) => _then(
    Input$BooleanOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as bool?),
      if (neq != _undefined) 'neq': (neq as bool?),
    }),
  );
}

class _CopyWithStubImpl$Input$BooleanOperationFilterInput<TRes>
    implements CopyWith$Input$BooleanOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$BooleanOperationFilterInput(this._res);

  TRes _res;

  call({bool? eq, bool? neq}) => _res;
}

class Input$ByteOperationFilterInput {
  factory Input$ByteOperationFilterInput({
    int? eq,
    int? neq,
    List<int?>? $in,
    List<int?>? nin,
    int? gt,
    int? ngt,
    int? gte,
    int? ngte,
    int? lt,
    int? nlt,
    int? lte,
    int? nlte,
  }) => Input$ByteOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
    if (gt != null) r'gt': gt,
    if (ngt != null) r'ngt': ngt,
    if (gte != null) r'gte': gte,
    if (ngte != null) r'ngte': ngte,
    if (lt != null) r'lt': lt,
    if (nlt != null) r'nlt': nlt,
    if (lte != null) r'lte': lte,
    if (nlte != null) r'nlte': nlte,
  });

  Input$ByteOperationFilterInput._(this._$data);

  factory Input$ByteOperationFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as int?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => (e as int?))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => (e as int?))
          .toList();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as int?);
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as int?);
    }
    return Input$ByteOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get eq => (_$data['eq'] as int?);

  int? get neq => (_$data['neq'] as int?);

  List<int?>? get $in => (_$data['in'] as List<int?>?);

  List<int?>? get nin => (_$data['nin'] as List<int?>?);

  int? get gt => (_$data['gt'] as int?);

  int? get ngt => (_$data['ngt'] as int?);

  int? get gte => (_$data['gte'] as int?);

  int? get ngte => (_$data['ngte'] as int?);

  int? get lt => (_$data['lt'] as int?);

  int? get nlt => (_$data['nlt'] as int?);

  int? get lte => (_$data['lte'] as int?);

  int? get nlte => (_$data['nlte'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$ByteOperationFilterInput<Input$ByteOperationFilterInput>
  get copyWith => CopyWith$Input$ByteOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ByteOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    final l$gt = gt;
    final l$ngt = ngt;
    final l$gte = gte;
    final l$ngte = ngte;
    final l$lt = lt;
    final l$nlt = nlt;
    final l$lte = lte;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$ByteOperationFilterInput<TRes> {
  factory CopyWith$Input$ByteOperationFilterInput(
    Input$ByteOperationFilterInput instance,
    TRes Function(Input$ByteOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ByteOperationFilterInput;

  factory CopyWith$Input$ByteOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ByteOperationFilterInput;

  TRes call({
    int? eq,
    int? neq,
    List<int?>? $in,
    List<int?>? nin,
    int? gt,
    int? ngt,
    int? gte,
    int? ngte,
    int? lt,
    int? nlt,
    int? lte,
    int? nlte,
  });
}

class _CopyWithImpl$Input$ByteOperationFilterInput<TRes>
    implements CopyWith$Input$ByteOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ByteOperationFilterInput(this._instance, this._then);

  final Input$ByteOperationFilterInput _instance;

  final TRes Function(Input$ByteOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
    Object? gt = _undefined,
    Object? ngt = _undefined,
    Object? gte = _undefined,
    Object? ngte = _undefined,
    Object? lt = _undefined,
    Object? nlt = _undefined,
    Object? lte = _undefined,
    Object? nlte = _undefined,
  }) => _then(
    Input$ByteOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as int?),
      if (neq != _undefined) 'neq': (neq as int?),
      if ($in != _undefined) 'in': ($in as List<int?>?),
      if (nin != _undefined) 'nin': (nin as List<int?>?),
      if (gt != _undefined) 'gt': (gt as int?),
      if (ngt != _undefined) 'ngt': (ngt as int?),
      if (gte != _undefined) 'gte': (gte as int?),
      if (ngte != _undefined) 'ngte': (ngte as int?),
      if (lt != _undefined) 'lt': (lt as int?),
      if (nlt != _undefined) 'nlt': (nlt as int?),
      if (lte != _undefined) 'lte': (lte as int?),
      if (nlte != _undefined) 'nlte': (nlte as int?),
    }),
  );
}

class _CopyWithStubImpl$Input$ByteOperationFilterInput<TRes>
    implements CopyWith$Input$ByteOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ByteOperationFilterInput(this._res);

  TRes _res;

  call({
    int? eq,
    int? neq,
    List<int?>? $in,
    List<int?>? nin,
    int? gt,
    int? ngt,
    int? gte,
    int? ngte,
    int? lt,
    int? nlt,
    int? lte,
    int? nlte,
  }) => _res;
}

class Input$CategoryFilterInput {
  factory Input$CategoryFilterInput({
    List<Input$CategoryFilterInput>? and,
    List<Input$CategoryFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? slug,
    Input$CategoryTypeOperationFilterInput? type,
    Input$ListStringOperationFilterInput? aliases,
    Input$IntOperationFilterInput? popularity,
    Input$StringOperationFilterInput? description,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$CategoryFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (slug != null) r'slug': slug,
    if (type != null) r'type': type,
    if (aliases != null) r'aliases': aliases,
    if (popularity != null) r'popularity': popularity,
    if (description != null) r'description': description,
    if (isVisible != null) r'isVisible': isVisible,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$CategoryFilterInput._(this._$data);

  factory Input$CategoryFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$CategoryFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$CategoryFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>),
            );
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = l$slug == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$slug as Map<String, dynamic>),
            );
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : Input$CategoryTypeOperationFilterInput.fromJson(
              (l$type as Map<String, dynamic>),
            );
    }
    if (data.containsKey('aliases')) {
      final l$aliases = data['aliases'];
      result$data['aliases'] = l$aliases == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$aliases as Map<String, dynamic>),
            );
    }
    if (data.containsKey('popularity')) {
      final l$popularity = data['popularity'];
      result$data['popularity'] = l$popularity == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$popularity as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isVisible as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$CategoryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CategoryFilterInput>? get and =>
      (_$data['and'] as List<Input$CategoryFilterInput>?);

  List<Input$CategoryFilterInput>? get or =>
      (_$data['or'] as List<Input$CategoryFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get slug =>
      (_$data['slug'] as Input$StringOperationFilterInput?);

  Input$CategoryTypeOperationFilterInput? get type =>
      (_$data['type'] as Input$CategoryTypeOperationFilterInput?);

  Input$ListStringOperationFilterInput? get aliases =>
      (_$data['aliases'] as Input$ListStringOperationFilterInput?);

  Input$IntOperationFilterInput? get popularity =>
      (_$data['popularity'] as Input$IntOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isVisible =>
      (_$data['isVisible'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug?.toJson();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.toJson();
    }
    if (_$data.containsKey('aliases')) {
      final l$aliases = aliases;
      result$data['aliases'] = l$aliases?.toJson();
    }
    if (_$data.containsKey('popularity')) {
      final l$popularity = popularity;
      result$data['popularity'] = l$popularity?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CategoryFilterInput<Input$CategoryFilterInput> get copyWith =>
      CopyWith$Input$CategoryFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CategoryFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$aliases = aliases;
    final lOther$aliases = other.aliases;
    if (_$data.containsKey('aliases') != other._$data.containsKey('aliases')) {
      return false;
    }
    if (l$aliases != lOther$aliases) {
      return false;
    }
    final l$popularity = popularity;
    final lOther$popularity = other.popularity;
    if (_$data.containsKey('popularity') !=
        other._$data.containsKey('popularity')) {
      return false;
    }
    if (l$popularity != lOther$popularity) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$type = type;
    final l$aliases = aliases;
    final l$popularity = popularity;
    final l$description = description;
    final l$isVisible = isVisible;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('aliases') ? l$aliases : const {},
      _$data.containsKey('popularity') ? l$popularity : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$CategoryFilterInput<TRes> {
  factory CopyWith$Input$CategoryFilterInput(
    Input$CategoryFilterInput instance,
    TRes Function(Input$CategoryFilterInput) then,
  ) = _CopyWithImpl$Input$CategoryFilterInput;

  factory CopyWith$Input$CategoryFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CategoryFilterInput;

  TRes call({
    List<Input$CategoryFilterInput>? and,
    List<Input$CategoryFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? slug,
    Input$CategoryTypeOperationFilterInput? type,
    Input$ListStringOperationFilterInput? aliases,
    Input$IntOperationFilterInput? popularity,
    Input$StringOperationFilterInput? description,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$CategoryFilterInput>? Function(
      Iterable<CopyWith$Input$CategoryFilterInput<Input$CategoryFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$CategoryFilterInput>? Function(
      Iterable<CopyWith$Input$CategoryFilterInput<Input$CategoryFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  CopyWith$Input$StringOperationFilterInput<TRes> get slug;
  CopyWith$Input$CategoryTypeOperationFilterInput<TRes> get type;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get aliases;
  CopyWith$Input$IntOperationFilterInput<TRes> get popularity;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$CategoryFilterInput<TRes>
    implements CopyWith$Input$CategoryFilterInput<TRes> {
  _CopyWithImpl$Input$CategoryFilterInput(this._instance, this._then);

  final Input$CategoryFilterInput _instance;

  final TRes Function(Input$CategoryFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? type = _undefined,
    Object? aliases = _undefined,
    Object? popularity = _undefined,
    Object? description = _undefined,
    Object? isVisible = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$CategoryFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$CategoryFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$CategoryFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (name != _undefined)
        'name': (name as Input$StringOperationFilterInput?),
      if (slug != _undefined)
        'slug': (slug as Input$StringOperationFilterInput?),
      if (type != _undefined)
        'type': (type as Input$CategoryTypeOperationFilterInput?),
      if (aliases != _undefined)
        'aliases': (aliases as Input$ListStringOperationFilterInput?),
      if (popularity != _undefined)
        'popularity': (popularity as Input$IntOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Input$BooleanOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$CategoryFilterInput>? Function(
      Iterable<CopyWith$Input$CategoryFilterInput<Input$CategoryFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$CategoryFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$CategoryFilterInput>? Function(
      Iterable<CopyWith$Input$CategoryFilterInput<Input$CategoryFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$CategoryFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name,
            (e) => call(name: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get slug {
    final local$slug = _instance.slug;
    return local$slug == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$slug,
            (e) => call(slug: e),
          );
  }

  CopyWith$Input$CategoryTypeOperationFilterInput<TRes> get type {
    final local$type = _instance.type;
    return local$type == null
        ? CopyWith$Input$CategoryTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CategoryTypeOperationFilterInput(
            local$type,
            (e) => call(type: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get aliases {
    final local$aliases = _instance.aliases;
    return local$aliases == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$aliases,
            (e) => call(aliases: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get popularity {
    final local$popularity = _instance.popularity;
    return local$popularity == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$popularity,
            (e) => call(popularity: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible {
    final local$isVisible = _instance.isVisible;
    return local$isVisible == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isVisible,
            (e) => call(isVisible: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$CategoryFilterInput<TRes>
    implements CopyWith$Input$CategoryFilterInput<TRes> {
  _CopyWithStubImpl$Input$CategoryFilterInput(this._res);

  TRes _res;

  call({
    List<Input$CategoryFilterInput>? and,
    List<Input$CategoryFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? slug,
    Input$CategoryTypeOperationFilterInput? type,
    Input$ListStringOperationFilterInput? aliases,
    Input$IntOperationFilterInput? popularity,
    Input$StringOperationFilterInput? description,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get slug =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$CategoryTypeOperationFilterInput<TRes> get type =>
      CopyWith$Input$CategoryTypeOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get aliases =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get popularity =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$CategorySortInput {
  factory Input$CategorySortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? slug,
    Enum$SortEnumType? type,
    Enum$SortEnumType? popularity,
    Enum$SortEnumType? description,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$CategorySortInput._({
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (slug != null) r'slug': slug,
    if (type != null) r'type': type,
    if (popularity != null) r'popularity': popularity,
    if (description != null) r'description': description,
    if (isVisible != null) r'isVisible': isVisible,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$CategorySortInput._(this._$data);

  factory Input$CategorySortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = l$slug == null
          ? null
          : fromJson$Enum$SortEnumType((l$slug as String));
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : fromJson$Enum$SortEnumType((l$type as String));
    }
    if (data.containsKey('popularity')) {
      final l$popularity = data['popularity'];
      result$data['popularity'] = l$popularity == null
          ? null
          : fromJson$Enum$SortEnumType((l$popularity as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : fromJson$Enum$SortEnumType((l$isVisible as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$CategorySortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);

  Enum$SortEnumType? get slug => (_$data['slug'] as Enum$SortEnumType?);

  Enum$SortEnumType? get type => (_$data['type'] as Enum$SortEnumType?);

  Enum$SortEnumType? get popularity =>
      (_$data['popularity'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isVisible =>
      (_$data['isVisible'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null
          ? null
          : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug == null
          ? null
          : toJson$Enum$SortEnumType(l$slug);
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type == null
          ? null
          : toJson$Enum$SortEnumType(l$type);
    }
    if (_$data.containsKey('popularity')) {
      final l$popularity = popularity;
      result$data['popularity'] = l$popularity == null
          ? null
          : toJson$Enum$SortEnumType(l$popularity);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible == null
          ? null
          : toJson$Enum$SortEnumType(l$isVisible);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$CategorySortInput<Input$CategorySortInput> get copyWith =>
      CopyWith$Input$CategorySortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CategorySortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$popularity = popularity;
    final lOther$popularity = other.popularity;
    if (_$data.containsKey('popularity') !=
        other._$data.containsKey('popularity')) {
      return false;
    }
    if (l$popularity != lOther$popularity) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$slug = slug;
    final l$type = type;
    final l$popularity = popularity;
    final l$description = description;
    final l$isVisible = isVisible;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('slug') ? l$slug : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('popularity') ? l$popularity : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$CategorySortInput<TRes> {
  factory CopyWith$Input$CategorySortInput(
    Input$CategorySortInput instance,
    TRes Function(Input$CategorySortInput) then,
  ) = _CopyWithImpl$Input$CategorySortInput;

  factory CopyWith$Input$CategorySortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CategorySortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? slug,
    Enum$SortEnumType? type,
    Enum$SortEnumType? popularity,
    Enum$SortEnumType? description,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$CategorySortInput<TRes>
    implements CopyWith$Input$CategorySortInput<TRes> {
  _CopyWithImpl$Input$CategorySortInput(this._instance, this._then);

  final Input$CategorySortInput _instance;

  final TRes Function(Input$CategorySortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? slug = _undefined,
    Object? type = _undefined,
    Object? popularity = _undefined,
    Object? description = _undefined,
    Object? isVisible = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$CategorySortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      if (slug != _undefined) 'slug': (slug as Enum$SortEnumType?),
      if (type != _undefined) 'type': (type as Enum$SortEnumType?),
      if (popularity != _undefined)
        'popularity': (popularity as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$CategorySortInput<TRes>
    implements CopyWith$Input$CategorySortInput<TRes> {
  _CopyWithStubImpl$Input$CategorySortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? slug,
    Enum$SortEnumType? type,
    Enum$SortEnumType? popularity,
    Enum$SortEnumType? description,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$CategoryTypeOperationFilterInput {
  factory Input$CategoryTypeOperationFilterInput({
    Enum$CategoryType? eq,
    Enum$CategoryType? neq,
    List<Enum$CategoryType>? $in,
    List<Enum$CategoryType>? nin,
  }) => Input$CategoryTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$CategoryTypeOperationFilterInput._(this._$data);

  factory Input$CategoryTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$CategoryType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$CategoryType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CategoryType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CategoryType((e as String)))
          .toList();
    }
    return Input$CategoryTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CategoryType? get eq => (_$data['eq'] as Enum$CategoryType?);

  Enum$CategoryType? get neq => (_$data['neq'] as Enum$CategoryType?);

  List<Enum$CategoryType>? get $in =>
      (_$data['in'] as List<Enum$CategoryType>?);

  List<Enum$CategoryType>? get nin =>
      (_$data['nin'] as List<Enum$CategoryType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$CategoryType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$CategoryType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$CategoryType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$CategoryType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$CategoryTypeOperationFilterInput<
    Input$CategoryTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$CategoryTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CategoryTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CategoryTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$CategoryTypeOperationFilterInput(
    Input$CategoryTypeOperationFilterInput instance,
    TRes Function(Input$CategoryTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$CategoryTypeOperationFilterInput;

  factory CopyWith$Input$CategoryTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CategoryTypeOperationFilterInput;

  TRes call({
    Enum$CategoryType? eq,
    Enum$CategoryType? neq,
    List<Enum$CategoryType>? $in,
    List<Enum$CategoryType>? nin,
  });
}

class _CopyWithImpl$Input$CategoryTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CategoryTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$CategoryTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$CategoryTypeOperationFilterInput _instance;

  final TRes Function(Input$CategoryTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$CategoryTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$CategoryType?),
      if (neq != _undefined) 'neq': (neq as Enum$CategoryType?),
      if ($in != _undefined) 'in': ($in as List<Enum$CategoryType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$CategoryType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$CategoryTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CategoryTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$CategoryTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$CategoryType? eq,
    Enum$CategoryType? neq,
    List<Enum$CategoryType>? $in,
    List<Enum$CategoryType>? nin,
  }) => _res;
}

class Input$ChangeOrderStatusRequestInput {
  factory Input$ChangeOrderStatusRequestInput({
    required String id,
    required Enum$PackageOrderStatus status,
  }) => Input$ChangeOrderStatusRequestInput._({r'id': id, r'status': status});

  Input$ChangeOrderStatusRequestInput._(this._$data);

  factory Input$ChangeOrderStatusRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$status = data['status'];
    result$data['status'] = fromJson$Enum$PackageOrderStatus(
      (l$status as String),
    );
    return Input$ChangeOrderStatusRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  Enum$PackageOrderStatus get status =>
      (_$data['status'] as Enum$PackageOrderStatus);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$status = status;
    result$data['status'] = toJson$Enum$PackageOrderStatus(l$status);
    return result$data;
  }

  CopyWith$Input$ChangeOrderStatusRequestInput<
    Input$ChangeOrderStatusRequestInput
  >
  get copyWith => CopyWith$Input$ChangeOrderStatusRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ChangeOrderStatusRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$status = status;
    return Object.hashAll([l$id, l$status]);
  }
}

abstract class CopyWith$Input$ChangeOrderStatusRequestInput<TRes> {
  factory CopyWith$Input$ChangeOrderStatusRequestInput(
    Input$ChangeOrderStatusRequestInput instance,
    TRes Function(Input$ChangeOrderStatusRequestInput) then,
  ) = _CopyWithImpl$Input$ChangeOrderStatusRequestInput;

  factory CopyWith$Input$ChangeOrderStatusRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeOrderStatusRequestInput;

  TRes call({String? id, Enum$PackageOrderStatus? status});
}

class _CopyWithImpl$Input$ChangeOrderStatusRequestInput<TRes>
    implements CopyWith$Input$ChangeOrderStatusRequestInput<TRes> {
  _CopyWithImpl$Input$ChangeOrderStatusRequestInput(this._instance, this._then);

  final Input$ChangeOrderStatusRequestInput _instance;

  final TRes Function(Input$ChangeOrderStatusRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined, Object? status = _undefined}) => _then(
    Input$ChangeOrderStatusRequestInput._({
      ..._instance._$data,
      if (id != _undefined && id != null) 'id': (id as String),
      if (status != _undefined && status != null)
        'status': (status as Enum$PackageOrderStatus),
    }),
  );
}

class _CopyWithStubImpl$Input$ChangeOrderStatusRequestInput<TRes>
    implements CopyWith$Input$ChangeOrderStatusRequestInput<TRes> {
  _CopyWithStubImpl$Input$ChangeOrderStatusRequestInput(this._res);

  TRes _res;

  call({String? id, Enum$PackageOrderStatus? status}) => _res;
}

class Input$ChangeStatusRequestInput {
  factory Input$ChangeStatusRequestInput({
    required String requestId,
    required Enum$RequestStatus status,
  }) => Input$ChangeStatusRequestInput._({
    r'requestId': requestId,
    r'status': status,
  });

  Input$ChangeStatusRequestInput._(this._$data);

  factory Input$ChangeStatusRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$requestId = data['requestId'];
    result$data['requestId'] = (l$requestId as String);
    final l$status = data['status'];
    result$data['status'] = fromJson$Enum$RequestStatus((l$status as String));
    return Input$ChangeStatusRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get requestId => (_$data['requestId'] as String);

  Enum$RequestStatus get status => (_$data['status'] as Enum$RequestStatus);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$requestId = requestId;
    result$data['requestId'] = l$requestId;
    final l$status = status;
    result$data['status'] = toJson$Enum$RequestStatus(l$status);
    return result$data;
  }

  CopyWith$Input$ChangeStatusRequestInput<Input$ChangeStatusRequestInput>
  get copyWith => CopyWith$Input$ChangeStatusRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ChangeStatusRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$requestId = requestId;
    final l$status = status;
    return Object.hashAll([l$requestId, l$status]);
  }
}

abstract class CopyWith$Input$ChangeStatusRequestInput<TRes> {
  factory CopyWith$Input$ChangeStatusRequestInput(
    Input$ChangeStatusRequestInput instance,
    TRes Function(Input$ChangeStatusRequestInput) then,
  ) = _CopyWithImpl$Input$ChangeStatusRequestInput;

  factory CopyWith$Input$ChangeStatusRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeStatusRequestInput;

  TRes call({String? requestId, Enum$RequestStatus? status});
}

class _CopyWithImpl$Input$ChangeStatusRequestInput<TRes>
    implements CopyWith$Input$ChangeStatusRequestInput<TRes> {
  _CopyWithImpl$Input$ChangeStatusRequestInput(this._instance, this._then);

  final Input$ChangeStatusRequestInput _instance;

  final TRes Function(Input$ChangeStatusRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? requestId = _undefined, Object? status = _undefined}) =>
      _then(
        Input$ChangeStatusRequestInput._({
          ..._instance._$data,
          if (requestId != _undefined && requestId != null)
            'requestId': (requestId as String),
          if (status != _undefined && status != null)
            'status': (status as Enum$RequestStatus),
        }),
      );
}

class _CopyWithStubImpl$Input$ChangeStatusRequestInput<TRes>
    implements CopyWith$Input$ChangeStatusRequestInput<TRes> {
  _CopyWithStubImpl$Input$ChangeStatusRequestInput(this._res);

  TRes _res;

  call({String? requestId, Enum$RequestStatus? status}) => _res;
}

class Input$CommentFilterInput {
  factory Input$CommentFilterInput({
    List<Input$CommentFilterInput>? and,
    List<Input$CommentFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? targetId,
    Input$CommentTypeOperationFilterInput? commentType,
    Input$StringOperationFilterInput? commenterId,
    Input$StringOperationFilterInput? content,
    Input$StringOperationFilterInput? parentCommentId,
    Input$StringOperationFilterInput? rootCommentId,
    Input$ListStringOperationFilterInput? threadPath,
    Input$IntOperationFilterInput? depth,
    Input$LongOperationFilterInput? replyCount,
    Input$LongOperationFilterInput? totalRepliesCount,
    Input$IntOperationFilterInput? sortOrder,
    Input$DateTimeOperationFilterInput? threadUpdatedAt,
    Input$BooleanOperationFilterInput? isEdited,
    Input$BooleanOperationFilterInput? isDeleted,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$CommentFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (targetId != null) r'targetId': targetId,
    if (commentType != null) r'commentType': commentType,
    if (commenterId != null) r'commenterId': commenterId,
    if (content != null) r'content': content,
    if (parentCommentId != null) r'parentCommentId': parentCommentId,
    if (rootCommentId != null) r'rootCommentId': rootCommentId,
    if (threadPath != null) r'threadPath': threadPath,
    if (depth != null) r'depth': depth,
    if (replyCount != null) r'replyCount': replyCount,
    if (totalRepliesCount != null) r'totalRepliesCount': totalRepliesCount,
    if (sortOrder != null) r'sortOrder': sortOrder,
    if (threadUpdatedAt != null) r'threadUpdatedAt': threadUpdatedAt,
    if (isEdited != null) r'isEdited': isEdited,
    if (isDeleted != null) r'isDeleted': isDeleted,
    if (isVisible != null) r'isVisible': isVisible,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$CommentFilterInput._(this._$data);

  factory Input$CommentFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$CommentFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$CommentFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('targetId')) {
      final l$targetId = data['targetId'];
      result$data['targetId'] = l$targetId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$targetId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('commentType')) {
      final l$commentType = data['commentType'];
      result$data['commentType'] = l$commentType == null
          ? null
          : Input$CommentTypeOperationFilterInput.fromJson(
              (l$commentType as Map<String, dynamic>),
            );
    }
    if (data.containsKey('commenterId')) {
      final l$commenterId = data['commenterId'];
      result$data['commenterId'] = l$commenterId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$commenterId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$content as Map<String, dynamic>),
            );
    }
    if (data.containsKey('parentCommentId')) {
      final l$parentCommentId = data['parentCommentId'];
      result$data['parentCommentId'] = l$parentCommentId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$parentCommentId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('rootCommentId')) {
      final l$rootCommentId = data['rootCommentId'];
      result$data['rootCommentId'] = l$rootCommentId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$rootCommentId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('threadPath')) {
      final l$threadPath = data['threadPath'];
      result$data['threadPath'] = l$threadPath == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$threadPath as Map<String, dynamic>),
            );
    }
    if (data.containsKey('depth')) {
      final l$depth = data['depth'];
      result$data['depth'] = l$depth == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$depth as Map<String, dynamic>),
            );
    }
    if (data.containsKey('replyCount')) {
      final l$replyCount = data['replyCount'];
      result$data['replyCount'] = l$replyCount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$replyCount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('totalRepliesCount')) {
      final l$totalRepliesCount = data['totalRepliesCount'];
      result$data['totalRepliesCount'] = l$totalRepliesCount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$totalRepliesCount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('sortOrder')) {
      final l$sortOrder = data['sortOrder'];
      result$data['sortOrder'] = l$sortOrder == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$sortOrder as Map<String, dynamic>),
            );
    }
    if (data.containsKey('threadUpdatedAt')) {
      final l$threadUpdatedAt = data['threadUpdatedAt'];
      result$data['threadUpdatedAt'] = l$threadUpdatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$threadUpdatedAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isEdited')) {
      final l$isEdited = data['isEdited'];
      result$data['isEdited'] = l$isEdited == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isEdited as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isDeleted')) {
      final l$isDeleted = data['isDeleted'];
      result$data['isDeleted'] = l$isDeleted == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isDeleted as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isVisible as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$CommentFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CommentFilterInput>? get and =>
      (_$data['and'] as List<Input$CommentFilterInput>?);

  List<Input$CommentFilterInput>? get or =>
      (_$data['or'] as List<Input$CommentFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get targetId =>
      (_$data['targetId'] as Input$StringOperationFilterInput?);

  Input$CommentTypeOperationFilterInput? get commentType =>
      (_$data['commentType'] as Input$CommentTypeOperationFilterInput?);

  Input$StringOperationFilterInput? get commenterId =>
      (_$data['commenterId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get content =>
      (_$data['content'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get parentCommentId =>
      (_$data['parentCommentId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get rootCommentId =>
      (_$data['rootCommentId'] as Input$StringOperationFilterInput?);

  Input$ListStringOperationFilterInput? get threadPath =>
      (_$data['threadPath'] as Input$ListStringOperationFilterInput?);

  Input$IntOperationFilterInput? get depth =>
      (_$data['depth'] as Input$IntOperationFilterInput?);

  Input$LongOperationFilterInput? get replyCount =>
      (_$data['replyCount'] as Input$LongOperationFilterInput?);

  Input$LongOperationFilterInput? get totalRepliesCount =>
      (_$data['totalRepliesCount'] as Input$LongOperationFilterInput?);

  Input$IntOperationFilterInput? get sortOrder =>
      (_$data['sortOrder'] as Input$IntOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get threadUpdatedAt =>
      (_$data['threadUpdatedAt'] as Input$DateTimeOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isEdited =>
      (_$data['isEdited'] as Input$BooleanOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isDeleted =>
      (_$data['isDeleted'] as Input$BooleanOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isVisible =>
      (_$data['isVisible'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('targetId')) {
      final l$targetId = targetId;
      result$data['targetId'] = l$targetId?.toJson();
    }
    if (_$data.containsKey('commentType')) {
      final l$commentType = commentType;
      result$data['commentType'] = l$commentType?.toJson();
    }
    if (_$data.containsKey('commenterId')) {
      final l$commenterId = commenterId;
      result$data['commenterId'] = l$commenterId?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('parentCommentId')) {
      final l$parentCommentId = parentCommentId;
      result$data['parentCommentId'] = l$parentCommentId?.toJson();
    }
    if (_$data.containsKey('rootCommentId')) {
      final l$rootCommentId = rootCommentId;
      result$data['rootCommentId'] = l$rootCommentId?.toJson();
    }
    if (_$data.containsKey('threadPath')) {
      final l$threadPath = threadPath;
      result$data['threadPath'] = l$threadPath?.toJson();
    }
    if (_$data.containsKey('depth')) {
      final l$depth = depth;
      result$data['depth'] = l$depth?.toJson();
    }
    if (_$data.containsKey('replyCount')) {
      final l$replyCount = replyCount;
      result$data['replyCount'] = l$replyCount?.toJson();
    }
    if (_$data.containsKey('totalRepliesCount')) {
      final l$totalRepliesCount = totalRepliesCount;
      result$data['totalRepliesCount'] = l$totalRepliesCount?.toJson();
    }
    if (_$data.containsKey('sortOrder')) {
      final l$sortOrder = sortOrder;
      result$data['sortOrder'] = l$sortOrder?.toJson();
    }
    if (_$data.containsKey('threadUpdatedAt')) {
      final l$threadUpdatedAt = threadUpdatedAt;
      result$data['threadUpdatedAt'] = l$threadUpdatedAt?.toJson();
    }
    if (_$data.containsKey('isEdited')) {
      final l$isEdited = isEdited;
      result$data['isEdited'] = l$isEdited?.toJson();
    }
    if (_$data.containsKey('isDeleted')) {
      final l$isDeleted = isDeleted;
      result$data['isDeleted'] = l$isDeleted?.toJson();
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CommentFilterInput<Input$CommentFilterInput> get copyWith =>
      CopyWith$Input$CommentFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommentFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (_$data.containsKey('targetId') !=
        other._$data.containsKey('targetId')) {
      return false;
    }
    if (l$targetId != lOther$targetId) {
      return false;
    }
    final l$commentType = commentType;
    final lOther$commentType = other.commentType;
    if (_$data.containsKey('commentType') !=
        other._$data.containsKey('commentType')) {
      return false;
    }
    if (l$commentType != lOther$commentType) {
      return false;
    }
    final l$commenterId = commenterId;
    final lOther$commenterId = other.commenterId;
    if (_$data.containsKey('commenterId') !=
        other._$data.containsKey('commenterId')) {
      return false;
    }
    if (l$commenterId != lOther$commenterId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$parentCommentId = parentCommentId;
    final lOther$parentCommentId = other.parentCommentId;
    if (_$data.containsKey('parentCommentId') !=
        other._$data.containsKey('parentCommentId')) {
      return false;
    }
    if (l$parentCommentId != lOther$parentCommentId) {
      return false;
    }
    final l$rootCommentId = rootCommentId;
    final lOther$rootCommentId = other.rootCommentId;
    if (_$data.containsKey('rootCommentId') !=
        other._$data.containsKey('rootCommentId')) {
      return false;
    }
    if (l$rootCommentId != lOther$rootCommentId) {
      return false;
    }
    final l$threadPath = threadPath;
    final lOther$threadPath = other.threadPath;
    if (_$data.containsKey('threadPath') !=
        other._$data.containsKey('threadPath')) {
      return false;
    }
    if (l$threadPath != lOther$threadPath) {
      return false;
    }
    final l$depth = depth;
    final lOther$depth = other.depth;
    if (_$data.containsKey('depth') != other._$data.containsKey('depth')) {
      return false;
    }
    if (l$depth != lOther$depth) {
      return false;
    }
    final l$replyCount = replyCount;
    final lOther$replyCount = other.replyCount;
    if (_$data.containsKey('replyCount') !=
        other._$data.containsKey('replyCount')) {
      return false;
    }
    if (l$replyCount != lOther$replyCount) {
      return false;
    }
    final l$totalRepliesCount = totalRepliesCount;
    final lOther$totalRepliesCount = other.totalRepliesCount;
    if (_$data.containsKey('totalRepliesCount') !=
        other._$data.containsKey('totalRepliesCount')) {
      return false;
    }
    if (l$totalRepliesCount != lOther$totalRepliesCount) {
      return false;
    }
    final l$sortOrder = sortOrder;
    final lOther$sortOrder = other.sortOrder;
    if (_$data.containsKey('sortOrder') !=
        other._$data.containsKey('sortOrder')) {
      return false;
    }
    if (l$sortOrder != lOther$sortOrder) {
      return false;
    }
    final l$threadUpdatedAt = threadUpdatedAt;
    final lOther$threadUpdatedAt = other.threadUpdatedAt;
    if (_$data.containsKey('threadUpdatedAt') !=
        other._$data.containsKey('threadUpdatedAt')) {
      return false;
    }
    if (l$threadUpdatedAt != lOther$threadUpdatedAt) {
      return false;
    }
    final l$isEdited = isEdited;
    final lOther$isEdited = other.isEdited;
    if (_$data.containsKey('isEdited') !=
        other._$data.containsKey('isEdited')) {
      return false;
    }
    if (l$isEdited != lOther$isEdited) {
      return false;
    }
    final l$isDeleted = isDeleted;
    final lOther$isDeleted = other.isDeleted;
    if (_$data.containsKey('isDeleted') !=
        other._$data.containsKey('isDeleted')) {
      return false;
    }
    if (l$isDeleted != lOther$isDeleted) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$targetId = targetId;
    final l$commentType = commentType;
    final l$commenterId = commenterId;
    final l$content = content;
    final l$parentCommentId = parentCommentId;
    final l$rootCommentId = rootCommentId;
    final l$threadPath = threadPath;
    final l$depth = depth;
    final l$replyCount = replyCount;
    final l$totalRepliesCount = totalRepliesCount;
    final l$sortOrder = sortOrder;
    final l$threadUpdatedAt = threadUpdatedAt;
    final l$isEdited = isEdited;
    final l$isDeleted = isDeleted;
    final l$isVisible = isVisible;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('targetId') ? l$targetId : const {},
      _$data.containsKey('commentType') ? l$commentType : const {},
      _$data.containsKey('commenterId') ? l$commenterId : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('parentCommentId') ? l$parentCommentId : const {},
      _$data.containsKey('rootCommentId') ? l$rootCommentId : const {},
      _$data.containsKey('threadPath') ? l$threadPath : const {},
      _$data.containsKey('depth') ? l$depth : const {},
      _$data.containsKey('replyCount') ? l$replyCount : const {},
      _$data.containsKey('totalRepliesCount') ? l$totalRepliesCount : const {},
      _$data.containsKey('sortOrder') ? l$sortOrder : const {},
      _$data.containsKey('threadUpdatedAt') ? l$threadUpdatedAt : const {},
      _$data.containsKey('isEdited') ? l$isEdited : const {},
      _$data.containsKey('isDeleted') ? l$isDeleted : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommentFilterInput<TRes> {
  factory CopyWith$Input$CommentFilterInput(
    Input$CommentFilterInput instance,
    TRes Function(Input$CommentFilterInput) then,
  ) = _CopyWithImpl$Input$CommentFilterInput;

  factory CopyWith$Input$CommentFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommentFilterInput;

  TRes call({
    List<Input$CommentFilterInput>? and,
    List<Input$CommentFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? targetId,
    Input$CommentTypeOperationFilterInput? commentType,
    Input$StringOperationFilterInput? commenterId,
    Input$StringOperationFilterInput? content,
    Input$StringOperationFilterInput? parentCommentId,
    Input$StringOperationFilterInput? rootCommentId,
    Input$ListStringOperationFilterInput? threadPath,
    Input$IntOperationFilterInput? depth,
    Input$LongOperationFilterInput? replyCount,
    Input$LongOperationFilterInput? totalRepliesCount,
    Input$IntOperationFilterInput? sortOrder,
    Input$DateTimeOperationFilterInput? threadUpdatedAt,
    Input$BooleanOperationFilterInput? isEdited,
    Input$BooleanOperationFilterInput? isDeleted,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$CommentFilterInput>? Function(
      Iterable<CopyWith$Input$CommentFilterInput<Input$CommentFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$CommentFilterInput>? Function(
      Iterable<CopyWith$Input$CommentFilterInput<Input$CommentFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get targetId;
  CopyWith$Input$CommentTypeOperationFilterInput<TRes> get commentType;
  CopyWith$Input$StringOperationFilterInput<TRes> get commenterId;
  CopyWith$Input$StringOperationFilterInput<TRes> get content;
  CopyWith$Input$StringOperationFilterInput<TRes> get parentCommentId;
  CopyWith$Input$StringOperationFilterInput<TRes> get rootCommentId;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get threadPath;
  CopyWith$Input$IntOperationFilterInput<TRes> get depth;
  CopyWith$Input$LongOperationFilterInput<TRes> get replyCount;
  CopyWith$Input$LongOperationFilterInput<TRes> get totalRepliesCount;
  CopyWith$Input$IntOperationFilterInput<TRes> get sortOrder;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get threadUpdatedAt;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isEdited;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDeleted;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$CommentFilterInput<TRes>
    implements CopyWith$Input$CommentFilterInput<TRes> {
  _CopyWithImpl$Input$CommentFilterInput(this._instance, this._then);

  final Input$CommentFilterInput _instance;

  final TRes Function(Input$CommentFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? targetId = _undefined,
    Object? commentType = _undefined,
    Object? commenterId = _undefined,
    Object? content = _undefined,
    Object? parentCommentId = _undefined,
    Object? rootCommentId = _undefined,
    Object? threadPath = _undefined,
    Object? depth = _undefined,
    Object? replyCount = _undefined,
    Object? totalRepliesCount = _undefined,
    Object? sortOrder = _undefined,
    Object? threadUpdatedAt = _undefined,
    Object? isEdited = _undefined,
    Object? isDeleted = _undefined,
    Object? isVisible = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$CommentFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$CommentFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$CommentFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (targetId != _undefined)
        'targetId': (targetId as Input$StringOperationFilterInput?),
      if (commentType != _undefined)
        'commentType': (commentType as Input$CommentTypeOperationFilterInput?),
      if (commenterId != _undefined)
        'commenterId': (commenterId as Input$StringOperationFilterInput?),
      if (content != _undefined)
        'content': (content as Input$StringOperationFilterInput?),
      if (parentCommentId != _undefined)
        'parentCommentId':
            (parentCommentId as Input$StringOperationFilterInput?),
      if (rootCommentId != _undefined)
        'rootCommentId': (rootCommentId as Input$StringOperationFilterInput?),
      if (threadPath != _undefined)
        'threadPath': (threadPath as Input$ListStringOperationFilterInput?),
      if (depth != _undefined)
        'depth': (depth as Input$IntOperationFilterInput?),
      if (replyCount != _undefined)
        'replyCount': (replyCount as Input$LongOperationFilterInput?),
      if (totalRepliesCount != _undefined)
        'totalRepliesCount':
            (totalRepliesCount as Input$LongOperationFilterInput?),
      if (sortOrder != _undefined)
        'sortOrder': (sortOrder as Input$IntOperationFilterInput?),
      if (threadUpdatedAt != _undefined)
        'threadUpdatedAt':
            (threadUpdatedAt as Input$DateTimeOperationFilterInput?),
      if (isEdited != _undefined)
        'isEdited': (isEdited as Input$BooleanOperationFilterInput?),
      if (isDeleted != _undefined)
        'isDeleted': (isDeleted as Input$BooleanOperationFilterInput?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Input$BooleanOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$CommentFilterInput>? Function(
      Iterable<CopyWith$Input$CommentFilterInput<Input$CommentFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$CommentFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$CommentFilterInput>? Function(
      Iterable<CopyWith$Input$CommentFilterInput<Input$CommentFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$CommentFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get targetId {
    final local$targetId = _instance.targetId;
    return local$targetId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$targetId,
            (e) => call(targetId: e),
          );
  }

  CopyWith$Input$CommentTypeOperationFilterInput<TRes> get commentType {
    final local$commentType = _instance.commentType;
    return local$commentType == null
        ? CopyWith$Input$CommentTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CommentTypeOperationFilterInput(
            local$commentType,
            (e) => call(commentType: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get commenterId {
    final local$commenterId = _instance.commenterId;
    return local$commenterId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$commenterId,
            (e) => call(commenterId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$content,
            (e) => call(content: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get parentCommentId {
    final local$parentCommentId = _instance.parentCommentId;
    return local$parentCommentId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$parentCommentId,
            (e) => call(parentCommentId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get rootCommentId {
    final local$rootCommentId = _instance.rootCommentId;
    return local$rootCommentId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$rootCommentId,
            (e) => call(rootCommentId: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get threadPath {
    final local$threadPath = _instance.threadPath;
    return local$threadPath == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$threadPath,
            (e) => call(threadPath: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get depth {
    final local$depth = _instance.depth;
    return local$depth == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$depth,
            (e) => call(depth: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get replyCount {
    final local$replyCount = _instance.replyCount;
    return local$replyCount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$replyCount,
            (e) => call(replyCount: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get totalRepliesCount {
    final local$totalRepliesCount = _instance.totalRepliesCount;
    return local$totalRepliesCount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$totalRepliesCount,
            (e) => call(totalRepliesCount: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get sortOrder {
    final local$sortOrder = _instance.sortOrder;
    return local$sortOrder == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$sortOrder,
            (e) => call(sortOrder: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get threadUpdatedAt {
    final local$threadUpdatedAt = _instance.threadUpdatedAt;
    return local$threadUpdatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$threadUpdatedAt,
            (e) => call(threadUpdatedAt: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isEdited {
    final local$isEdited = _instance.isEdited;
    return local$isEdited == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isEdited,
            (e) => call(isEdited: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDeleted {
    final local$isDeleted = _instance.isDeleted;
    return local$isDeleted == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isDeleted,
            (e) => call(isDeleted: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible {
    final local$isVisible = _instance.isVisible;
    return local$isVisible == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isVisible,
            (e) => call(isVisible: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$CommentFilterInput<TRes>
    implements CopyWith$Input$CommentFilterInput<TRes> {
  _CopyWithStubImpl$Input$CommentFilterInput(this._res);

  TRes _res;

  call({
    List<Input$CommentFilterInput>? and,
    List<Input$CommentFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? targetId,
    Input$CommentTypeOperationFilterInput? commentType,
    Input$StringOperationFilterInput? commenterId,
    Input$StringOperationFilterInput? content,
    Input$StringOperationFilterInput? parentCommentId,
    Input$StringOperationFilterInput? rootCommentId,
    Input$ListStringOperationFilterInput? threadPath,
    Input$IntOperationFilterInput? depth,
    Input$LongOperationFilterInput? replyCount,
    Input$LongOperationFilterInput? totalRepliesCount,
    Input$IntOperationFilterInput? sortOrder,
    Input$DateTimeOperationFilterInput? threadUpdatedAt,
    Input$BooleanOperationFilterInput? isEdited,
    Input$BooleanOperationFilterInput? isDeleted,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get targetId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$CommentTypeOperationFilterInput<TRes> get commentType =>
      CopyWith$Input$CommentTypeOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get commenterId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get content =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get parentCommentId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get rootCommentId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get threadPath =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get depth =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get replyCount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get totalRepliesCount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get sortOrder =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get threadUpdatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isEdited =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDeleted =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$CommentRepliesRequestInput {
  factory Input$CommentRepliesRequestInput({
    required String commentId,
    required int page,
    required int pageSize,
    required Enum$CommentSortOrder sortOrder,
  }) => Input$CommentRepliesRequestInput._({
    r'commentId': commentId,
    r'page': page,
    r'pageSize': pageSize,
    r'sortOrder': sortOrder,
  });

  Input$CommentRepliesRequestInput._(this._$data);

  factory Input$CommentRepliesRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$commentId = data['commentId'];
    result$data['commentId'] = (l$commentId as String);
    final l$page = data['page'];
    result$data['page'] = (l$page as int);
    final l$pageSize = data['pageSize'];
    result$data['pageSize'] = (l$pageSize as int);
    final l$sortOrder = data['sortOrder'];
    result$data['sortOrder'] = fromJson$Enum$CommentSortOrder(
      (l$sortOrder as String),
    );
    return Input$CommentRepliesRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get commentId => (_$data['commentId'] as String);

  int get page => (_$data['page'] as int);

  int get pageSize => (_$data['pageSize'] as int);

  Enum$CommentSortOrder get sortOrder =>
      (_$data['sortOrder'] as Enum$CommentSortOrder);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$commentId = commentId;
    result$data['commentId'] = l$commentId;
    final l$page = page;
    result$data['page'] = l$page;
    final l$pageSize = pageSize;
    result$data['pageSize'] = l$pageSize;
    final l$sortOrder = sortOrder;
    result$data['sortOrder'] = toJson$Enum$CommentSortOrder(l$sortOrder);
    return result$data;
  }

  CopyWith$Input$CommentRepliesRequestInput<Input$CommentRepliesRequestInput>
  get copyWith => CopyWith$Input$CommentRepliesRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommentRepliesRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$commentId = commentId;
    final lOther$commentId = other.commentId;
    if (l$commentId != lOther$commentId) {
      return false;
    }
    final l$page = page;
    final lOther$page = other.page;
    if (l$page != lOther$page) {
      return false;
    }
    final l$pageSize = pageSize;
    final lOther$pageSize = other.pageSize;
    if (l$pageSize != lOther$pageSize) {
      return false;
    }
    final l$sortOrder = sortOrder;
    final lOther$sortOrder = other.sortOrder;
    if (l$sortOrder != lOther$sortOrder) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$commentId = commentId;
    final l$page = page;
    final l$pageSize = pageSize;
    final l$sortOrder = sortOrder;
    return Object.hashAll([l$commentId, l$page, l$pageSize, l$sortOrder]);
  }
}

abstract class CopyWith$Input$CommentRepliesRequestInput<TRes> {
  factory CopyWith$Input$CommentRepliesRequestInput(
    Input$CommentRepliesRequestInput instance,
    TRes Function(Input$CommentRepliesRequestInput) then,
  ) = _CopyWithImpl$Input$CommentRepliesRequestInput;

  factory CopyWith$Input$CommentRepliesRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommentRepliesRequestInput;

  TRes call({
    String? commentId,
    int? page,
    int? pageSize,
    Enum$CommentSortOrder? sortOrder,
  });
}

class _CopyWithImpl$Input$CommentRepliesRequestInput<TRes>
    implements CopyWith$Input$CommentRepliesRequestInput<TRes> {
  _CopyWithImpl$Input$CommentRepliesRequestInput(this._instance, this._then);

  final Input$CommentRepliesRequestInput _instance;

  final TRes Function(Input$CommentRepliesRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? commentId = _undefined,
    Object? page = _undefined,
    Object? pageSize = _undefined,
    Object? sortOrder = _undefined,
  }) => _then(
    Input$CommentRepliesRequestInput._({
      ..._instance._$data,
      if (commentId != _undefined && commentId != null)
        'commentId': (commentId as String),
      if (page != _undefined && page != null) 'page': (page as int),
      if (pageSize != _undefined && pageSize != null)
        'pageSize': (pageSize as int),
      if (sortOrder != _undefined && sortOrder != null)
        'sortOrder': (sortOrder as Enum$CommentSortOrder),
    }),
  );
}

class _CopyWithStubImpl$Input$CommentRepliesRequestInput<TRes>
    implements CopyWith$Input$CommentRepliesRequestInput<TRes> {
  _CopyWithStubImpl$Input$CommentRepliesRequestInput(this._res);

  TRes _res;

  call({
    String? commentId,
    int? page,
    int? pageSize,
    Enum$CommentSortOrder? sortOrder,
  }) => _res;
}

class Input$CommentSortInput {
  factory Input$CommentSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? targetId,
    Enum$SortEnumType? commentType,
    Enum$SortEnumType? commenterId,
    Enum$SortEnumType? content,
    Enum$SortEnumType? parentCommentId,
    Enum$SortEnumType? rootCommentId,
    Enum$SortEnumType? depth,
    Enum$SortEnumType? replyCount,
    Enum$SortEnumType? totalRepliesCount,
    Enum$SortEnumType? sortOrder,
    Enum$SortEnumType? threadUpdatedAt,
    Enum$SortEnumType? isEdited,
    Enum$SortEnumType? isDeleted,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$CommentSortInput._({
    if (id != null) r'id': id,
    if (targetId != null) r'targetId': targetId,
    if (commentType != null) r'commentType': commentType,
    if (commenterId != null) r'commenterId': commenterId,
    if (content != null) r'content': content,
    if (parentCommentId != null) r'parentCommentId': parentCommentId,
    if (rootCommentId != null) r'rootCommentId': rootCommentId,
    if (depth != null) r'depth': depth,
    if (replyCount != null) r'replyCount': replyCount,
    if (totalRepliesCount != null) r'totalRepliesCount': totalRepliesCount,
    if (sortOrder != null) r'sortOrder': sortOrder,
    if (threadUpdatedAt != null) r'threadUpdatedAt': threadUpdatedAt,
    if (isEdited != null) r'isEdited': isEdited,
    if (isDeleted != null) r'isDeleted': isDeleted,
    if (isVisible != null) r'isVisible': isVisible,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$CommentSortInput._(this._$data);

  factory Input$CommentSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('targetId')) {
      final l$targetId = data['targetId'];
      result$data['targetId'] = l$targetId == null
          ? null
          : fromJson$Enum$SortEnumType((l$targetId as String));
    }
    if (data.containsKey('commentType')) {
      final l$commentType = data['commentType'];
      result$data['commentType'] = l$commentType == null
          ? null
          : fromJson$Enum$SortEnumType((l$commentType as String));
    }
    if (data.containsKey('commenterId')) {
      final l$commenterId = data['commenterId'];
      result$data['commenterId'] = l$commenterId == null
          ? null
          : fromJson$Enum$SortEnumType((l$commenterId as String));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : fromJson$Enum$SortEnumType((l$content as String));
    }
    if (data.containsKey('parentCommentId')) {
      final l$parentCommentId = data['parentCommentId'];
      result$data['parentCommentId'] = l$parentCommentId == null
          ? null
          : fromJson$Enum$SortEnumType((l$parentCommentId as String));
    }
    if (data.containsKey('rootCommentId')) {
      final l$rootCommentId = data['rootCommentId'];
      result$data['rootCommentId'] = l$rootCommentId == null
          ? null
          : fromJson$Enum$SortEnumType((l$rootCommentId as String));
    }
    if (data.containsKey('depth')) {
      final l$depth = data['depth'];
      result$data['depth'] = l$depth == null
          ? null
          : fromJson$Enum$SortEnumType((l$depth as String));
    }
    if (data.containsKey('replyCount')) {
      final l$replyCount = data['replyCount'];
      result$data['replyCount'] = l$replyCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$replyCount as String));
    }
    if (data.containsKey('totalRepliesCount')) {
      final l$totalRepliesCount = data['totalRepliesCount'];
      result$data['totalRepliesCount'] = l$totalRepliesCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$totalRepliesCount as String));
    }
    if (data.containsKey('sortOrder')) {
      final l$sortOrder = data['sortOrder'];
      result$data['sortOrder'] = l$sortOrder == null
          ? null
          : fromJson$Enum$SortEnumType((l$sortOrder as String));
    }
    if (data.containsKey('threadUpdatedAt')) {
      final l$threadUpdatedAt = data['threadUpdatedAt'];
      result$data['threadUpdatedAt'] = l$threadUpdatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$threadUpdatedAt as String));
    }
    if (data.containsKey('isEdited')) {
      final l$isEdited = data['isEdited'];
      result$data['isEdited'] = l$isEdited == null
          ? null
          : fromJson$Enum$SortEnumType((l$isEdited as String));
    }
    if (data.containsKey('isDeleted')) {
      final l$isDeleted = data['isDeleted'];
      result$data['isDeleted'] = l$isDeleted == null
          ? null
          : fromJson$Enum$SortEnumType((l$isDeleted as String));
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : fromJson$Enum$SortEnumType((l$isVisible as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$CommentSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get targetId => (_$data['targetId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get commentType =>
      (_$data['commentType'] as Enum$SortEnumType?);

  Enum$SortEnumType? get commenterId =>
      (_$data['commenterId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get content => (_$data['content'] as Enum$SortEnumType?);

  Enum$SortEnumType? get parentCommentId =>
      (_$data['parentCommentId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get rootCommentId =>
      (_$data['rootCommentId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get depth => (_$data['depth'] as Enum$SortEnumType?);

  Enum$SortEnumType? get replyCount =>
      (_$data['replyCount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get totalRepliesCount =>
      (_$data['totalRepliesCount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get sortOrder =>
      (_$data['sortOrder'] as Enum$SortEnumType?);

  Enum$SortEnumType? get threadUpdatedAt =>
      (_$data['threadUpdatedAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isEdited => (_$data['isEdited'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isDeleted =>
      (_$data['isDeleted'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isVisible =>
      (_$data['isVisible'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('targetId')) {
      final l$targetId = targetId;
      result$data['targetId'] = l$targetId == null
          ? null
          : toJson$Enum$SortEnumType(l$targetId);
    }
    if (_$data.containsKey('commentType')) {
      final l$commentType = commentType;
      result$data['commentType'] = l$commentType == null
          ? null
          : toJson$Enum$SortEnumType(l$commentType);
    }
    if (_$data.containsKey('commenterId')) {
      final l$commenterId = commenterId;
      result$data['commenterId'] = l$commenterId == null
          ? null
          : toJson$Enum$SortEnumType(l$commenterId);
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content == null
          ? null
          : toJson$Enum$SortEnumType(l$content);
    }
    if (_$data.containsKey('parentCommentId')) {
      final l$parentCommentId = parentCommentId;
      result$data['parentCommentId'] = l$parentCommentId == null
          ? null
          : toJson$Enum$SortEnumType(l$parentCommentId);
    }
    if (_$data.containsKey('rootCommentId')) {
      final l$rootCommentId = rootCommentId;
      result$data['rootCommentId'] = l$rootCommentId == null
          ? null
          : toJson$Enum$SortEnumType(l$rootCommentId);
    }
    if (_$data.containsKey('depth')) {
      final l$depth = depth;
      result$data['depth'] = l$depth == null
          ? null
          : toJson$Enum$SortEnumType(l$depth);
    }
    if (_$data.containsKey('replyCount')) {
      final l$replyCount = replyCount;
      result$data['replyCount'] = l$replyCount == null
          ? null
          : toJson$Enum$SortEnumType(l$replyCount);
    }
    if (_$data.containsKey('totalRepliesCount')) {
      final l$totalRepliesCount = totalRepliesCount;
      result$data['totalRepliesCount'] = l$totalRepliesCount == null
          ? null
          : toJson$Enum$SortEnumType(l$totalRepliesCount);
    }
    if (_$data.containsKey('sortOrder')) {
      final l$sortOrder = sortOrder;
      result$data['sortOrder'] = l$sortOrder == null
          ? null
          : toJson$Enum$SortEnumType(l$sortOrder);
    }
    if (_$data.containsKey('threadUpdatedAt')) {
      final l$threadUpdatedAt = threadUpdatedAt;
      result$data['threadUpdatedAt'] = l$threadUpdatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$threadUpdatedAt);
    }
    if (_$data.containsKey('isEdited')) {
      final l$isEdited = isEdited;
      result$data['isEdited'] = l$isEdited == null
          ? null
          : toJson$Enum$SortEnumType(l$isEdited);
    }
    if (_$data.containsKey('isDeleted')) {
      final l$isDeleted = isDeleted;
      result$data['isDeleted'] = l$isDeleted == null
          ? null
          : toJson$Enum$SortEnumType(l$isDeleted);
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible == null
          ? null
          : toJson$Enum$SortEnumType(l$isVisible);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$CommentSortInput<Input$CommentSortInput> get copyWith =>
      CopyWith$Input$CommentSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommentSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (_$data.containsKey('targetId') !=
        other._$data.containsKey('targetId')) {
      return false;
    }
    if (l$targetId != lOther$targetId) {
      return false;
    }
    final l$commentType = commentType;
    final lOther$commentType = other.commentType;
    if (_$data.containsKey('commentType') !=
        other._$data.containsKey('commentType')) {
      return false;
    }
    if (l$commentType != lOther$commentType) {
      return false;
    }
    final l$commenterId = commenterId;
    final lOther$commenterId = other.commenterId;
    if (_$data.containsKey('commenterId') !=
        other._$data.containsKey('commenterId')) {
      return false;
    }
    if (l$commenterId != lOther$commenterId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$parentCommentId = parentCommentId;
    final lOther$parentCommentId = other.parentCommentId;
    if (_$data.containsKey('parentCommentId') !=
        other._$data.containsKey('parentCommentId')) {
      return false;
    }
    if (l$parentCommentId != lOther$parentCommentId) {
      return false;
    }
    final l$rootCommentId = rootCommentId;
    final lOther$rootCommentId = other.rootCommentId;
    if (_$data.containsKey('rootCommentId') !=
        other._$data.containsKey('rootCommentId')) {
      return false;
    }
    if (l$rootCommentId != lOther$rootCommentId) {
      return false;
    }
    final l$depth = depth;
    final lOther$depth = other.depth;
    if (_$data.containsKey('depth') != other._$data.containsKey('depth')) {
      return false;
    }
    if (l$depth != lOther$depth) {
      return false;
    }
    final l$replyCount = replyCount;
    final lOther$replyCount = other.replyCount;
    if (_$data.containsKey('replyCount') !=
        other._$data.containsKey('replyCount')) {
      return false;
    }
    if (l$replyCount != lOther$replyCount) {
      return false;
    }
    final l$totalRepliesCount = totalRepliesCount;
    final lOther$totalRepliesCount = other.totalRepliesCount;
    if (_$data.containsKey('totalRepliesCount') !=
        other._$data.containsKey('totalRepliesCount')) {
      return false;
    }
    if (l$totalRepliesCount != lOther$totalRepliesCount) {
      return false;
    }
    final l$sortOrder = sortOrder;
    final lOther$sortOrder = other.sortOrder;
    if (_$data.containsKey('sortOrder') !=
        other._$data.containsKey('sortOrder')) {
      return false;
    }
    if (l$sortOrder != lOther$sortOrder) {
      return false;
    }
    final l$threadUpdatedAt = threadUpdatedAt;
    final lOther$threadUpdatedAt = other.threadUpdatedAt;
    if (_$data.containsKey('threadUpdatedAt') !=
        other._$data.containsKey('threadUpdatedAt')) {
      return false;
    }
    if (l$threadUpdatedAt != lOther$threadUpdatedAt) {
      return false;
    }
    final l$isEdited = isEdited;
    final lOther$isEdited = other.isEdited;
    if (_$data.containsKey('isEdited') !=
        other._$data.containsKey('isEdited')) {
      return false;
    }
    if (l$isEdited != lOther$isEdited) {
      return false;
    }
    final l$isDeleted = isDeleted;
    final lOther$isDeleted = other.isDeleted;
    if (_$data.containsKey('isDeleted') !=
        other._$data.containsKey('isDeleted')) {
      return false;
    }
    if (l$isDeleted != lOther$isDeleted) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$targetId = targetId;
    final l$commentType = commentType;
    final l$commenterId = commenterId;
    final l$content = content;
    final l$parentCommentId = parentCommentId;
    final l$rootCommentId = rootCommentId;
    final l$depth = depth;
    final l$replyCount = replyCount;
    final l$totalRepliesCount = totalRepliesCount;
    final l$sortOrder = sortOrder;
    final l$threadUpdatedAt = threadUpdatedAt;
    final l$isEdited = isEdited;
    final l$isDeleted = isDeleted;
    final l$isVisible = isVisible;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('targetId') ? l$targetId : const {},
      _$data.containsKey('commentType') ? l$commentType : const {},
      _$data.containsKey('commenterId') ? l$commenterId : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('parentCommentId') ? l$parentCommentId : const {},
      _$data.containsKey('rootCommentId') ? l$rootCommentId : const {},
      _$data.containsKey('depth') ? l$depth : const {},
      _$data.containsKey('replyCount') ? l$replyCount : const {},
      _$data.containsKey('totalRepliesCount') ? l$totalRepliesCount : const {},
      _$data.containsKey('sortOrder') ? l$sortOrder : const {},
      _$data.containsKey('threadUpdatedAt') ? l$threadUpdatedAt : const {},
      _$data.containsKey('isEdited') ? l$isEdited : const {},
      _$data.containsKey('isDeleted') ? l$isDeleted : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommentSortInput<TRes> {
  factory CopyWith$Input$CommentSortInput(
    Input$CommentSortInput instance,
    TRes Function(Input$CommentSortInput) then,
  ) = _CopyWithImpl$Input$CommentSortInput;

  factory CopyWith$Input$CommentSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommentSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? targetId,
    Enum$SortEnumType? commentType,
    Enum$SortEnumType? commenterId,
    Enum$SortEnumType? content,
    Enum$SortEnumType? parentCommentId,
    Enum$SortEnumType? rootCommentId,
    Enum$SortEnumType? depth,
    Enum$SortEnumType? replyCount,
    Enum$SortEnumType? totalRepliesCount,
    Enum$SortEnumType? sortOrder,
    Enum$SortEnumType? threadUpdatedAt,
    Enum$SortEnumType? isEdited,
    Enum$SortEnumType? isDeleted,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$CommentSortInput<TRes>
    implements CopyWith$Input$CommentSortInput<TRes> {
  _CopyWithImpl$Input$CommentSortInput(this._instance, this._then);

  final Input$CommentSortInput _instance;

  final TRes Function(Input$CommentSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? targetId = _undefined,
    Object? commentType = _undefined,
    Object? commenterId = _undefined,
    Object? content = _undefined,
    Object? parentCommentId = _undefined,
    Object? rootCommentId = _undefined,
    Object? depth = _undefined,
    Object? replyCount = _undefined,
    Object? totalRepliesCount = _undefined,
    Object? sortOrder = _undefined,
    Object? threadUpdatedAt = _undefined,
    Object? isEdited = _undefined,
    Object? isDeleted = _undefined,
    Object? isVisible = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$CommentSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (targetId != _undefined) 'targetId': (targetId as Enum$SortEnumType?),
      if (commentType != _undefined)
        'commentType': (commentType as Enum$SortEnumType?),
      if (commenterId != _undefined)
        'commenterId': (commenterId as Enum$SortEnumType?),
      if (content != _undefined) 'content': (content as Enum$SortEnumType?),
      if (parentCommentId != _undefined)
        'parentCommentId': (parentCommentId as Enum$SortEnumType?),
      if (rootCommentId != _undefined)
        'rootCommentId': (rootCommentId as Enum$SortEnumType?),
      if (depth != _undefined) 'depth': (depth as Enum$SortEnumType?),
      if (replyCount != _undefined)
        'replyCount': (replyCount as Enum$SortEnumType?),
      if (totalRepliesCount != _undefined)
        'totalRepliesCount': (totalRepliesCount as Enum$SortEnumType?),
      if (sortOrder != _undefined)
        'sortOrder': (sortOrder as Enum$SortEnumType?),
      if (threadUpdatedAt != _undefined)
        'threadUpdatedAt': (threadUpdatedAt as Enum$SortEnumType?),
      if (isEdited != _undefined) 'isEdited': (isEdited as Enum$SortEnumType?),
      if (isDeleted != _undefined)
        'isDeleted': (isDeleted as Enum$SortEnumType?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$CommentSortInput<TRes>
    implements CopyWith$Input$CommentSortInput<TRes> {
  _CopyWithStubImpl$Input$CommentSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? targetId,
    Enum$SortEnumType? commentType,
    Enum$SortEnumType? commenterId,
    Enum$SortEnumType? content,
    Enum$SortEnumType? parentCommentId,
    Enum$SortEnumType? rootCommentId,
    Enum$SortEnumType? depth,
    Enum$SortEnumType? replyCount,
    Enum$SortEnumType? totalRepliesCount,
    Enum$SortEnumType? sortOrder,
    Enum$SortEnumType? threadUpdatedAt,
    Enum$SortEnumType? isEdited,
    Enum$SortEnumType? isDeleted,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$CommentThreadRequestInput {
  factory Input$CommentThreadRequestInput({
    required String commentId,
    required bool includeDeleted,
  }) => Input$CommentThreadRequestInput._({
    r'commentId': commentId,
    r'includeDeleted': includeDeleted,
  });

  Input$CommentThreadRequestInput._(this._$data);

  factory Input$CommentThreadRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$commentId = data['commentId'];
    result$data['commentId'] = (l$commentId as String);
    final l$includeDeleted = data['includeDeleted'];
    result$data['includeDeleted'] = (l$includeDeleted as bool);
    return Input$CommentThreadRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get commentId => (_$data['commentId'] as String);

  bool get includeDeleted => (_$data['includeDeleted'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$commentId = commentId;
    result$data['commentId'] = l$commentId;
    final l$includeDeleted = includeDeleted;
    result$data['includeDeleted'] = l$includeDeleted;
    return result$data;
  }

  CopyWith$Input$CommentThreadRequestInput<Input$CommentThreadRequestInput>
  get copyWith => CopyWith$Input$CommentThreadRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommentThreadRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$commentId = commentId;
    final lOther$commentId = other.commentId;
    if (l$commentId != lOther$commentId) {
      return false;
    }
    final l$includeDeleted = includeDeleted;
    final lOther$includeDeleted = other.includeDeleted;
    if (l$includeDeleted != lOther$includeDeleted) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$commentId = commentId;
    final l$includeDeleted = includeDeleted;
    return Object.hashAll([l$commentId, l$includeDeleted]);
  }
}

abstract class CopyWith$Input$CommentThreadRequestInput<TRes> {
  factory CopyWith$Input$CommentThreadRequestInput(
    Input$CommentThreadRequestInput instance,
    TRes Function(Input$CommentThreadRequestInput) then,
  ) = _CopyWithImpl$Input$CommentThreadRequestInput;

  factory CopyWith$Input$CommentThreadRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommentThreadRequestInput;

  TRes call({String? commentId, bool? includeDeleted});
}

class _CopyWithImpl$Input$CommentThreadRequestInput<TRes>
    implements CopyWith$Input$CommentThreadRequestInput<TRes> {
  _CopyWithImpl$Input$CommentThreadRequestInput(this._instance, this._then);

  final Input$CommentThreadRequestInput _instance;

  final TRes Function(Input$CommentThreadRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? commentId = _undefined,
    Object? includeDeleted = _undefined,
  }) => _then(
    Input$CommentThreadRequestInput._({
      ..._instance._$data,
      if (commentId != _undefined && commentId != null)
        'commentId': (commentId as String),
      if (includeDeleted != _undefined && includeDeleted != null)
        'includeDeleted': (includeDeleted as bool),
    }),
  );
}

class _CopyWithStubImpl$Input$CommentThreadRequestInput<TRes>
    implements CopyWith$Input$CommentThreadRequestInput<TRes> {
  _CopyWithStubImpl$Input$CommentThreadRequestInput(this._res);

  TRes _res;

  call({String? commentId, bool? includeDeleted}) => _res;
}

class Input$CommentTypeOperationFilterInput {
  factory Input$CommentTypeOperationFilterInput({
    Enum$CommentType? eq,
    Enum$CommentType? neq,
    List<Enum$CommentType>? $in,
    List<Enum$CommentType>? nin,
  }) => Input$CommentTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$CommentTypeOperationFilterInput._(this._$data);

  factory Input$CommentTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$CommentType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$CommentType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CommentType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CommentType((e as String)))
          .toList();
    }
    return Input$CommentTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CommentType? get eq => (_$data['eq'] as Enum$CommentType?);

  Enum$CommentType? get neq => (_$data['neq'] as Enum$CommentType?);

  List<Enum$CommentType>? get $in => (_$data['in'] as List<Enum$CommentType>?);

  List<Enum$CommentType>? get nin => (_$data['nin'] as List<Enum$CommentType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$CommentType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$CommentType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$CommentType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$CommentType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$CommentTypeOperationFilterInput<
    Input$CommentTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$CommentTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommentTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommentTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$CommentTypeOperationFilterInput(
    Input$CommentTypeOperationFilterInput instance,
    TRes Function(Input$CommentTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$CommentTypeOperationFilterInput;

  factory CopyWith$Input$CommentTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommentTypeOperationFilterInput;

  TRes call({
    Enum$CommentType? eq,
    Enum$CommentType? neq,
    List<Enum$CommentType>? $in,
    List<Enum$CommentType>? nin,
  });
}

class _CopyWithImpl$Input$CommentTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CommentTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$CommentTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$CommentTypeOperationFilterInput _instance;

  final TRes Function(Input$CommentTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$CommentTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$CommentType?),
      if (neq != _undefined) 'neq': (neq as Enum$CommentType?),
      if ($in != _undefined) 'in': ($in as List<Enum$CommentType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$CommentType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$CommentTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CommentTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$CommentTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$CommentType? eq,
    Enum$CommentType? neq,
    List<Enum$CommentType>? $in,
    List<Enum$CommentType>? nin,
  }) => _res;
}

class Input$ContributingArtistFilterInput {
  factory Input$ContributingArtistFilterInput({
    List<Input$ContributingArtistFilterInput>? and,
    List<Input$ContributingArtistFilterInput>? or,
    Input$StringOperationFilterInput? artistId,
    Input$ArtistRoleOperationFilterInput? role,
  }) => Input$ContributingArtistFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (artistId != null) r'artistId': artistId,
    if (role != null) r'role': role,
  });

  Input$ContributingArtistFilterInput._(this._$data);

  factory Input$ContributingArtistFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$ContributingArtistFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$ContributingArtistFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('artistId')) {
      final l$artistId = data['artistId'];
      result$data['artistId'] = l$artistId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$artistId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$ArtistRoleOperationFilterInput.fromJson(
              (l$role as Map<String, dynamic>),
            );
    }
    return Input$ContributingArtistFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ContributingArtistFilterInput>? get and =>
      (_$data['and'] as List<Input$ContributingArtistFilterInput>?);

  List<Input$ContributingArtistFilterInput>? get or =>
      (_$data['or'] as List<Input$ContributingArtistFilterInput>?);

  Input$StringOperationFilterInput? get artistId =>
      (_$data['artistId'] as Input$StringOperationFilterInput?);

  Input$ArtistRoleOperationFilterInput? get role =>
      (_$data['role'] as Input$ArtistRoleOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('artistId')) {
      final l$artistId = artistId;
      result$data['artistId'] = l$artistId?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ContributingArtistFilterInput<
    Input$ContributingArtistFilterInput
  >
  get copyWith => CopyWith$Input$ContributingArtistFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ContributingArtistFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$artistId = artistId;
    final lOther$artistId = other.artistId;
    if (_$data.containsKey('artistId') !=
        other._$data.containsKey('artistId')) {
      return false;
    }
    if (l$artistId != lOther$artistId) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$artistId = artistId;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('artistId') ? l$artistId : const {},
      _$data.containsKey('role') ? l$role : const {},
    ]);
  }
}

abstract class CopyWith$Input$ContributingArtistFilterInput<TRes> {
  factory CopyWith$Input$ContributingArtistFilterInput(
    Input$ContributingArtistFilterInput instance,
    TRes Function(Input$ContributingArtistFilterInput) then,
  ) = _CopyWithImpl$Input$ContributingArtistFilterInput;

  factory CopyWith$Input$ContributingArtistFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContributingArtistFilterInput;

  TRes call({
    List<Input$ContributingArtistFilterInput>? and,
    List<Input$ContributingArtistFilterInput>? or,
    Input$StringOperationFilterInput? artistId,
    Input$ArtistRoleOperationFilterInput? role,
  });
  TRes and(
    Iterable<Input$ContributingArtistFilterInput>? Function(
      Iterable<
        CopyWith$Input$ContributingArtistFilterInput<
          Input$ContributingArtistFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$ContributingArtistFilterInput>? Function(
      Iterable<
        CopyWith$Input$ContributingArtistFilterInput<
          Input$ContributingArtistFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get artistId;
  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get role;
}

class _CopyWithImpl$Input$ContributingArtistFilterInput<TRes>
    implements CopyWith$Input$ContributingArtistFilterInput<TRes> {
  _CopyWithImpl$Input$ContributingArtistFilterInput(this._instance, this._then);

  final Input$ContributingArtistFilterInput _instance;

  final TRes Function(Input$ContributingArtistFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? artistId = _undefined,
    Object? role = _undefined,
  }) => _then(
    Input$ContributingArtistFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$ContributingArtistFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$ContributingArtistFilterInput>?),
      if (artistId != _undefined)
        'artistId': (artistId as Input$StringOperationFilterInput?),
      if (role != _undefined)
        'role': (role as Input$ArtistRoleOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$ContributingArtistFilterInput>? Function(
      Iterable<
        CopyWith$Input$ContributingArtistFilterInput<
          Input$ContributingArtistFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$ContributingArtistFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$ContributingArtistFilterInput>? Function(
      Iterable<
        CopyWith$Input$ContributingArtistFilterInput<
          Input$ContributingArtistFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$ContributingArtistFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get artistId {
    final local$artistId = _instance.artistId;
    return local$artistId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$artistId,
            (e) => call(artistId: e),
          );
  }

  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$ArtistRoleOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ArtistRoleOperationFilterInput(
            local$role,
            (e) => call(role: e),
          );
  }
}

class _CopyWithStubImpl$Input$ContributingArtistFilterInput<TRes>
    implements CopyWith$Input$ContributingArtistFilterInput<TRes> {
  _CopyWithStubImpl$Input$ContributingArtistFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ContributingArtistFilterInput>? and,
    List<Input$ContributingArtistFilterInput>? or,
    Input$StringOperationFilterInput? artistId,
    Input$ArtistRoleOperationFilterInput? role,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get artistId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get role =>
      CopyWith$Input$ArtistRoleOperationFilterInput.stub(_res);
}

class Input$ContributingArtistInput {
  factory Input$ContributingArtistInput({
    required String artistId,
    required Enum$ArtistRole role,
  }) => Input$ContributingArtistInput._({r'artistId': artistId, r'role': role});

  Input$ContributingArtistInput._(this._$data);

  factory Input$ContributingArtistInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$artistId = data['artistId'];
    result$data['artistId'] = (l$artistId as String);
    final l$role = data['role'];
    result$data['role'] = fromJson$Enum$ArtistRole((l$role as String));
    return Input$ContributingArtistInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get artistId => (_$data['artistId'] as String);

  Enum$ArtistRole get role => (_$data['role'] as Enum$ArtistRole);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$artistId = artistId;
    result$data['artistId'] = l$artistId;
    final l$role = role;
    result$data['role'] = toJson$Enum$ArtistRole(l$role);
    return result$data;
  }

  CopyWith$Input$ContributingArtistInput<Input$ContributingArtistInput>
  get copyWith => CopyWith$Input$ContributingArtistInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ContributingArtistInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$artistId = artistId;
    final lOther$artistId = other.artistId;
    if (l$artistId != lOther$artistId) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$artistId = artistId;
    final l$role = role;
    return Object.hashAll([l$artistId, l$role]);
  }
}

abstract class CopyWith$Input$ContributingArtistInput<TRes> {
  factory CopyWith$Input$ContributingArtistInput(
    Input$ContributingArtistInput instance,
    TRes Function(Input$ContributingArtistInput) then,
  ) = _CopyWithImpl$Input$ContributingArtistInput;

  factory CopyWith$Input$ContributingArtistInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ContributingArtistInput;

  TRes call({String? artistId, Enum$ArtistRole? role});
}

class _CopyWithImpl$Input$ContributingArtistInput<TRes>
    implements CopyWith$Input$ContributingArtistInput<TRes> {
  _CopyWithImpl$Input$ContributingArtistInput(this._instance, this._then);

  final Input$ContributingArtistInput _instance;

  final TRes Function(Input$ContributingArtistInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? artistId = _undefined, Object? role = _undefined}) =>
      _then(
        Input$ContributingArtistInput._({
          ..._instance._$data,
          if (artistId != _undefined && artistId != null)
            'artistId': (artistId as String),
          if (role != _undefined && role != null)
            'role': (role as Enum$ArtistRole),
        }),
      );
}

class _CopyWithStubImpl$Input$ContributingArtistInput<TRes>
    implements CopyWith$Input$ContributingArtistInput<TRes> {
  _CopyWithStubImpl$Input$ContributingArtistInput(this._res);

  TRes _res;

  call({String? artistId, Enum$ArtistRole? role}) => _res;
}

class Input$ConversationFilterInput {
  factory Input$ConversationFilterInput({
    List<Input$ConversationFilterInput>? and,
    List<Input$ConversationFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$ListStringOperationFilterInput? userIds,
    Input$StringOperationFilterInput? requestHubId,
    Input$ConversationStatusOperationFilterInput? status,
    Input$LastMessageFilterInput? lastMessage,
    Input$ListFilterInputTypeOfDeletedForEntryFilterInput? deletedFor,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$ConversationFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (userIds != null) r'userIds': userIds,
    if (requestHubId != null) r'requestHubId': requestHubId,
    if (status != null) r'status': status,
    if (lastMessage != null) r'lastMessage': lastMessage,
    if (deletedFor != null) r'deletedFor': deletedFor,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ConversationFilterInput._(this._$data);

  factory Input$ConversationFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$ConversationFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$ConversationFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('userIds')) {
      final l$userIds = data['userIds'];
      result$data['userIds'] = l$userIds == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$userIds as Map<String, dynamic>),
            );
    }
    if (data.containsKey('requestHubId')) {
      final l$requestHubId = data['requestHubId'];
      result$data['requestHubId'] = l$requestHubId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$requestHubId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$ConversationStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('lastMessage')) {
      final l$lastMessage = data['lastMessage'];
      result$data['lastMessage'] = l$lastMessage == null
          ? null
          : Input$LastMessageFilterInput.fromJson(
              (l$lastMessage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('deletedFor')) {
      final l$deletedFor = data['deletedFor'];
      result$data['deletedFor'] = l$deletedFor == null
          ? null
          : Input$ListFilterInputTypeOfDeletedForEntryFilterInput.fromJson(
              (l$deletedFor as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$ConversationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ConversationFilterInput>? get and =>
      (_$data['and'] as List<Input$ConversationFilterInput>?);

  List<Input$ConversationFilterInput>? get or =>
      (_$data['or'] as List<Input$ConversationFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$ListStringOperationFilterInput? get userIds =>
      (_$data['userIds'] as Input$ListStringOperationFilterInput?);

  Input$StringOperationFilterInput? get requestHubId =>
      (_$data['requestHubId'] as Input$StringOperationFilterInput?);

  Input$ConversationStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$ConversationStatusOperationFilterInput?);

  Input$LastMessageFilterInput? get lastMessage =>
      (_$data['lastMessage'] as Input$LastMessageFilterInput?);

  Input$ListFilterInputTypeOfDeletedForEntryFilterInput? get deletedFor =>
      (_$data['deletedFor']
          as Input$ListFilterInputTypeOfDeletedForEntryFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userIds')) {
      final l$userIds = userIds;
      result$data['userIds'] = l$userIds?.toJson();
    }
    if (_$data.containsKey('requestHubId')) {
      final l$requestHubId = requestHubId;
      result$data['requestHubId'] = l$requestHubId?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('lastMessage')) {
      final l$lastMessage = lastMessage;
      result$data['lastMessage'] = l$lastMessage?.toJson();
    }
    if (_$data.containsKey('deletedFor')) {
      final l$deletedFor = deletedFor;
      result$data['deletedFor'] = l$deletedFor?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ConversationFilterInput<Input$ConversationFilterInput>
  get copyWith => CopyWith$Input$ConversationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ConversationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userIds = userIds;
    final lOther$userIds = other.userIds;
    if (_$data.containsKey('userIds') != other._$data.containsKey('userIds')) {
      return false;
    }
    if (l$userIds != lOther$userIds) {
      return false;
    }
    final l$requestHubId = requestHubId;
    final lOther$requestHubId = other.requestHubId;
    if (_$data.containsKey('requestHubId') !=
        other._$data.containsKey('requestHubId')) {
      return false;
    }
    if (l$requestHubId != lOther$requestHubId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$lastMessage = lastMessage;
    final lOther$lastMessage = other.lastMessage;
    if (_$data.containsKey('lastMessage') !=
        other._$data.containsKey('lastMessage')) {
      return false;
    }
    if (l$lastMessage != lOther$lastMessage) {
      return false;
    }
    final l$deletedFor = deletedFor;
    final lOther$deletedFor = other.deletedFor;
    if (_$data.containsKey('deletedFor') !=
        other._$data.containsKey('deletedFor')) {
      return false;
    }
    if (l$deletedFor != lOther$deletedFor) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$userIds = userIds;
    final l$requestHubId = requestHubId;
    final l$status = status;
    final l$lastMessage = lastMessage;
    final l$deletedFor = deletedFor;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userIds') ? l$userIds : const {},
      _$data.containsKey('requestHubId') ? l$requestHubId : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('lastMessage') ? l$lastMessage : const {},
      _$data.containsKey('deletedFor') ? l$deletedFor : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConversationFilterInput<TRes> {
  factory CopyWith$Input$ConversationFilterInput(
    Input$ConversationFilterInput instance,
    TRes Function(Input$ConversationFilterInput) then,
  ) = _CopyWithImpl$Input$ConversationFilterInput;

  factory CopyWith$Input$ConversationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConversationFilterInput;

  TRes call({
    List<Input$ConversationFilterInput>? and,
    List<Input$ConversationFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$ListStringOperationFilterInput? userIds,
    Input$StringOperationFilterInput? requestHubId,
    Input$ConversationStatusOperationFilterInput? status,
    Input$LastMessageFilterInput? lastMessage,
    Input$ListFilterInputTypeOfDeletedForEntryFilterInput? deletedFor,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$ConversationFilterInput>? Function(
      Iterable<
        CopyWith$Input$ConversationFilterInput<Input$ConversationFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$ConversationFilterInput>? Function(
      Iterable<
        CopyWith$Input$ConversationFilterInput<Input$ConversationFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get userIds;
  CopyWith$Input$StringOperationFilterInput<TRes> get requestHubId;
  CopyWith$Input$ConversationStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$LastMessageFilterInput<TRes> get lastMessage;
  CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput<TRes>
  get deletedFor;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$ConversationFilterInput<TRes>
    implements CopyWith$Input$ConversationFilterInput<TRes> {
  _CopyWithImpl$Input$ConversationFilterInput(this._instance, this._then);

  final Input$ConversationFilterInput _instance;

  final TRes Function(Input$ConversationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? userIds = _undefined,
    Object? requestHubId = _undefined,
    Object? status = _undefined,
    Object? lastMessage = _undefined,
    Object? deletedFor = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ConversationFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$ConversationFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$ConversationFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (userIds != _undefined)
        'userIds': (userIds as Input$ListStringOperationFilterInput?),
      if (requestHubId != _undefined)
        'requestHubId': (requestHubId as Input$StringOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$ConversationStatusOperationFilterInput?),
      if (lastMessage != _undefined)
        'lastMessage': (lastMessage as Input$LastMessageFilterInput?),
      if (deletedFor != _undefined)
        'deletedFor':
            (deletedFor
                as Input$ListFilterInputTypeOfDeletedForEntryFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$ConversationFilterInput>? Function(
      Iterable<
        CopyWith$Input$ConversationFilterInput<Input$ConversationFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$ConversationFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$ConversationFilterInput>? Function(
      Iterable<
        CopyWith$Input$ConversationFilterInput<Input$ConversationFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$ConversationFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get userIds {
    final local$userIds = _instance.userIds;
    return local$userIds == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$userIds,
            (e) => call(userIds: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get requestHubId {
    final local$requestHubId = _instance.requestHubId;
    return local$requestHubId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$requestHubId,
            (e) => call(requestHubId: e),
          );
  }

  CopyWith$Input$ConversationStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$ConversationStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ConversationStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$LastMessageFilterInput<TRes> get lastMessage {
    final local$lastMessage = _instance.lastMessage;
    return local$lastMessage == null
        ? CopyWith$Input$LastMessageFilterInput.stub(_then(_instance))
        : CopyWith$Input$LastMessageFilterInput(
            local$lastMessage,
            (e) => call(lastMessage: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput<TRes>
  get deletedFor {
    final local$deletedFor = _instance.deletedFor;
    return local$deletedFor == null
        ? CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput(
            local$deletedFor,
            (e) => call(deletedFor: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$ConversationFilterInput<TRes>
    implements CopyWith$Input$ConversationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ConversationFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ConversationFilterInput>? and,
    List<Input$ConversationFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$ListStringOperationFilterInput? userIds,
    Input$StringOperationFilterInput? requestHubId,
    Input$ConversationStatusOperationFilterInput? status,
    Input$LastMessageFilterInput? lastMessage,
    Input$ListFilterInputTypeOfDeletedForEntryFilterInput? deletedFor,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get userIds =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get requestHubId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ConversationStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$ConversationStatusOperationFilterInput.stub(_res);

  CopyWith$Input$LastMessageFilterInput<TRes> get lastMessage =>
      CopyWith$Input$LastMessageFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput<TRes>
  get deletedFor =>
      CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$ConversationSortInput {
  factory Input$ConversationSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? requestHubId,
    Enum$SortEnumType? status,
    Input$LastMessageSortInput? lastMessage,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$ConversationSortInput._({
    if (id != null) r'id': id,
    if (requestHubId != null) r'requestHubId': requestHubId,
    if (status != null) r'status': status,
    if (lastMessage != null) r'lastMessage': lastMessage,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ConversationSortInput._(this._$data);

  factory Input$ConversationSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('requestHubId')) {
      final l$requestHubId = data['requestHubId'];
      result$data['requestHubId'] = l$requestHubId == null
          ? null
          : fromJson$Enum$SortEnumType((l$requestHubId as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('lastMessage')) {
      final l$lastMessage = data['lastMessage'];
      result$data['lastMessage'] = l$lastMessage == null
          ? null
          : Input$LastMessageSortInput.fromJson(
              (l$lastMessage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$ConversationSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get requestHubId =>
      (_$data['requestHubId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Input$LastMessageSortInput? get lastMessage =>
      (_$data['lastMessage'] as Input$LastMessageSortInput?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('requestHubId')) {
      final l$requestHubId = requestHubId;
      result$data['requestHubId'] = l$requestHubId == null
          ? null
          : toJson$Enum$SortEnumType(l$requestHubId);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('lastMessage')) {
      final l$lastMessage = lastMessage;
      result$data['lastMessage'] = l$lastMessage?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$ConversationSortInput<Input$ConversationSortInput>
  get copyWith => CopyWith$Input$ConversationSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ConversationSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$requestHubId = requestHubId;
    final lOther$requestHubId = other.requestHubId;
    if (_$data.containsKey('requestHubId') !=
        other._$data.containsKey('requestHubId')) {
      return false;
    }
    if (l$requestHubId != lOther$requestHubId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$lastMessage = lastMessage;
    final lOther$lastMessage = other.lastMessage;
    if (_$data.containsKey('lastMessage') !=
        other._$data.containsKey('lastMessage')) {
      return false;
    }
    if (l$lastMessage != lOther$lastMessage) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$requestHubId = requestHubId;
    final l$status = status;
    final l$lastMessage = lastMessage;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('requestHubId') ? l$requestHubId : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('lastMessage') ? l$lastMessage : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConversationSortInput<TRes> {
  factory CopyWith$Input$ConversationSortInput(
    Input$ConversationSortInput instance,
    TRes Function(Input$ConversationSortInput) then,
  ) = _CopyWithImpl$Input$ConversationSortInput;

  factory CopyWith$Input$ConversationSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConversationSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? requestHubId,
    Enum$SortEnumType? status,
    Input$LastMessageSortInput? lastMessage,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
  CopyWith$Input$LastMessageSortInput<TRes> get lastMessage;
}

class _CopyWithImpl$Input$ConversationSortInput<TRes>
    implements CopyWith$Input$ConversationSortInput<TRes> {
  _CopyWithImpl$Input$ConversationSortInput(this._instance, this._then);

  final Input$ConversationSortInput _instance;

  final TRes Function(Input$ConversationSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? requestHubId = _undefined,
    Object? status = _undefined,
    Object? lastMessage = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ConversationSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (requestHubId != _undefined)
        'requestHubId': (requestHubId as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (lastMessage != _undefined)
        'lastMessage': (lastMessage as Input$LastMessageSortInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );

  CopyWith$Input$LastMessageSortInput<TRes> get lastMessage {
    final local$lastMessage = _instance.lastMessage;
    return local$lastMessage == null
        ? CopyWith$Input$LastMessageSortInput.stub(_then(_instance))
        : CopyWith$Input$LastMessageSortInput(
            local$lastMessage,
            (e) => call(lastMessage: e),
          );
  }
}

class _CopyWithStubImpl$Input$ConversationSortInput<TRes>
    implements CopyWith$Input$ConversationSortInput<TRes> {
  _CopyWithStubImpl$Input$ConversationSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? requestHubId,
    Enum$SortEnumType? status,
    Input$LastMessageSortInput? lastMessage,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;

  CopyWith$Input$LastMessageSortInput<TRes> get lastMessage =>
      CopyWith$Input$LastMessageSortInput.stub(_res);
}

class Input$ConversationStatusOperationFilterInput {
  factory Input$ConversationStatusOperationFilterInput({
    Enum$ConversationStatus? eq,
    Enum$ConversationStatus? neq,
    List<Enum$ConversationStatus>? $in,
    List<Enum$ConversationStatus>? nin,
  }) => Input$ConversationStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$ConversationStatusOperationFilterInput._(this._$data);

  factory Input$ConversationStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$ConversationStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$ConversationStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ConversationStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ConversationStatus((e as String)))
          .toList();
    }
    return Input$ConversationStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ConversationStatus? get eq => (_$data['eq'] as Enum$ConversationStatus?);

  Enum$ConversationStatus? get neq =>
      (_$data['neq'] as Enum$ConversationStatus?);

  List<Enum$ConversationStatus>? get $in =>
      (_$data['in'] as List<Enum$ConversationStatus>?);

  List<Enum$ConversationStatus>? get nin =>
      (_$data['nin'] as List<Enum$ConversationStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$ConversationStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$ConversationStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$ConversationStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$ConversationStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$ConversationStatusOperationFilterInput<
    Input$ConversationStatusOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$ConversationStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ConversationStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConversationStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$ConversationStatusOperationFilterInput(
    Input$ConversationStatusOperationFilterInput instance,
    TRes Function(Input$ConversationStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ConversationStatusOperationFilterInput;

  factory CopyWith$Input$ConversationStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConversationStatusOperationFilterInput;

  TRes call({
    Enum$ConversationStatus? eq,
    Enum$ConversationStatus? neq,
    List<Enum$ConversationStatus>? $in,
    List<Enum$ConversationStatus>? nin,
  });
}

class _CopyWithImpl$Input$ConversationStatusOperationFilterInput<TRes>
    implements CopyWith$Input$ConversationStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ConversationStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ConversationStatusOperationFilterInput _instance;

  final TRes Function(Input$ConversationStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$ConversationStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$ConversationStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$ConversationStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$ConversationStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$ConversationStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$ConversationStatusOperationFilterInput<TRes>
    implements CopyWith$Input$ConversationStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ConversationStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$ConversationStatus? eq,
    Enum$ConversationStatus? neq,
    List<Enum$ConversationStatus>? $in,
    List<Enum$ConversationStatus>? nin,
  }) => _res;
}

class Input$CouponDurationTypeOperationFilterInput {
  factory Input$CouponDurationTypeOperationFilterInput({
    Enum$CouponDurationType? eq,
    Enum$CouponDurationType? neq,
    List<Enum$CouponDurationType>? $in,
    List<Enum$CouponDurationType>? nin,
  }) => Input$CouponDurationTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$CouponDurationTypeOperationFilterInput._(this._$data);

  factory Input$CouponDurationTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$CouponDurationType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$CouponDurationType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CouponDurationType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CouponDurationType((e as String)))
          .toList();
    }
    return Input$CouponDurationTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CouponDurationType? get eq => (_$data['eq'] as Enum$CouponDurationType?);

  Enum$CouponDurationType? get neq =>
      (_$data['neq'] as Enum$CouponDurationType?);

  List<Enum$CouponDurationType>? get $in =>
      (_$data['in'] as List<Enum$CouponDurationType>?);

  List<Enum$CouponDurationType>? get nin =>
      (_$data['nin'] as List<Enum$CouponDurationType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$CouponDurationType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$CouponDurationType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$CouponDurationType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$CouponDurationType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$CouponDurationTypeOperationFilterInput<
    Input$CouponDurationTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$CouponDurationTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CouponDurationTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CouponDurationTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$CouponDurationTypeOperationFilterInput(
    Input$CouponDurationTypeOperationFilterInput instance,
    TRes Function(Input$CouponDurationTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$CouponDurationTypeOperationFilterInput;

  factory CopyWith$Input$CouponDurationTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CouponDurationTypeOperationFilterInput;

  TRes call({
    Enum$CouponDurationType? eq,
    Enum$CouponDurationType? neq,
    List<Enum$CouponDurationType>? $in,
    List<Enum$CouponDurationType>? nin,
  });
}

class _CopyWithImpl$Input$CouponDurationTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CouponDurationTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$CouponDurationTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$CouponDurationTypeOperationFilterInput _instance;

  final TRes Function(Input$CouponDurationTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$CouponDurationTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$CouponDurationType?),
      if (neq != _undefined) 'neq': (neq as Enum$CouponDurationType?),
      if ($in != _undefined) 'in': ($in as List<Enum$CouponDurationType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$CouponDurationType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$CouponDurationTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CouponDurationTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$CouponDurationTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$CouponDurationType? eq,
    Enum$CouponDurationType? neq,
    List<Enum$CouponDurationType>? $in,
    List<Enum$CouponDurationType>? nin,
  }) => _res;
}

class Input$CouponFilterInput {
  factory Input$CouponFilterInput({
    List<Input$CouponFilterInput>? and,
    List<Input$CouponFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? stripeCouponId,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? code,
    Input$DecimalOperationFilterInput? percentOff,
    Input$CouponDurationTypeOperationFilterInput? duration,
    Input$CouponPurposeTypeOperationFilterInput? purpose,
    Input$CouponStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$CouponFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (stripeCouponId != null) r'stripeCouponId': stripeCouponId,
    if (name != null) r'name': name,
    if (description != null) r'description': description,
    if (code != null) r'code': code,
    if (percentOff != null) r'percentOff': percentOff,
    if (duration != null) r'duration': duration,
    if (purpose != null) r'purpose': purpose,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$CouponFilterInput._(this._$data);

  factory Input$CouponFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$CouponFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$CouponFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeCouponId')) {
      final l$stripeCouponId = data['stripeCouponId'];
      result$data['stripeCouponId'] = l$stripeCouponId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeCouponId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('code')) {
      final l$code = data['code'];
      result$data['code'] = l$code == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$code as Map<String, dynamic>),
            );
    }
    if (data.containsKey('percentOff')) {
      final l$percentOff = data['percentOff'];
      result$data['percentOff'] = l$percentOff == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$percentOff as Map<String, dynamic>),
            );
    }
    if (data.containsKey('duration')) {
      final l$duration = data['duration'];
      result$data['duration'] = l$duration == null
          ? null
          : Input$CouponDurationTypeOperationFilterInput.fromJson(
              (l$duration as Map<String, dynamic>),
            );
    }
    if (data.containsKey('purpose')) {
      final l$purpose = data['purpose'];
      result$data['purpose'] = l$purpose == null
          ? null
          : Input$CouponPurposeTypeOperationFilterInput.fromJson(
              (l$purpose as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$CouponStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$CouponFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CouponFilterInput>? get and =>
      (_$data['and'] as List<Input$CouponFilterInput>?);

  List<Input$CouponFilterInput>? get or =>
      (_$data['or'] as List<Input$CouponFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeCouponId =>
      (_$data['stripeCouponId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get code =>
      (_$data['code'] as Input$StringOperationFilterInput?);

  Input$DecimalOperationFilterInput? get percentOff =>
      (_$data['percentOff'] as Input$DecimalOperationFilterInput?);

  Input$CouponDurationTypeOperationFilterInput? get duration =>
      (_$data['duration'] as Input$CouponDurationTypeOperationFilterInput?);

  Input$CouponPurposeTypeOperationFilterInput? get purpose =>
      (_$data['purpose'] as Input$CouponPurposeTypeOperationFilterInput?);

  Input$CouponStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$CouponStatusOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('stripeCouponId')) {
      final l$stripeCouponId = stripeCouponId;
      result$data['stripeCouponId'] = l$stripeCouponId?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('code')) {
      final l$code = code;
      result$data['code'] = l$code?.toJson();
    }
    if (_$data.containsKey('percentOff')) {
      final l$percentOff = percentOff;
      result$data['percentOff'] = l$percentOff?.toJson();
    }
    if (_$data.containsKey('duration')) {
      final l$duration = duration;
      result$data['duration'] = l$duration?.toJson();
    }
    if (_$data.containsKey('purpose')) {
      final l$purpose = purpose;
      result$data['purpose'] = l$purpose?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CouponFilterInput<Input$CouponFilterInput> get copyWith =>
      CopyWith$Input$CouponFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CouponFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$stripeCouponId = stripeCouponId;
    final lOther$stripeCouponId = other.stripeCouponId;
    if (_$data.containsKey('stripeCouponId') !=
        other._$data.containsKey('stripeCouponId')) {
      return false;
    }
    if (l$stripeCouponId != lOther$stripeCouponId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (_$data.containsKey('code') != other._$data.containsKey('code')) {
      return false;
    }
    if (l$code != lOther$code) {
      return false;
    }
    final l$percentOff = percentOff;
    final lOther$percentOff = other.percentOff;
    if (_$data.containsKey('percentOff') !=
        other._$data.containsKey('percentOff')) {
      return false;
    }
    if (l$percentOff != lOther$percentOff) {
      return false;
    }
    final l$duration = duration;
    final lOther$duration = other.duration;
    if (_$data.containsKey('duration') !=
        other._$data.containsKey('duration')) {
      return false;
    }
    if (l$duration != lOther$duration) {
      return false;
    }
    final l$purpose = purpose;
    final lOther$purpose = other.purpose;
    if (_$data.containsKey('purpose') != other._$data.containsKey('purpose')) {
      return false;
    }
    if (l$purpose != lOther$purpose) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$stripeCouponId = stripeCouponId;
    final l$name = name;
    final l$description = description;
    final l$code = code;
    final l$percentOff = percentOff;
    final l$duration = duration;
    final l$purpose = purpose;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('stripeCouponId') ? l$stripeCouponId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('code') ? l$code : const {},
      _$data.containsKey('percentOff') ? l$percentOff : const {},
      _$data.containsKey('duration') ? l$duration : const {},
      _$data.containsKey('purpose') ? l$purpose : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$CouponFilterInput<TRes> {
  factory CopyWith$Input$CouponFilterInput(
    Input$CouponFilterInput instance,
    TRes Function(Input$CouponFilterInput) then,
  ) = _CopyWithImpl$Input$CouponFilterInput;

  factory CopyWith$Input$CouponFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CouponFilterInput;

  TRes call({
    List<Input$CouponFilterInput>? and,
    List<Input$CouponFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? stripeCouponId,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? code,
    Input$DecimalOperationFilterInput? percentOff,
    Input$CouponDurationTypeOperationFilterInput? duration,
    Input$CouponPurposeTypeOperationFilterInput? purpose,
    Input$CouponStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$CouponFilterInput>? Function(
      Iterable<CopyWith$Input$CouponFilterInput<Input$CouponFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$CouponFilterInput>? Function(
      Iterable<CopyWith$Input$CouponFilterInput<Input$CouponFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeCouponId;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$StringOperationFilterInput<TRes> get code;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentOff;
  CopyWith$Input$CouponDurationTypeOperationFilterInput<TRes> get duration;
  CopyWith$Input$CouponPurposeTypeOperationFilterInput<TRes> get purpose;
  CopyWith$Input$CouponStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$CouponFilterInput<TRes>
    implements CopyWith$Input$CouponFilterInput<TRes> {
  _CopyWithImpl$Input$CouponFilterInput(this._instance, this._then);

  final Input$CouponFilterInput _instance;

  final TRes Function(Input$CouponFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? stripeCouponId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? code = _undefined,
    Object? percentOff = _undefined,
    Object? duration = _undefined,
    Object? purpose = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$CouponFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$CouponFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$CouponFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (stripeCouponId != _undefined)
        'stripeCouponId': (stripeCouponId as Input$StringOperationFilterInput?),
      if (name != _undefined)
        'name': (name as Input$StringOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (code != _undefined)
        'code': (code as Input$StringOperationFilterInput?),
      if (percentOff != _undefined)
        'percentOff': (percentOff as Input$DecimalOperationFilterInput?),
      if (duration != _undefined)
        'duration': (duration as Input$CouponDurationTypeOperationFilterInput?),
      if (purpose != _undefined)
        'purpose': (purpose as Input$CouponPurposeTypeOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$CouponStatusOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$CouponFilterInput>? Function(
      Iterable<CopyWith$Input$CouponFilterInput<Input$CouponFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$CouponFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$CouponFilterInput>? Function(
      Iterable<CopyWith$Input$CouponFilterInput<Input$CouponFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$CouponFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeCouponId {
    final local$stripeCouponId = _instance.stripeCouponId;
    return local$stripeCouponId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeCouponId,
            (e) => call(stripeCouponId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name,
            (e) => call(name: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get code {
    final local$code = _instance.code;
    return local$code == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$code,
            (e) => call(code: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentOff {
    final local$percentOff = _instance.percentOff;
    return local$percentOff == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$percentOff,
            (e) => call(percentOff: e),
          );
  }

  CopyWith$Input$CouponDurationTypeOperationFilterInput<TRes> get duration {
    final local$duration = _instance.duration;
    return local$duration == null
        ? CopyWith$Input$CouponDurationTypeOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$CouponDurationTypeOperationFilterInput(
            local$duration,
            (e) => call(duration: e),
          );
  }

  CopyWith$Input$CouponPurposeTypeOperationFilterInput<TRes> get purpose {
    final local$purpose = _instance.purpose;
    return local$purpose == null
        ? CopyWith$Input$CouponPurposeTypeOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$CouponPurposeTypeOperationFilterInput(
            local$purpose,
            (e) => call(purpose: e),
          );
  }

  CopyWith$Input$CouponStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$CouponStatusOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CouponStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$CouponFilterInput<TRes>
    implements CopyWith$Input$CouponFilterInput<TRes> {
  _CopyWithStubImpl$Input$CouponFilterInput(this._res);

  TRes _res;

  call({
    List<Input$CouponFilterInput>? and,
    List<Input$CouponFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? stripeCouponId,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? code,
    Input$DecimalOperationFilterInput? percentOff,
    Input$CouponDurationTypeOperationFilterInput? duration,
    Input$CouponPurposeTypeOperationFilterInput? purpose,
    Input$CouponStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeCouponId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get code =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentOff =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$CouponDurationTypeOperationFilterInput<TRes> get duration =>
      CopyWith$Input$CouponDurationTypeOperationFilterInput.stub(_res);

  CopyWith$Input$CouponPurposeTypeOperationFilterInput<TRes> get purpose =>
      CopyWith$Input$CouponPurposeTypeOperationFilterInput.stub(_res);

  CopyWith$Input$CouponStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$CouponStatusOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$CouponPurposeTypeOperationFilterInput {
  factory Input$CouponPurposeTypeOperationFilterInput({
    Enum$CouponPurposeType? eq,
    Enum$CouponPurposeType? neq,
    List<Enum$CouponPurposeType>? $in,
    List<Enum$CouponPurposeType>? nin,
  }) => Input$CouponPurposeTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$CouponPurposeTypeOperationFilterInput._(this._$data);

  factory Input$CouponPurposeTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$CouponPurposeType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$CouponPurposeType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CouponPurposeType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CouponPurposeType((e as String)))
          .toList();
    }
    return Input$CouponPurposeTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CouponPurposeType? get eq => (_$data['eq'] as Enum$CouponPurposeType?);

  Enum$CouponPurposeType? get neq => (_$data['neq'] as Enum$CouponPurposeType?);

  List<Enum$CouponPurposeType>? get $in =>
      (_$data['in'] as List<Enum$CouponPurposeType>?);

  List<Enum$CouponPurposeType>? get nin =>
      (_$data['nin'] as List<Enum$CouponPurposeType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$CouponPurposeType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$CouponPurposeType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$CouponPurposeType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$CouponPurposeType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$CouponPurposeTypeOperationFilterInput<
    Input$CouponPurposeTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$CouponPurposeTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CouponPurposeTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CouponPurposeTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$CouponPurposeTypeOperationFilterInput(
    Input$CouponPurposeTypeOperationFilterInput instance,
    TRes Function(Input$CouponPurposeTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$CouponPurposeTypeOperationFilterInput;

  factory CopyWith$Input$CouponPurposeTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CouponPurposeTypeOperationFilterInput;

  TRes call({
    Enum$CouponPurposeType? eq,
    Enum$CouponPurposeType? neq,
    List<Enum$CouponPurposeType>? $in,
    List<Enum$CouponPurposeType>? nin,
  });
}

class _CopyWithImpl$Input$CouponPurposeTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CouponPurposeTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$CouponPurposeTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$CouponPurposeTypeOperationFilterInput _instance;

  final TRes Function(Input$CouponPurposeTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$CouponPurposeTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$CouponPurposeType?),
      if (neq != _undefined) 'neq': (neq as Enum$CouponPurposeType?),
      if ($in != _undefined) 'in': ($in as List<Enum$CouponPurposeType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$CouponPurposeType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$CouponPurposeTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CouponPurposeTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$CouponPurposeTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$CouponPurposeType? eq,
    Enum$CouponPurposeType? neq,
    List<Enum$CouponPurposeType>? $in,
    List<Enum$CouponPurposeType>? nin,
  }) => _res;
}

class Input$CouponSortInput {
  factory Input$CouponSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? stripeCouponId,
    Enum$SortEnumType? name,
    Enum$SortEnumType? description,
    Enum$SortEnumType? code,
    Enum$SortEnumType? percentOff,
    Enum$SortEnumType? duration,
    Enum$SortEnumType? purpose,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$CouponSortInput._({
    if (id != null) r'id': id,
    if (stripeCouponId != null) r'stripeCouponId': stripeCouponId,
    if (name != null) r'name': name,
    if (description != null) r'description': description,
    if (code != null) r'code': code,
    if (percentOff != null) r'percentOff': percentOff,
    if (duration != null) r'duration': duration,
    if (purpose != null) r'purpose': purpose,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$CouponSortInput._(this._$data);

  factory Input$CouponSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('stripeCouponId')) {
      final l$stripeCouponId = data['stripeCouponId'];
      result$data['stripeCouponId'] = l$stripeCouponId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeCouponId as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('code')) {
      final l$code = data['code'];
      result$data['code'] = l$code == null
          ? null
          : fromJson$Enum$SortEnumType((l$code as String));
    }
    if (data.containsKey('percentOff')) {
      final l$percentOff = data['percentOff'];
      result$data['percentOff'] = l$percentOff == null
          ? null
          : fromJson$Enum$SortEnumType((l$percentOff as String));
    }
    if (data.containsKey('duration')) {
      final l$duration = data['duration'];
      result$data['duration'] = l$duration == null
          ? null
          : fromJson$Enum$SortEnumType((l$duration as String));
    }
    if (data.containsKey('purpose')) {
      final l$purpose = data['purpose'];
      result$data['purpose'] = l$purpose == null
          ? null
          : fromJson$Enum$SortEnumType((l$purpose as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$CouponSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeCouponId =>
      (_$data['stripeCouponId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get code => (_$data['code'] as Enum$SortEnumType?);

  Enum$SortEnumType? get percentOff =>
      (_$data['percentOff'] as Enum$SortEnumType?);

  Enum$SortEnumType? get duration => (_$data['duration'] as Enum$SortEnumType?);

  Enum$SortEnumType? get purpose => (_$data['purpose'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('stripeCouponId')) {
      final l$stripeCouponId = stripeCouponId;
      result$data['stripeCouponId'] = l$stripeCouponId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeCouponId);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null
          ? null
          : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('code')) {
      final l$code = code;
      result$data['code'] = l$code == null
          ? null
          : toJson$Enum$SortEnumType(l$code);
    }
    if (_$data.containsKey('percentOff')) {
      final l$percentOff = percentOff;
      result$data['percentOff'] = l$percentOff == null
          ? null
          : toJson$Enum$SortEnumType(l$percentOff);
    }
    if (_$data.containsKey('duration')) {
      final l$duration = duration;
      result$data['duration'] = l$duration == null
          ? null
          : toJson$Enum$SortEnumType(l$duration);
    }
    if (_$data.containsKey('purpose')) {
      final l$purpose = purpose;
      result$data['purpose'] = l$purpose == null
          ? null
          : toJson$Enum$SortEnumType(l$purpose);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$CouponSortInput<Input$CouponSortInput> get copyWith =>
      CopyWith$Input$CouponSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CouponSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$stripeCouponId = stripeCouponId;
    final lOther$stripeCouponId = other.stripeCouponId;
    if (_$data.containsKey('stripeCouponId') !=
        other._$data.containsKey('stripeCouponId')) {
      return false;
    }
    if (l$stripeCouponId != lOther$stripeCouponId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (_$data.containsKey('code') != other._$data.containsKey('code')) {
      return false;
    }
    if (l$code != lOther$code) {
      return false;
    }
    final l$percentOff = percentOff;
    final lOther$percentOff = other.percentOff;
    if (_$data.containsKey('percentOff') !=
        other._$data.containsKey('percentOff')) {
      return false;
    }
    if (l$percentOff != lOther$percentOff) {
      return false;
    }
    final l$duration = duration;
    final lOther$duration = other.duration;
    if (_$data.containsKey('duration') !=
        other._$data.containsKey('duration')) {
      return false;
    }
    if (l$duration != lOther$duration) {
      return false;
    }
    final l$purpose = purpose;
    final lOther$purpose = other.purpose;
    if (_$data.containsKey('purpose') != other._$data.containsKey('purpose')) {
      return false;
    }
    if (l$purpose != lOther$purpose) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$stripeCouponId = stripeCouponId;
    final l$name = name;
    final l$description = description;
    final l$code = code;
    final l$percentOff = percentOff;
    final l$duration = duration;
    final l$purpose = purpose;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('stripeCouponId') ? l$stripeCouponId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('code') ? l$code : const {},
      _$data.containsKey('percentOff') ? l$percentOff : const {},
      _$data.containsKey('duration') ? l$duration : const {},
      _$data.containsKey('purpose') ? l$purpose : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$CouponSortInput<TRes> {
  factory CopyWith$Input$CouponSortInput(
    Input$CouponSortInput instance,
    TRes Function(Input$CouponSortInput) then,
  ) = _CopyWithImpl$Input$CouponSortInput;

  factory CopyWith$Input$CouponSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CouponSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? stripeCouponId,
    Enum$SortEnumType? name,
    Enum$SortEnumType? description,
    Enum$SortEnumType? code,
    Enum$SortEnumType? percentOff,
    Enum$SortEnumType? duration,
    Enum$SortEnumType? purpose,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$CouponSortInput<TRes>
    implements CopyWith$Input$CouponSortInput<TRes> {
  _CopyWithImpl$Input$CouponSortInput(this._instance, this._then);

  final Input$CouponSortInput _instance;

  final TRes Function(Input$CouponSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? stripeCouponId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? code = _undefined,
    Object? percentOff = _undefined,
    Object? duration = _undefined,
    Object? purpose = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$CouponSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (stripeCouponId != _undefined)
        'stripeCouponId': (stripeCouponId as Enum$SortEnumType?),
      if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (code != _undefined) 'code': (code as Enum$SortEnumType?),
      if (percentOff != _undefined)
        'percentOff': (percentOff as Enum$SortEnumType?),
      if (duration != _undefined) 'duration': (duration as Enum$SortEnumType?),
      if (purpose != _undefined) 'purpose': (purpose as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$CouponSortInput<TRes>
    implements CopyWith$Input$CouponSortInput<TRes> {
  _CopyWithStubImpl$Input$CouponSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? stripeCouponId,
    Enum$SortEnumType? name,
    Enum$SortEnumType? description,
    Enum$SortEnumType? code,
    Enum$SortEnumType? percentOff,
    Enum$SortEnumType? duration,
    Enum$SortEnumType? purpose,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$CouponStatusOperationFilterInput {
  factory Input$CouponStatusOperationFilterInput({
    Enum$CouponStatus? eq,
    Enum$CouponStatus? neq,
    List<Enum$CouponStatus>? $in,
    List<Enum$CouponStatus>? nin,
  }) => Input$CouponStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$CouponStatusOperationFilterInput._(this._$data);

  factory Input$CouponStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$CouponStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$CouponStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CouponStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CouponStatus((e as String)))
          .toList();
    }
    return Input$CouponStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CouponStatus? get eq => (_$data['eq'] as Enum$CouponStatus?);

  Enum$CouponStatus? get neq => (_$data['neq'] as Enum$CouponStatus?);

  List<Enum$CouponStatus>? get $in =>
      (_$data['in'] as List<Enum$CouponStatus>?);

  List<Enum$CouponStatus>? get nin =>
      (_$data['nin'] as List<Enum$CouponStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$CouponStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$CouponStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$CouponStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$CouponStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$CouponStatusOperationFilterInput<
    Input$CouponStatusOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$CouponStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CouponStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CouponStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$CouponStatusOperationFilterInput(
    Input$CouponStatusOperationFilterInput instance,
    TRes Function(Input$CouponStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$CouponStatusOperationFilterInput;

  factory CopyWith$Input$CouponStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CouponStatusOperationFilterInput;

  TRes call({
    Enum$CouponStatus? eq,
    Enum$CouponStatus? neq,
    List<Enum$CouponStatus>? $in,
    List<Enum$CouponStatus>? nin,
  });
}

class _CopyWithImpl$Input$CouponStatusOperationFilterInput<TRes>
    implements CopyWith$Input$CouponStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$CouponStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$CouponStatusOperationFilterInput _instance;

  final TRes Function(Input$CouponStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$CouponStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$CouponStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$CouponStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$CouponStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$CouponStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$CouponStatusOperationFilterInput<TRes>
    implements CopyWith$Input$CouponStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$CouponStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$CouponStatus? eq,
    Enum$CouponStatus? neq,
    List<Enum$CouponStatus>? $in,
    List<Enum$CouponStatus>? nin,
  }) => _res;
}

class Input$CreateAdminRequestInput {
  factory Input$CreateAdminRequestInput({
    required String fullName,
    required String email,
    required String password,
  }) => Input$CreateAdminRequestInput._({
    r'fullName': fullName,
    r'email': email,
    r'password': password,
  });

  Input$CreateAdminRequestInput._(this._$data);

  factory Input$CreateAdminRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$fullName = data['fullName'];
    result$data['fullName'] = (l$fullName as String);
    final l$email = data['email'];
    result$data['email'] = (l$email as String);
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    return Input$CreateAdminRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get fullName => (_$data['fullName'] as String);

  String get email => (_$data['email'] as String);

  String get password => (_$data['password'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$fullName = fullName;
    result$data['fullName'] = l$fullName;
    final l$email = email;
    result$data['email'] = l$email;
    final l$password = password;
    result$data['password'] = l$password;
    return result$data;
  }

  CopyWith$Input$CreateAdminRequestInput<Input$CreateAdminRequestInput>
  get copyWith => CopyWith$Input$CreateAdminRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateAdminRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    return Object.hashAll([l$fullName, l$email, l$password]);
  }
}

abstract class CopyWith$Input$CreateAdminRequestInput<TRes> {
  factory CopyWith$Input$CreateAdminRequestInput(
    Input$CreateAdminRequestInput instance,
    TRes Function(Input$CreateAdminRequestInput) then,
  ) = _CopyWithImpl$Input$CreateAdminRequestInput;

  factory CopyWith$Input$CreateAdminRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateAdminRequestInput;

  TRes call({String? fullName, String? email, String? password});
}

class _CopyWithImpl$Input$CreateAdminRequestInput<TRes>
    implements CopyWith$Input$CreateAdminRequestInput<TRes> {
  _CopyWithImpl$Input$CreateAdminRequestInput(this._instance, this._then);

  final Input$CreateAdminRequestInput _instance;

  final TRes Function(Input$CreateAdminRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
  }) => _then(
    Input$CreateAdminRequestInput._({
      ..._instance._$data,
      if (fullName != _undefined && fullName != null)
        'fullName': (fullName as String),
      if (email != _undefined && email != null) 'email': (email as String),
      if (password != _undefined && password != null)
        'password': (password as String),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateAdminRequestInput<TRes>
    implements CopyWith$Input$CreateAdminRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateAdminRequestInput(this._res);

  TRes _res;

  call({String? fullName, String? email, String? password}) => _res;
}

class Input$CreateAlbumRequestInput {
  factory Input$CreateAlbumRequestInput({
    required String name,
    String? description,
    required Enum$AlbumType type,
    required List<String> trackIds,
    required List<Input$ContributingArtistInput> artistInfos,
    String? coverImage,
    String? thumbnailImage,
    required Input$ReleaseInfoInput releaseInfo,
    required bool isVisible,
  }) => Input$CreateAlbumRequestInput._({
    r'name': name,
    if (description != null) r'description': description,
    r'type': type,
    r'trackIds': trackIds,
    r'artistInfos': artistInfos,
    if (coverImage != null) r'coverImage': coverImage,
    if (thumbnailImage != null) r'thumbnailImage': thumbnailImage,
    r'releaseInfo': releaseInfo,
    r'isVisible': isVisible,
  });

  Input$CreateAlbumRequestInput._(this._$data);

  factory Input$CreateAlbumRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$type = data['type'];
    result$data['type'] = fromJson$Enum$AlbumType((l$type as String));
    final l$trackIds = data['trackIds'];
    result$data['trackIds'] = (l$trackIds as List<dynamic>)
        .map((e) => (e as String))
        .toList();
    final l$artistInfos = data['artistInfos'];
    result$data['artistInfos'] = (l$artistInfos as List<dynamic>)
        .map(
          (e) => Input$ContributingArtistInput.fromJson(
            (e as Map<String, dynamic>),
          ),
        )
        .toList();
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = (l$coverImage as String?);
    }
    if (data.containsKey('thumbnailImage')) {
      final l$thumbnailImage = data['thumbnailImage'];
      result$data['thumbnailImage'] = (l$thumbnailImage as String?);
    }
    final l$releaseInfo = data['releaseInfo'];
    result$data['releaseInfo'] = Input$ReleaseInfoInput.fromJson(
      (l$releaseInfo as Map<String, dynamic>),
    );
    final l$isVisible = data['isVisible'];
    result$data['isVisible'] = (l$isVisible as bool);
    return Input$CreateAlbumRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get description => (_$data['description'] as String?);

  Enum$AlbumType get type => (_$data['type'] as Enum$AlbumType);

  List<String> get trackIds => (_$data['trackIds'] as List<String>);

  List<Input$ContributingArtistInput> get artistInfos =>
      (_$data['artistInfos'] as List<Input$ContributingArtistInput>);

  String? get coverImage => (_$data['coverImage'] as String?);

  String? get thumbnailImage => (_$data['thumbnailImage'] as String?);

  Input$ReleaseInfoInput get releaseInfo =>
      (_$data['releaseInfo'] as Input$ReleaseInfoInput);

  bool get isVisible => (_$data['isVisible'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$type = type;
    result$data['type'] = toJson$Enum$AlbumType(l$type);
    final l$trackIds = trackIds;
    result$data['trackIds'] = l$trackIds.map((e) => e).toList();
    final l$artistInfos = artistInfos;
    result$data['artistInfos'] = l$artistInfos.map((e) => e.toJson()).toList();
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage;
    }
    if (_$data.containsKey('thumbnailImage')) {
      final l$thumbnailImage = thumbnailImage;
      result$data['thumbnailImage'] = l$thumbnailImage;
    }
    final l$releaseInfo = releaseInfo;
    result$data['releaseInfo'] = l$releaseInfo.toJson();
    final l$isVisible = isVisible;
    result$data['isVisible'] = l$isVisible;
    return result$data;
  }

  CopyWith$Input$CreateAlbumRequestInput<Input$CreateAlbumRequestInput>
  get copyWith => CopyWith$Input$CreateAlbumRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateAlbumRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$trackIds = trackIds;
    final lOther$trackIds = other.trackIds;
    if (l$trackIds.length != lOther$trackIds.length) {
      return false;
    }
    for (int i = 0; i < l$trackIds.length; i++) {
      final l$trackIds$entry = l$trackIds[i];
      final lOther$trackIds$entry = lOther$trackIds[i];
      if (l$trackIds$entry != lOther$trackIds$entry) {
        return false;
      }
    }
    final l$artistInfos = artistInfos;
    final lOther$artistInfos = other.artistInfos;
    if (l$artistInfos.length != lOther$artistInfos.length) {
      return false;
    }
    for (int i = 0; i < l$artistInfos.length; i++) {
      final l$artistInfos$entry = l$artistInfos[i];
      final lOther$artistInfos$entry = lOther$artistInfos[i];
      if (l$artistInfos$entry != lOther$artistInfos$entry) {
        return false;
      }
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$thumbnailImage = thumbnailImage;
    final lOther$thumbnailImage = other.thumbnailImage;
    if (_$data.containsKey('thumbnailImage') !=
        other._$data.containsKey('thumbnailImage')) {
      return false;
    }
    if (l$thumbnailImage != lOther$thumbnailImage) {
      return false;
    }
    final l$releaseInfo = releaseInfo;
    final lOther$releaseInfo = other.releaseInfo;
    if (l$releaseInfo != lOther$releaseInfo) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$type = type;
    final l$trackIds = trackIds;
    final l$artistInfos = artistInfos;
    final l$coverImage = coverImage;
    final l$thumbnailImage = thumbnailImage;
    final l$releaseInfo = releaseInfo;
    final l$isVisible = isVisible;
    return Object.hashAll([
      l$name,
      _$data.containsKey('description') ? l$description : const {},
      l$type,
      Object.hashAll(l$trackIds.map((v) => v)),
      Object.hashAll(l$artistInfos.map((v) => v)),
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('thumbnailImage') ? l$thumbnailImage : const {},
      l$releaseInfo,
      l$isVisible,
    ]);
  }
}

abstract class CopyWith$Input$CreateAlbumRequestInput<TRes> {
  factory CopyWith$Input$CreateAlbumRequestInput(
    Input$CreateAlbumRequestInput instance,
    TRes Function(Input$CreateAlbumRequestInput) then,
  ) = _CopyWithImpl$Input$CreateAlbumRequestInput;

  factory CopyWith$Input$CreateAlbumRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateAlbumRequestInput;

  TRes call({
    String? name,
    String? description,
    Enum$AlbumType? type,
    List<String>? trackIds,
    List<Input$ContributingArtistInput>? artistInfos,
    String? coverImage,
    String? thumbnailImage,
    Input$ReleaseInfoInput? releaseInfo,
    bool? isVisible,
  });
  TRes artistInfos(
    Iterable<Input$ContributingArtistInput> Function(
      Iterable<
        CopyWith$Input$ContributingArtistInput<Input$ContributingArtistInput>
      >,
    )
    _fn,
  );
  CopyWith$Input$ReleaseInfoInput<TRes> get releaseInfo;
}

class _CopyWithImpl$Input$CreateAlbumRequestInput<TRes>
    implements CopyWith$Input$CreateAlbumRequestInput<TRes> {
  _CopyWithImpl$Input$CreateAlbumRequestInput(this._instance, this._then);

  final Input$CreateAlbumRequestInput _instance;

  final TRes Function(Input$CreateAlbumRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? type = _undefined,
    Object? trackIds = _undefined,
    Object? artistInfos = _undefined,
    Object? coverImage = _undefined,
    Object? thumbnailImage = _undefined,
    Object? releaseInfo = _undefined,
    Object? isVisible = _undefined,
  }) => _then(
    Input$CreateAlbumRequestInput._({
      ..._instance._$data,
      if (name != _undefined && name != null) 'name': (name as String),
      if (description != _undefined) 'description': (description as String?),
      if (type != _undefined && type != null) 'type': (type as Enum$AlbumType),
      if (trackIds != _undefined && trackIds != null)
        'trackIds': (trackIds as List<String>),
      if (artistInfos != _undefined && artistInfos != null)
        'artistInfos': (artistInfos as List<Input$ContributingArtistInput>),
      if (coverImage != _undefined) 'coverImage': (coverImage as String?),
      if (thumbnailImage != _undefined)
        'thumbnailImage': (thumbnailImage as String?),
      if (releaseInfo != _undefined && releaseInfo != null)
        'releaseInfo': (releaseInfo as Input$ReleaseInfoInput),
      if (isVisible != _undefined && isVisible != null)
        'isVisible': (isVisible as bool),
    }),
  );

  TRes artistInfos(
    Iterable<Input$ContributingArtistInput> Function(
      Iterable<
        CopyWith$Input$ContributingArtistInput<Input$ContributingArtistInput>
      >,
    )
    _fn,
  ) => call(
    artistInfos: _fn(
      _instance.artistInfos.map(
        (e) => CopyWith$Input$ContributingArtistInput(e, (i) => i),
      ),
    ).toList(),
  );

  CopyWith$Input$ReleaseInfoInput<TRes> get releaseInfo {
    final local$releaseInfo = _instance.releaseInfo;
    return CopyWith$Input$ReleaseInfoInput(
      local$releaseInfo,
      (e) => call(releaseInfo: e),
    );
  }
}

class _CopyWithStubImpl$Input$CreateAlbumRequestInput<TRes>
    implements CopyWith$Input$CreateAlbumRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateAlbumRequestInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    Enum$AlbumType? type,
    List<String>? trackIds,
    List<Input$ContributingArtistInput>? artistInfos,
    String? coverImage,
    String? thumbnailImage,
    Input$ReleaseInfoInput? releaseInfo,
    bool? isVisible,
  }) => _res;

  artistInfos(_fn) => _res;

  CopyWith$Input$ReleaseInfoInput<TRes> get releaseInfo =>
      CopyWith$Input$ReleaseInfoInput.stub(_res);
}

class Input$CreateArtistPackageRequestInput {
  factory Input$CreateArtistPackageRequestInput({
    required String packageName,
    required String artistId,
    required double amount,
    required int estimateDeliveryDays,
    String? description,
    required List<Input$MetadataInput> serviceDetails,
    required int maxRevision,
  }) => Input$CreateArtistPackageRequestInput._({
    r'packageName': packageName,
    r'artistId': artistId,
    r'amount': amount,
    r'estimateDeliveryDays': estimateDeliveryDays,
    if (description != null) r'description': description,
    r'serviceDetails': serviceDetails,
    r'maxRevision': maxRevision,
  });

  Input$CreateArtistPackageRequestInput._(this._$data);

  factory Input$CreateArtistPackageRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$packageName = data['packageName'];
    result$data['packageName'] = (l$packageName as String);
    final l$artistId = data['artistId'];
    result$data['artistId'] = (l$artistId as String);
    final l$amount = data['amount'];
    result$data['amount'] = (l$amount as num).toDouble();
    final l$estimateDeliveryDays = data['estimateDeliveryDays'];
    result$data['estimateDeliveryDays'] = (l$estimateDeliveryDays as int);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$serviceDetails = data['serviceDetails'];
    result$data['serviceDetails'] = (l$serviceDetails as List<dynamic>)
        .map((e) => Input$MetadataInput.fromJson((e as Map<String, dynamic>)))
        .toList();
    final l$maxRevision = data['maxRevision'];
    result$data['maxRevision'] = (l$maxRevision as int);
    return Input$CreateArtistPackageRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get packageName => (_$data['packageName'] as String);

  String get artistId => (_$data['artistId'] as String);

  double get amount => (_$data['amount'] as double);

  int get estimateDeliveryDays => (_$data['estimateDeliveryDays'] as int);

  String? get description => (_$data['description'] as String?);

  List<Input$MetadataInput> get serviceDetails =>
      (_$data['serviceDetails'] as List<Input$MetadataInput>);

  int get maxRevision => (_$data['maxRevision'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$packageName = packageName;
    result$data['packageName'] = l$packageName;
    final l$artistId = artistId;
    result$data['artistId'] = l$artistId;
    final l$amount = amount;
    result$data['amount'] = l$amount;
    final l$estimateDeliveryDays = estimateDeliveryDays;
    result$data['estimateDeliveryDays'] = l$estimateDeliveryDays;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$serviceDetails = serviceDetails;
    result$data['serviceDetails'] = l$serviceDetails
        .map((e) => e.toJson())
        .toList();
    final l$maxRevision = maxRevision;
    result$data['maxRevision'] = l$maxRevision;
    return result$data;
  }

  CopyWith$Input$CreateArtistPackageRequestInput<
    Input$CreateArtistPackageRequestInput
  >
  get copyWith =>
      CopyWith$Input$CreateArtistPackageRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateArtistPackageRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$packageName = packageName;
    final lOther$packageName = other.packageName;
    if (l$packageName != lOther$packageName) {
      return false;
    }
    final l$artistId = artistId;
    final lOther$artistId = other.artistId;
    if (l$artistId != lOther$artistId) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$estimateDeliveryDays = estimateDeliveryDays;
    final lOther$estimateDeliveryDays = other.estimateDeliveryDays;
    if (l$estimateDeliveryDays != lOther$estimateDeliveryDays) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$serviceDetails = serviceDetails;
    final lOther$serviceDetails = other.serviceDetails;
    if (l$serviceDetails.length != lOther$serviceDetails.length) {
      return false;
    }
    for (int i = 0; i < l$serviceDetails.length; i++) {
      final l$serviceDetails$entry = l$serviceDetails[i];
      final lOther$serviceDetails$entry = lOther$serviceDetails[i];
      if (l$serviceDetails$entry != lOther$serviceDetails$entry) {
        return false;
      }
    }
    final l$maxRevision = maxRevision;
    final lOther$maxRevision = other.maxRevision;
    if (l$maxRevision != lOther$maxRevision) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$packageName = packageName;
    final l$artistId = artistId;
    final l$amount = amount;
    final l$estimateDeliveryDays = estimateDeliveryDays;
    final l$description = description;
    final l$serviceDetails = serviceDetails;
    final l$maxRevision = maxRevision;
    return Object.hashAll([
      l$packageName,
      l$artistId,
      l$amount,
      l$estimateDeliveryDays,
      _$data.containsKey('description') ? l$description : const {},
      Object.hashAll(l$serviceDetails.map((v) => v)),
      l$maxRevision,
    ]);
  }
}

abstract class CopyWith$Input$CreateArtistPackageRequestInput<TRes> {
  factory CopyWith$Input$CreateArtistPackageRequestInput(
    Input$CreateArtistPackageRequestInput instance,
    TRes Function(Input$CreateArtistPackageRequestInput) then,
  ) = _CopyWithImpl$Input$CreateArtistPackageRequestInput;

  factory CopyWith$Input$CreateArtistPackageRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateArtistPackageRequestInput;

  TRes call({
    String? packageName,
    String? artistId,
    double? amount,
    int? estimateDeliveryDays,
    String? description,
    List<Input$MetadataInput>? serviceDetails,
    int? maxRevision,
  });
  TRes serviceDetails(
    Iterable<Input$MetadataInput> Function(
      Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$CreateArtistPackageRequestInput<TRes>
    implements CopyWith$Input$CreateArtistPackageRequestInput<TRes> {
  _CopyWithImpl$Input$CreateArtistPackageRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreateArtistPackageRequestInput _instance;

  final TRes Function(Input$CreateArtistPackageRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? packageName = _undefined,
    Object? artistId = _undefined,
    Object? amount = _undefined,
    Object? estimateDeliveryDays = _undefined,
    Object? description = _undefined,
    Object? serviceDetails = _undefined,
    Object? maxRevision = _undefined,
  }) => _then(
    Input$CreateArtistPackageRequestInput._({
      ..._instance._$data,
      if (packageName != _undefined && packageName != null)
        'packageName': (packageName as String),
      if (artistId != _undefined && artistId != null)
        'artistId': (artistId as String),
      if (amount != _undefined && amount != null) 'amount': (amount as double),
      if (estimateDeliveryDays != _undefined && estimateDeliveryDays != null)
        'estimateDeliveryDays': (estimateDeliveryDays as int),
      if (description != _undefined) 'description': (description as String?),
      if (serviceDetails != _undefined && serviceDetails != null)
        'serviceDetails': (serviceDetails as List<Input$MetadataInput>),
      if (maxRevision != _undefined && maxRevision != null)
        'maxRevision': (maxRevision as int),
    }),
  );

  TRes serviceDetails(
    Iterable<Input$MetadataInput> Function(
      Iterable<CopyWith$Input$MetadataInput<Input$MetadataInput>>,
    )
    _fn,
  ) => call(
    serviceDetails: _fn(
      _instance.serviceDetails.map(
        (e) => CopyWith$Input$MetadataInput(e, (i) => i),
      ),
    ).toList(),
  );
}

class _CopyWithStubImpl$Input$CreateArtistPackageRequestInput<TRes>
    implements CopyWith$Input$CreateArtistPackageRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateArtistPackageRequestInput(this._res);

  TRes _res;

  call({
    String? packageName,
    String? artistId,
    double? amount,
    int? estimateDeliveryDays,
    String? description,
    List<Input$MetadataInput>? serviceDetails,
    int? maxRevision,
  }) => _res;

  serviceDetails(_fn) => _res;
}

class Input$CreateArtistRequestInput {
  factory Input$CreateArtistRequestInput({
    required String userId,
    required String name,
    required String biography,
    required Input$IdentityCardInput identityCard,
  }) => Input$CreateArtistRequestInput._({
    r'userId': userId,
    r'name': name,
    r'biography': biography,
    r'identityCard': identityCard,
  });

  Input$CreateArtistRequestInput._(this._$data);

  factory Input$CreateArtistRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$biography = data['biography'];
    result$data['biography'] = (l$biography as String);
    final l$identityCard = data['identityCard'];
    result$data['identityCard'] = Input$IdentityCardInput.fromJson(
      (l$identityCard as Map<String, dynamic>),
    );
    return Input$CreateArtistRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get userId => (_$data['userId'] as String);

  String get name => (_$data['name'] as String);

  String get biography => (_$data['biography'] as String);

  Input$IdentityCardInput get identityCard =>
      (_$data['identityCard'] as Input$IdentityCardInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$userId = userId;
    result$data['userId'] = l$userId;
    final l$name = name;
    result$data['name'] = l$name;
    final l$biography = biography;
    result$data['biography'] = l$biography;
    final l$identityCard = identityCard;
    result$data['identityCard'] = l$identityCard.toJson();
    return result$data;
  }

  CopyWith$Input$CreateArtistRequestInput<Input$CreateArtistRequestInput>
  get copyWith => CopyWith$Input$CreateArtistRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateArtistRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$biography = biography;
    final lOther$biography = other.biography;
    if (l$biography != lOther$biography) {
      return false;
    }
    final l$identityCard = identityCard;
    final lOther$identityCard = other.identityCard;
    if (l$identityCard != lOther$identityCard) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$name = name;
    final l$biography = biography;
    final l$identityCard = identityCard;
    return Object.hashAll([l$userId, l$name, l$biography, l$identityCard]);
  }
}

abstract class CopyWith$Input$CreateArtistRequestInput<TRes> {
  factory CopyWith$Input$CreateArtistRequestInput(
    Input$CreateArtistRequestInput instance,
    TRes Function(Input$CreateArtistRequestInput) then,
  ) = _CopyWithImpl$Input$CreateArtistRequestInput;

  factory CopyWith$Input$CreateArtistRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateArtistRequestInput;

  TRes call({
    String? userId,
    String? name,
    String? biography,
    Input$IdentityCardInput? identityCard,
  });
  CopyWith$Input$IdentityCardInput<TRes> get identityCard;
}

class _CopyWithImpl$Input$CreateArtistRequestInput<TRes>
    implements CopyWith$Input$CreateArtistRequestInput<TRes> {
  _CopyWithImpl$Input$CreateArtistRequestInput(this._instance, this._then);

  final Input$CreateArtistRequestInput _instance;

  final TRes Function(Input$CreateArtistRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? userId = _undefined,
    Object? name = _undefined,
    Object? biography = _undefined,
    Object? identityCard = _undefined,
  }) => _then(
    Input$CreateArtistRequestInput._({
      ..._instance._$data,
      if (userId != _undefined && userId != null) 'userId': (userId as String),
      if (name != _undefined && name != null) 'name': (name as String),
      if (biography != _undefined && biography != null)
        'biography': (biography as String),
      if (identityCard != _undefined && identityCard != null)
        'identityCard': (identityCard as Input$IdentityCardInput),
    }),
  );

  CopyWith$Input$IdentityCardInput<TRes> get identityCard {
    final local$identityCard = _instance.identityCard;
    return CopyWith$Input$IdentityCardInput(
      local$identityCard,
      (e) => call(identityCard: e),
    );
  }
}

class _CopyWithStubImpl$Input$CreateArtistRequestInput<TRes>
    implements CopyWith$Input$CreateArtistRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateArtistRequestInput(this._res);

  TRes _res;

  call({
    String? userId,
    String? name,
    String? biography,
    Input$IdentityCardInput? identityCard,
  }) => _res;

  CopyWith$Input$IdentityCardInput<TRes> get identityCard =>
      CopyWith$Input$IdentityCardInput.stub(_res);
}

class Input$CreateBillingPortalConfigurationRequestInput {
  factory Input$CreateBillingPortalConfigurationRequestInput({
    required bool customerUpdateEnabled,
    required List<Enum$CustomerUpdate> allowedCustomerUpdates,
    required Enum$UserRole userRole,
    required Enum$SubscriptionTier subscriptionTier,
    required int subscriptionVersion,
    required int version,
    required bool paymentMethodUpdateEnabled,
    required bool invoiceHistoryEnabled,
    required bool subscriptionCancelEnabled,
    required Enum$StripeSubscriptionCancelMode mode,
    required bool suscriptionUpdateEnabled,
    required List<Enum$StripeSubscriptionUpdate> allowedSubscriptionUpdates,
    required List<Input$StripeProductRequestInput> products,
    required Enum$BillingPortalConfigStatus status,
  }) => Input$CreateBillingPortalConfigurationRequestInput._({
    r'customerUpdateEnabled': customerUpdateEnabled,
    r'allowedCustomerUpdates': allowedCustomerUpdates,
    r'userRole': userRole,
    r'subscriptionTier': subscriptionTier,
    r'subscriptionVersion': subscriptionVersion,
    r'version': version,
    r'paymentMethodUpdateEnabled': paymentMethodUpdateEnabled,
    r'invoiceHistoryEnabled': invoiceHistoryEnabled,
    r'subscriptionCancelEnabled': subscriptionCancelEnabled,
    r'mode': mode,
    r'suscriptionUpdateEnabled': suscriptionUpdateEnabled,
    r'allowedSubscriptionUpdates': allowedSubscriptionUpdates,
    r'products': products,
    r'status': status,
  });

  Input$CreateBillingPortalConfigurationRequestInput._(this._$data);

  factory Input$CreateBillingPortalConfigurationRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$customerUpdateEnabled = data['customerUpdateEnabled'];
    result$data['customerUpdateEnabled'] = (l$customerUpdateEnabled as bool);
    final l$allowedCustomerUpdates = data['allowedCustomerUpdates'];
    result$data['allowedCustomerUpdates'] =
        (l$allowedCustomerUpdates as List<dynamic>)
            .map((e) => fromJson$Enum$CustomerUpdate((e as String)))
            .toList();
    final l$userRole = data['userRole'];
    result$data['userRole'] = fromJson$Enum$UserRole((l$userRole as String));
    final l$subscriptionTier = data['subscriptionTier'];
    result$data['subscriptionTier'] = fromJson$Enum$SubscriptionTier(
      (l$subscriptionTier as String),
    );
    final l$subscriptionVersion = data['subscriptionVersion'];
    result$data['subscriptionVersion'] = (l$subscriptionVersion as int);
    final l$version = data['version'];
    result$data['version'] = (l$version as int);
    final l$paymentMethodUpdateEnabled = data['paymentMethodUpdateEnabled'];
    result$data['paymentMethodUpdateEnabled'] =
        (l$paymentMethodUpdateEnabled as bool);
    final l$invoiceHistoryEnabled = data['invoiceHistoryEnabled'];
    result$data['invoiceHistoryEnabled'] = (l$invoiceHistoryEnabled as bool);
    final l$subscriptionCancelEnabled = data['subscriptionCancelEnabled'];
    result$data['subscriptionCancelEnabled'] =
        (l$subscriptionCancelEnabled as bool);
    final l$mode = data['mode'];
    result$data['mode'] = fromJson$Enum$StripeSubscriptionCancelMode(
      (l$mode as String),
    );
    final l$suscriptionUpdateEnabled = data['suscriptionUpdateEnabled'];
    result$data['suscriptionUpdateEnabled'] =
        (l$suscriptionUpdateEnabled as bool);
    final l$allowedSubscriptionUpdates = data['allowedSubscriptionUpdates'];
    result$data['allowedSubscriptionUpdates'] =
        (l$allowedSubscriptionUpdates as List<dynamic>)
            .map((e) => fromJson$Enum$StripeSubscriptionUpdate((e as String)))
            .toList();
    final l$products = data['products'];
    result$data['products'] = (l$products as List<dynamic>)
        .map(
          (e) => Input$StripeProductRequestInput.fromJson(
            (e as Map<String, dynamic>),
          ),
        )
        .toList();
    final l$status = data['status'];
    result$data['status'] = fromJson$Enum$BillingPortalConfigStatus(
      (l$status as String),
    );
    return Input$CreateBillingPortalConfigurationRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool get customerUpdateEnabled => (_$data['customerUpdateEnabled'] as bool);

  List<Enum$CustomerUpdate> get allowedCustomerUpdates =>
      (_$data['allowedCustomerUpdates'] as List<Enum$CustomerUpdate>);

  Enum$UserRole get userRole => (_$data['userRole'] as Enum$UserRole);

  Enum$SubscriptionTier get subscriptionTier =>
      (_$data['subscriptionTier'] as Enum$SubscriptionTier);

  int get subscriptionVersion => (_$data['subscriptionVersion'] as int);

  int get version => (_$data['version'] as int);

  bool get paymentMethodUpdateEnabled =>
      (_$data['paymentMethodUpdateEnabled'] as bool);

  bool get invoiceHistoryEnabled => (_$data['invoiceHistoryEnabled'] as bool);

  bool get subscriptionCancelEnabled =>
      (_$data['subscriptionCancelEnabled'] as bool);

  Enum$StripeSubscriptionCancelMode get mode =>
      (_$data['mode'] as Enum$StripeSubscriptionCancelMode);

  bool get suscriptionUpdateEnabled =>
      (_$data['suscriptionUpdateEnabled'] as bool);

  List<Enum$StripeSubscriptionUpdate> get allowedSubscriptionUpdates =>
      (_$data['allowedSubscriptionUpdates']
          as List<Enum$StripeSubscriptionUpdate>);

  List<Input$StripeProductRequestInput> get products =>
      (_$data['products'] as List<Input$StripeProductRequestInput>);

  Enum$BillingPortalConfigStatus get status =>
      (_$data['status'] as Enum$BillingPortalConfigStatus);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$customerUpdateEnabled = customerUpdateEnabled;
    result$data['customerUpdateEnabled'] = l$customerUpdateEnabled;
    final l$allowedCustomerUpdates = allowedCustomerUpdates;
    result$data['allowedCustomerUpdates'] = l$allowedCustomerUpdates
        .map((e) => toJson$Enum$CustomerUpdate(e))
        .toList();
    final l$userRole = userRole;
    result$data['userRole'] = toJson$Enum$UserRole(l$userRole);
    final l$subscriptionTier = subscriptionTier;
    result$data['subscriptionTier'] = toJson$Enum$SubscriptionTier(
      l$subscriptionTier,
    );
    final l$subscriptionVersion = subscriptionVersion;
    result$data['subscriptionVersion'] = l$subscriptionVersion;
    final l$version = version;
    result$data['version'] = l$version;
    final l$paymentMethodUpdateEnabled = paymentMethodUpdateEnabled;
    result$data['paymentMethodUpdateEnabled'] = l$paymentMethodUpdateEnabled;
    final l$invoiceHistoryEnabled = invoiceHistoryEnabled;
    result$data['invoiceHistoryEnabled'] = l$invoiceHistoryEnabled;
    final l$subscriptionCancelEnabled = subscriptionCancelEnabled;
    result$data['subscriptionCancelEnabled'] = l$subscriptionCancelEnabled;
    final l$mode = mode;
    result$data['mode'] = toJson$Enum$StripeSubscriptionCancelMode(l$mode);
    final l$suscriptionUpdateEnabled = suscriptionUpdateEnabled;
    result$data['suscriptionUpdateEnabled'] = l$suscriptionUpdateEnabled;
    final l$allowedSubscriptionUpdates = allowedSubscriptionUpdates;
    result$data['allowedSubscriptionUpdates'] = l$allowedSubscriptionUpdates
        .map((e) => toJson$Enum$StripeSubscriptionUpdate(e))
        .toList();
    final l$products = products;
    result$data['products'] = l$products.map((e) => e.toJson()).toList();
    final l$status = status;
    result$data['status'] = toJson$Enum$BillingPortalConfigStatus(l$status);
    return result$data;
  }

  CopyWith$Input$CreateBillingPortalConfigurationRequestInput<
    Input$CreateBillingPortalConfigurationRequestInput
  >
  get copyWith => CopyWith$Input$CreateBillingPortalConfigurationRequestInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateBillingPortalConfigurationRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$customerUpdateEnabled = customerUpdateEnabled;
    final lOther$customerUpdateEnabled = other.customerUpdateEnabled;
    if (l$customerUpdateEnabled != lOther$customerUpdateEnabled) {
      return false;
    }
    final l$allowedCustomerUpdates = allowedCustomerUpdates;
    final lOther$allowedCustomerUpdates = other.allowedCustomerUpdates;
    if (l$allowedCustomerUpdates.length !=
        lOther$allowedCustomerUpdates.length) {
      return false;
    }
    for (int i = 0; i < l$allowedCustomerUpdates.length; i++) {
      final l$allowedCustomerUpdates$entry = l$allowedCustomerUpdates[i];
      final lOther$allowedCustomerUpdates$entry =
          lOther$allowedCustomerUpdates[i];
      if (l$allowedCustomerUpdates$entry !=
          lOther$allowedCustomerUpdates$entry) {
        return false;
      }
    }
    final l$userRole = userRole;
    final lOther$userRole = other.userRole;
    if (l$userRole != lOther$userRole) {
      return false;
    }
    final l$subscriptionTier = subscriptionTier;
    final lOther$subscriptionTier = other.subscriptionTier;
    if (l$subscriptionTier != lOther$subscriptionTier) {
      return false;
    }
    final l$subscriptionVersion = subscriptionVersion;
    final lOther$subscriptionVersion = other.subscriptionVersion;
    if (l$subscriptionVersion != lOther$subscriptionVersion) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) {
      return false;
    }
    final l$paymentMethodUpdateEnabled = paymentMethodUpdateEnabled;
    final lOther$paymentMethodUpdateEnabled = other.paymentMethodUpdateEnabled;
    if (l$paymentMethodUpdateEnabled != lOther$paymentMethodUpdateEnabled) {
      return false;
    }
    final l$invoiceHistoryEnabled = invoiceHistoryEnabled;
    final lOther$invoiceHistoryEnabled = other.invoiceHistoryEnabled;
    if (l$invoiceHistoryEnabled != lOther$invoiceHistoryEnabled) {
      return false;
    }
    final l$subscriptionCancelEnabled = subscriptionCancelEnabled;
    final lOther$subscriptionCancelEnabled = other.subscriptionCancelEnabled;
    if (l$subscriptionCancelEnabled != lOther$subscriptionCancelEnabled) {
      return false;
    }
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (l$mode != lOther$mode) {
      return false;
    }
    final l$suscriptionUpdateEnabled = suscriptionUpdateEnabled;
    final lOther$suscriptionUpdateEnabled = other.suscriptionUpdateEnabled;
    if (l$suscriptionUpdateEnabled != lOther$suscriptionUpdateEnabled) {
      return false;
    }
    final l$allowedSubscriptionUpdates = allowedSubscriptionUpdates;
    final lOther$allowedSubscriptionUpdates = other.allowedSubscriptionUpdates;
    if (l$allowedSubscriptionUpdates.length !=
        lOther$allowedSubscriptionUpdates.length) {
      return false;
    }
    for (int i = 0; i < l$allowedSubscriptionUpdates.length; i++) {
      final l$allowedSubscriptionUpdates$entry =
          l$allowedSubscriptionUpdates[i];
      final lOther$allowedSubscriptionUpdates$entry =
          lOther$allowedSubscriptionUpdates[i];
      if (l$allowedSubscriptionUpdates$entry !=
          lOther$allowedSubscriptionUpdates$entry) {
        return false;
      }
    }
    final l$products = products;
    final lOther$products = other.products;
    if (l$products.length != lOther$products.length) {
      return false;
    }
    for (int i = 0; i < l$products.length; i++) {
      final l$products$entry = l$products[i];
      final lOther$products$entry = lOther$products[i];
      if (l$products$entry != lOther$products$entry) {
        return false;
      }
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$customerUpdateEnabled = customerUpdateEnabled;
    final l$allowedCustomerUpdates = allowedCustomerUpdates;
    final l$userRole = userRole;
    final l$subscriptionTier = subscriptionTier;
    final l$subscriptionVersion = subscriptionVersion;
    final l$version = version;
    final l$paymentMethodUpdateEnabled = paymentMethodUpdateEnabled;
    final l$invoiceHistoryEnabled = invoiceHistoryEnabled;
    final l$subscriptionCancelEnabled = subscriptionCancelEnabled;
    final l$mode = mode;
    final l$suscriptionUpdateEnabled = suscriptionUpdateEnabled;
    final l$allowedSubscriptionUpdates = allowedSubscriptionUpdates;
    final l$products = products;
    final l$status = status;
    return Object.hashAll([
      l$customerUpdateEnabled,
      Object.hashAll(l$allowedCustomerUpdates.map((v) => v)),
      l$userRole,
      l$subscriptionTier,
      l$subscriptionVersion,
      l$version,
      l$paymentMethodUpdateEnabled,
      l$invoiceHistoryEnabled,
      l$subscriptionCancelEnabled,
      l$mode,
      l$suscriptionUpdateEnabled,
      Object.hashAll(l$allowedSubscriptionUpdates.map((v) => v)),
      Object.hashAll(l$products.map((v) => v)),
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$CreateBillingPortalConfigurationRequestInput<
  TRes
> {
  factory CopyWith$Input$CreateBillingPortalConfigurationRequestInput(
    Input$CreateBillingPortalConfigurationRequestInput instance,
    TRes Function(Input$CreateBillingPortalConfigurationRequestInput) then,
  ) = _CopyWithImpl$Input$CreateBillingPortalConfigurationRequestInput;

  factory CopyWith$Input$CreateBillingPortalConfigurationRequestInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$CreateBillingPortalConfigurationRequestInput;

  TRes call({
    bool? customerUpdateEnabled,
    List<Enum$CustomerUpdate>? allowedCustomerUpdates,
    Enum$UserRole? userRole,
    Enum$SubscriptionTier? subscriptionTier,
    int? subscriptionVersion,
    int? version,
    bool? paymentMethodUpdateEnabled,
    bool? invoiceHistoryEnabled,
    bool? subscriptionCancelEnabled,
    Enum$StripeSubscriptionCancelMode? mode,
    bool? suscriptionUpdateEnabled,
    List<Enum$StripeSubscriptionUpdate>? allowedSubscriptionUpdates,
    List<Input$StripeProductRequestInput>? products,
    Enum$BillingPortalConfigStatus? status,
  });
  TRes products(
    Iterable<Input$StripeProductRequestInput> Function(
      Iterable<
        CopyWith$Input$StripeProductRequestInput<
          Input$StripeProductRequestInput
        >
      >,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$CreateBillingPortalConfigurationRequestInput<TRes>
    implements
        CopyWith$Input$CreateBillingPortalConfigurationRequestInput<TRes> {
  _CopyWithImpl$Input$CreateBillingPortalConfigurationRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreateBillingPortalConfigurationRequestInput _instance;

  final TRes Function(Input$CreateBillingPortalConfigurationRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? customerUpdateEnabled = _undefined,
    Object? allowedCustomerUpdates = _undefined,
    Object? userRole = _undefined,
    Object? subscriptionTier = _undefined,
    Object? subscriptionVersion = _undefined,
    Object? version = _undefined,
    Object? paymentMethodUpdateEnabled = _undefined,
    Object? invoiceHistoryEnabled = _undefined,
    Object? subscriptionCancelEnabled = _undefined,
    Object? mode = _undefined,
    Object? suscriptionUpdateEnabled = _undefined,
    Object? allowedSubscriptionUpdates = _undefined,
    Object? products = _undefined,
    Object? status = _undefined,
  }) => _then(
    Input$CreateBillingPortalConfigurationRequestInput._({
      ..._instance._$data,
      if (customerUpdateEnabled != _undefined && customerUpdateEnabled != null)
        'customerUpdateEnabled': (customerUpdateEnabled as bool),
      if (allowedCustomerUpdates != _undefined &&
          allowedCustomerUpdates != null)
        'allowedCustomerUpdates':
            (allowedCustomerUpdates as List<Enum$CustomerUpdate>),
      if (userRole != _undefined && userRole != null)
        'userRole': (userRole as Enum$UserRole),
      if (subscriptionTier != _undefined && subscriptionTier != null)
        'subscriptionTier': (subscriptionTier as Enum$SubscriptionTier),
      if (subscriptionVersion != _undefined && subscriptionVersion != null)
        'subscriptionVersion': (subscriptionVersion as int),
      if (version != _undefined && version != null) 'version': (version as int),
      if (paymentMethodUpdateEnabled != _undefined &&
          paymentMethodUpdateEnabled != null)
        'paymentMethodUpdateEnabled': (paymentMethodUpdateEnabled as bool),
      if (invoiceHistoryEnabled != _undefined && invoiceHistoryEnabled != null)
        'invoiceHistoryEnabled': (invoiceHistoryEnabled as bool),
      if (subscriptionCancelEnabled != _undefined &&
          subscriptionCancelEnabled != null)
        'subscriptionCancelEnabled': (subscriptionCancelEnabled as bool),
      if (mode != _undefined && mode != null)
        'mode': (mode as Enum$StripeSubscriptionCancelMode),
      if (suscriptionUpdateEnabled != _undefined &&
          suscriptionUpdateEnabled != null)
        'suscriptionUpdateEnabled': (suscriptionUpdateEnabled as bool),
      if (allowedSubscriptionUpdates != _undefined &&
          allowedSubscriptionUpdates != null)
        'allowedSubscriptionUpdates':
            (allowedSubscriptionUpdates as List<Enum$StripeSubscriptionUpdate>),
      if (products != _undefined && products != null)
        'products': (products as List<Input$StripeProductRequestInput>),
      if (status != _undefined && status != null)
        'status': (status as Enum$BillingPortalConfigStatus),
    }),
  );

  TRes products(
    Iterable<Input$StripeProductRequestInput> Function(
      Iterable<
        CopyWith$Input$StripeProductRequestInput<
          Input$StripeProductRequestInput
        >
      >,
    )
    _fn,
  ) => call(
    products: _fn(
      _instance.products.map(
        (e) => CopyWith$Input$StripeProductRequestInput(e, (i) => i),
      ),
    ).toList(),
  );
}

class _CopyWithStubImpl$Input$CreateBillingPortalConfigurationRequestInput<TRes>
    implements
        CopyWith$Input$CreateBillingPortalConfigurationRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateBillingPortalConfigurationRequestInput(
    this._res,
  );

  TRes _res;

  call({
    bool? customerUpdateEnabled,
    List<Enum$CustomerUpdate>? allowedCustomerUpdates,
    Enum$UserRole? userRole,
    Enum$SubscriptionTier? subscriptionTier,
    int? subscriptionVersion,
    int? version,
    bool? paymentMethodUpdateEnabled,
    bool? invoiceHistoryEnabled,
    bool? subscriptionCancelEnabled,
    Enum$StripeSubscriptionCancelMode? mode,
    bool? suscriptionUpdateEnabled,
    List<Enum$StripeSubscriptionUpdate>? allowedSubscriptionUpdates,
    List<Input$StripeProductRequestInput>? products,
    Enum$BillingPortalConfigStatus? status,
  }) => _res;

  products(_fn) => _res;
}

class Input$CreateCategoryRequestInput {
  factory Input$CreateCategoryRequestInput({
    required String name,
    required String description,
    required Enum$CategoryType type,
  }) => Input$CreateCategoryRequestInput._({
    r'name': name,
    r'description': description,
    r'type': type,
  });

  Input$CreateCategoryRequestInput._(this._$data);

  factory Input$CreateCategoryRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$type = data['type'];
    result$data['type'] = fromJson$Enum$CategoryType((l$type as String));
    return Input$CreateCategoryRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String get description => (_$data['description'] as String);

  Enum$CategoryType get type => (_$data['type'] as Enum$CategoryType);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$description = description;
    result$data['description'] = l$description;
    final l$type = type;
    result$data['type'] = toJson$Enum$CategoryType(l$type);
    return result$data;
  }

  CopyWith$Input$CreateCategoryRequestInput<Input$CreateCategoryRequestInput>
  get copyWith => CopyWith$Input$CreateCategoryRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateCategoryRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$type = type;
    return Object.hashAll([l$name, l$description, l$type]);
  }
}

abstract class CopyWith$Input$CreateCategoryRequestInput<TRes> {
  factory CopyWith$Input$CreateCategoryRequestInput(
    Input$CreateCategoryRequestInput instance,
    TRes Function(Input$CreateCategoryRequestInput) then,
  ) = _CopyWithImpl$Input$CreateCategoryRequestInput;

  factory CopyWith$Input$CreateCategoryRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCategoryRequestInput;

  TRes call({String? name, String? description, Enum$CategoryType? type});
}

class _CopyWithImpl$Input$CreateCategoryRequestInput<TRes>
    implements CopyWith$Input$CreateCategoryRequestInput<TRes> {
  _CopyWithImpl$Input$CreateCategoryRequestInput(this._instance, this._then);

  final Input$CreateCategoryRequestInput _instance;

  final TRes Function(Input$CreateCategoryRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? type = _undefined,
  }) => _then(
    Input$CreateCategoryRequestInput._({
      ..._instance._$data,
      if (name != _undefined && name != null) 'name': (name as String),
      if (description != _undefined && description != null)
        'description': (description as String),
      if (type != _undefined && type != null)
        'type': (type as Enum$CategoryType),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateCategoryRequestInput<TRes>
    implements CopyWith$Input$CreateCategoryRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateCategoryRequestInput(this._res);

  TRes _res;

  call({String? name, String? description, Enum$CategoryType? type}) => _res;
}

class Input$CreateCommentRequestInput {
  factory Input$CreateCommentRequestInput({
    required String targetId,
    required Enum$CommentType commentType,
    required String content,
    String? parentCommentId,
  }) => Input$CreateCommentRequestInput._({
    r'targetId': targetId,
    r'commentType': commentType,
    r'content': content,
    if (parentCommentId != null) r'parentCommentId': parentCommentId,
  });

  Input$CreateCommentRequestInput._(this._$data);

  factory Input$CreateCommentRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$targetId = data['targetId'];
    result$data['targetId'] = (l$targetId as String);
    final l$commentType = data['commentType'];
    result$data['commentType'] = fromJson$Enum$CommentType(
      (l$commentType as String),
    );
    final l$content = data['content'];
    result$data['content'] = (l$content as String);
    if (data.containsKey('parentCommentId')) {
      final l$parentCommentId = data['parentCommentId'];
      result$data['parentCommentId'] = (l$parentCommentId as String?);
    }
    return Input$CreateCommentRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get targetId => (_$data['targetId'] as String);

  Enum$CommentType get commentType =>
      (_$data['commentType'] as Enum$CommentType);

  String get content => (_$data['content'] as String);

  String? get parentCommentId => (_$data['parentCommentId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$targetId = targetId;
    result$data['targetId'] = l$targetId;
    final l$commentType = commentType;
    result$data['commentType'] = toJson$Enum$CommentType(l$commentType);
    final l$content = content;
    result$data['content'] = l$content;
    if (_$data.containsKey('parentCommentId')) {
      final l$parentCommentId = parentCommentId;
      result$data['parentCommentId'] = l$parentCommentId;
    }
    return result$data;
  }

  CopyWith$Input$CreateCommentRequestInput<Input$CreateCommentRequestInput>
  get copyWith => CopyWith$Input$CreateCommentRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateCommentRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (l$targetId != lOther$targetId) {
      return false;
    }
    final l$commentType = commentType;
    final lOther$commentType = other.commentType;
    if (l$commentType != lOther$commentType) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    final l$parentCommentId = parentCommentId;
    final lOther$parentCommentId = other.parentCommentId;
    if (_$data.containsKey('parentCommentId') !=
        other._$data.containsKey('parentCommentId')) {
      return false;
    }
    if (l$parentCommentId != lOther$parentCommentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$targetId = targetId;
    final l$commentType = commentType;
    final l$content = content;
    final l$parentCommentId = parentCommentId;
    return Object.hashAll([
      l$targetId,
      l$commentType,
      l$content,
      _$data.containsKey('parentCommentId') ? l$parentCommentId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateCommentRequestInput<TRes> {
  factory CopyWith$Input$CreateCommentRequestInput(
    Input$CreateCommentRequestInput instance,
    TRes Function(Input$CreateCommentRequestInput) then,
  ) = _CopyWithImpl$Input$CreateCommentRequestInput;

  factory CopyWith$Input$CreateCommentRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCommentRequestInput;

  TRes call({
    String? targetId,
    Enum$CommentType? commentType,
    String? content,
    String? parentCommentId,
  });
}

class _CopyWithImpl$Input$CreateCommentRequestInput<TRes>
    implements CopyWith$Input$CreateCommentRequestInput<TRes> {
  _CopyWithImpl$Input$CreateCommentRequestInput(this._instance, this._then);

  final Input$CreateCommentRequestInput _instance;

  final TRes Function(Input$CreateCommentRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? targetId = _undefined,
    Object? commentType = _undefined,
    Object? content = _undefined,
    Object? parentCommentId = _undefined,
  }) => _then(
    Input$CreateCommentRequestInput._({
      ..._instance._$data,
      if (targetId != _undefined && targetId != null)
        'targetId': (targetId as String),
      if (commentType != _undefined && commentType != null)
        'commentType': (commentType as Enum$CommentType),
      if (content != _undefined && content != null)
        'content': (content as String),
      if (parentCommentId != _undefined)
        'parentCommentId': (parentCommentId as String?),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateCommentRequestInput<TRes>
    implements CopyWith$Input$CreateCommentRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateCommentRequestInput(this._res);

  TRes _res;

  call({
    String? targetId,
    Enum$CommentType? commentType,
    String? content,
    String? parentCommentId,
  }) => _res;
}

class Input$CreateConversationRequestInput {
  factory Input$CreateConversationRequestInput({
    required String otherUserId,
    required String requestHubId,
  }) => Input$CreateConversationRequestInput._({
    r'otherUserId': otherUserId,
    r'requestHubId': requestHubId,
  });

  Input$CreateConversationRequestInput._(this._$data);

  factory Input$CreateConversationRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$otherUserId = data['otherUserId'];
    result$data['otherUserId'] = (l$otherUserId as String);
    final l$requestHubId = data['requestHubId'];
    result$data['requestHubId'] = (l$requestHubId as String);
    return Input$CreateConversationRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get otherUserId => (_$data['otherUserId'] as String);

  String get requestHubId => (_$data['requestHubId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$otherUserId = otherUserId;
    result$data['otherUserId'] = l$otherUserId;
    final l$requestHubId = requestHubId;
    result$data['requestHubId'] = l$requestHubId;
    return result$data;
  }

  CopyWith$Input$CreateConversationRequestInput<
    Input$CreateConversationRequestInput
  >
  get copyWith => CopyWith$Input$CreateConversationRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateConversationRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$otherUserId = otherUserId;
    final lOther$otherUserId = other.otherUserId;
    if (l$otherUserId != lOther$otherUserId) {
      return false;
    }
    final l$requestHubId = requestHubId;
    final lOther$requestHubId = other.requestHubId;
    if (l$requestHubId != lOther$requestHubId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$otherUserId = otherUserId;
    final l$requestHubId = requestHubId;
    return Object.hashAll([l$otherUserId, l$requestHubId]);
  }
}

abstract class CopyWith$Input$CreateConversationRequestInput<TRes> {
  factory CopyWith$Input$CreateConversationRequestInput(
    Input$CreateConversationRequestInput instance,
    TRes Function(Input$CreateConversationRequestInput) then,
  ) = _CopyWithImpl$Input$CreateConversationRequestInput;

  factory CopyWith$Input$CreateConversationRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateConversationRequestInput;

  TRes call({String? otherUserId, String? requestHubId});
}

class _CopyWithImpl$Input$CreateConversationRequestInput<TRes>
    implements CopyWith$Input$CreateConversationRequestInput<TRes> {
  _CopyWithImpl$Input$CreateConversationRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreateConversationRequestInput _instance;

  final TRes Function(Input$CreateConversationRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? otherUserId = _undefined,
    Object? requestHubId = _undefined,
  }) => _then(
    Input$CreateConversationRequestInput._({
      ..._instance._$data,
      if (otherUserId != _undefined && otherUserId != null)
        'otherUserId': (otherUserId as String),
      if (requestHubId != _undefined && requestHubId != null)
        'requestHubId': (requestHubId as String),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateConversationRequestInput<TRes>
    implements CopyWith$Input$CreateConversationRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateConversationRequestInput(this._res);

  TRes _res;

  call({String? otherUserId, String? requestHubId}) => _res;
}

class Input$CreateCouponRequestInput {
  factory Input$CreateCouponRequestInput({
    required String name,
    String? description,
    required String code,
    required double percentOff,
    required Enum$CouponDurationType duration,
    required Enum$CouponPurposeType purpose,
    required Enum$CouponStatus status,
  }) => Input$CreateCouponRequestInput._({
    r'name': name,
    if (description != null) r'description': description,
    r'code': code,
    r'percentOff': percentOff,
    r'duration': duration,
    r'purpose': purpose,
    r'status': status,
  });

  Input$CreateCouponRequestInput._(this._$data);

  factory Input$CreateCouponRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$code = data['code'];
    result$data['code'] = (l$code as String);
    final l$percentOff = data['percentOff'];
    result$data['percentOff'] = (l$percentOff as num).toDouble();
    final l$duration = data['duration'];
    result$data['duration'] = fromJson$Enum$CouponDurationType(
      (l$duration as String),
    );
    final l$purpose = data['purpose'];
    result$data['purpose'] = fromJson$Enum$CouponPurposeType(
      (l$purpose as String),
    );
    final l$status = data['status'];
    result$data['status'] = fromJson$Enum$CouponStatus((l$status as String));
    return Input$CreateCouponRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get description => (_$data['description'] as String?);

  String get code => (_$data['code'] as String);

  double get percentOff => (_$data['percentOff'] as double);

  Enum$CouponDurationType get duration =>
      (_$data['duration'] as Enum$CouponDurationType);

  Enum$CouponPurposeType get purpose =>
      (_$data['purpose'] as Enum$CouponPurposeType);

  Enum$CouponStatus get status => (_$data['status'] as Enum$CouponStatus);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$code = code;
    result$data['code'] = l$code;
    final l$percentOff = percentOff;
    result$data['percentOff'] = l$percentOff;
    final l$duration = duration;
    result$data['duration'] = toJson$Enum$CouponDurationType(l$duration);
    final l$purpose = purpose;
    result$data['purpose'] = toJson$Enum$CouponPurposeType(l$purpose);
    final l$status = status;
    result$data['status'] = toJson$Enum$CouponStatus(l$status);
    return result$data;
  }

  CopyWith$Input$CreateCouponRequestInput<Input$CreateCouponRequestInput>
  get copyWith => CopyWith$Input$CreateCouponRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateCouponRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (l$code != lOther$code) {
      return false;
    }
    final l$percentOff = percentOff;
    final lOther$percentOff = other.percentOff;
    if (l$percentOff != lOther$percentOff) {
      return false;
    }
    final l$duration = duration;
    final lOther$duration = other.duration;
    if (l$duration != lOther$duration) {
      return false;
    }
    final l$purpose = purpose;
    final lOther$purpose = other.purpose;
    if (l$purpose != lOther$purpose) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$code = code;
    final l$percentOff = percentOff;
    final l$duration = duration;
    final l$purpose = purpose;
    final l$status = status;
    return Object.hashAll([
      l$name,
      _$data.containsKey('description') ? l$description : const {},
      l$code,
      l$percentOff,
      l$duration,
      l$purpose,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$CreateCouponRequestInput<TRes> {
  factory CopyWith$Input$CreateCouponRequestInput(
    Input$CreateCouponRequestInput instance,
    TRes Function(Input$CreateCouponRequestInput) then,
  ) = _CopyWithImpl$Input$CreateCouponRequestInput;

  factory CopyWith$Input$CreateCouponRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCouponRequestInput;

  TRes call({
    String? name,
    String? description,
    String? code,
    double? percentOff,
    Enum$CouponDurationType? duration,
    Enum$CouponPurposeType? purpose,
    Enum$CouponStatus? status,
  });
}

class _CopyWithImpl$Input$CreateCouponRequestInput<TRes>
    implements CopyWith$Input$CreateCouponRequestInput<TRes> {
  _CopyWithImpl$Input$CreateCouponRequestInput(this._instance, this._then);

  final Input$CreateCouponRequestInput _instance;

  final TRes Function(Input$CreateCouponRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? code = _undefined,
    Object? percentOff = _undefined,
    Object? duration = _undefined,
    Object? purpose = _undefined,
    Object? status = _undefined,
  }) => _then(
    Input$CreateCouponRequestInput._({
      ..._instance._$data,
      if (name != _undefined && name != null) 'name': (name as String),
      if (description != _undefined) 'description': (description as String?),
      if (code != _undefined && code != null) 'code': (code as String),
      if (percentOff != _undefined && percentOff != null)
        'percentOff': (percentOff as double),
      if (duration != _undefined && duration != null)
        'duration': (duration as Enum$CouponDurationType),
      if (purpose != _undefined && purpose != null)
        'purpose': (purpose as Enum$CouponPurposeType),
      if (status != _undefined && status != null)
        'status': (status as Enum$CouponStatus),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateCouponRequestInput<TRes>
    implements CopyWith$Input$CreateCouponRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateCouponRequestInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    String? code,
    double? percentOff,
    Enum$CouponDurationType? duration,
    Enum$CouponPurposeType? purpose,
    Enum$CouponStatus? status,
  }) => _res;
}

class Input$CreateDirectRequestInput {
  factory Input$CreateDirectRequestInput({
    String? publicRequestId,
    required String artistId,
    required DateTime deadline,
    String? requirements,
    required String packageId,
  }) => Input$CreateDirectRequestInput._({
    if (publicRequestId != null) r'publicRequestId': publicRequestId,
    r'artistId': artistId,
    r'deadline': deadline,
    if (requirements != null) r'requirements': requirements,
    r'packageId': packageId,
  });

  Input$CreateDirectRequestInput._(this._$data);

  factory Input$CreateDirectRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('publicRequestId')) {
      final l$publicRequestId = data['publicRequestId'];
      result$data['publicRequestId'] = (l$publicRequestId as String?);
    }
    final l$artistId = data['artistId'];
    result$data['artistId'] = (l$artistId as String);
    final l$deadline = data['deadline'];
    result$data['deadline'] = DateTime.parse((l$deadline as String));
    if (data.containsKey('requirements')) {
      final l$requirements = data['requirements'];
      result$data['requirements'] = (l$requirements as String?);
    }
    final l$packageId = data['packageId'];
    result$data['packageId'] = (l$packageId as String);
    return Input$CreateDirectRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get publicRequestId => (_$data['publicRequestId'] as String?);

  String get artistId => (_$data['artistId'] as String);

  DateTime get deadline => (_$data['deadline'] as DateTime);

  String? get requirements => (_$data['requirements'] as String?);

  String get packageId => (_$data['packageId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('publicRequestId')) {
      final l$publicRequestId = publicRequestId;
      result$data['publicRequestId'] = l$publicRequestId;
    }
    final l$artistId = artistId;
    result$data['artistId'] = l$artistId;
    final l$deadline = deadline;
    result$data['deadline'] = l$deadline.toIso8601String();
    if (_$data.containsKey('requirements')) {
      final l$requirements = requirements;
      result$data['requirements'] = l$requirements;
    }
    final l$packageId = packageId;
    result$data['packageId'] = l$packageId;
    return result$data;
  }

  CopyWith$Input$CreateDirectRequestInput<Input$CreateDirectRequestInput>
  get copyWith => CopyWith$Input$CreateDirectRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateDirectRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$publicRequestId = publicRequestId;
    final lOther$publicRequestId = other.publicRequestId;
    if (_$data.containsKey('publicRequestId') !=
        other._$data.containsKey('publicRequestId')) {
      return false;
    }
    if (l$publicRequestId != lOther$publicRequestId) {
      return false;
    }
    final l$artistId = artistId;
    final lOther$artistId = other.artistId;
    if (l$artistId != lOther$artistId) {
      return false;
    }
    final l$deadline = deadline;
    final lOther$deadline = other.deadline;
    if (l$deadline != lOther$deadline) {
      return false;
    }
    final l$requirements = requirements;
    final lOther$requirements = other.requirements;
    if (_$data.containsKey('requirements') !=
        other._$data.containsKey('requirements')) {
      return false;
    }
    if (l$requirements != lOther$requirements) {
      return false;
    }
    final l$packageId = packageId;
    final lOther$packageId = other.packageId;
    if (l$packageId != lOther$packageId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$publicRequestId = publicRequestId;
    final l$artistId = artistId;
    final l$deadline = deadline;
    final l$requirements = requirements;
    final l$packageId = packageId;
    return Object.hashAll([
      _$data.containsKey('publicRequestId') ? l$publicRequestId : const {},
      l$artistId,
      l$deadline,
      _$data.containsKey('requirements') ? l$requirements : const {},
      l$packageId,
    ]);
  }
}

abstract class CopyWith$Input$CreateDirectRequestInput<TRes> {
  factory CopyWith$Input$CreateDirectRequestInput(
    Input$CreateDirectRequestInput instance,
    TRes Function(Input$CreateDirectRequestInput) then,
  ) = _CopyWithImpl$Input$CreateDirectRequestInput;

  factory CopyWith$Input$CreateDirectRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateDirectRequestInput;

  TRes call({
    String? publicRequestId,
    String? artistId,
    DateTime? deadline,
    String? requirements,
    String? packageId,
  });
}

class _CopyWithImpl$Input$CreateDirectRequestInput<TRes>
    implements CopyWith$Input$CreateDirectRequestInput<TRes> {
  _CopyWithImpl$Input$CreateDirectRequestInput(this._instance, this._then);

  final Input$CreateDirectRequestInput _instance;

  final TRes Function(Input$CreateDirectRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? publicRequestId = _undefined,
    Object? artistId = _undefined,
    Object? deadline = _undefined,
    Object? requirements = _undefined,
    Object? packageId = _undefined,
  }) => _then(
    Input$CreateDirectRequestInput._({
      ..._instance._$data,
      if (publicRequestId != _undefined)
        'publicRequestId': (publicRequestId as String?),
      if (artistId != _undefined && artistId != null)
        'artistId': (artistId as String),
      if (deadline != _undefined && deadline != null)
        'deadline': (deadline as DateTime),
      if (requirements != _undefined) 'requirements': (requirements as String?),
      if (packageId != _undefined && packageId != null)
        'packageId': (packageId as String),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateDirectRequestInput<TRes>
    implements CopyWith$Input$CreateDirectRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateDirectRequestInput(this._res);

  TRes _res;

  call({
    String? publicRequestId,
    String? artistId,
    DateTime? deadline,
    String? requirements,
    String? packageId,
  }) => _res;
}

class Input$CreateEntitlementRequestInput {
  factory Input$CreateEntitlementRequestInput({
    required dynamic defaultValues,
    required String name,
    required String code,
    required String description,
    required Enum$EntitlementValueType valueType,
    required List<Input$CreateEntitlementSubscriptionOverrideRequestInput>
    subscriptionOverrides,
    required bool isActive,
  }) => Input$CreateEntitlementRequestInput._({
    r'defaultValues': defaultValues,
    r'name': name,
    r'code': code,
    r'description': description,
    r'valueType': valueType,
    r'subscriptionOverrides': subscriptionOverrides,
    r'isActive': isActive,
  });

  Input$CreateEntitlementRequestInput._(this._$data);

  factory Input$CreateEntitlementRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$defaultValues = data['defaultValues'];
    result$data['defaultValues'] = (l$defaultValues as dynamic);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$code = data['code'];
    result$data['code'] = (l$code as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$valueType = data['valueType'];
    result$data['valueType'] = fromJson$Enum$EntitlementValueType(
      (l$valueType as String),
    );
    final l$subscriptionOverrides = data['subscriptionOverrides'];
    result$data['subscriptionOverrides'] =
        (l$subscriptionOverrides as List<dynamic>)
            .map(
              (e) =>
                  Input$CreateEntitlementSubscriptionOverrideRequestInput.fromJson(
                    (e as Map<String, dynamic>),
                  ),
            )
            .toList();
    final l$isActive = data['isActive'];
    result$data['isActive'] = (l$isActive as bool);
    return Input$CreateEntitlementRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  dynamic get defaultValues => (_$data['defaultValues'] as dynamic);

  String get name => (_$data['name'] as String);

  String get code => (_$data['code'] as String);

  String get description => (_$data['description'] as String);

  Enum$EntitlementValueType get valueType =>
      (_$data['valueType'] as Enum$EntitlementValueType);

  List<Input$CreateEntitlementSubscriptionOverrideRequestInput>
  get subscriptionOverrides =>
      (_$data['subscriptionOverrides']
          as List<Input$CreateEntitlementSubscriptionOverrideRequestInput>);

  bool get isActive => (_$data['isActive'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$defaultValues = defaultValues;
    result$data['defaultValues'] = l$defaultValues;
    final l$name = name;
    result$data['name'] = l$name;
    final l$code = code;
    result$data['code'] = l$code;
    final l$description = description;
    result$data['description'] = l$description;
    final l$valueType = valueType;
    result$data['valueType'] = toJson$Enum$EntitlementValueType(l$valueType);
    final l$subscriptionOverrides = subscriptionOverrides;
    result$data['subscriptionOverrides'] = l$subscriptionOverrides
        .map((e) => e.toJson())
        .toList();
    final l$isActive = isActive;
    result$data['isActive'] = l$isActive;
    return result$data;
  }

  CopyWith$Input$CreateEntitlementRequestInput<
    Input$CreateEntitlementRequestInput
  >
  get copyWith => CopyWith$Input$CreateEntitlementRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateEntitlementRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$defaultValues = defaultValues;
    final lOther$defaultValues = other.defaultValues;
    if (l$defaultValues != lOther$defaultValues) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (l$code != lOther$code) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$valueType = valueType;
    final lOther$valueType = other.valueType;
    if (l$valueType != lOther$valueType) {
      return false;
    }
    final l$subscriptionOverrides = subscriptionOverrides;
    final lOther$subscriptionOverrides = other.subscriptionOverrides;
    if (l$subscriptionOverrides.length != lOther$subscriptionOverrides.length) {
      return false;
    }
    for (int i = 0; i < l$subscriptionOverrides.length; i++) {
      final l$subscriptionOverrides$entry = l$subscriptionOverrides[i];
      final lOther$subscriptionOverrides$entry =
          lOther$subscriptionOverrides[i];
      if (l$subscriptionOverrides$entry != lOther$subscriptionOverrides$entry) {
        return false;
      }
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (l$isActive != lOther$isActive) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$defaultValues = defaultValues;
    final l$name = name;
    final l$code = code;
    final l$description = description;
    final l$valueType = valueType;
    final l$subscriptionOverrides = subscriptionOverrides;
    final l$isActive = isActive;
    return Object.hashAll([
      l$defaultValues,
      l$name,
      l$code,
      l$description,
      l$valueType,
      Object.hashAll(l$subscriptionOverrides.map((v) => v)),
      l$isActive,
    ]);
  }
}

abstract class CopyWith$Input$CreateEntitlementRequestInput<TRes> {
  factory CopyWith$Input$CreateEntitlementRequestInput(
    Input$CreateEntitlementRequestInput instance,
    TRes Function(Input$CreateEntitlementRequestInput) then,
  ) = _CopyWithImpl$Input$CreateEntitlementRequestInput;

  factory CopyWith$Input$CreateEntitlementRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateEntitlementRequestInput;

  TRes call({
    dynamic? defaultValues,
    String? name,
    String? code,
    String? description,
    Enum$EntitlementValueType? valueType,
    List<Input$CreateEntitlementSubscriptionOverrideRequestInput>?
    subscriptionOverrides,
    bool? isActive,
  });
  TRes subscriptionOverrides(
    Iterable<Input$CreateEntitlementSubscriptionOverrideRequestInput> Function(
      Iterable<
        CopyWith$Input$CreateEntitlementSubscriptionOverrideRequestInput<
          Input$CreateEntitlementSubscriptionOverrideRequestInput
        >
      >,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$CreateEntitlementRequestInput<TRes>
    implements CopyWith$Input$CreateEntitlementRequestInput<TRes> {
  _CopyWithImpl$Input$CreateEntitlementRequestInput(this._instance, this._then);

  final Input$CreateEntitlementRequestInput _instance;

  final TRes Function(Input$CreateEntitlementRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? defaultValues = _undefined,
    Object? name = _undefined,
    Object? code = _undefined,
    Object? description = _undefined,
    Object? valueType = _undefined,
    Object? subscriptionOverrides = _undefined,
    Object? isActive = _undefined,
  }) => _then(
    Input$CreateEntitlementRequestInput._({
      ..._instance._$data,
      if (defaultValues != _undefined && defaultValues != null)
        'defaultValues': (defaultValues as dynamic),
      if (name != _undefined && name != null) 'name': (name as String),
      if (code != _undefined && code != null) 'code': (code as String),
      if (description != _undefined && description != null)
        'description': (description as String),
      if (valueType != _undefined && valueType != null)
        'valueType': (valueType as Enum$EntitlementValueType),
      if (subscriptionOverrides != _undefined && subscriptionOverrides != null)
        'subscriptionOverrides':
            (subscriptionOverrides
                as List<
                  Input$CreateEntitlementSubscriptionOverrideRequestInput
                >),
      if (isActive != _undefined && isActive != null)
        'isActive': (isActive as bool),
    }),
  );

  TRes subscriptionOverrides(
    Iterable<Input$CreateEntitlementSubscriptionOverrideRequestInput> Function(
      Iterable<
        CopyWith$Input$CreateEntitlementSubscriptionOverrideRequestInput<
          Input$CreateEntitlementSubscriptionOverrideRequestInput
        >
      >,
    )
    _fn,
  ) => call(
    subscriptionOverrides: _fn(
      _instance.subscriptionOverrides.map(
        (e) => CopyWith$Input$CreateEntitlementSubscriptionOverrideRequestInput(
          e,
          (i) => i,
        ),
      ),
    ).toList(),
  );
}

class _CopyWithStubImpl$Input$CreateEntitlementRequestInput<TRes>
    implements CopyWith$Input$CreateEntitlementRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateEntitlementRequestInput(this._res);

  TRes _res;

  call({
    dynamic? defaultValues,
    String? name,
    String? code,
    String? description,
    Enum$EntitlementValueType? valueType,
    List<Input$CreateEntitlementSubscriptionOverrideRequestInput>?
    subscriptionOverrides,
    bool? isActive,
  }) => _res;

  subscriptionOverrides(_fn) => _res;
}

class Input$CreateEntitlementSubscriptionOverrideRequestInput {
  factory Input$CreateEntitlementSubscriptionOverrideRequestInput({
    required String subscriptionCode,
  }) => Input$CreateEntitlementSubscriptionOverrideRequestInput._({
    r'subscriptionCode': subscriptionCode,
  });

  Input$CreateEntitlementSubscriptionOverrideRequestInput._(this._$data);

  factory Input$CreateEntitlementSubscriptionOverrideRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$subscriptionCode = data['subscriptionCode'];
    result$data['subscriptionCode'] = (l$subscriptionCode as String);
    return Input$CreateEntitlementSubscriptionOverrideRequestInput._(
      result$data,
    );
  }

  Map<String, dynamic> _$data;

  String get subscriptionCode => (_$data['subscriptionCode'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$subscriptionCode = subscriptionCode;
    result$data['subscriptionCode'] = l$subscriptionCode;
    return result$data;
  }

  CopyWith$Input$CreateEntitlementSubscriptionOverrideRequestInput<
    Input$CreateEntitlementSubscriptionOverrideRequestInput
  >
  get copyWith =>
      CopyWith$Input$CreateEntitlementSubscriptionOverrideRequestInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateEntitlementSubscriptionOverrideRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$subscriptionCode = subscriptionCode;
    final lOther$subscriptionCode = other.subscriptionCode;
    if (l$subscriptionCode != lOther$subscriptionCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subscriptionCode = subscriptionCode;
    return Object.hashAll([l$subscriptionCode]);
  }
}

abstract class CopyWith$Input$CreateEntitlementSubscriptionOverrideRequestInput<
  TRes
> {
  factory CopyWith$Input$CreateEntitlementSubscriptionOverrideRequestInput(
    Input$CreateEntitlementSubscriptionOverrideRequestInput instance,
    TRes Function(Input$CreateEntitlementSubscriptionOverrideRequestInput) then,
  ) = _CopyWithImpl$Input$CreateEntitlementSubscriptionOverrideRequestInput;

  factory CopyWith$Input$CreateEntitlementSubscriptionOverrideRequestInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$CreateEntitlementSubscriptionOverrideRequestInput;

  TRes call({String? subscriptionCode});
}

class _CopyWithImpl$Input$CreateEntitlementSubscriptionOverrideRequestInput<
  TRes
>
    implements
        CopyWith$Input$CreateEntitlementSubscriptionOverrideRequestInput<TRes> {
  _CopyWithImpl$Input$CreateEntitlementSubscriptionOverrideRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreateEntitlementSubscriptionOverrideRequestInput _instance;

  final TRes Function(Input$CreateEntitlementSubscriptionOverrideRequestInput)
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? subscriptionCode = _undefined}) => _then(
    Input$CreateEntitlementSubscriptionOverrideRequestInput._({
      ..._instance._$data,
      if (subscriptionCode != _undefined && subscriptionCode != null)
        'subscriptionCode': (subscriptionCode as String),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateEntitlementSubscriptionOverrideRequestInput<
  TRes
>
    implements
        CopyWith$Input$CreateEntitlementSubscriptionOverrideRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateEntitlementSubscriptionOverrideRequestInput(
    this._res,
  );

  TRes _res;

  call({String? subscriptionCode}) => _res;
}

class Input$CreateEscrowCommissionPolicyRequestInput {
  factory Input$CreateEscrowCommissionPolicyRequestInput({
    required Enum$CurrencyType currency,
    required double platformFeePercentage,
  }) => Input$CreateEscrowCommissionPolicyRequestInput._({
    r'currency': currency,
    r'platformFeePercentage': platformFeePercentage,
  });

  Input$CreateEscrowCommissionPolicyRequestInput._(this._$data);

  factory Input$CreateEscrowCommissionPolicyRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$currency = data['currency'];
    result$data['currency'] = fromJson$Enum$CurrencyType(
      (l$currency as String),
    );
    final l$platformFeePercentage = data['platformFeePercentage'];
    result$data['platformFeePercentage'] = (l$platformFeePercentage as num)
        .toDouble();
    return Input$CreateEscrowCommissionPolicyRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CurrencyType get currency => (_$data['currency'] as Enum$CurrencyType);

  double get platformFeePercentage =>
      (_$data['platformFeePercentage'] as double);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$currency = currency;
    result$data['currency'] = toJson$Enum$CurrencyType(l$currency);
    final l$platformFeePercentage = platformFeePercentage;
    result$data['platformFeePercentage'] = l$platformFeePercentage;
    return result$data;
  }

  CopyWith$Input$CreateEscrowCommissionPolicyRequestInput<
    Input$CreateEscrowCommissionPolicyRequestInput
  >
  get copyWith =>
      CopyWith$Input$CreateEscrowCommissionPolicyRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateEscrowCommissionPolicyRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$platformFeePercentage = platformFeePercentage;
    final lOther$platformFeePercentage = other.platformFeePercentage;
    if (l$platformFeePercentage != lOther$platformFeePercentage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$currency = currency;
    final l$platformFeePercentage = platformFeePercentage;
    return Object.hashAll([l$currency, l$platformFeePercentage]);
  }
}

abstract class CopyWith$Input$CreateEscrowCommissionPolicyRequestInput<TRes> {
  factory CopyWith$Input$CreateEscrowCommissionPolicyRequestInput(
    Input$CreateEscrowCommissionPolicyRequestInput instance,
    TRes Function(Input$CreateEscrowCommissionPolicyRequestInput) then,
  ) = _CopyWithImpl$Input$CreateEscrowCommissionPolicyRequestInput;

  factory CopyWith$Input$CreateEscrowCommissionPolicyRequestInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$CreateEscrowCommissionPolicyRequestInput;

  TRes call({Enum$CurrencyType? currency, double? platformFeePercentage});
}

class _CopyWithImpl$Input$CreateEscrowCommissionPolicyRequestInput<TRes>
    implements CopyWith$Input$CreateEscrowCommissionPolicyRequestInput<TRes> {
  _CopyWithImpl$Input$CreateEscrowCommissionPolicyRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreateEscrowCommissionPolicyRequestInput _instance;

  final TRes Function(Input$CreateEscrowCommissionPolicyRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? currency = _undefined,
    Object? platformFeePercentage = _undefined,
  }) => _then(
    Input$CreateEscrowCommissionPolicyRequestInput._({
      ..._instance._$data,
      if (currency != _undefined && currency != null)
        'currency': (currency as Enum$CurrencyType),
      if (platformFeePercentage != _undefined && platformFeePercentage != null)
        'platformFeePercentage': (platformFeePercentage as double),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateEscrowCommissionPolicyRequestInput<TRes>
    implements CopyWith$Input$CreateEscrowCommissionPolicyRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateEscrowCommissionPolicyRequestInput(this._res);

  TRes _res;

  call({Enum$CurrencyType? currency, double? platformFeePercentage}) => _res;
}

class Input$CreateLegalPolicyRequestInput {
  factory Input$CreateLegalPolicyRequestInput({
    required String name,
    required String content,
    required bool isActive,
  }) => Input$CreateLegalPolicyRequestInput._({
    r'name': name,
    r'content': content,
    r'isActive': isActive,
  });

  Input$CreateLegalPolicyRequestInput._(this._$data);

  factory Input$CreateLegalPolicyRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$content = data['content'];
    result$data['content'] = (l$content as String);
    final l$isActive = data['isActive'];
    result$data['isActive'] = (l$isActive as bool);
    return Input$CreateLegalPolicyRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String get content => (_$data['content'] as String);

  bool get isActive => (_$data['isActive'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$content = content;
    result$data['content'] = l$content;
    final l$isActive = isActive;
    result$data['isActive'] = l$isActive;
    return result$data;
  }

  CopyWith$Input$CreateLegalPolicyRequestInput<
    Input$CreateLegalPolicyRequestInput
  >
  get copyWith => CopyWith$Input$CreateLegalPolicyRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateLegalPolicyRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (l$isActive != lOther$isActive) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$content = content;
    final l$isActive = isActive;
    return Object.hashAll([l$name, l$content, l$isActive]);
  }
}

abstract class CopyWith$Input$CreateLegalPolicyRequestInput<TRes> {
  factory CopyWith$Input$CreateLegalPolicyRequestInput(
    Input$CreateLegalPolicyRequestInput instance,
    TRes Function(Input$CreateLegalPolicyRequestInput) then,
  ) = _CopyWithImpl$Input$CreateLegalPolicyRequestInput;

  factory CopyWith$Input$CreateLegalPolicyRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateLegalPolicyRequestInput;

  TRes call({String? name, String? content, bool? isActive});
}

class _CopyWithImpl$Input$CreateLegalPolicyRequestInput<TRes>
    implements CopyWith$Input$CreateLegalPolicyRequestInput<TRes> {
  _CopyWithImpl$Input$CreateLegalPolicyRequestInput(this._instance, this._then);

  final Input$CreateLegalPolicyRequestInput _instance;

  final TRes Function(Input$CreateLegalPolicyRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? content = _undefined,
    Object? isActive = _undefined,
  }) => _then(
    Input$CreateLegalPolicyRequestInput._({
      ..._instance._$data,
      if (name != _undefined && name != null) 'name': (name as String),
      if (content != _undefined && content != null)
        'content': (content as String),
      if (isActive != _undefined && isActive != null)
        'isActive': (isActive as bool),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateLegalPolicyRequestInput<TRes>
    implements CopyWith$Input$CreateLegalPolicyRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateLegalPolicyRequestInput(this._res);

  TRes _res;

  call({String? name, String? content, bool? isActive}) => _res;
}

class Input$CreateModeratorRequestInput {
  factory Input$CreateModeratorRequestInput({
    required String fullName,
    required String email,
    required String password,
  }) => Input$CreateModeratorRequestInput._({
    r'fullName': fullName,
    r'email': email,
    r'password': password,
  });

  Input$CreateModeratorRequestInput._(this._$data);

  factory Input$CreateModeratorRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$fullName = data['fullName'];
    result$data['fullName'] = (l$fullName as String);
    final l$email = data['email'];
    result$data['email'] = (l$email as String);
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    return Input$CreateModeratorRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get fullName => (_$data['fullName'] as String);

  String get email => (_$data['email'] as String);

  String get password => (_$data['password'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$fullName = fullName;
    result$data['fullName'] = l$fullName;
    final l$email = email;
    result$data['email'] = l$email;
    final l$password = password;
    result$data['password'] = l$password;
    return result$data;
  }

  CopyWith$Input$CreateModeratorRequestInput<Input$CreateModeratorRequestInput>
  get copyWith => CopyWith$Input$CreateModeratorRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateModeratorRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    return Object.hashAll([l$fullName, l$email, l$password]);
  }
}

abstract class CopyWith$Input$CreateModeratorRequestInput<TRes> {
  factory CopyWith$Input$CreateModeratorRequestInput(
    Input$CreateModeratorRequestInput instance,
    TRes Function(Input$CreateModeratorRequestInput) then,
  ) = _CopyWithImpl$Input$CreateModeratorRequestInput;

  factory CopyWith$Input$CreateModeratorRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateModeratorRequestInput;

  TRes call({String? fullName, String? email, String? password});
}

class _CopyWithImpl$Input$CreateModeratorRequestInput<TRes>
    implements CopyWith$Input$CreateModeratorRequestInput<TRes> {
  _CopyWithImpl$Input$CreateModeratorRequestInput(this._instance, this._then);

  final Input$CreateModeratorRequestInput _instance;

  final TRes Function(Input$CreateModeratorRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
  }) => _then(
    Input$CreateModeratorRequestInput._({
      ..._instance._$data,
      if (fullName != _undefined && fullName != null)
        'fullName': (fullName as String),
      if (email != _undefined && email != null) 'email': (email as String),
      if (password != _undefined && password != null)
        'password': (password as String),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateModeratorRequestInput<TRes>
    implements CopyWith$Input$CreateModeratorRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateModeratorRequestInput(this._res);

  TRes _res;

  call({String? fullName, String? email, String? password}) => _res;
}

class Input$CreateMomoPaymentRequestInput {
  factory Input$CreateMomoPaymentRequestInput({
    required int amount,
    required String orderId,
    required String orderInfo,
  }) => Input$CreateMomoPaymentRequestInput._({
    r'amount': amount,
    r'orderId': orderId,
    r'orderInfo': orderInfo,
  });

  Input$CreateMomoPaymentRequestInput._(this._$data);

  factory Input$CreateMomoPaymentRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$amount = data['amount'];
    result$data['amount'] = (l$amount as int);
    final l$orderId = data['orderId'];
    result$data['orderId'] = (l$orderId as String);
    final l$orderInfo = data['orderInfo'];
    result$data['orderInfo'] = (l$orderInfo as String);
    return Input$CreateMomoPaymentRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get amount => (_$data['amount'] as int);

  String get orderId => (_$data['orderId'] as String);

  String get orderInfo => (_$data['orderInfo'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$amount = amount;
    result$data['amount'] = l$amount;
    final l$orderId = orderId;
    result$data['orderId'] = l$orderId;
    final l$orderInfo = orderInfo;
    result$data['orderInfo'] = l$orderInfo;
    return result$data;
  }

  CopyWith$Input$CreateMomoPaymentRequestInput<
    Input$CreateMomoPaymentRequestInput
  >
  get copyWith => CopyWith$Input$CreateMomoPaymentRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateMomoPaymentRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$orderId = orderId;
    final lOther$orderId = other.orderId;
    if (l$orderId != lOther$orderId) {
      return false;
    }
    final l$orderInfo = orderInfo;
    final lOther$orderInfo = other.orderInfo;
    if (l$orderInfo != lOther$orderInfo) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$orderId = orderId;
    final l$orderInfo = orderInfo;
    return Object.hashAll([l$amount, l$orderId, l$orderInfo]);
  }
}

abstract class CopyWith$Input$CreateMomoPaymentRequestInput<TRes> {
  factory CopyWith$Input$CreateMomoPaymentRequestInput(
    Input$CreateMomoPaymentRequestInput instance,
    TRes Function(Input$CreateMomoPaymentRequestInput) then,
  ) = _CopyWithImpl$Input$CreateMomoPaymentRequestInput;

  factory CopyWith$Input$CreateMomoPaymentRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateMomoPaymentRequestInput;

  TRes call({int? amount, String? orderId, String? orderInfo});
}

class _CopyWithImpl$Input$CreateMomoPaymentRequestInput<TRes>
    implements CopyWith$Input$CreateMomoPaymentRequestInput<TRes> {
  _CopyWithImpl$Input$CreateMomoPaymentRequestInput(this._instance, this._then);

  final Input$CreateMomoPaymentRequestInput _instance;

  final TRes Function(Input$CreateMomoPaymentRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? orderId = _undefined,
    Object? orderInfo = _undefined,
  }) => _then(
    Input$CreateMomoPaymentRequestInput._({
      ..._instance._$data,
      if (amount != _undefined && amount != null) 'amount': (amount as int),
      if (orderId != _undefined && orderId != null)
        'orderId': (orderId as String),
      if (orderInfo != _undefined && orderInfo != null)
        'orderInfo': (orderInfo as String),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateMomoPaymentRequestInput<TRes>
    implements CopyWith$Input$CreateMomoPaymentRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateMomoPaymentRequestInput(this._res);

  TRes _res;

  call({int? amount, String? orderId, String? orderInfo}) => _res;
}

class Input$CreatePaymentCheckoutSessionRequestInput {
  factory Input$CreatePaymentCheckoutSessionRequestInput({
    required String packageId,
    required String requestHubId,
    required String successUrl,
    required String cancelUrl,
    required bool isSavePaymentMethod,
    required bool isReceiptEmail,
    required String conversationId,
    required List<String> requirementFiles,
    required List<Input$PackageOrderDeliveryInput> deliveries,
    required DateTime deadline,
  }) => Input$CreatePaymentCheckoutSessionRequestInput._({
    r'packageId': packageId,
    r'requestHubId': requestHubId,
    r'successUrl': successUrl,
    r'cancelUrl': cancelUrl,
    r'isSavePaymentMethod': isSavePaymentMethod,
    r'isReceiptEmail': isReceiptEmail,
    r'conversationId': conversationId,
    r'requirementFiles': requirementFiles,
    r'deliveries': deliveries,
    r'deadline': deadline,
  });

  Input$CreatePaymentCheckoutSessionRequestInput._(this._$data);

  factory Input$CreatePaymentCheckoutSessionRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$packageId = data['packageId'];
    result$data['packageId'] = (l$packageId as String);
    final l$requestHubId = data['requestHubId'];
    result$data['requestHubId'] = (l$requestHubId as String);
    final l$successUrl = data['successUrl'];
    result$data['successUrl'] = (l$successUrl as String);
    final l$cancelUrl = data['cancelUrl'];
    result$data['cancelUrl'] = (l$cancelUrl as String);
    final l$isSavePaymentMethod = data['isSavePaymentMethod'];
    result$data['isSavePaymentMethod'] = (l$isSavePaymentMethod as bool);
    final l$isReceiptEmail = data['isReceiptEmail'];
    result$data['isReceiptEmail'] = (l$isReceiptEmail as bool);
    final l$conversationId = data['conversationId'];
    result$data['conversationId'] = (l$conversationId as String);
    final l$requirementFiles = data['requirementFiles'];
    result$data['requirementFiles'] = (l$requirementFiles as List<dynamic>)
        .map((e) => (e as String))
        .toList();
    final l$deliveries = data['deliveries'];
    result$data['deliveries'] = (l$deliveries as List<dynamic>)
        .map(
          (e) => Input$PackageOrderDeliveryInput.fromJson(
            (e as Map<String, dynamic>),
          ),
        )
        .toList();
    final l$deadline = data['deadline'];
    result$data['deadline'] = DateTime.parse((l$deadline as String));
    return Input$CreatePaymentCheckoutSessionRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get packageId => (_$data['packageId'] as String);

  String get requestHubId => (_$data['requestHubId'] as String);

  String get successUrl => (_$data['successUrl'] as String);

  String get cancelUrl => (_$data['cancelUrl'] as String);

  bool get isSavePaymentMethod => (_$data['isSavePaymentMethod'] as bool);

  bool get isReceiptEmail => (_$data['isReceiptEmail'] as bool);

  String get conversationId => (_$data['conversationId'] as String);

  List<String> get requirementFiles =>
      (_$data['requirementFiles'] as List<String>);

  List<Input$PackageOrderDeliveryInput> get deliveries =>
      (_$data['deliveries'] as List<Input$PackageOrderDeliveryInput>);

  DateTime get deadline => (_$data['deadline'] as DateTime);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$packageId = packageId;
    result$data['packageId'] = l$packageId;
    final l$requestHubId = requestHubId;
    result$data['requestHubId'] = l$requestHubId;
    final l$successUrl = successUrl;
    result$data['successUrl'] = l$successUrl;
    final l$cancelUrl = cancelUrl;
    result$data['cancelUrl'] = l$cancelUrl;
    final l$isSavePaymentMethod = isSavePaymentMethod;
    result$data['isSavePaymentMethod'] = l$isSavePaymentMethod;
    final l$isReceiptEmail = isReceiptEmail;
    result$data['isReceiptEmail'] = l$isReceiptEmail;
    final l$conversationId = conversationId;
    result$data['conversationId'] = l$conversationId;
    final l$requirementFiles = requirementFiles;
    result$data['requirementFiles'] = l$requirementFiles.map((e) => e).toList();
    final l$deliveries = deliveries;
    result$data['deliveries'] = l$deliveries.map((e) => e.toJson()).toList();
    final l$deadline = deadline;
    result$data['deadline'] = l$deadline.toIso8601String();
    return result$data;
  }

  CopyWith$Input$CreatePaymentCheckoutSessionRequestInput<
    Input$CreatePaymentCheckoutSessionRequestInput
  >
  get copyWith =>
      CopyWith$Input$CreatePaymentCheckoutSessionRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreatePaymentCheckoutSessionRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$packageId = packageId;
    final lOther$packageId = other.packageId;
    if (l$packageId != lOther$packageId) {
      return false;
    }
    final l$requestHubId = requestHubId;
    final lOther$requestHubId = other.requestHubId;
    if (l$requestHubId != lOther$requestHubId) {
      return false;
    }
    final l$successUrl = successUrl;
    final lOther$successUrl = other.successUrl;
    if (l$successUrl != lOther$successUrl) {
      return false;
    }
    final l$cancelUrl = cancelUrl;
    final lOther$cancelUrl = other.cancelUrl;
    if (l$cancelUrl != lOther$cancelUrl) {
      return false;
    }
    final l$isSavePaymentMethod = isSavePaymentMethod;
    final lOther$isSavePaymentMethod = other.isSavePaymentMethod;
    if (l$isSavePaymentMethod != lOther$isSavePaymentMethod) {
      return false;
    }
    final l$isReceiptEmail = isReceiptEmail;
    final lOther$isReceiptEmail = other.isReceiptEmail;
    if (l$isReceiptEmail != lOther$isReceiptEmail) {
      return false;
    }
    final l$conversationId = conversationId;
    final lOther$conversationId = other.conversationId;
    if (l$conversationId != lOther$conversationId) {
      return false;
    }
    final l$requirementFiles = requirementFiles;
    final lOther$requirementFiles = other.requirementFiles;
    if (l$requirementFiles.length != lOther$requirementFiles.length) {
      return false;
    }
    for (int i = 0; i < l$requirementFiles.length; i++) {
      final l$requirementFiles$entry = l$requirementFiles[i];
      final lOther$requirementFiles$entry = lOther$requirementFiles[i];
      if (l$requirementFiles$entry != lOther$requirementFiles$entry) {
        return false;
      }
    }
    final l$deliveries = deliveries;
    final lOther$deliveries = other.deliveries;
    if (l$deliveries.length != lOther$deliveries.length) {
      return false;
    }
    for (int i = 0; i < l$deliveries.length; i++) {
      final l$deliveries$entry = l$deliveries[i];
      final lOther$deliveries$entry = lOther$deliveries[i];
      if (l$deliveries$entry != lOther$deliveries$entry) {
        return false;
      }
    }
    final l$deadline = deadline;
    final lOther$deadline = other.deadline;
    if (l$deadline != lOther$deadline) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$packageId = packageId;
    final l$requestHubId = requestHubId;
    final l$successUrl = successUrl;
    final l$cancelUrl = cancelUrl;
    final l$isSavePaymentMethod = isSavePaymentMethod;
    final l$isReceiptEmail = isReceiptEmail;
    final l$conversationId = conversationId;
    final l$requirementFiles = requirementFiles;
    final l$deliveries = deliveries;
    final l$deadline = deadline;
    return Object.hashAll([
      l$packageId,
      l$requestHubId,
      l$successUrl,
      l$cancelUrl,
      l$isSavePaymentMethod,
      l$isReceiptEmail,
      l$conversationId,
      Object.hashAll(l$requirementFiles.map((v) => v)),
      Object.hashAll(l$deliveries.map((v) => v)),
      l$deadline,
    ]);
  }
}

abstract class CopyWith$Input$CreatePaymentCheckoutSessionRequestInput<TRes> {
  factory CopyWith$Input$CreatePaymentCheckoutSessionRequestInput(
    Input$CreatePaymentCheckoutSessionRequestInput instance,
    TRes Function(Input$CreatePaymentCheckoutSessionRequestInput) then,
  ) = _CopyWithImpl$Input$CreatePaymentCheckoutSessionRequestInput;

  factory CopyWith$Input$CreatePaymentCheckoutSessionRequestInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$CreatePaymentCheckoutSessionRequestInput;

  TRes call({
    String? packageId,
    String? requestHubId,
    String? successUrl,
    String? cancelUrl,
    bool? isSavePaymentMethod,
    bool? isReceiptEmail,
    String? conversationId,
    List<String>? requirementFiles,
    List<Input$PackageOrderDeliveryInput>? deliveries,
    DateTime? deadline,
  });
  TRes deliveries(
    Iterable<Input$PackageOrderDeliveryInput> Function(
      Iterable<
        CopyWith$Input$PackageOrderDeliveryInput<
          Input$PackageOrderDeliveryInput
        >
      >,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$CreatePaymentCheckoutSessionRequestInput<TRes>
    implements CopyWith$Input$CreatePaymentCheckoutSessionRequestInput<TRes> {
  _CopyWithImpl$Input$CreatePaymentCheckoutSessionRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreatePaymentCheckoutSessionRequestInput _instance;

  final TRes Function(Input$CreatePaymentCheckoutSessionRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? packageId = _undefined,
    Object? requestHubId = _undefined,
    Object? successUrl = _undefined,
    Object? cancelUrl = _undefined,
    Object? isSavePaymentMethod = _undefined,
    Object? isReceiptEmail = _undefined,
    Object? conversationId = _undefined,
    Object? requirementFiles = _undefined,
    Object? deliveries = _undefined,
    Object? deadline = _undefined,
  }) => _then(
    Input$CreatePaymentCheckoutSessionRequestInput._({
      ..._instance._$data,
      if (packageId != _undefined && packageId != null)
        'packageId': (packageId as String),
      if (requestHubId != _undefined && requestHubId != null)
        'requestHubId': (requestHubId as String),
      if (successUrl != _undefined && successUrl != null)
        'successUrl': (successUrl as String),
      if (cancelUrl != _undefined && cancelUrl != null)
        'cancelUrl': (cancelUrl as String),
      if (isSavePaymentMethod != _undefined && isSavePaymentMethod != null)
        'isSavePaymentMethod': (isSavePaymentMethod as bool),
      if (isReceiptEmail != _undefined && isReceiptEmail != null)
        'isReceiptEmail': (isReceiptEmail as bool),
      if (conversationId != _undefined && conversationId != null)
        'conversationId': (conversationId as String),
      if (requirementFiles != _undefined && requirementFiles != null)
        'requirementFiles': (requirementFiles as List<String>),
      if (deliveries != _undefined && deliveries != null)
        'deliveries': (deliveries as List<Input$PackageOrderDeliveryInput>),
      if (deadline != _undefined && deadline != null)
        'deadline': (deadline as DateTime),
    }),
  );

  TRes deliveries(
    Iterable<Input$PackageOrderDeliveryInput> Function(
      Iterable<
        CopyWith$Input$PackageOrderDeliveryInput<
          Input$PackageOrderDeliveryInput
        >
      >,
    )
    _fn,
  ) => call(
    deliveries: _fn(
      _instance.deliveries.map(
        (e) => CopyWith$Input$PackageOrderDeliveryInput(e, (i) => i),
      ),
    ).toList(),
  );
}

class _CopyWithStubImpl$Input$CreatePaymentCheckoutSessionRequestInput<TRes>
    implements CopyWith$Input$CreatePaymentCheckoutSessionRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreatePaymentCheckoutSessionRequestInput(this._res);

  TRes _res;

  call({
    String? packageId,
    String? requestHubId,
    String? successUrl,
    String? cancelUrl,
    bool? isSavePaymentMethod,
    bool? isReceiptEmail,
    String? conversationId,
    List<String>? requirementFiles,
    List<Input$PackageOrderDeliveryInput>? deliveries,
    DateTime? deadline,
  }) => _res;

  deliveries(_fn) => _res;
}

class Input$CreatePlaylistRequestInput {
  factory Input$CreatePlaylistRequestInput({
    required String name,
    required String description,
    String? coverImage,
    required bool isPublic,
  }) => Input$CreatePlaylistRequestInput._({
    r'name': name,
    r'description': description,
    if (coverImage != null) r'coverImage': coverImage,
    r'isPublic': isPublic,
  });

  Input$CreatePlaylistRequestInput._(this._$data);

  factory Input$CreatePlaylistRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = (l$coverImage as String?);
    }
    final l$isPublic = data['isPublic'];
    result$data['isPublic'] = (l$isPublic as bool);
    return Input$CreatePlaylistRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String get description => (_$data['description'] as String);

  String? get coverImage => (_$data['coverImage'] as String?);

  bool get isPublic => (_$data['isPublic'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$description = description;
    result$data['description'] = l$description;
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage;
    }
    final l$isPublic = isPublic;
    result$data['isPublic'] = l$isPublic;
    return result$data;
  }

  CopyWith$Input$CreatePlaylistRequestInput<Input$CreatePlaylistRequestInput>
  get copyWith => CopyWith$Input$CreatePlaylistRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreatePlaylistRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$isPublic = isPublic;
    final lOther$isPublic = other.isPublic;
    if (l$isPublic != lOther$isPublic) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$coverImage = coverImage;
    final l$isPublic = isPublic;
    return Object.hashAll([
      l$name,
      l$description,
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      l$isPublic,
    ]);
  }
}

abstract class CopyWith$Input$CreatePlaylistRequestInput<TRes> {
  factory CopyWith$Input$CreatePlaylistRequestInput(
    Input$CreatePlaylistRequestInput instance,
    TRes Function(Input$CreatePlaylistRequestInput) then,
  ) = _CopyWithImpl$Input$CreatePlaylistRequestInput;

  factory CopyWith$Input$CreatePlaylistRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreatePlaylistRequestInput;

  TRes call({
    String? name,
    String? description,
    String? coverImage,
    bool? isPublic,
  });
}

class _CopyWithImpl$Input$CreatePlaylistRequestInput<TRes>
    implements CopyWith$Input$CreatePlaylistRequestInput<TRes> {
  _CopyWithImpl$Input$CreatePlaylistRequestInput(this._instance, this._then);

  final Input$CreatePlaylistRequestInput _instance;

  final TRes Function(Input$CreatePlaylistRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? coverImage = _undefined,
    Object? isPublic = _undefined,
  }) => _then(
    Input$CreatePlaylistRequestInput._({
      ..._instance._$data,
      if (name != _undefined && name != null) 'name': (name as String),
      if (description != _undefined && description != null)
        'description': (description as String),
      if (coverImage != _undefined) 'coverImage': (coverImage as String?),
      if (isPublic != _undefined && isPublic != null)
        'isPublic': (isPublic as bool),
    }),
  );
}

class _CopyWithStubImpl$Input$CreatePlaylistRequestInput<TRes>
    implements CopyWith$Input$CreatePlaylistRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreatePlaylistRequestInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    String? coverImage,
    bool? isPublic,
  }) => _res;
}

class Input$CreatePriceRequestInput {
  factory Input$CreatePriceRequestInput({
    required String lookupKey,
    required Enum$PeriodTime interval,
    required int intervalCount,
  }) => Input$CreatePriceRequestInput._({
    r'lookupKey': lookupKey,
    r'interval': interval,
    r'intervalCount': intervalCount,
  });

  Input$CreatePriceRequestInput._(this._$data);

  factory Input$CreatePriceRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$lookupKey = data['lookupKey'];
    result$data['lookupKey'] = (l$lookupKey as String);
    final l$interval = data['interval'];
    result$data['interval'] = fromJson$Enum$PeriodTime((l$interval as String));
    final l$intervalCount = data['intervalCount'];
    result$data['intervalCount'] = (l$intervalCount as int);
    return Input$CreatePriceRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get lookupKey => (_$data['lookupKey'] as String);

  Enum$PeriodTime get interval => (_$data['interval'] as Enum$PeriodTime);

  int get intervalCount => (_$data['intervalCount'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$lookupKey = lookupKey;
    result$data['lookupKey'] = l$lookupKey;
    final l$interval = interval;
    result$data['interval'] = toJson$Enum$PeriodTime(l$interval);
    final l$intervalCount = intervalCount;
    result$data['intervalCount'] = l$intervalCount;
    return result$data;
  }

  CopyWith$Input$CreatePriceRequestInput<Input$CreatePriceRequestInput>
  get copyWith => CopyWith$Input$CreatePriceRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreatePriceRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$lookupKey = lookupKey;
    final lOther$lookupKey = other.lookupKey;
    if (l$lookupKey != lOther$lookupKey) {
      return false;
    }
    final l$interval = interval;
    final lOther$interval = other.interval;
    if (l$interval != lOther$interval) {
      return false;
    }
    final l$intervalCount = intervalCount;
    final lOther$intervalCount = other.intervalCount;
    if (l$intervalCount != lOther$intervalCount) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$lookupKey = lookupKey;
    final l$interval = interval;
    final l$intervalCount = intervalCount;
    return Object.hashAll([l$lookupKey, l$interval, l$intervalCount]);
  }
}

abstract class CopyWith$Input$CreatePriceRequestInput<TRes> {
  factory CopyWith$Input$CreatePriceRequestInput(
    Input$CreatePriceRequestInput instance,
    TRes Function(Input$CreatePriceRequestInput) then,
  ) = _CopyWithImpl$Input$CreatePriceRequestInput;

  factory CopyWith$Input$CreatePriceRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreatePriceRequestInput;

  TRes call({String? lookupKey, Enum$PeriodTime? interval, int? intervalCount});
}

class _CopyWithImpl$Input$CreatePriceRequestInput<TRes>
    implements CopyWith$Input$CreatePriceRequestInput<TRes> {
  _CopyWithImpl$Input$CreatePriceRequestInput(this._instance, this._then);

  final Input$CreatePriceRequestInput _instance;

  final TRes Function(Input$CreatePriceRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? lookupKey = _undefined,
    Object? interval = _undefined,
    Object? intervalCount = _undefined,
  }) => _then(
    Input$CreatePriceRequestInput._({
      ..._instance._$data,
      if (lookupKey != _undefined && lookupKey != null)
        'lookupKey': (lookupKey as String),
      if (interval != _undefined && interval != null)
        'interval': (interval as Enum$PeriodTime),
      if (intervalCount != _undefined && intervalCount != null)
        'intervalCount': (intervalCount as int),
    }),
  );
}

class _CopyWithStubImpl$Input$CreatePriceRequestInput<TRes>
    implements CopyWith$Input$CreatePriceRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreatePriceRequestInput(this._res);

  TRes _res;

  call({String? lookupKey, Enum$PeriodTime? interval, int? intervalCount}) =>
      _res;
}

class Input$CreateRecordingRequestInput {
  factory Input$CreateRecordingRequestInput({
    String? description,
    required List<Input$CreateRecordingSplitRequestInput> recordingSplits,
  }) => Input$CreateRecordingRequestInput._({
    if (description != null) r'description': description,
    r'recordingSplits': recordingSplits,
  });

  Input$CreateRecordingRequestInput._(this._$data);

  factory Input$CreateRecordingRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$recordingSplits = data['recordingSplits'];
    result$data['recordingSplits'] = (l$recordingSplits as List<dynamic>)
        .map(
          (e) => Input$CreateRecordingSplitRequestInput.fromJson(
            (e as Map<String, dynamic>),
          ),
        )
        .toList();
    return Input$CreateRecordingRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get description => (_$data['description'] as String?);

  List<Input$CreateRecordingSplitRequestInput> get recordingSplits =>
      (_$data['recordingSplits']
          as List<Input$CreateRecordingSplitRequestInput>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$recordingSplits = recordingSplits;
    result$data['recordingSplits'] = l$recordingSplits
        .map((e) => e.toJson())
        .toList();
    return result$data;
  }

  CopyWith$Input$CreateRecordingRequestInput<Input$CreateRecordingRequestInput>
  get copyWith => CopyWith$Input$CreateRecordingRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateRecordingRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$recordingSplits = recordingSplits;
    final lOther$recordingSplits = other.recordingSplits;
    if (l$recordingSplits.length != lOther$recordingSplits.length) {
      return false;
    }
    for (int i = 0; i < l$recordingSplits.length; i++) {
      final l$recordingSplits$entry = l$recordingSplits[i];
      final lOther$recordingSplits$entry = lOther$recordingSplits[i];
      if (l$recordingSplits$entry != lOther$recordingSplits$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$description = description;
    final l$recordingSplits = recordingSplits;
    return Object.hashAll([
      _$data.containsKey('description') ? l$description : const {},
      Object.hashAll(l$recordingSplits.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$CreateRecordingRequestInput<TRes> {
  factory CopyWith$Input$CreateRecordingRequestInput(
    Input$CreateRecordingRequestInput instance,
    TRes Function(Input$CreateRecordingRequestInput) then,
  ) = _CopyWithImpl$Input$CreateRecordingRequestInput;

  factory CopyWith$Input$CreateRecordingRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRecordingRequestInput;

  TRes call({
    String? description,
    List<Input$CreateRecordingSplitRequestInput>? recordingSplits,
  });
  TRes recordingSplits(
    Iterable<Input$CreateRecordingSplitRequestInput> Function(
      Iterable<
        CopyWith$Input$CreateRecordingSplitRequestInput<
          Input$CreateRecordingSplitRequestInput
        >
      >,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$CreateRecordingRequestInput<TRes>
    implements CopyWith$Input$CreateRecordingRequestInput<TRes> {
  _CopyWithImpl$Input$CreateRecordingRequestInput(this._instance, this._then);

  final Input$CreateRecordingRequestInput _instance;

  final TRes Function(Input$CreateRecordingRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? description = _undefined,
    Object? recordingSplits = _undefined,
  }) => _then(
    Input$CreateRecordingRequestInput._({
      ..._instance._$data,
      if (description != _undefined) 'description': (description as String?),
      if (recordingSplits != _undefined && recordingSplits != null)
        'recordingSplits':
            (recordingSplits as List<Input$CreateRecordingSplitRequestInput>),
    }),
  );

  TRes recordingSplits(
    Iterable<Input$CreateRecordingSplitRequestInput> Function(
      Iterable<
        CopyWith$Input$CreateRecordingSplitRequestInput<
          Input$CreateRecordingSplitRequestInput
        >
      >,
    )
    _fn,
  ) => call(
    recordingSplits: _fn(
      _instance.recordingSplits.map(
        (e) => CopyWith$Input$CreateRecordingSplitRequestInput(e, (i) => i),
      ),
    ).toList(),
  );
}

class _CopyWithStubImpl$Input$CreateRecordingRequestInput<TRes>
    implements CopyWith$Input$CreateRecordingRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateRecordingRequestInput(this._res);

  TRes _res;

  call({
    String? description,
    List<Input$CreateRecordingSplitRequestInput>? recordingSplits,
  }) => _res;

  recordingSplits(_fn) => _res;
}

class Input$CreateRecordingSplitRequestInput {
  factory Input$CreateRecordingSplitRequestInput({
    required String userId,
    required Enum$ArtistRole artistRole,
    required double percentage,
  }) => Input$CreateRecordingSplitRequestInput._({
    r'userId': userId,
    r'artistRole': artistRole,
    r'percentage': percentage,
  });

  Input$CreateRecordingSplitRequestInput._(this._$data);

  factory Input$CreateRecordingSplitRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    final l$artistRole = data['artistRole'];
    result$data['artistRole'] = fromJson$Enum$ArtistRole(
      (l$artistRole as String),
    );
    final l$percentage = data['percentage'];
    result$data['percentage'] = (l$percentage as num).toDouble();
    return Input$CreateRecordingSplitRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get userId => (_$data['userId'] as String);

  Enum$ArtistRole get artistRole => (_$data['artistRole'] as Enum$ArtistRole);

  double get percentage => (_$data['percentage'] as double);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$userId = userId;
    result$data['userId'] = l$userId;
    final l$artistRole = artistRole;
    result$data['artistRole'] = toJson$Enum$ArtistRole(l$artistRole);
    final l$percentage = percentage;
    result$data['percentage'] = l$percentage;
    return result$data;
  }

  CopyWith$Input$CreateRecordingSplitRequestInput<
    Input$CreateRecordingSplitRequestInput
  >
  get copyWith =>
      CopyWith$Input$CreateRecordingSplitRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateRecordingSplitRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$artistRole = artistRole;
    final lOther$artistRole = other.artistRole;
    if (l$artistRole != lOther$artistRole) {
      return false;
    }
    final l$percentage = percentage;
    final lOther$percentage = other.percentage;
    if (l$percentage != lOther$percentage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$artistRole = artistRole;
    final l$percentage = percentage;
    return Object.hashAll([l$userId, l$artistRole, l$percentage]);
  }
}

abstract class CopyWith$Input$CreateRecordingSplitRequestInput<TRes> {
  factory CopyWith$Input$CreateRecordingSplitRequestInput(
    Input$CreateRecordingSplitRequestInput instance,
    TRes Function(Input$CreateRecordingSplitRequestInput) then,
  ) = _CopyWithImpl$Input$CreateRecordingSplitRequestInput;

  factory CopyWith$Input$CreateRecordingSplitRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRecordingSplitRequestInput;

  TRes call({String? userId, Enum$ArtistRole? artistRole, double? percentage});
}

class _CopyWithImpl$Input$CreateRecordingSplitRequestInput<TRes>
    implements CopyWith$Input$CreateRecordingSplitRequestInput<TRes> {
  _CopyWithImpl$Input$CreateRecordingSplitRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreateRecordingSplitRequestInput _instance;

  final TRes Function(Input$CreateRecordingSplitRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? userId = _undefined,
    Object? artistRole = _undefined,
    Object? percentage = _undefined,
  }) => _then(
    Input$CreateRecordingSplitRequestInput._({
      ..._instance._$data,
      if (userId != _undefined && userId != null) 'userId': (userId as String),
      if (artistRole != _undefined && artistRole != null)
        'artistRole': (artistRole as Enum$ArtistRole),
      if (percentage != _undefined && percentage != null)
        'percentage': (percentage as double),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateRecordingSplitRequestInput<TRes>
    implements CopyWith$Input$CreateRecordingSplitRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateRecordingSplitRequestInput(this._res);

  TRes _res;

  call({String? userId, Enum$ArtistRole? artistRole, double? percentage}) =>
      _res;
}

class Input$CreateReportRequestInput {
  factory Input$CreateReportRequestInput({
    required String reportedUserId,
    required Enum$ReportType reportType,
    required String description,
    String? relatedContentId,
    Enum$ReportRelatedContentType? relatedContentType,
    List<String>? evidences,
  }) => Input$CreateReportRequestInput._({
    r'reportedUserId': reportedUserId,
    r'reportType': reportType,
    r'description': description,
    if (relatedContentId != null) r'relatedContentId': relatedContentId,
    if (relatedContentType != null) r'relatedContentType': relatedContentType,
    if (evidences != null) r'evidences': evidences,
  });

  Input$CreateReportRequestInput._(this._$data);

  factory Input$CreateReportRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$reportedUserId = data['reportedUserId'];
    result$data['reportedUserId'] = (l$reportedUserId as String);
    final l$reportType = data['reportType'];
    result$data['reportType'] = fromJson$Enum$ReportType(
      (l$reportType as String),
    );
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    if (data.containsKey('relatedContentId')) {
      final l$relatedContentId = data['relatedContentId'];
      result$data['relatedContentId'] = (l$relatedContentId as String?);
    }
    if (data.containsKey('relatedContentType')) {
      final l$relatedContentType = data['relatedContentType'];
      result$data['relatedContentType'] = l$relatedContentType == null
          ? null
          : fromJson$Enum$ReportRelatedContentType(
              (l$relatedContentType as String),
            );
    }
    if (data.containsKey('evidences')) {
      final l$evidences = data['evidences'];
      result$data['evidences'] = (l$evidences as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$CreateReportRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get reportedUserId => (_$data['reportedUserId'] as String);

  Enum$ReportType get reportType => (_$data['reportType'] as Enum$ReportType);

  String get description => (_$data['description'] as String);

  String? get relatedContentId => (_$data['relatedContentId'] as String?);

  Enum$ReportRelatedContentType? get relatedContentType =>
      (_$data['relatedContentType'] as Enum$ReportRelatedContentType?);

  List<String>? get evidences => (_$data['evidences'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$reportedUserId = reportedUserId;
    result$data['reportedUserId'] = l$reportedUserId;
    final l$reportType = reportType;
    result$data['reportType'] = toJson$Enum$ReportType(l$reportType);
    final l$description = description;
    result$data['description'] = l$description;
    if (_$data.containsKey('relatedContentId')) {
      final l$relatedContentId = relatedContentId;
      result$data['relatedContentId'] = l$relatedContentId;
    }
    if (_$data.containsKey('relatedContentType')) {
      final l$relatedContentType = relatedContentType;
      result$data['relatedContentType'] = l$relatedContentType == null
          ? null
          : toJson$Enum$ReportRelatedContentType(l$relatedContentType);
    }
    if (_$data.containsKey('evidences')) {
      final l$evidences = evidences;
      result$data['evidences'] = l$evidences?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$CreateReportRequestInput<Input$CreateReportRequestInput>
  get copyWith => CopyWith$Input$CreateReportRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateReportRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reportedUserId = reportedUserId;
    final lOther$reportedUserId = other.reportedUserId;
    if (l$reportedUserId != lOther$reportedUserId) {
      return false;
    }
    final l$reportType = reportType;
    final lOther$reportType = other.reportType;
    if (l$reportType != lOther$reportType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$relatedContentId = relatedContentId;
    final lOther$relatedContentId = other.relatedContentId;
    if (_$data.containsKey('relatedContentId') !=
        other._$data.containsKey('relatedContentId')) {
      return false;
    }
    if (l$relatedContentId != lOther$relatedContentId) {
      return false;
    }
    final l$relatedContentType = relatedContentType;
    final lOther$relatedContentType = other.relatedContentType;
    if (_$data.containsKey('relatedContentType') !=
        other._$data.containsKey('relatedContentType')) {
      return false;
    }
    if (l$relatedContentType != lOther$relatedContentType) {
      return false;
    }
    final l$evidences = evidences;
    final lOther$evidences = other.evidences;
    if (_$data.containsKey('evidences') !=
        other._$data.containsKey('evidences')) {
      return false;
    }
    if (l$evidences != null && lOther$evidences != null) {
      if (l$evidences.length != lOther$evidences.length) {
        return false;
      }
      for (int i = 0; i < l$evidences.length; i++) {
        final l$evidences$entry = l$evidences[i];
        final lOther$evidences$entry = lOther$evidences[i];
        if (l$evidences$entry != lOther$evidences$entry) {
          return false;
        }
      }
    } else if (l$evidences != lOther$evidences) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reportedUserId = reportedUserId;
    final l$reportType = reportType;
    final l$description = description;
    final l$relatedContentId = relatedContentId;
    final l$relatedContentType = relatedContentType;
    final l$evidences = evidences;
    return Object.hashAll([
      l$reportedUserId,
      l$reportType,
      l$description,
      _$data.containsKey('relatedContentId') ? l$relatedContentId : const {},
      _$data.containsKey('relatedContentType')
          ? l$relatedContentType
          : const {},
      _$data.containsKey('evidences')
          ? l$evidences == null
                ? null
                : Object.hashAll(l$evidences.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateReportRequestInput<TRes> {
  factory CopyWith$Input$CreateReportRequestInput(
    Input$CreateReportRequestInput instance,
    TRes Function(Input$CreateReportRequestInput) then,
  ) = _CopyWithImpl$Input$CreateReportRequestInput;

  factory CopyWith$Input$CreateReportRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateReportRequestInput;

  TRes call({
    String? reportedUserId,
    Enum$ReportType? reportType,
    String? description,
    String? relatedContentId,
    Enum$ReportRelatedContentType? relatedContentType,
    List<String>? evidences,
  });
}

class _CopyWithImpl$Input$CreateReportRequestInput<TRes>
    implements CopyWith$Input$CreateReportRequestInput<TRes> {
  _CopyWithImpl$Input$CreateReportRequestInput(this._instance, this._then);

  final Input$CreateReportRequestInput _instance;

  final TRes Function(Input$CreateReportRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reportedUserId = _undefined,
    Object? reportType = _undefined,
    Object? description = _undefined,
    Object? relatedContentId = _undefined,
    Object? relatedContentType = _undefined,
    Object? evidences = _undefined,
  }) => _then(
    Input$CreateReportRequestInput._({
      ..._instance._$data,
      if (reportedUserId != _undefined && reportedUserId != null)
        'reportedUserId': (reportedUserId as String),
      if (reportType != _undefined && reportType != null)
        'reportType': (reportType as Enum$ReportType),
      if (description != _undefined && description != null)
        'description': (description as String),
      if (relatedContentId != _undefined)
        'relatedContentId': (relatedContentId as String?),
      if (relatedContentType != _undefined)
        'relatedContentType':
            (relatedContentType as Enum$ReportRelatedContentType?),
      if (evidences != _undefined) 'evidences': (evidences as List<String>?),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateReportRequestInput<TRes>
    implements CopyWith$Input$CreateReportRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateReportRequestInput(this._res);

  TRes _res;

  call({
    String? reportedUserId,
    Enum$ReportType? reportType,
    String? description,
    String? relatedContentId,
    Enum$ReportRelatedContentType? relatedContentType,
    List<String>? evidences,
  }) => _res;
}

class Input$CreateReviewRequestInput {
  factory Input$CreateReviewRequestInput({
    required String packageOrderId,
    required int rating,
    required String content,
  }) => Input$CreateReviewRequestInput._({
    r'packageOrderId': packageOrderId,
    r'rating': rating,
    r'content': content,
  });

  Input$CreateReviewRequestInput._(this._$data);

  factory Input$CreateReviewRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$packageOrderId = data['packageOrderId'];
    result$data['packageOrderId'] = (l$packageOrderId as String);
    final l$rating = data['rating'];
    result$data['rating'] = (l$rating as int);
    final l$content = data['content'];
    result$data['content'] = (l$content as String);
    return Input$CreateReviewRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get packageOrderId => (_$data['packageOrderId'] as String);

  int get rating => (_$data['rating'] as int);

  String get content => (_$data['content'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$packageOrderId = packageOrderId;
    result$data['packageOrderId'] = l$packageOrderId;
    final l$rating = rating;
    result$data['rating'] = l$rating;
    final l$content = content;
    result$data['content'] = l$content;
    return result$data;
  }

  CopyWith$Input$CreateReviewRequestInput<Input$CreateReviewRequestInput>
  get copyWith => CopyWith$Input$CreateReviewRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateReviewRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$packageOrderId = packageOrderId;
    final lOther$packageOrderId = other.packageOrderId;
    if (l$packageOrderId != lOther$packageOrderId) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$packageOrderId = packageOrderId;
    final l$rating = rating;
    final l$content = content;
    return Object.hashAll([l$packageOrderId, l$rating, l$content]);
  }
}

abstract class CopyWith$Input$CreateReviewRequestInput<TRes> {
  factory CopyWith$Input$CreateReviewRequestInput(
    Input$CreateReviewRequestInput instance,
    TRes Function(Input$CreateReviewRequestInput) then,
  ) = _CopyWithImpl$Input$CreateReviewRequestInput;

  factory CopyWith$Input$CreateReviewRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateReviewRequestInput;

  TRes call({String? packageOrderId, int? rating, String? content});
}

class _CopyWithImpl$Input$CreateReviewRequestInput<TRes>
    implements CopyWith$Input$CreateReviewRequestInput<TRes> {
  _CopyWithImpl$Input$CreateReviewRequestInput(this._instance, this._then);

  final Input$CreateReviewRequestInput _instance;

  final TRes Function(Input$CreateReviewRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? packageOrderId = _undefined,
    Object? rating = _undefined,
    Object? content = _undefined,
  }) => _then(
    Input$CreateReviewRequestInput._({
      ..._instance._$data,
      if (packageOrderId != _undefined && packageOrderId != null)
        'packageOrderId': (packageOrderId as String),
      if (rating != _undefined && rating != null) 'rating': (rating as int),
      if (content != _undefined && content != null)
        'content': (content as String),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateReviewRequestInput<TRes>
    implements CopyWith$Input$CreateReviewRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateReviewRequestInput(this._res);

  TRes _res;

  call({String? packageOrderId, int? rating, String? content}) => _res;
}

class Input$CreateRoyalPolicyRequestInput {
  factory Input$CreateRoyalPolicyRequestInput({
    required double ratePerStream,
    required Enum$CurrencyType currency,
    required double recordingPercentage,
    required double workPercentage,
  }) => Input$CreateRoyalPolicyRequestInput._({
    r'ratePerStream': ratePerStream,
    r'currency': currency,
    r'recordingPercentage': recordingPercentage,
    r'workPercentage': workPercentage,
  });

  Input$CreateRoyalPolicyRequestInput._(this._$data);

  factory Input$CreateRoyalPolicyRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$ratePerStream = data['ratePerStream'];
    result$data['ratePerStream'] = (l$ratePerStream as num).toDouble();
    final l$currency = data['currency'];
    result$data['currency'] = fromJson$Enum$CurrencyType(
      (l$currency as String),
    );
    final l$recordingPercentage = data['recordingPercentage'];
    result$data['recordingPercentage'] = (l$recordingPercentage as num)
        .toDouble();
    final l$workPercentage = data['workPercentage'];
    result$data['workPercentage'] = (l$workPercentage as num).toDouble();
    return Input$CreateRoyalPolicyRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double get ratePerStream => (_$data['ratePerStream'] as double);

  Enum$CurrencyType get currency => (_$data['currency'] as Enum$CurrencyType);

  double get recordingPercentage => (_$data['recordingPercentage'] as double);

  double get workPercentage => (_$data['workPercentage'] as double);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ratePerStream = ratePerStream;
    result$data['ratePerStream'] = l$ratePerStream;
    final l$currency = currency;
    result$data['currency'] = toJson$Enum$CurrencyType(l$currency);
    final l$recordingPercentage = recordingPercentage;
    result$data['recordingPercentage'] = l$recordingPercentage;
    final l$workPercentage = workPercentage;
    result$data['workPercentage'] = l$workPercentage;
    return result$data;
  }

  CopyWith$Input$CreateRoyalPolicyRequestInput<
    Input$CreateRoyalPolicyRequestInput
  >
  get copyWith => CopyWith$Input$CreateRoyalPolicyRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateRoyalPolicyRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ratePerStream = ratePerStream;
    final lOther$ratePerStream = other.ratePerStream;
    if (l$ratePerStream != lOther$ratePerStream) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$recordingPercentage = recordingPercentage;
    final lOther$recordingPercentage = other.recordingPercentage;
    if (l$recordingPercentage != lOther$recordingPercentage) {
      return false;
    }
    final l$workPercentage = workPercentage;
    final lOther$workPercentage = other.workPercentage;
    if (l$workPercentage != lOther$workPercentage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ratePerStream = ratePerStream;
    final l$currency = currency;
    final l$recordingPercentage = recordingPercentage;
    final l$workPercentage = workPercentage;
    return Object.hashAll([
      l$ratePerStream,
      l$currency,
      l$recordingPercentage,
      l$workPercentage,
    ]);
  }
}

abstract class CopyWith$Input$CreateRoyalPolicyRequestInput<TRes> {
  factory CopyWith$Input$CreateRoyalPolicyRequestInput(
    Input$CreateRoyalPolicyRequestInput instance,
    TRes Function(Input$CreateRoyalPolicyRequestInput) then,
  ) = _CopyWithImpl$Input$CreateRoyalPolicyRequestInput;

  factory CopyWith$Input$CreateRoyalPolicyRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRoyalPolicyRequestInput;

  TRes call({
    double? ratePerStream,
    Enum$CurrencyType? currency,
    double? recordingPercentage,
    double? workPercentage,
  });
}

class _CopyWithImpl$Input$CreateRoyalPolicyRequestInput<TRes>
    implements CopyWith$Input$CreateRoyalPolicyRequestInput<TRes> {
  _CopyWithImpl$Input$CreateRoyalPolicyRequestInput(this._instance, this._then);

  final Input$CreateRoyalPolicyRequestInput _instance;

  final TRes Function(Input$CreateRoyalPolicyRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? ratePerStream = _undefined,
    Object? currency = _undefined,
    Object? recordingPercentage = _undefined,
    Object? workPercentage = _undefined,
  }) => _then(
    Input$CreateRoyalPolicyRequestInput._({
      ..._instance._$data,
      if (ratePerStream != _undefined && ratePerStream != null)
        'ratePerStream': (ratePerStream as double),
      if (currency != _undefined && currency != null)
        'currency': (currency as Enum$CurrencyType),
      if (recordingPercentage != _undefined && recordingPercentage != null)
        'recordingPercentage': (recordingPercentage as double),
      if (workPercentage != _undefined && workPercentage != null)
        'workPercentage': (workPercentage as double),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateRoyalPolicyRequestInput<TRes>
    implements CopyWith$Input$CreateRoyalPolicyRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateRoyalPolicyRequestInput(this._res);

  TRes _res;

  call({
    double? ratePerStream,
    Enum$CurrencyType? currency,
    double? recordingPercentage,
    double? workPercentage,
  }) => _res;
}

class Input$CreateSubScriptionPlanRequestInput {
  factory Input$CreateSubScriptionPlanRequestInput({
    required List<Input$CreatePriceRequestInput> prices,
    required String name,
    List<String>? images,
    List<Input$KeyValuePairOfStringAndStringInput>? metadata,
    required String subscriptionCode,
  }) => Input$CreateSubScriptionPlanRequestInput._({
    r'prices': prices,
    r'name': name,
    if (images != null) r'images': images,
    if (metadata != null) r'metadata': metadata,
    r'subscriptionCode': subscriptionCode,
  });

  Input$CreateSubScriptionPlanRequestInput._(this._$data);

  factory Input$CreateSubScriptionPlanRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$prices = data['prices'];
    result$data['prices'] = (l$prices as List<dynamic>)
        .map(
          (e) => Input$CreatePriceRequestInput.fromJson(
            (e as Map<String, dynamic>),
          ),
        )
        .toList();
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('images')) {
      final l$images = data['images'];
      result$data['images'] = (l$images as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
            (e) => Input$KeyValuePairOfStringAndStringInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    final l$subscriptionCode = data['subscriptionCode'];
    result$data['subscriptionCode'] = (l$subscriptionCode as String);
    return Input$CreateSubScriptionPlanRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CreatePriceRequestInput> get prices =>
      (_$data['prices'] as List<Input$CreatePriceRequestInput>);

  String get name => (_$data['name'] as String);

  List<String>? get images => (_$data['images'] as List<String>?);

  List<Input$KeyValuePairOfStringAndStringInput>? get metadata =>
      (_$data['metadata'] as List<Input$KeyValuePairOfStringAndStringInput>?);

  String get subscriptionCode => (_$data['subscriptionCode'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$prices = prices;
    result$data['prices'] = l$prices.map((e) => e.toJson()).toList();
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('images')) {
      final l$images = images;
      result$data['images'] = l$images?.map((e) => e).toList();
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    final l$subscriptionCode = subscriptionCode;
    result$data['subscriptionCode'] = l$subscriptionCode;
    return result$data;
  }

  CopyWith$Input$CreateSubScriptionPlanRequestInput<
    Input$CreateSubScriptionPlanRequestInput
  >
  get copyWith =>
      CopyWith$Input$CreateSubScriptionPlanRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateSubScriptionPlanRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$prices = prices;
    final lOther$prices = other.prices;
    if (l$prices.length != lOther$prices.length) {
      return false;
    }
    for (int i = 0; i < l$prices.length; i++) {
      final l$prices$entry = l$prices[i];
      final lOther$prices$entry = lOther$prices[i];
      if (l$prices$entry != lOther$prices$entry) {
        return false;
      }
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$images = images;
    final lOther$images = other.images;
    if (_$data.containsKey('images') != other._$data.containsKey('images')) {
      return false;
    }
    if (l$images != null && lOther$images != null) {
      if (l$images.length != lOther$images.length) {
        return false;
      }
      for (int i = 0; i < l$images.length; i++) {
        final l$images$entry = l$images[i];
        final lOther$images$entry = lOther$images[i];
        if (l$images$entry != lOther$images$entry) {
          return false;
        }
      }
    } else if (l$images != lOther$images) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$subscriptionCode = subscriptionCode;
    final lOther$subscriptionCode = other.subscriptionCode;
    if (l$subscriptionCode != lOther$subscriptionCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$prices = prices;
    final l$name = name;
    final l$images = images;
    final l$metadata = metadata;
    final l$subscriptionCode = subscriptionCode;
    return Object.hashAll([
      Object.hashAll(l$prices.map((v) => v)),
      l$name,
      _$data.containsKey('images')
          ? l$images == null
                ? null
                : Object.hashAll(l$images.map((v) => v))
          : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
                ? null
                : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      l$subscriptionCode,
    ]);
  }
}

abstract class CopyWith$Input$CreateSubScriptionPlanRequestInput<TRes> {
  factory CopyWith$Input$CreateSubScriptionPlanRequestInput(
    Input$CreateSubScriptionPlanRequestInput instance,
    TRes Function(Input$CreateSubScriptionPlanRequestInput) then,
  ) = _CopyWithImpl$Input$CreateSubScriptionPlanRequestInput;

  factory CopyWith$Input$CreateSubScriptionPlanRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSubScriptionPlanRequestInput;

  TRes call({
    List<Input$CreatePriceRequestInput>? prices,
    String? name,
    List<String>? images,
    List<Input$KeyValuePairOfStringAndStringInput>? metadata,
    String? subscriptionCode,
  });
  TRes prices(
    Iterable<Input$CreatePriceRequestInput> Function(
      Iterable<
        CopyWith$Input$CreatePriceRequestInput<Input$CreatePriceRequestInput>
      >,
    )
    _fn,
  );
  TRes metadata(
    Iterable<Input$KeyValuePairOfStringAndStringInput>? Function(
      Iterable<
        CopyWith$Input$KeyValuePairOfStringAndStringInput<
          Input$KeyValuePairOfStringAndStringInput
        >
      >?,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$CreateSubScriptionPlanRequestInput<TRes>
    implements CopyWith$Input$CreateSubScriptionPlanRequestInput<TRes> {
  _CopyWithImpl$Input$CreateSubScriptionPlanRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreateSubScriptionPlanRequestInput _instance;

  final TRes Function(Input$CreateSubScriptionPlanRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? prices = _undefined,
    Object? name = _undefined,
    Object? images = _undefined,
    Object? metadata = _undefined,
    Object? subscriptionCode = _undefined,
  }) => _then(
    Input$CreateSubScriptionPlanRequestInput._({
      ..._instance._$data,
      if (prices != _undefined && prices != null)
        'prices': (prices as List<Input$CreatePriceRequestInput>),
      if (name != _undefined && name != null) 'name': (name as String),
      if (images != _undefined) 'images': (images as List<String>?),
      if (metadata != _undefined)
        'metadata':
            (metadata as List<Input$KeyValuePairOfStringAndStringInput>?),
      if (subscriptionCode != _undefined && subscriptionCode != null)
        'subscriptionCode': (subscriptionCode as String),
    }),
  );

  TRes prices(
    Iterable<Input$CreatePriceRequestInput> Function(
      Iterable<
        CopyWith$Input$CreatePriceRequestInput<Input$CreatePriceRequestInput>
      >,
    )
    _fn,
  ) => call(
    prices: _fn(
      _instance.prices.map(
        (e) => CopyWith$Input$CreatePriceRequestInput(e, (i) => i),
      ),
    ).toList(),
  );

  TRes metadata(
    Iterable<Input$KeyValuePairOfStringAndStringInput>? Function(
      Iterable<
        CopyWith$Input$KeyValuePairOfStringAndStringInput<
          Input$KeyValuePairOfStringAndStringInput
        >
      >?,
    )
    _fn,
  ) => call(
    metadata: _fn(
      _instance.metadata?.map(
        (e) => CopyWith$Input$KeyValuePairOfStringAndStringInput(e, (i) => i),
      ),
    )?.toList(),
  );
}

class _CopyWithStubImpl$Input$CreateSubScriptionPlanRequestInput<TRes>
    implements CopyWith$Input$CreateSubScriptionPlanRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateSubScriptionPlanRequestInput(this._res);

  TRes _res;

  call({
    List<Input$CreatePriceRequestInput>? prices,
    String? name,
    List<String>? images,
    List<Input$KeyValuePairOfStringAndStringInput>? metadata,
    String? subscriptionCode,
  }) => _res;

  prices(_fn) => _res;

  metadata(_fn) => _res;
}

class Input$CreateSubscriptionCheckoutSessionRequestInput {
  factory Input$CreateSubscriptionCheckoutSessionRequestInput({
    required String subscriptionCode,
    required Enum$PeriodTime period,
    required String successUrl,
    required String cancelUrl,
    required bool isSavePaymentMethod,
  }) => Input$CreateSubscriptionCheckoutSessionRequestInput._({
    r'subscriptionCode': subscriptionCode,
    r'period': period,
    r'successUrl': successUrl,
    r'cancelUrl': cancelUrl,
    r'isSavePaymentMethod': isSavePaymentMethod,
  });

  Input$CreateSubscriptionCheckoutSessionRequestInput._(this._$data);

  factory Input$CreateSubscriptionCheckoutSessionRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$subscriptionCode = data['subscriptionCode'];
    result$data['subscriptionCode'] = (l$subscriptionCode as String);
    final l$period = data['period'];
    result$data['period'] = fromJson$Enum$PeriodTime((l$period as String));
    final l$successUrl = data['successUrl'];
    result$data['successUrl'] = (l$successUrl as String);
    final l$cancelUrl = data['cancelUrl'];
    result$data['cancelUrl'] = (l$cancelUrl as String);
    final l$isSavePaymentMethod = data['isSavePaymentMethod'];
    result$data['isSavePaymentMethod'] = (l$isSavePaymentMethod as bool);
    return Input$CreateSubscriptionCheckoutSessionRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get subscriptionCode => (_$data['subscriptionCode'] as String);

  Enum$PeriodTime get period => (_$data['period'] as Enum$PeriodTime);

  String get successUrl => (_$data['successUrl'] as String);

  String get cancelUrl => (_$data['cancelUrl'] as String);

  bool get isSavePaymentMethod => (_$data['isSavePaymentMethod'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$subscriptionCode = subscriptionCode;
    result$data['subscriptionCode'] = l$subscriptionCode;
    final l$period = period;
    result$data['period'] = toJson$Enum$PeriodTime(l$period);
    final l$successUrl = successUrl;
    result$data['successUrl'] = l$successUrl;
    final l$cancelUrl = cancelUrl;
    result$data['cancelUrl'] = l$cancelUrl;
    final l$isSavePaymentMethod = isSavePaymentMethod;
    result$data['isSavePaymentMethod'] = l$isSavePaymentMethod;
    return result$data;
  }

  CopyWith$Input$CreateSubscriptionCheckoutSessionRequestInput<
    Input$CreateSubscriptionCheckoutSessionRequestInput
  >
  get copyWith => CopyWith$Input$CreateSubscriptionCheckoutSessionRequestInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateSubscriptionCheckoutSessionRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$subscriptionCode = subscriptionCode;
    final lOther$subscriptionCode = other.subscriptionCode;
    if (l$subscriptionCode != lOther$subscriptionCode) {
      return false;
    }
    final l$period = period;
    final lOther$period = other.period;
    if (l$period != lOther$period) {
      return false;
    }
    final l$successUrl = successUrl;
    final lOther$successUrl = other.successUrl;
    if (l$successUrl != lOther$successUrl) {
      return false;
    }
    final l$cancelUrl = cancelUrl;
    final lOther$cancelUrl = other.cancelUrl;
    if (l$cancelUrl != lOther$cancelUrl) {
      return false;
    }
    final l$isSavePaymentMethod = isSavePaymentMethod;
    final lOther$isSavePaymentMethod = other.isSavePaymentMethod;
    if (l$isSavePaymentMethod != lOther$isSavePaymentMethod) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subscriptionCode = subscriptionCode;
    final l$period = period;
    final l$successUrl = successUrl;
    final l$cancelUrl = cancelUrl;
    final l$isSavePaymentMethod = isSavePaymentMethod;
    return Object.hashAll([
      l$subscriptionCode,
      l$period,
      l$successUrl,
      l$cancelUrl,
      l$isSavePaymentMethod,
    ]);
  }
}

abstract class CopyWith$Input$CreateSubscriptionCheckoutSessionRequestInput<
  TRes
> {
  factory CopyWith$Input$CreateSubscriptionCheckoutSessionRequestInput(
    Input$CreateSubscriptionCheckoutSessionRequestInput instance,
    TRes Function(Input$CreateSubscriptionCheckoutSessionRequestInput) then,
  ) = _CopyWithImpl$Input$CreateSubscriptionCheckoutSessionRequestInput;

  factory CopyWith$Input$CreateSubscriptionCheckoutSessionRequestInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$CreateSubscriptionCheckoutSessionRequestInput;

  TRes call({
    String? subscriptionCode,
    Enum$PeriodTime? period,
    String? successUrl,
    String? cancelUrl,
    bool? isSavePaymentMethod,
  });
}

class _CopyWithImpl$Input$CreateSubscriptionCheckoutSessionRequestInput<TRes>
    implements
        CopyWith$Input$CreateSubscriptionCheckoutSessionRequestInput<TRes> {
  _CopyWithImpl$Input$CreateSubscriptionCheckoutSessionRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreateSubscriptionCheckoutSessionRequestInput _instance;

  final TRes Function(Input$CreateSubscriptionCheckoutSessionRequestInput)
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? subscriptionCode = _undefined,
    Object? period = _undefined,
    Object? successUrl = _undefined,
    Object? cancelUrl = _undefined,
    Object? isSavePaymentMethod = _undefined,
  }) => _then(
    Input$CreateSubscriptionCheckoutSessionRequestInput._({
      ..._instance._$data,
      if (subscriptionCode != _undefined && subscriptionCode != null)
        'subscriptionCode': (subscriptionCode as String),
      if (period != _undefined && period != null)
        'period': (period as Enum$PeriodTime),
      if (successUrl != _undefined && successUrl != null)
        'successUrl': (successUrl as String),
      if (cancelUrl != _undefined && cancelUrl != null)
        'cancelUrl': (cancelUrl as String),
      if (isSavePaymentMethod != _undefined && isSavePaymentMethod != null)
        'isSavePaymentMethod': (isSavePaymentMethod as bool),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateSubscriptionCheckoutSessionRequestInput<
  TRes
>
    implements
        CopyWith$Input$CreateSubscriptionCheckoutSessionRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateSubscriptionCheckoutSessionRequestInput(
    this._res,
  );

  TRes _res;

  call({
    String? subscriptionCode,
    Enum$PeriodTime? period,
    String? successUrl,
    String? cancelUrl,
    bool? isSavePaymentMethod,
  }) => _res;
}

class Input$CreateSubscriptionRequestInput {
  factory Input$CreateSubscriptionRequestInput({
    required String name,
    String? description,
    required String code,
    required double price,
    required Enum$SubscriptionTier tier,
  }) => Input$CreateSubscriptionRequestInput._({
    r'name': name,
    if (description != null) r'description': description,
    r'code': code,
    r'price': price,
    r'tier': tier,
  });

  Input$CreateSubscriptionRequestInput._(this._$data);

  factory Input$CreateSubscriptionRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$code = data['code'];
    result$data['code'] = (l$code as String);
    final l$price = data['price'];
    result$data['price'] = (l$price as num).toDouble();
    final l$tier = data['tier'];
    result$data['tier'] = fromJson$Enum$SubscriptionTier((l$tier as String));
    return Input$CreateSubscriptionRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get description => (_$data['description'] as String?);

  String get code => (_$data['code'] as String);

  double get price => (_$data['price'] as double);

  Enum$SubscriptionTier get tier => (_$data['tier'] as Enum$SubscriptionTier);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$code = code;
    result$data['code'] = l$code;
    final l$price = price;
    result$data['price'] = l$price;
    final l$tier = tier;
    result$data['tier'] = toJson$Enum$SubscriptionTier(l$tier);
    return result$data;
  }

  CopyWith$Input$CreateSubscriptionRequestInput<
    Input$CreateSubscriptionRequestInput
  >
  get copyWith => CopyWith$Input$CreateSubscriptionRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateSubscriptionRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (l$code != lOther$code) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (l$price != lOther$price) {
      return false;
    }
    final l$tier = tier;
    final lOther$tier = other.tier;
    if (l$tier != lOther$tier) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$code = code;
    final l$price = price;
    final l$tier = tier;
    return Object.hashAll([
      l$name,
      _$data.containsKey('description') ? l$description : const {},
      l$code,
      l$price,
      l$tier,
    ]);
  }
}

abstract class CopyWith$Input$CreateSubscriptionRequestInput<TRes> {
  factory CopyWith$Input$CreateSubscriptionRequestInput(
    Input$CreateSubscriptionRequestInput instance,
    TRes Function(Input$CreateSubscriptionRequestInput) then,
  ) = _CopyWithImpl$Input$CreateSubscriptionRequestInput;

  factory CopyWith$Input$CreateSubscriptionRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSubscriptionRequestInput;

  TRes call({
    String? name,
    String? description,
    String? code,
    double? price,
    Enum$SubscriptionTier? tier,
  });
}

class _CopyWithImpl$Input$CreateSubscriptionRequestInput<TRes>
    implements CopyWith$Input$CreateSubscriptionRequestInput<TRes> {
  _CopyWithImpl$Input$CreateSubscriptionRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreateSubscriptionRequestInput _instance;

  final TRes Function(Input$CreateSubscriptionRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? code = _undefined,
    Object? price = _undefined,
    Object? tier = _undefined,
  }) => _then(
    Input$CreateSubscriptionRequestInput._({
      ..._instance._$data,
      if (name != _undefined && name != null) 'name': (name as String),
      if (description != _undefined) 'description': (description as String?),
      if (code != _undefined && code != null) 'code': (code as String),
      if (price != _undefined && price != null) 'price': (price as double),
      if (tier != _undefined && tier != null)
        'tier': (tier as Enum$SubscriptionTier),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateSubscriptionRequestInput<TRes>
    implements CopyWith$Input$CreateSubscriptionRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateSubscriptionRequestInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    String? code,
    double? price,
    Enum$SubscriptionTier? tier,
  }) => _res;
}

class Input$CreateTrackRequestInput {
  factory Input$CreateTrackRequestInput({
    required String name,
    String? description,
    required List<String> mainArtistIds,
    required List<String> featuredArtistIds,
    required List<String> categoryIds,
    required List<String> tags,
    required String coverImage,
    String? previewVideo,
    required bool isExplicit,
    String? lyrics,
    required bool isRelease,
    DateTime? releaseDate,
    required Enum$ReleaseStatus releaseStatus,
    required List<Input$LegalDocumentInput> legalDocuments,
    required bool isOriginal,
  }) => Input$CreateTrackRequestInput._({
    r'name': name,
    if (description != null) r'description': description,
    r'mainArtistIds': mainArtistIds,
    r'featuredArtistIds': featuredArtistIds,
    r'categoryIds': categoryIds,
    r'tags': tags,
    r'coverImage': coverImage,
    if (previewVideo != null) r'previewVideo': previewVideo,
    r'isExplicit': isExplicit,
    if (lyrics != null) r'lyrics': lyrics,
    r'isRelease': isRelease,
    if (releaseDate != null) r'releaseDate': releaseDate,
    r'releaseStatus': releaseStatus,
    r'legalDocuments': legalDocuments,
    r'isOriginal': isOriginal,
  });

  Input$CreateTrackRequestInput._(this._$data);

  factory Input$CreateTrackRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$mainArtistIds = data['mainArtistIds'];
    result$data['mainArtistIds'] = (l$mainArtistIds as List<dynamic>)
        .map((e) => (e as String))
        .toList();
    final l$featuredArtistIds = data['featuredArtistIds'];
    result$data['featuredArtistIds'] = (l$featuredArtistIds as List<dynamic>)
        .map((e) => (e as String))
        .toList();
    final l$categoryIds = data['categoryIds'];
    result$data['categoryIds'] = (l$categoryIds as List<dynamic>)
        .map((e) => (e as String))
        .toList();
    final l$tags = data['tags'];
    result$data['tags'] = (l$tags as List<dynamic>)
        .map((e) => (e as String))
        .toList();
    final l$coverImage = data['coverImage'];
    result$data['coverImage'] = (l$coverImage as String);
    if (data.containsKey('previewVideo')) {
      final l$previewVideo = data['previewVideo'];
      result$data['previewVideo'] = (l$previewVideo as String?);
    }
    final l$isExplicit = data['isExplicit'];
    result$data['isExplicit'] = (l$isExplicit as bool);
    if (data.containsKey('lyrics')) {
      final l$lyrics = data['lyrics'];
      result$data['lyrics'] = (l$lyrics as String?);
    }
    final l$isRelease = data['isRelease'];
    result$data['isRelease'] = (l$isRelease as bool);
    if (data.containsKey('releaseDate')) {
      final l$releaseDate = data['releaseDate'];
      result$data['releaseDate'] = l$releaseDate == null
          ? null
          : DateTime.parse((l$releaseDate as String));
    }
    final l$releaseStatus = data['releaseStatus'];
    result$data['releaseStatus'] = fromJson$Enum$ReleaseStatus(
      (l$releaseStatus as String),
    );
    final l$legalDocuments = data['legalDocuments'];
    result$data['legalDocuments'] = (l$legalDocuments as List<dynamic>)
        .map(
          (e) => Input$LegalDocumentInput.fromJson((e as Map<String, dynamic>)),
        )
        .toList();
    final l$isOriginal = data['isOriginal'];
    result$data['isOriginal'] = (l$isOriginal as bool);
    return Input$CreateTrackRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get description => (_$data['description'] as String?);

  List<String> get mainArtistIds => (_$data['mainArtistIds'] as List<String>);

  List<String> get featuredArtistIds =>
      (_$data['featuredArtistIds'] as List<String>);

  List<String> get categoryIds => (_$data['categoryIds'] as List<String>);

  List<String> get tags => (_$data['tags'] as List<String>);

  String get coverImage => (_$data['coverImage'] as String);

  String? get previewVideo => (_$data['previewVideo'] as String?);

  bool get isExplicit => (_$data['isExplicit'] as bool);

  String? get lyrics => (_$data['lyrics'] as String?);

  bool get isRelease => (_$data['isRelease'] as bool);

  DateTime? get releaseDate => (_$data['releaseDate'] as DateTime?);

  Enum$ReleaseStatus get releaseStatus =>
      (_$data['releaseStatus'] as Enum$ReleaseStatus);

  List<Input$LegalDocumentInput> get legalDocuments =>
      (_$data['legalDocuments'] as List<Input$LegalDocumentInput>);

  bool get isOriginal => (_$data['isOriginal'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$mainArtistIds = mainArtistIds;
    result$data['mainArtistIds'] = l$mainArtistIds.map((e) => e).toList();
    final l$featuredArtistIds = featuredArtistIds;
    result$data['featuredArtistIds'] = l$featuredArtistIds
        .map((e) => e)
        .toList();
    final l$categoryIds = categoryIds;
    result$data['categoryIds'] = l$categoryIds.map((e) => e).toList();
    final l$tags = tags;
    result$data['tags'] = l$tags.map((e) => e).toList();
    final l$coverImage = coverImage;
    result$data['coverImage'] = l$coverImage;
    if (_$data.containsKey('previewVideo')) {
      final l$previewVideo = previewVideo;
      result$data['previewVideo'] = l$previewVideo;
    }
    final l$isExplicit = isExplicit;
    result$data['isExplicit'] = l$isExplicit;
    if (_$data.containsKey('lyrics')) {
      final l$lyrics = lyrics;
      result$data['lyrics'] = l$lyrics;
    }
    final l$isRelease = isRelease;
    result$data['isRelease'] = l$isRelease;
    if (_$data.containsKey('releaseDate')) {
      final l$releaseDate = releaseDate;
      result$data['releaseDate'] = l$releaseDate?.toIso8601String();
    }
    final l$releaseStatus = releaseStatus;
    result$data['releaseStatus'] = toJson$Enum$ReleaseStatus(l$releaseStatus);
    final l$legalDocuments = legalDocuments;
    result$data['legalDocuments'] = l$legalDocuments
        .map((e) => e.toJson())
        .toList();
    final l$isOriginal = isOriginal;
    result$data['isOriginal'] = l$isOriginal;
    return result$data;
  }

  CopyWith$Input$CreateTrackRequestInput<Input$CreateTrackRequestInput>
  get copyWith => CopyWith$Input$CreateTrackRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateTrackRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$mainArtistIds = mainArtistIds;
    final lOther$mainArtistIds = other.mainArtistIds;
    if (l$mainArtistIds.length != lOther$mainArtistIds.length) {
      return false;
    }
    for (int i = 0; i < l$mainArtistIds.length; i++) {
      final l$mainArtistIds$entry = l$mainArtistIds[i];
      final lOther$mainArtistIds$entry = lOther$mainArtistIds[i];
      if (l$mainArtistIds$entry != lOther$mainArtistIds$entry) {
        return false;
      }
    }
    final l$featuredArtistIds = featuredArtistIds;
    final lOther$featuredArtistIds = other.featuredArtistIds;
    if (l$featuredArtistIds.length != lOther$featuredArtistIds.length) {
      return false;
    }
    for (int i = 0; i < l$featuredArtistIds.length; i++) {
      final l$featuredArtistIds$entry = l$featuredArtistIds[i];
      final lOther$featuredArtistIds$entry = lOther$featuredArtistIds[i];
      if (l$featuredArtistIds$entry != lOther$featuredArtistIds$entry) {
        return false;
      }
    }
    final l$categoryIds = categoryIds;
    final lOther$categoryIds = other.categoryIds;
    if (l$categoryIds.length != lOther$categoryIds.length) {
      return false;
    }
    for (int i = 0; i < l$categoryIds.length; i++) {
      final l$categoryIds$entry = l$categoryIds[i];
      final lOther$categoryIds$entry = lOther$categoryIds[i];
      if (l$categoryIds$entry != lOther$categoryIds$entry) {
        return false;
      }
    }
    final l$tags = tags;
    final lOther$tags = other.tags;
    if (l$tags.length != lOther$tags.length) {
      return false;
    }
    for (int i = 0; i < l$tags.length; i++) {
      final l$tags$entry = l$tags[i];
      final lOther$tags$entry = lOther$tags[i];
      if (l$tags$entry != lOther$tags$entry) {
        return false;
      }
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$previewVideo = previewVideo;
    final lOther$previewVideo = other.previewVideo;
    if (_$data.containsKey('previewVideo') !=
        other._$data.containsKey('previewVideo')) {
      return false;
    }
    if (l$previewVideo != lOther$previewVideo) {
      return false;
    }
    final l$isExplicit = isExplicit;
    final lOther$isExplicit = other.isExplicit;
    if (l$isExplicit != lOther$isExplicit) {
      return false;
    }
    final l$lyrics = lyrics;
    final lOther$lyrics = other.lyrics;
    if (_$data.containsKey('lyrics') != other._$data.containsKey('lyrics')) {
      return false;
    }
    if (l$lyrics != lOther$lyrics) {
      return false;
    }
    final l$isRelease = isRelease;
    final lOther$isRelease = other.isRelease;
    if (l$isRelease != lOther$isRelease) {
      return false;
    }
    final l$releaseDate = releaseDate;
    final lOther$releaseDate = other.releaseDate;
    if (_$data.containsKey('releaseDate') !=
        other._$data.containsKey('releaseDate')) {
      return false;
    }
    if (l$releaseDate != lOther$releaseDate) {
      return false;
    }
    final l$releaseStatus = releaseStatus;
    final lOther$releaseStatus = other.releaseStatus;
    if (l$releaseStatus != lOther$releaseStatus) {
      return false;
    }
    final l$legalDocuments = legalDocuments;
    final lOther$legalDocuments = other.legalDocuments;
    if (l$legalDocuments.length != lOther$legalDocuments.length) {
      return false;
    }
    for (int i = 0; i < l$legalDocuments.length; i++) {
      final l$legalDocuments$entry = l$legalDocuments[i];
      final lOther$legalDocuments$entry = lOther$legalDocuments[i];
      if (l$legalDocuments$entry != lOther$legalDocuments$entry) {
        return false;
      }
    }
    final l$isOriginal = isOriginal;
    final lOther$isOriginal = other.isOriginal;
    if (l$isOriginal != lOther$isOriginal) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$mainArtistIds = mainArtistIds;
    final l$featuredArtistIds = featuredArtistIds;
    final l$categoryIds = categoryIds;
    final l$tags = tags;
    final l$coverImage = coverImage;
    final l$previewVideo = previewVideo;
    final l$isExplicit = isExplicit;
    final l$lyrics = lyrics;
    final l$isRelease = isRelease;
    final l$releaseDate = releaseDate;
    final l$releaseStatus = releaseStatus;
    final l$legalDocuments = legalDocuments;
    final l$isOriginal = isOriginal;
    return Object.hashAll([
      l$name,
      _$data.containsKey('description') ? l$description : const {},
      Object.hashAll(l$mainArtistIds.map((v) => v)),
      Object.hashAll(l$featuredArtistIds.map((v) => v)),
      Object.hashAll(l$categoryIds.map((v) => v)),
      Object.hashAll(l$tags.map((v) => v)),
      l$coverImage,
      _$data.containsKey('previewVideo') ? l$previewVideo : const {},
      l$isExplicit,
      _$data.containsKey('lyrics') ? l$lyrics : const {},
      l$isRelease,
      _$data.containsKey('releaseDate') ? l$releaseDate : const {},
      l$releaseStatus,
      Object.hashAll(l$legalDocuments.map((v) => v)),
      l$isOriginal,
    ]);
  }
}

abstract class CopyWith$Input$CreateTrackRequestInput<TRes> {
  factory CopyWith$Input$CreateTrackRequestInput(
    Input$CreateTrackRequestInput instance,
    TRes Function(Input$CreateTrackRequestInput) then,
  ) = _CopyWithImpl$Input$CreateTrackRequestInput;

  factory CopyWith$Input$CreateTrackRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateTrackRequestInput;

  TRes call({
    String? name,
    String? description,
    List<String>? mainArtistIds,
    List<String>? featuredArtistIds,
    List<String>? categoryIds,
    List<String>? tags,
    String? coverImage,
    String? previewVideo,
    bool? isExplicit,
    String? lyrics,
    bool? isRelease,
    DateTime? releaseDate,
    Enum$ReleaseStatus? releaseStatus,
    List<Input$LegalDocumentInput>? legalDocuments,
    bool? isOriginal,
  });
  TRes legalDocuments(
    Iterable<Input$LegalDocumentInput> Function(
      Iterable<CopyWith$Input$LegalDocumentInput<Input$LegalDocumentInput>>,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$CreateTrackRequestInput<TRes>
    implements CopyWith$Input$CreateTrackRequestInput<TRes> {
  _CopyWithImpl$Input$CreateTrackRequestInput(this._instance, this._then);

  final Input$CreateTrackRequestInput _instance;

  final TRes Function(Input$CreateTrackRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? mainArtistIds = _undefined,
    Object? featuredArtistIds = _undefined,
    Object? categoryIds = _undefined,
    Object? tags = _undefined,
    Object? coverImage = _undefined,
    Object? previewVideo = _undefined,
    Object? isExplicit = _undefined,
    Object? lyrics = _undefined,
    Object? isRelease = _undefined,
    Object? releaseDate = _undefined,
    Object? releaseStatus = _undefined,
    Object? legalDocuments = _undefined,
    Object? isOriginal = _undefined,
  }) => _then(
    Input$CreateTrackRequestInput._({
      ..._instance._$data,
      if (name != _undefined && name != null) 'name': (name as String),
      if (description != _undefined) 'description': (description as String?),
      if (mainArtistIds != _undefined && mainArtistIds != null)
        'mainArtistIds': (mainArtistIds as List<String>),
      if (featuredArtistIds != _undefined && featuredArtistIds != null)
        'featuredArtistIds': (featuredArtistIds as List<String>),
      if (categoryIds != _undefined && categoryIds != null)
        'categoryIds': (categoryIds as List<String>),
      if (tags != _undefined && tags != null) 'tags': (tags as List<String>),
      if (coverImage != _undefined && coverImage != null)
        'coverImage': (coverImage as String),
      if (previewVideo != _undefined) 'previewVideo': (previewVideo as String?),
      if (isExplicit != _undefined && isExplicit != null)
        'isExplicit': (isExplicit as bool),
      if (lyrics != _undefined) 'lyrics': (lyrics as String?),
      if (isRelease != _undefined && isRelease != null)
        'isRelease': (isRelease as bool),
      if (releaseDate != _undefined) 'releaseDate': (releaseDate as DateTime?),
      if (releaseStatus != _undefined && releaseStatus != null)
        'releaseStatus': (releaseStatus as Enum$ReleaseStatus),
      if (legalDocuments != _undefined && legalDocuments != null)
        'legalDocuments': (legalDocuments as List<Input$LegalDocumentInput>),
      if (isOriginal != _undefined && isOriginal != null)
        'isOriginal': (isOriginal as bool),
    }),
  );

  TRes legalDocuments(
    Iterable<Input$LegalDocumentInput> Function(
      Iterable<CopyWith$Input$LegalDocumentInput<Input$LegalDocumentInput>>,
    )
    _fn,
  ) => call(
    legalDocuments: _fn(
      _instance.legalDocuments.map(
        (e) => CopyWith$Input$LegalDocumentInput(e, (i) => i),
      ),
    ).toList(),
  );
}

class _CopyWithStubImpl$Input$CreateTrackRequestInput<TRes>
    implements CopyWith$Input$CreateTrackRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateTrackRequestInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    List<String>? mainArtistIds,
    List<String>? featuredArtistIds,
    List<String>? categoryIds,
    List<String>? tags,
    String? coverImage,
    String? previewVideo,
    bool? isExplicit,
    String? lyrics,
    bool? isRelease,
    DateTime? releaseDate,
    Enum$ReleaseStatus? releaseStatus,
    List<Input$LegalDocumentInput>? legalDocuments,
    bool? isOriginal,
  }) => _res;

  legalDocuments(_fn) => _res;
}

class Input$CreateWorkRequestInput {
  factory Input$CreateWorkRequestInput({
    String? description,
    required List<Input$CreateWorkSplitRequestInput> workSplits,
  }) => Input$CreateWorkRequestInput._({
    if (description != null) r'description': description,
    r'workSplits': workSplits,
  });

  Input$CreateWorkRequestInput._(this._$data);

  factory Input$CreateWorkRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$workSplits = data['workSplits'];
    result$data['workSplits'] = (l$workSplits as List<dynamic>)
        .map(
          (e) => Input$CreateWorkSplitRequestInput.fromJson(
            (e as Map<String, dynamic>),
          ),
        )
        .toList();
    return Input$CreateWorkRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get description => (_$data['description'] as String?);

  List<Input$CreateWorkSplitRequestInput> get workSplits =>
      (_$data['workSplits'] as List<Input$CreateWorkSplitRequestInput>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$workSplits = workSplits;
    result$data['workSplits'] = l$workSplits.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$CreateWorkRequestInput<Input$CreateWorkRequestInput>
  get copyWith => CopyWith$Input$CreateWorkRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateWorkRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$workSplits = workSplits;
    final lOther$workSplits = other.workSplits;
    if (l$workSplits.length != lOther$workSplits.length) {
      return false;
    }
    for (int i = 0; i < l$workSplits.length; i++) {
      final l$workSplits$entry = l$workSplits[i];
      final lOther$workSplits$entry = lOther$workSplits[i];
      if (l$workSplits$entry != lOther$workSplits$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$description = description;
    final l$workSplits = workSplits;
    return Object.hashAll([
      _$data.containsKey('description') ? l$description : const {},
      Object.hashAll(l$workSplits.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$CreateWorkRequestInput<TRes> {
  factory CopyWith$Input$CreateWorkRequestInput(
    Input$CreateWorkRequestInput instance,
    TRes Function(Input$CreateWorkRequestInput) then,
  ) = _CopyWithImpl$Input$CreateWorkRequestInput;

  factory CopyWith$Input$CreateWorkRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateWorkRequestInput;

  TRes call({
    String? description,
    List<Input$CreateWorkSplitRequestInput>? workSplits,
  });
  TRes workSplits(
    Iterable<Input$CreateWorkSplitRequestInput> Function(
      Iterable<
        CopyWith$Input$CreateWorkSplitRequestInput<
          Input$CreateWorkSplitRequestInput
        >
      >,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$CreateWorkRequestInput<TRes>
    implements CopyWith$Input$CreateWorkRequestInput<TRes> {
  _CopyWithImpl$Input$CreateWorkRequestInput(this._instance, this._then);

  final Input$CreateWorkRequestInput _instance;

  final TRes Function(Input$CreateWorkRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? description = _undefined,
    Object? workSplits = _undefined,
  }) => _then(
    Input$CreateWorkRequestInput._({
      ..._instance._$data,
      if (description != _undefined) 'description': (description as String?),
      if (workSplits != _undefined && workSplits != null)
        'workSplits': (workSplits as List<Input$CreateWorkSplitRequestInput>),
    }),
  );

  TRes workSplits(
    Iterable<Input$CreateWorkSplitRequestInput> Function(
      Iterable<
        CopyWith$Input$CreateWorkSplitRequestInput<
          Input$CreateWorkSplitRequestInput
        >
      >,
    )
    _fn,
  ) => call(
    workSplits: _fn(
      _instance.workSplits.map(
        (e) => CopyWith$Input$CreateWorkSplitRequestInput(e, (i) => i),
      ),
    ).toList(),
  );
}

class _CopyWithStubImpl$Input$CreateWorkRequestInput<TRes>
    implements CopyWith$Input$CreateWorkRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateWorkRequestInput(this._res);

  TRes _res;

  call({
    String? description,
    List<Input$CreateWorkSplitRequestInput>? workSplits,
  }) => _res;

  workSplits(_fn) => _res;
}

class Input$CreateWorkSplitRequestInput {
  factory Input$CreateWorkSplitRequestInput({
    required String userId,
    required Enum$ArtistRole artistRole,
    required double percentage,
  }) => Input$CreateWorkSplitRequestInput._({
    r'userId': userId,
    r'artistRole': artistRole,
    r'percentage': percentage,
  });

  Input$CreateWorkSplitRequestInput._(this._$data);

  factory Input$CreateWorkSplitRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    final l$artistRole = data['artistRole'];
    result$data['artistRole'] = fromJson$Enum$ArtistRole(
      (l$artistRole as String),
    );
    final l$percentage = data['percentage'];
    result$data['percentage'] = (l$percentage as num).toDouble();
    return Input$CreateWorkSplitRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get userId => (_$data['userId'] as String);

  Enum$ArtistRole get artistRole => (_$data['artistRole'] as Enum$ArtistRole);

  double get percentage => (_$data['percentage'] as double);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$userId = userId;
    result$data['userId'] = l$userId;
    final l$artistRole = artistRole;
    result$data['artistRole'] = toJson$Enum$ArtistRole(l$artistRole);
    final l$percentage = percentage;
    result$data['percentage'] = l$percentage;
    return result$data;
  }

  CopyWith$Input$CreateWorkSplitRequestInput<Input$CreateWorkSplitRequestInput>
  get copyWith => CopyWith$Input$CreateWorkSplitRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateWorkSplitRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$artistRole = artistRole;
    final lOther$artistRole = other.artistRole;
    if (l$artistRole != lOther$artistRole) {
      return false;
    }
    final l$percentage = percentage;
    final lOther$percentage = other.percentage;
    if (l$percentage != lOther$percentage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$artistRole = artistRole;
    final l$percentage = percentage;
    return Object.hashAll([l$userId, l$artistRole, l$percentage]);
  }
}

abstract class CopyWith$Input$CreateWorkSplitRequestInput<TRes> {
  factory CopyWith$Input$CreateWorkSplitRequestInput(
    Input$CreateWorkSplitRequestInput instance,
    TRes Function(Input$CreateWorkSplitRequestInput) then,
  ) = _CopyWithImpl$Input$CreateWorkSplitRequestInput;

  factory CopyWith$Input$CreateWorkSplitRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateWorkSplitRequestInput;

  TRes call({String? userId, Enum$ArtistRole? artistRole, double? percentage});
}

class _CopyWithImpl$Input$CreateWorkSplitRequestInput<TRes>
    implements CopyWith$Input$CreateWorkSplitRequestInput<TRes> {
  _CopyWithImpl$Input$CreateWorkSplitRequestInput(this._instance, this._then);

  final Input$CreateWorkSplitRequestInput _instance;

  final TRes Function(Input$CreateWorkSplitRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? userId = _undefined,
    Object? artistRole = _undefined,
    Object? percentage = _undefined,
  }) => _then(
    Input$CreateWorkSplitRequestInput._({
      ..._instance._$data,
      if (userId != _undefined && userId != null) 'userId': (userId as String),
      if (artistRole != _undefined && artistRole != null)
        'artistRole': (artistRole as Enum$ArtistRole),
      if (percentage != _undefined && percentage != null)
        'percentage': (percentage as double),
    }),
  );
}

class _CopyWithStubImpl$Input$CreateWorkSplitRequestInput<TRes>
    implements CopyWith$Input$CreateWorkSplitRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreateWorkSplitRequestInput(this._res);

  TRes _res;

  call({String? userId, Enum$ArtistRole? artistRole, double? percentage}) =>
      _res;
}

class Input$CurrencyTypeOperationFilterInput {
  factory Input$CurrencyTypeOperationFilterInput({
    Enum$CurrencyType? eq,
    Enum$CurrencyType? neq,
    List<Enum$CurrencyType>? $in,
    List<Enum$CurrencyType>? nin,
  }) => Input$CurrencyTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$CurrencyTypeOperationFilterInput._(this._$data);

  factory Input$CurrencyTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$CurrencyType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$CurrencyType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CurrencyType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CurrencyType((e as String)))
          .toList();
    }
    return Input$CurrencyTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CurrencyType? get eq => (_$data['eq'] as Enum$CurrencyType?);

  Enum$CurrencyType? get neq => (_$data['neq'] as Enum$CurrencyType?);

  List<Enum$CurrencyType>? get $in =>
      (_$data['in'] as List<Enum$CurrencyType>?);

  List<Enum$CurrencyType>? get nin =>
      (_$data['nin'] as List<Enum$CurrencyType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$CurrencyType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$CurrencyType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$CurrencyType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$CurrencyType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$CurrencyTypeOperationFilterInput<
    Input$CurrencyTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$CurrencyTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CurrencyTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$CurrencyTypeOperationFilterInput(
    Input$CurrencyTypeOperationFilterInput instance,
    TRes Function(Input$CurrencyTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$CurrencyTypeOperationFilterInput;

  factory CopyWith$Input$CurrencyTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CurrencyTypeOperationFilterInput;

  TRes call({
    Enum$CurrencyType? eq,
    Enum$CurrencyType? neq,
    List<Enum$CurrencyType>? $in,
    List<Enum$CurrencyType>? nin,
  });
}

class _CopyWithImpl$Input$CurrencyTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$CurrencyTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$CurrencyTypeOperationFilterInput _instance;

  final TRes Function(Input$CurrencyTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$CurrencyTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$CurrencyType?),
      if (neq != _undefined) 'neq': (neq as Enum$CurrencyType?),
      if ($in != _undefined) 'in': ($in as List<Enum$CurrencyType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$CurrencyType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$CurrencyTypeOperationFilterInput<TRes>
    implements CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$CurrencyTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$CurrencyType? eq,
    Enum$CurrencyType? neq,
    List<Enum$CurrencyType>? $in,
    List<Enum$CurrencyType>? nin,
  }) => _res;
}

class Input$DateTimeOperationFilterInput {
  factory Input$DateTimeOperationFilterInput({
    DateTime? eq,
    DateTime? neq,
    List<DateTime?>? $in,
    List<DateTime?>? nin,
    DateTime? gt,
    DateTime? ngt,
    DateTime? gte,
    DateTime? ngte,
    DateTime? lt,
    DateTime? nlt,
    DateTime? lte,
    DateTime? nlte,
  }) => Input$DateTimeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
    if (gt != null) r'gt': gt,
    if (ngt != null) r'ngt': ngt,
    if (gte != null) r'gte': gte,
    if (ngte != null) r'ngte': ngte,
    if (lt != null) r'lt': lt,
    if (nlt != null) r'nlt': nlt,
    if (lte != null) r'lte': lte,
    if (nlte != null) r'nlte': nlte,
  });

  Input$DateTimeOperationFilterInput._(this._$data);

  factory Input$DateTimeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : DateTime.parse((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : DateTime.parse((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => e == null ? null : DateTime.parse((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => e == null ? null : DateTime.parse((e as String)))
          .toList();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = l$gt == null
          ? null
          : DateTime.parse((l$gt as String));
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = l$ngt == null
          ? null
          : DateTime.parse((l$ngt as String));
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = l$gte == null
          ? null
          : DateTime.parse((l$gte as String));
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = l$ngte == null
          ? null
          : DateTime.parse((l$ngte as String));
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = l$lt == null
          ? null
          : DateTime.parse((l$lt as String));
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = l$nlt == null
          ? null
          : DateTime.parse((l$nlt as String));
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = l$lte == null
          ? null
          : DateTime.parse((l$lte as String));
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = l$nlte == null
          ? null
          : DateTime.parse((l$nlte as String));
    }
    return Input$DateTimeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get eq => (_$data['eq'] as DateTime?);

  DateTime? get neq => (_$data['neq'] as DateTime?);

  List<DateTime?>? get $in => (_$data['in'] as List<DateTime?>?);

  List<DateTime?>? get nin => (_$data['nin'] as List<DateTime?>?);

  DateTime? get gt => (_$data['gt'] as DateTime?);

  DateTime? get ngt => (_$data['ngt'] as DateTime?);

  DateTime? get gte => (_$data['gte'] as DateTime?);

  DateTime? get ngte => (_$data['ngte'] as DateTime?);

  DateTime? get lt => (_$data['lt'] as DateTime?);

  DateTime? get nlt => (_$data['nlt'] as DateTime?);

  DateTime? get lte => (_$data['lte'] as DateTime?);

  DateTime? get nlte => (_$data['nlte'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq?.toIso8601String();
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq?.toIso8601String();
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e?.toIso8601String()).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e?.toIso8601String()).toList();
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt?.toIso8601String();
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt?.toIso8601String();
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte?.toIso8601String();
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte?.toIso8601String();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt?.toIso8601String();
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt?.toIso8601String();
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte?.toIso8601String();
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$DateTimeOperationFilterInput<
    Input$DateTimeOperationFilterInput
  >
  get copyWith => CopyWith$Input$DateTimeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DateTimeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    final l$gt = gt;
    final l$ngt = ngt;
    final l$gte = gte;
    final l$ngte = ngte;
    final l$lt = lt;
    final l$nlt = nlt;
    final l$lte = lte;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateTimeOperationFilterInput<TRes> {
  factory CopyWith$Input$DateTimeOperationFilterInput(
    Input$DateTimeOperationFilterInput instance,
    TRes Function(Input$DateTimeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$DateTimeOperationFilterInput;

  factory CopyWith$Input$DateTimeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeOperationFilterInput;

  TRes call({
    DateTime? eq,
    DateTime? neq,
    List<DateTime?>? $in,
    List<DateTime?>? nin,
    DateTime? gt,
    DateTime? ngt,
    DateTime? gte,
    DateTime? ngte,
    DateTime? lt,
    DateTime? nlt,
    DateTime? lte,
    DateTime? nlte,
  });
}

class _CopyWithImpl$Input$DateTimeOperationFilterInput<TRes>
    implements CopyWith$Input$DateTimeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$DateTimeOperationFilterInput(this._instance, this._then);

  final Input$DateTimeOperationFilterInput _instance;

  final TRes Function(Input$DateTimeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
    Object? gt = _undefined,
    Object? ngt = _undefined,
    Object? gte = _undefined,
    Object? ngte = _undefined,
    Object? lt = _undefined,
    Object? nlt = _undefined,
    Object? lte = _undefined,
    Object? nlte = _undefined,
  }) => _then(
    Input$DateTimeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as DateTime?),
      if (neq != _undefined) 'neq': (neq as DateTime?),
      if ($in != _undefined) 'in': ($in as List<DateTime?>?),
      if (nin != _undefined) 'nin': (nin as List<DateTime?>?),
      if (gt != _undefined) 'gt': (gt as DateTime?),
      if (ngt != _undefined) 'ngt': (ngt as DateTime?),
      if (gte != _undefined) 'gte': (gte as DateTime?),
      if (ngte != _undefined) 'ngte': (ngte as DateTime?),
      if (lt != _undefined) 'lt': (lt as DateTime?),
      if (nlt != _undefined) 'nlt': (nlt as DateTime?),
      if (lte != _undefined) 'lte': (lte as DateTime?),
      if (nlte != _undefined) 'nlte': (nlte as DateTime?),
    }),
  );
}

class _CopyWithStubImpl$Input$DateTimeOperationFilterInput<TRes>
    implements CopyWith$Input$DateTimeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$DateTimeOperationFilterInput(this._res);

  TRes _res;

  call({
    DateTime? eq,
    DateTime? neq,
    List<DateTime?>? $in,
    List<DateTime?>? nin,
    DateTime? gt,
    DateTime? ngt,
    DateTime? gte,
    DateTime? ngte,
    DateTime? lt,
    DateTime? nlt,
    DateTime? lte,
    DateTime? nlte,
  }) => _res;
}

class Input$DecimalOperationFilterInput {
  factory Input$DecimalOperationFilterInput({
    double? eq,
    double? neq,
    List<double?>? $in,
    List<double?>? nin,
    double? gt,
    double? ngt,
    double? gte,
    double? ngte,
    double? lt,
    double? nlt,
    double? lte,
    double? nlte,
  }) => Input$DecimalOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
    if (gt != null) r'gt': gt,
    if (ngt != null) r'ngt': ngt,
    if (gte != null) r'gte': gte,
    if (ngte != null) r'ngte': ngte,
    if (lt != null) r'lt': lt,
    if (nlt != null) r'nlt': nlt,
    if (lte != null) r'lte': lte,
    if (nlte != null) r'nlte': nlte,
  });

  Input$DecimalOperationFilterInput._(this._$data);

  factory Input$DecimalOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as num?)?.toDouble();
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as num?)?.toDouble();
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => (e as num?)?.toDouble())
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => (e as num?)?.toDouble())
          .toList();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as num?)?.toDouble();
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as num?)?.toDouble();
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as num?)?.toDouble();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as num?)?.toDouble();
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as num?)?.toDouble();
    }
    return Input$DecimalOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get eq => (_$data['eq'] as double?);

  double? get neq => (_$data['neq'] as double?);

  List<double?>? get $in => (_$data['in'] as List<double?>?);

  List<double?>? get nin => (_$data['nin'] as List<double?>?);

  double? get gt => (_$data['gt'] as double?);

  double? get ngt => (_$data['ngt'] as double?);

  double? get gte => (_$data['gte'] as double?);

  double? get ngte => (_$data['ngte'] as double?);

  double? get lt => (_$data['lt'] as double?);

  double? get nlt => (_$data['nlt'] as double?);

  double? get lte => (_$data['lte'] as double?);

  double? get nlte => (_$data['nlte'] as double?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$DecimalOperationFilterInput<Input$DecimalOperationFilterInput>
  get copyWith => CopyWith$Input$DecimalOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DecimalOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    final l$gt = gt;
    final l$ngt = ngt;
    final l$gte = gte;
    final l$ngte = ngte;
    final l$lt = lt;
    final l$nlt = nlt;
    final l$lte = lte;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$DecimalOperationFilterInput<TRes> {
  factory CopyWith$Input$DecimalOperationFilterInput(
    Input$DecimalOperationFilterInput instance,
    TRes Function(Input$DecimalOperationFilterInput) then,
  ) = _CopyWithImpl$Input$DecimalOperationFilterInput;

  factory CopyWith$Input$DecimalOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DecimalOperationFilterInput;

  TRes call({
    double? eq,
    double? neq,
    List<double?>? $in,
    List<double?>? nin,
    double? gt,
    double? ngt,
    double? gte,
    double? ngte,
    double? lt,
    double? nlt,
    double? lte,
    double? nlte,
  });
}

class _CopyWithImpl$Input$DecimalOperationFilterInput<TRes>
    implements CopyWith$Input$DecimalOperationFilterInput<TRes> {
  _CopyWithImpl$Input$DecimalOperationFilterInput(this._instance, this._then);

  final Input$DecimalOperationFilterInput _instance;

  final TRes Function(Input$DecimalOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
    Object? gt = _undefined,
    Object? ngt = _undefined,
    Object? gte = _undefined,
    Object? ngte = _undefined,
    Object? lt = _undefined,
    Object? nlt = _undefined,
    Object? lte = _undefined,
    Object? nlte = _undefined,
  }) => _then(
    Input$DecimalOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as double?),
      if (neq != _undefined) 'neq': (neq as double?),
      if ($in != _undefined) 'in': ($in as List<double?>?),
      if (nin != _undefined) 'nin': (nin as List<double?>?),
      if (gt != _undefined) 'gt': (gt as double?),
      if (ngt != _undefined) 'ngt': (ngt as double?),
      if (gte != _undefined) 'gte': (gte as double?),
      if (ngte != _undefined) 'ngte': (ngte as double?),
      if (lt != _undefined) 'lt': (lt as double?),
      if (nlt != _undefined) 'nlt': (nlt as double?),
      if (lte != _undefined) 'lte': (lte as double?),
      if (nlte != _undefined) 'nlte': (nlte as double?),
    }),
  );
}

class _CopyWithStubImpl$Input$DecimalOperationFilterInput<TRes>
    implements CopyWith$Input$DecimalOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$DecimalOperationFilterInput(this._res);

  TRes _res;

  call({
    double? eq,
    double? neq,
    List<double?>? $in,
    List<double?>? nin,
    double? gt,
    double? ngt,
    double? gte,
    double? ngte,
    double? lt,
    double? nlt,
    double? lte,
    double? nlte,
  }) => _res;
}

class Input$DeleteCommentRequestInput {
  factory Input$DeleteCommentRequestInput({required String commentId}) =>
      Input$DeleteCommentRequestInput._({r'commentId': commentId});

  Input$DeleteCommentRequestInput._(this._$data);

  factory Input$DeleteCommentRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$commentId = data['commentId'];
    result$data['commentId'] = (l$commentId as String);
    return Input$DeleteCommentRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get commentId => (_$data['commentId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$commentId = commentId;
    result$data['commentId'] = l$commentId;
    return result$data;
  }

  CopyWith$Input$DeleteCommentRequestInput<Input$DeleteCommentRequestInput>
  get copyWith => CopyWith$Input$DeleteCommentRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteCommentRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$commentId = commentId;
    final lOther$commentId = other.commentId;
    if (l$commentId != lOther$commentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$commentId = commentId;
    return Object.hashAll([l$commentId]);
  }
}

abstract class CopyWith$Input$DeleteCommentRequestInput<TRes> {
  factory CopyWith$Input$DeleteCommentRequestInput(
    Input$DeleteCommentRequestInput instance,
    TRes Function(Input$DeleteCommentRequestInput) then,
  ) = _CopyWithImpl$Input$DeleteCommentRequestInput;

  factory CopyWith$Input$DeleteCommentRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteCommentRequestInput;

  TRes call({String? commentId});
}

class _CopyWithImpl$Input$DeleteCommentRequestInput<TRes>
    implements CopyWith$Input$DeleteCommentRequestInput<TRes> {
  _CopyWithImpl$Input$DeleteCommentRequestInput(this._instance, this._then);

  final Input$DeleteCommentRequestInput _instance;

  final TRes Function(Input$DeleteCommentRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? commentId = _undefined}) => _then(
    Input$DeleteCommentRequestInput._({
      ..._instance._$data,
      if (commentId != _undefined && commentId != null)
        'commentId': (commentId as String),
    }),
  );
}

class _CopyWithStubImpl$Input$DeleteCommentRequestInput<TRes>
    implements CopyWith$Input$DeleteCommentRequestInput<TRes> {
  _CopyWithStubImpl$Input$DeleteCommentRequestInput(this._res);

  TRes _res;

  call({String? commentId}) => _res;
}

class Input$DeletedForEntryFilterInput {
  factory Input$DeletedForEntryFilterInput({
    List<Input$DeletedForEntryFilterInput>? and,
    List<Input$DeletedForEntryFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$BooleanOperationFilterInput? isDeleted,
  }) => Input$DeletedForEntryFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (userId != null) r'userId': userId,
    if (isDeleted != null) r'isDeleted': isDeleted,
  });

  Input$DeletedForEntryFilterInput._(this._$data);

  factory Input$DeletedForEntryFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$DeletedForEntryFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$DeletedForEntryFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isDeleted')) {
      final l$isDeleted = data['isDeleted'];
      result$data['isDeleted'] = l$isDeleted == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isDeleted as Map<String, dynamic>),
            );
    }
    return Input$DeletedForEntryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$DeletedForEntryFilterInput>? get and =>
      (_$data['and'] as List<Input$DeletedForEntryFilterInput>?);

  List<Input$DeletedForEntryFilterInput>? get or =>
      (_$data['or'] as List<Input$DeletedForEntryFilterInput>?);

  Input$StringOperationFilterInput? get userId =>
      (_$data['userId'] as Input$StringOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isDeleted =>
      (_$data['isDeleted'] as Input$BooleanOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('isDeleted')) {
      final l$isDeleted = isDeleted;
      result$data['isDeleted'] = l$isDeleted?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DeletedForEntryFilterInput<Input$DeletedForEntryFilterInput>
  get copyWith => CopyWith$Input$DeletedForEntryFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeletedForEntryFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$isDeleted = isDeleted;
    final lOther$isDeleted = other.isDeleted;
    if (_$data.containsKey('isDeleted') !=
        other._$data.containsKey('isDeleted')) {
      return false;
    }
    if (l$isDeleted != lOther$isDeleted) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$userId = userId;
    final l$isDeleted = isDeleted;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('isDeleted') ? l$isDeleted : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeletedForEntryFilterInput<TRes> {
  factory CopyWith$Input$DeletedForEntryFilterInput(
    Input$DeletedForEntryFilterInput instance,
    TRes Function(Input$DeletedForEntryFilterInput) then,
  ) = _CopyWithImpl$Input$DeletedForEntryFilterInput;

  factory CopyWith$Input$DeletedForEntryFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeletedForEntryFilterInput;

  TRes call({
    List<Input$DeletedForEntryFilterInput>? and,
    List<Input$DeletedForEntryFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$BooleanOperationFilterInput? isDeleted,
  });
  TRes and(
    Iterable<Input$DeletedForEntryFilterInput>? Function(
      Iterable<
        CopyWith$Input$DeletedForEntryFilterInput<
          Input$DeletedForEntryFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$DeletedForEntryFilterInput>? Function(
      Iterable<
        CopyWith$Input$DeletedForEntryFilterInput<
          Input$DeletedForEntryFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get userId;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDeleted;
}

class _CopyWithImpl$Input$DeletedForEntryFilterInput<TRes>
    implements CopyWith$Input$DeletedForEntryFilterInput<TRes> {
  _CopyWithImpl$Input$DeletedForEntryFilterInput(this._instance, this._then);

  final Input$DeletedForEntryFilterInput _instance;

  final TRes Function(Input$DeletedForEntryFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? userId = _undefined,
    Object? isDeleted = _undefined,
  }) => _then(
    Input$DeletedForEntryFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$DeletedForEntryFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$DeletedForEntryFilterInput>?),
      if (userId != _undefined)
        'userId': (userId as Input$StringOperationFilterInput?),
      if (isDeleted != _undefined)
        'isDeleted': (isDeleted as Input$BooleanOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$DeletedForEntryFilterInput>? Function(
      Iterable<
        CopyWith$Input$DeletedForEntryFilterInput<
          Input$DeletedForEntryFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$DeletedForEntryFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$DeletedForEntryFilterInput>? Function(
      Iterable<
        CopyWith$Input$DeletedForEntryFilterInput<
          Input$DeletedForEntryFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$DeletedForEntryFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userId,
            (e) => call(userId: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDeleted {
    final local$isDeleted = _instance.isDeleted;
    return local$isDeleted == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isDeleted,
            (e) => call(isDeleted: e),
          );
  }
}

class _CopyWithStubImpl$Input$DeletedForEntryFilterInput<TRes>
    implements CopyWith$Input$DeletedForEntryFilterInput<TRes> {
  _CopyWithStubImpl$Input$DeletedForEntryFilterInput(this._res);

  TRes _res;

  call({
    List<Input$DeletedForEntryFilterInput>? and,
    List<Input$DeletedForEntryFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$BooleanOperationFilterInput? isDeleted,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get userId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDeleted =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
}

class Input$DocumentTypeOperationFilterInput {
  factory Input$DocumentTypeOperationFilterInput({
    Enum$DocumentType? eq,
    Enum$DocumentType? neq,
    List<Enum$DocumentType>? $in,
    List<Enum$DocumentType>? nin,
  }) => Input$DocumentTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$DocumentTypeOperationFilterInput._(this._$data);

  factory Input$DocumentTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$DocumentType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$DocumentType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$DocumentType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$DocumentType((e as String)))
          .toList();
    }
    return Input$DocumentTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$DocumentType? get eq => (_$data['eq'] as Enum$DocumentType?);

  Enum$DocumentType? get neq => (_$data['neq'] as Enum$DocumentType?);

  List<Enum$DocumentType>? get $in =>
      (_$data['in'] as List<Enum$DocumentType>?);

  List<Enum$DocumentType>? get nin =>
      (_$data['nin'] as List<Enum$DocumentType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$DocumentType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$DocumentType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$DocumentType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$DocumentType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$DocumentTypeOperationFilterInput<
    Input$DocumentTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$DocumentTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DocumentTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DocumentTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$DocumentTypeOperationFilterInput(
    Input$DocumentTypeOperationFilterInput instance,
    TRes Function(Input$DocumentTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$DocumentTypeOperationFilterInput;

  factory CopyWith$Input$DocumentTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DocumentTypeOperationFilterInput;

  TRes call({
    Enum$DocumentType? eq,
    Enum$DocumentType? neq,
    List<Enum$DocumentType>? $in,
    List<Enum$DocumentType>? nin,
  });
}

class _CopyWithImpl$Input$DocumentTypeOperationFilterInput<TRes>
    implements CopyWith$Input$DocumentTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$DocumentTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$DocumentTypeOperationFilterInput _instance;

  final TRes Function(Input$DocumentTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$DocumentTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$DocumentType?),
      if (neq != _undefined) 'neq': (neq as Enum$DocumentType?),
      if ($in != _undefined) 'in': ($in as List<Enum$DocumentType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$DocumentType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$DocumentTypeOperationFilterInput<TRes>
    implements CopyWith$Input$DocumentTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$DocumentTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$DocumentType? eq,
    Enum$DocumentType? neq,
    List<Enum$DocumentType>? $in,
    List<Enum$DocumentType>? nin,
  }) => _res;
}

class Input$EntitlementFilterInput {
  factory Input$EntitlementFilterInput({
    List<Input$EntitlementFilterInput>? and,
    List<Input$EntitlementFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? code,
    Input$StringOperationFilterInput? description,
    Input$EntitlementValueTypeOperationFilterInput? valueType,
    Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput? defaultValues,
    Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput?
    subscriptionOverrides,
    Input$BooleanOperationFilterInput? isActive,
    Input$DateTimeOperationFilterInput? expiredAt,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$EntitlementFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (code != null) r'code': code,
    if (description != null) r'description': description,
    if (valueType != null) r'valueType': valueType,
    if (defaultValues != null) r'defaultValues': defaultValues,
    if (subscriptionOverrides != null)
      r'subscriptionOverrides': subscriptionOverrides,
    if (isActive != null) r'isActive': isActive,
    if (expiredAt != null) r'expiredAt': expiredAt,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$EntitlementFilterInput._(this._$data);

  factory Input$EntitlementFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$EntitlementFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$EntitlementFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>),
            );
    }
    if (data.containsKey('code')) {
      final l$code = data['code'];
      result$data['code'] = l$code == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$code as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('valueType')) {
      final l$valueType = data['valueType'];
      result$data['valueType'] = l$valueType == null
          ? null
          : Input$EntitlementValueTypeOperationFilterInput.fromJson(
              (l$valueType as Map<String, dynamic>),
            );
    }
    if (data.containsKey('defaultValues')) {
      final l$defaultValues = data['defaultValues'];
      result$data['defaultValues'] = l$defaultValues == null
          ? null
          : Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput.fromJson(
              (l$defaultValues as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionOverrides')) {
      final l$subscriptionOverrides = data['subscriptionOverrides'];
      result$data['subscriptionOverrides'] = l$subscriptionOverrides == null
          ? null
          : Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput.fromJson(
              (l$subscriptionOverrides as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = l$isActive == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isActive as Map<String, dynamic>),
            );
    }
    if (data.containsKey('expiredAt')) {
      final l$expiredAt = data['expiredAt'];
      result$data['expiredAt'] = l$expiredAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$expiredAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$EntitlementFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EntitlementFilterInput>? get and =>
      (_$data['and'] as List<Input$EntitlementFilterInput>?);

  List<Input$EntitlementFilterInput>? get or =>
      (_$data['or'] as List<Input$EntitlementFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get code =>
      (_$data['code'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$EntitlementValueTypeOperationFilterInput? get valueType =>
      (_$data['valueType'] as Input$EntitlementValueTypeOperationFilterInput?);

  Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput?
  get defaultValues =>
      (_$data['defaultValues']
          as Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput?);

  Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput?
  get subscriptionOverrides =>
      (_$data['subscriptionOverrides']
          as Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput?);

  Input$BooleanOperationFilterInput? get isActive =>
      (_$data['isActive'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get expiredAt =>
      (_$data['expiredAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('code')) {
      final l$code = code;
      result$data['code'] = l$code?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('valueType')) {
      final l$valueType = valueType;
      result$data['valueType'] = l$valueType?.toJson();
    }
    if (_$data.containsKey('defaultValues')) {
      final l$defaultValues = defaultValues;
      result$data['defaultValues'] = l$defaultValues?.toJson();
    }
    if (_$data.containsKey('subscriptionOverrides')) {
      final l$subscriptionOverrides = subscriptionOverrides;
      result$data['subscriptionOverrides'] = l$subscriptionOverrides?.toJson();
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive?.toJson();
    }
    if (_$data.containsKey('expiredAt')) {
      final l$expiredAt = expiredAt;
      result$data['expiredAt'] = l$expiredAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EntitlementFilterInput<Input$EntitlementFilterInput>
  get copyWith => CopyWith$Input$EntitlementFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EntitlementFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (_$data.containsKey('code') != other._$data.containsKey('code')) {
      return false;
    }
    if (l$code != lOther$code) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$valueType = valueType;
    final lOther$valueType = other.valueType;
    if (_$data.containsKey('valueType') !=
        other._$data.containsKey('valueType')) {
      return false;
    }
    if (l$valueType != lOther$valueType) {
      return false;
    }
    final l$defaultValues = defaultValues;
    final lOther$defaultValues = other.defaultValues;
    if (_$data.containsKey('defaultValues') !=
        other._$data.containsKey('defaultValues')) {
      return false;
    }
    if (l$defaultValues != lOther$defaultValues) {
      return false;
    }
    final l$subscriptionOverrides = subscriptionOverrides;
    final lOther$subscriptionOverrides = other.subscriptionOverrides;
    if (_$data.containsKey('subscriptionOverrides') !=
        other._$data.containsKey('subscriptionOverrides')) {
      return false;
    }
    if (l$subscriptionOverrides != lOther$subscriptionOverrides) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$expiredAt = expiredAt;
    final lOther$expiredAt = other.expiredAt;
    if (_$data.containsKey('expiredAt') !=
        other._$data.containsKey('expiredAt')) {
      return false;
    }
    if (l$expiredAt != lOther$expiredAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$name = name;
    final l$code = code;
    final l$description = description;
    final l$valueType = valueType;
    final l$defaultValues = defaultValues;
    final l$subscriptionOverrides = subscriptionOverrides;
    final l$isActive = isActive;
    final l$expiredAt = expiredAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('code') ? l$code : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('valueType') ? l$valueType : const {},
      _$data.containsKey('defaultValues') ? l$defaultValues : const {},
      _$data.containsKey('subscriptionOverrides')
          ? l$subscriptionOverrides
          : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('expiredAt') ? l$expiredAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$EntitlementFilterInput<TRes> {
  factory CopyWith$Input$EntitlementFilterInput(
    Input$EntitlementFilterInput instance,
    TRes Function(Input$EntitlementFilterInput) then,
  ) = _CopyWithImpl$Input$EntitlementFilterInput;

  factory CopyWith$Input$EntitlementFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EntitlementFilterInput;

  TRes call({
    List<Input$EntitlementFilterInput>? and,
    List<Input$EntitlementFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? code,
    Input$StringOperationFilterInput? description,
    Input$EntitlementValueTypeOperationFilterInput? valueType,
    Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput? defaultValues,
    Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput?
    subscriptionOverrides,
    Input$BooleanOperationFilterInput? isActive,
    Input$DateTimeOperationFilterInput? expiredAt,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$EntitlementFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementFilterInput<Input$EntitlementFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$EntitlementFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementFilterInput<Input$EntitlementFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  CopyWith$Input$StringOperationFilterInput<TRes> get code;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$EntitlementValueTypeOperationFilterInput<TRes> get valueType;
  CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput<TRes>
  get defaultValues;
  CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput<
    TRes
  >
  get subscriptionOverrides;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isActive;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get expiredAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$EntitlementFilterInput<TRes>
    implements CopyWith$Input$EntitlementFilterInput<TRes> {
  _CopyWithImpl$Input$EntitlementFilterInput(this._instance, this._then);

  final Input$EntitlementFilterInput _instance;

  final TRes Function(Input$EntitlementFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? code = _undefined,
    Object? description = _undefined,
    Object? valueType = _undefined,
    Object? defaultValues = _undefined,
    Object? subscriptionOverrides = _undefined,
    Object? isActive = _undefined,
    Object? expiredAt = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$EntitlementFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$EntitlementFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$EntitlementFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (name != _undefined)
        'name': (name as Input$StringOperationFilterInput?),
      if (code != _undefined)
        'code': (code as Input$StringOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (valueType != _undefined)
        'valueType':
            (valueType as Input$EntitlementValueTypeOperationFilterInput?),
      if (defaultValues != _undefined)
        'defaultValues':
            (defaultValues
                as Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput?),
      if (subscriptionOverrides != _undefined)
        'subscriptionOverrides':
            (subscriptionOverrides
                as Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput?),
      if (isActive != _undefined)
        'isActive': (isActive as Input$BooleanOperationFilterInput?),
      if (expiredAt != _undefined)
        'expiredAt': (expiredAt as Input$DateTimeOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$EntitlementFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementFilterInput<Input$EntitlementFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$EntitlementFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$EntitlementFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementFilterInput<Input$EntitlementFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$EntitlementFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name,
            (e) => call(name: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get code {
    final local$code = _instance.code;
    return local$code == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$code,
            (e) => call(code: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$EntitlementValueTypeOperationFilterInput<TRes> get valueType {
    final local$valueType = _instance.valueType;
    return local$valueType == null
        ? CopyWith$Input$EntitlementValueTypeOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$EntitlementValueTypeOperationFilterInput(
            local$valueType,
            (e) => call(valueType: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput<TRes>
  get defaultValues {
    final local$defaultValues = _instance.defaultValues;
    return local$defaultValues == null
        ? CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput(
            local$defaultValues,
            (e) => call(defaultValues: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput<
    TRes
  >
  get subscriptionOverrides {
    final local$subscriptionOverrides = _instance.subscriptionOverrides;
    return local$subscriptionOverrides == null
        ? CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput(
            local$subscriptionOverrides,
            (e) => call(subscriptionOverrides: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isActive {
    final local$isActive = _instance.isActive;
    return local$isActive == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isActive,
            (e) => call(isActive: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get expiredAt {
    final local$expiredAt = _instance.expiredAt;
    return local$expiredAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$expiredAt,
            (e) => call(expiredAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$EntitlementFilterInput<TRes>
    implements CopyWith$Input$EntitlementFilterInput<TRes> {
  _CopyWithStubImpl$Input$EntitlementFilterInput(this._res);

  TRes _res;

  call({
    List<Input$EntitlementFilterInput>? and,
    List<Input$EntitlementFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? code,
    Input$StringOperationFilterInput? description,
    Input$EntitlementValueTypeOperationFilterInput? valueType,
    Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput? defaultValues,
    Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput?
    subscriptionOverrides,
    Input$BooleanOperationFilterInput? isActive,
    Input$DateTimeOperationFilterInput? expiredAt,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get code =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$EntitlementValueTypeOperationFilterInput<TRes> get valueType =>
      CopyWith$Input$EntitlementValueTypeOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput<TRes>
  get defaultValues =>
      CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput.stub(
        _res,
      );

  CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput<
    TRes
  >
  get subscriptionOverrides =>
      CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput.stub(
        _res,
      );

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isActive =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get expiredAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$EntitlementRoleDefaultFilterInput {
  factory Input$EntitlementRoleDefaultFilterInput({
    List<Input$EntitlementRoleDefaultFilterInput>? and,
    List<Input$EntitlementRoleDefaultFilterInput>? or,
    Input$UserRoleOperationFilterInput? role,
  }) => Input$EntitlementRoleDefaultFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (role != null) r'role': role,
  });

  Input$EntitlementRoleDefaultFilterInput._(this._$data);

  factory Input$EntitlementRoleDefaultFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$EntitlementRoleDefaultFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$EntitlementRoleDefaultFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$UserRoleOperationFilterInput.fromJson(
              (l$role as Map<String, dynamic>),
            );
    }
    return Input$EntitlementRoleDefaultFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EntitlementRoleDefaultFilterInput>? get and =>
      (_$data['and'] as List<Input$EntitlementRoleDefaultFilterInput>?);

  List<Input$EntitlementRoleDefaultFilterInput>? get or =>
      (_$data['or'] as List<Input$EntitlementRoleDefaultFilterInput>?);

  Input$UserRoleOperationFilterInput? get role =>
      (_$data['role'] as Input$UserRoleOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EntitlementRoleDefaultFilterInput<
    Input$EntitlementRoleDefaultFilterInput
  >
  get copyWith =>
      CopyWith$Input$EntitlementRoleDefaultFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EntitlementRoleDefaultFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('role') ? l$role : const {},
    ]);
  }
}

abstract class CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> {
  factory CopyWith$Input$EntitlementRoleDefaultFilterInput(
    Input$EntitlementRoleDefaultFilterInput instance,
    TRes Function(Input$EntitlementRoleDefaultFilterInput) then,
  ) = _CopyWithImpl$Input$EntitlementRoleDefaultFilterInput;

  factory CopyWith$Input$EntitlementRoleDefaultFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EntitlementRoleDefaultFilterInput;

  TRes call({
    List<Input$EntitlementRoleDefaultFilterInput>? and,
    List<Input$EntitlementRoleDefaultFilterInput>? or,
    Input$UserRoleOperationFilterInput? role,
  });
  TRes and(
    Iterable<Input$EntitlementRoleDefaultFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementRoleDefaultFilterInput<
          Input$EntitlementRoleDefaultFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$EntitlementRoleDefaultFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementRoleDefaultFilterInput<
          Input$EntitlementRoleDefaultFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$UserRoleOperationFilterInput<TRes> get role;
}

class _CopyWithImpl$Input$EntitlementRoleDefaultFilterInput<TRes>
    implements CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> {
  _CopyWithImpl$Input$EntitlementRoleDefaultFilterInput(
    this._instance,
    this._then,
  );

  final Input$EntitlementRoleDefaultFilterInput _instance;

  final TRes Function(Input$EntitlementRoleDefaultFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? role = _undefined,
  }) => _then(
    Input$EntitlementRoleDefaultFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$EntitlementRoleDefaultFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$EntitlementRoleDefaultFilterInput>?),
      if (role != _undefined)
        'role': (role as Input$UserRoleOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$EntitlementRoleDefaultFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementRoleDefaultFilterInput<
          Input$EntitlementRoleDefaultFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$EntitlementRoleDefaultFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$EntitlementRoleDefaultFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementRoleDefaultFilterInput<
          Input$EntitlementRoleDefaultFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$EntitlementRoleDefaultFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$UserRoleOperationFilterInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$UserRoleOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserRoleOperationFilterInput(
            local$role,
            (e) => call(role: e),
          );
  }
}

class _CopyWithStubImpl$Input$EntitlementRoleDefaultFilterInput<TRes>
    implements CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> {
  _CopyWithStubImpl$Input$EntitlementRoleDefaultFilterInput(this._res);

  TRes _res;

  call({
    List<Input$EntitlementRoleDefaultFilterInput>? and,
    List<Input$EntitlementRoleDefaultFilterInput>? or,
    Input$UserRoleOperationFilterInput? role,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$UserRoleOperationFilterInput<TRes> get role =>
      CopyWith$Input$UserRoleOperationFilterInput.stub(_res);
}

class Input$EntitlementSortInput {
  factory Input$EntitlementSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? code,
    Enum$SortEnumType? description,
    Enum$SortEnumType? valueType,
    Enum$SortEnumType? isActive,
    Enum$SortEnumType? expiredAt,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$EntitlementSortInput._({
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (code != null) r'code': code,
    if (description != null) r'description': description,
    if (valueType != null) r'valueType': valueType,
    if (isActive != null) r'isActive': isActive,
    if (expiredAt != null) r'expiredAt': expiredAt,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$EntitlementSortInput._(this._$data);

  factory Input$EntitlementSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('code')) {
      final l$code = data['code'];
      result$data['code'] = l$code == null
          ? null
          : fromJson$Enum$SortEnumType((l$code as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('valueType')) {
      final l$valueType = data['valueType'];
      result$data['valueType'] = l$valueType == null
          ? null
          : fromJson$Enum$SortEnumType((l$valueType as String));
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = l$isActive == null
          ? null
          : fromJson$Enum$SortEnumType((l$isActive as String));
    }
    if (data.containsKey('expiredAt')) {
      final l$expiredAt = data['expiredAt'];
      result$data['expiredAt'] = l$expiredAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$expiredAt as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$EntitlementSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);

  Enum$SortEnumType? get code => (_$data['code'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get valueType =>
      (_$data['valueType'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isActive => (_$data['isActive'] as Enum$SortEnumType?);

  Enum$SortEnumType? get expiredAt =>
      (_$data['expiredAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null
          ? null
          : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('code')) {
      final l$code = code;
      result$data['code'] = l$code == null
          ? null
          : toJson$Enum$SortEnumType(l$code);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('valueType')) {
      final l$valueType = valueType;
      result$data['valueType'] = l$valueType == null
          ? null
          : toJson$Enum$SortEnumType(l$valueType);
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive == null
          ? null
          : toJson$Enum$SortEnumType(l$isActive);
    }
    if (_$data.containsKey('expiredAt')) {
      final l$expiredAt = expiredAt;
      result$data['expiredAt'] = l$expiredAt == null
          ? null
          : toJson$Enum$SortEnumType(l$expiredAt);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$EntitlementSortInput<Input$EntitlementSortInput>
  get copyWith => CopyWith$Input$EntitlementSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EntitlementSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (_$data.containsKey('code') != other._$data.containsKey('code')) {
      return false;
    }
    if (l$code != lOther$code) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$valueType = valueType;
    final lOther$valueType = other.valueType;
    if (_$data.containsKey('valueType') !=
        other._$data.containsKey('valueType')) {
      return false;
    }
    if (l$valueType != lOther$valueType) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$expiredAt = expiredAt;
    final lOther$expiredAt = other.expiredAt;
    if (_$data.containsKey('expiredAt') !=
        other._$data.containsKey('expiredAt')) {
      return false;
    }
    if (l$expiredAt != lOther$expiredAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$code = code;
    final l$description = description;
    final l$valueType = valueType;
    final l$isActive = isActive;
    final l$expiredAt = expiredAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('code') ? l$code : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('valueType') ? l$valueType : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('expiredAt') ? l$expiredAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$EntitlementSortInput<TRes> {
  factory CopyWith$Input$EntitlementSortInput(
    Input$EntitlementSortInput instance,
    TRes Function(Input$EntitlementSortInput) then,
  ) = _CopyWithImpl$Input$EntitlementSortInput;

  factory CopyWith$Input$EntitlementSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EntitlementSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? code,
    Enum$SortEnumType? description,
    Enum$SortEnumType? valueType,
    Enum$SortEnumType? isActive,
    Enum$SortEnumType? expiredAt,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$EntitlementSortInput<TRes>
    implements CopyWith$Input$EntitlementSortInput<TRes> {
  _CopyWithImpl$Input$EntitlementSortInput(this._instance, this._then);

  final Input$EntitlementSortInput _instance;

  final TRes Function(Input$EntitlementSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? code = _undefined,
    Object? description = _undefined,
    Object? valueType = _undefined,
    Object? isActive = _undefined,
    Object? expiredAt = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$EntitlementSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      if (code != _undefined) 'code': (code as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (valueType != _undefined)
        'valueType': (valueType as Enum$SortEnumType?),
      if (isActive != _undefined) 'isActive': (isActive as Enum$SortEnumType?),
      if (expiredAt != _undefined)
        'expiredAt': (expiredAt as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$EntitlementSortInput<TRes>
    implements CopyWith$Input$EntitlementSortInput<TRes> {
  _CopyWithStubImpl$Input$EntitlementSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? code,
    Enum$SortEnumType? description,
    Enum$SortEnumType? valueType,
    Enum$SortEnumType? isActive,
    Enum$SortEnumType? expiredAt,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$EntitlementSubscriptionOverrideFilterInput {
  factory Input$EntitlementSubscriptionOverrideFilterInput({
    List<Input$EntitlementSubscriptionOverrideFilterInput>? and,
    List<Input$EntitlementSubscriptionOverrideFilterInput>? or,
    Input$StringOperationFilterInput? subscriptionCode,
  }) => Input$EntitlementSubscriptionOverrideFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (subscriptionCode != null) r'subscriptionCode': subscriptionCode,
  });

  Input$EntitlementSubscriptionOverrideFilterInput._(this._$data);

  factory Input$EntitlementSubscriptionOverrideFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$EntitlementSubscriptionOverrideFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$EntitlementSubscriptionOverrideFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('subscriptionCode')) {
      final l$subscriptionCode = data['subscriptionCode'];
      result$data['subscriptionCode'] = l$subscriptionCode == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$subscriptionCode as Map<String, dynamic>),
            );
    }
    return Input$EntitlementSubscriptionOverrideFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EntitlementSubscriptionOverrideFilterInput>? get and =>
      (_$data['and']
          as List<Input$EntitlementSubscriptionOverrideFilterInput>?);

  List<Input$EntitlementSubscriptionOverrideFilterInput>? get or =>
      (_$data['or'] as List<Input$EntitlementSubscriptionOverrideFilterInput>?);

  Input$StringOperationFilterInput? get subscriptionCode =>
      (_$data['subscriptionCode'] as Input$StringOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('subscriptionCode')) {
      final l$subscriptionCode = subscriptionCode;
      result$data['subscriptionCode'] = l$subscriptionCode?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<
    Input$EntitlementSubscriptionOverrideFilterInput
  >
  get copyWith =>
      CopyWith$Input$EntitlementSubscriptionOverrideFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EntitlementSubscriptionOverrideFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$subscriptionCode = subscriptionCode;
    final lOther$subscriptionCode = other.subscriptionCode;
    if (_$data.containsKey('subscriptionCode') !=
        other._$data.containsKey('subscriptionCode')) {
      return false;
    }
    if (l$subscriptionCode != lOther$subscriptionCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$subscriptionCode = subscriptionCode;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('subscriptionCode') ? l$subscriptionCode : const {},
    ]);
  }
}

abstract class CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> {
  factory CopyWith$Input$EntitlementSubscriptionOverrideFilterInput(
    Input$EntitlementSubscriptionOverrideFilterInput instance,
    TRes Function(Input$EntitlementSubscriptionOverrideFilterInput) then,
  ) = _CopyWithImpl$Input$EntitlementSubscriptionOverrideFilterInput;

  factory CopyWith$Input$EntitlementSubscriptionOverrideFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$EntitlementSubscriptionOverrideFilterInput;

  TRes call({
    List<Input$EntitlementSubscriptionOverrideFilterInput>? and,
    List<Input$EntitlementSubscriptionOverrideFilterInput>? or,
    Input$StringOperationFilterInput? subscriptionCode,
  });
  TRes and(
    Iterable<Input$EntitlementSubscriptionOverrideFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<
          Input$EntitlementSubscriptionOverrideFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$EntitlementSubscriptionOverrideFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<
          Input$EntitlementSubscriptionOverrideFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionCode;
}

class _CopyWithImpl$Input$EntitlementSubscriptionOverrideFilterInput<TRes>
    implements CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> {
  _CopyWithImpl$Input$EntitlementSubscriptionOverrideFilterInput(
    this._instance,
    this._then,
  );

  final Input$EntitlementSubscriptionOverrideFilterInput _instance;

  final TRes Function(Input$EntitlementSubscriptionOverrideFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? subscriptionCode = _undefined,
  }) => _then(
    Input$EntitlementSubscriptionOverrideFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$EntitlementSubscriptionOverrideFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$EntitlementSubscriptionOverrideFilterInput>?),
      if (subscriptionCode != _undefined)
        'subscriptionCode':
            (subscriptionCode as Input$StringOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$EntitlementSubscriptionOverrideFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<
          Input$EntitlementSubscriptionOverrideFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$EntitlementSubscriptionOverrideFilterInput(
          e,
          (i) => i,
        ),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$EntitlementSubscriptionOverrideFilterInput>? Function(
      Iterable<
        CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<
          Input$EntitlementSubscriptionOverrideFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$EntitlementSubscriptionOverrideFilterInput(
          e,
          (i) => i,
        ),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionCode {
    final local$subscriptionCode = _instance.subscriptionCode;
    return local$subscriptionCode == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$subscriptionCode,
            (e) => call(subscriptionCode: e),
          );
  }
}

class _CopyWithStubImpl$Input$EntitlementSubscriptionOverrideFilterInput<TRes>
    implements CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> {
  _CopyWithStubImpl$Input$EntitlementSubscriptionOverrideFilterInput(this._res);

  TRes _res;

  call({
    List<Input$EntitlementSubscriptionOverrideFilterInput>? and,
    List<Input$EntitlementSubscriptionOverrideFilterInput>? or,
    Input$StringOperationFilterInput? subscriptionCode,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionCode =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
}

class Input$EntitlementValueTypeOperationFilterInput {
  factory Input$EntitlementValueTypeOperationFilterInput({
    Enum$EntitlementValueType? eq,
    Enum$EntitlementValueType? neq,
    List<Enum$EntitlementValueType>? $in,
    List<Enum$EntitlementValueType>? nin,
  }) => Input$EntitlementValueTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$EntitlementValueTypeOperationFilterInput._(this._$data);

  factory Input$EntitlementValueTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$EntitlementValueType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$EntitlementValueType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$EntitlementValueType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$EntitlementValueType((e as String)))
          .toList();
    }
    return Input$EntitlementValueTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EntitlementValueType? get eq =>
      (_$data['eq'] as Enum$EntitlementValueType?);

  Enum$EntitlementValueType? get neq =>
      (_$data['neq'] as Enum$EntitlementValueType?);

  List<Enum$EntitlementValueType>? get $in =>
      (_$data['in'] as List<Enum$EntitlementValueType>?);

  List<Enum$EntitlementValueType>? get nin =>
      (_$data['nin'] as List<Enum$EntitlementValueType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$EntitlementValueType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$EntitlementValueType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$EntitlementValueType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$EntitlementValueType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$EntitlementValueTypeOperationFilterInput<
    Input$EntitlementValueTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$EntitlementValueTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EntitlementValueTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$EntitlementValueTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$EntitlementValueTypeOperationFilterInput(
    Input$EntitlementValueTypeOperationFilterInput instance,
    TRes Function(Input$EntitlementValueTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$EntitlementValueTypeOperationFilterInput;

  factory CopyWith$Input$EntitlementValueTypeOperationFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$EntitlementValueTypeOperationFilterInput;

  TRes call({
    Enum$EntitlementValueType? eq,
    Enum$EntitlementValueType? neq,
    List<Enum$EntitlementValueType>? $in,
    List<Enum$EntitlementValueType>? nin,
  });
}

class _CopyWithImpl$Input$EntitlementValueTypeOperationFilterInput<TRes>
    implements CopyWith$Input$EntitlementValueTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$EntitlementValueTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$EntitlementValueTypeOperationFilterInput _instance;

  final TRes Function(Input$EntitlementValueTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$EntitlementValueTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$EntitlementValueType?),
      if (neq != _undefined) 'neq': (neq as Enum$EntitlementValueType?),
      if ($in != _undefined) 'in': ($in as List<Enum$EntitlementValueType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$EntitlementValueType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$EntitlementValueTypeOperationFilterInput<TRes>
    implements CopyWith$Input$EntitlementValueTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$EntitlementValueTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$EntitlementValueType? eq,
    Enum$EntitlementValueType? neq,
    List<Enum$EntitlementValueType>? $in,
    List<Enum$EntitlementValueType>? nin,
  }) => _res;
}

class Input$EscrowCommissionPolicyFilterInput {
  factory Input$EscrowCommissionPolicyFilterInput({
    List<Input$EscrowCommissionPolicyFilterInput>? and,
    List<Input$EscrowCommissionPolicyFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DecimalOperationFilterInput? platformFeePercentage,
    Input$LongOperationFilterInput? version,
    Input$PolicyStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$EscrowCommissionPolicyFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (currency != null) r'currency': currency,
    if (platformFeePercentage != null)
      r'platformFeePercentage': platformFeePercentage,
    if (version != null) r'version': version,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$EscrowCommissionPolicyFilterInput._(this._$data);

  factory Input$EscrowCommissionPolicyFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$EscrowCommissionPolicyFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$EscrowCommissionPolicyFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : Input$CurrencyTypeOperationFilterInput.fromJson(
              (l$currency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = data['platformFeePercentage'];
      result$data['platformFeePercentage'] = l$platformFeePercentage == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$platformFeePercentage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$version as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$PolicyStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$EscrowCommissionPolicyFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EscrowCommissionPolicyFilterInput>? get and =>
      (_$data['and'] as List<Input$EscrowCommissionPolicyFilterInput>?);

  List<Input$EscrowCommissionPolicyFilterInput>? get or =>
      (_$data['or'] as List<Input$EscrowCommissionPolicyFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$CurrencyTypeOperationFilterInput? get currency =>
      (_$data['currency'] as Input$CurrencyTypeOperationFilterInput?);

  Input$DecimalOperationFilterInput? get platformFeePercentage =>
      (_$data['platformFeePercentage'] as Input$DecimalOperationFilterInput?);

  Input$LongOperationFilterInput? get version =>
      (_$data['version'] as Input$LongOperationFilterInput?);

  Input$PolicyStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$PolicyStatusOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency?.toJson();
    }
    if (_$data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = platformFeePercentage;
      result$data['platformFeePercentage'] = l$platformFeePercentage?.toJson();
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EscrowCommissionPolicyFilterInput<
    Input$EscrowCommissionPolicyFilterInput
  >
  get copyWith =>
      CopyWith$Input$EscrowCommissionPolicyFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EscrowCommissionPolicyFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$platformFeePercentage = platformFeePercentage;
    final lOther$platformFeePercentage = other.platformFeePercentage;
    if (_$data.containsKey('platformFeePercentage') !=
        other._$data.containsKey('platformFeePercentage')) {
      return false;
    }
    if (l$platformFeePercentage != lOther$platformFeePercentage) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$currency = currency;
    final l$platformFeePercentage = platformFeePercentage;
    final l$version = version;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('platformFeePercentage')
          ? l$platformFeePercentage
          : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$EscrowCommissionPolicyFilterInput<TRes> {
  factory CopyWith$Input$EscrowCommissionPolicyFilterInput(
    Input$EscrowCommissionPolicyFilterInput instance,
    TRes Function(Input$EscrowCommissionPolicyFilterInput) then,
  ) = _CopyWithImpl$Input$EscrowCommissionPolicyFilterInput;

  factory CopyWith$Input$EscrowCommissionPolicyFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EscrowCommissionPolicyFilterInput;

  TRes call({
    List<Input$EscrowCommissionPolicyFilterInput>? and,
    List<Input$EscrowCommissionPolicyFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DecimalOperationFilterInput? platformFeePercentage,
    Input$LongOperationFilterInput? version,
    Input$PolicyStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$EscrowCommissionPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$EscrowCommissionPolicyFilterInput<
          Input$EscrowCommissionPolicyFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$EscrowCommissionPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$EscrowCommissionPolicyFilterInput<
          Input$EscrowCommissionPolicyFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get platformFeePercentage;
  CopyWith$Input$LongOperationFilterInput<TRes> get version;
  CopyWith$Input$PolicyStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$EscrowCommissionPolicyFilterInput<TRes>
    implements CopyWith$Input$EscrowCommissionPolicyFilterInput<TRes> {
  _CopyWithImpl$Input$EscrowCommissionPolicyFilterInput(
    this._instance,
    this._then,
  );

  final Input$EscrowCommissionPolicyFilterInput _instance;

  final TRes Function(Input$EscrowCommissionPolicyFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? currency = _undefined,
    Object? platformFeePercentage = _undefined,
    Object? version = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$EscrowCommissionPolicyFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$EscrowCommissionPolicyFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$EscrowCommissionPolicyFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (currency != _undefined)
        'currency': (currency as Input$CurrencyTypeOperationFilterInput?),
      if (platformFeePercentage != _undefined)
        'platformFeePercentage':
            (platformFeePercentage as Input$DecimalOperationFilterInput?),
      if (version != _undefined)
        'version': (version as Input$LongOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$PolicyStatusOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$EscrowCommissionPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$EscrowCommissionPolicyFilterInput<
          Input$EscrowCommissionPolicyFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$EscrowCommissionPolicyFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$EscrowCommissionPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$EscrowCommissionPolicyFilterInput<
          Input$EscrowCommissionPolicyFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$EscrowCommissionPolicyFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency {
    final local$currency = _instance.currency;
    return local$currency == null
        ? CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CurrencyTypeOperationFilterInput(
            local$currency,
            (e) => call(currency: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get platformFeePercentage {
    final local$platformFeePercentage = _instance.platformFeePercentage;
    return local$platformFeePercentage == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$platformFeePercentage,
            (e) => call(platformFeePercentage: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get version {
    final local$version = _instance.version;
    return local$version == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$version,
            (e) => call(version: e),
          );
  }

  CopyWith$Input$PolicyStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$PolicyStatusOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$PolicyStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$EscrowCommissionPolicyFilterInput<TRes>
    implements CopyWith$Input$EscrowCommissionPolicyFilterInput<TRes> {
  _CopyWithStubImpl$Input$EscrowCommissionPolicyFilterInput(this._res);

  TRes _res;

  call({
    List<Input$EscrowCommissionPolicyFilterInput>? and,
    List<Input$EscrowCommissionPolicyFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DecimalOperationFilterInput? platformFeePercentage,
    Input$LongOperationFilterInput? version,
    Input$PolicyStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency =>
      CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get platformFeePercentage =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get version =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$PolicyStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$PolicyStatusOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$EscrowCommissionPolicySortInput {
  factory Input$EscrowCommissionPolicySortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? platformFeePercentage,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$EscrowCommissionPolicySortInput._({
    if (id != null) r'id': id,
    if (currency != null) r'currency': currency,
    if (platformFeePercentage != null)
      r'platformFeePercentage': platformFeePercentage,
    if (version != null) r'version': version,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$EscrowCommissionPolicySortInput._(this._$data);

  factory Input$EscrowCommissionPolicySortInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$SortEnumType((l$currency as String));
    }
    if (data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = data['platformFeePercentage'];
      result$data['platformFeePercentage'] = l$platformFeePercentage == null
          ? null
          : fromJson$Enum$SortEnumType((l$platformFeePercentage as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$SortEnumType((l$version as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$EscrowCommissionPolicySortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get currency => (_$data['currency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get platformFeePercentage =>
      (_$data['platformFeePercentage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get version => (_$data['version'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$SortEnumType(l$currency);
    }
    if (_$data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = platformFeePercentage;
      result$data['platformFeePercentage'] = l$platformFeePercentage == null
          ? null
          : toJson$Enum$SortEnumType(l$platformFeePercentage);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version == null
          ? null
          : toJson$Enum$SortEnumType(l$version);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$EscrowCommissionPolicySortInput<
    Input$EscrowCommissionPolicySortInput
  >
  get copyWith =>
      CopyWith$Input$EscrowCommissionPolicySortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EscrowCommissionPolicySortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$platformFeePercentage = platformFeePercentage;
    final lOther$platformFeePercentage = other.platformFeePercentage;
    if (_$data.containsKey('platformFeePercentage') !=
        other._$data.containsKey('platformFeePercentage')) {
      return false;
    }
    if (l$platformFeePercentage != lOther$platformFeePercentage) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$currency = currency;
    final l$platformFeePercentage = platformFeePercentage;
    final l$version = version;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('platformFeePercentage')
          ? l$platformFeePercentage
          : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$EscrowCommissionPolicySortInput<TRes> {
  factory CopyWith$Input$EscrowCommissionPolicySortInput(
    Input$EscrowCommissionPolicySortInput instance,
    TRes Function(Input$EscrowCommissionPolicySortInput) then,
  ) = _CopyWithImpl$Input$EscrowCommissionPolicySortInput;

  factory CopyWith$Input$EscrowCommissionPolicySortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EscrowCommissionPolicySortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? platformFeePercentage,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$EscrowCommissionPolicySortInput<TRes>
    implements CopyWith$Input$EscrowCommissionPolicySortInput<TRes> {
  _CopyWithImpl$Input$EscrowCommissionPolicySortInput(
    this._instance,
    this._then,
  );

  final Input$EscrowCommissionPolicySortInput _instance;

  final TRes Function(Input$EscrowCommissionPolicySortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? currency = _undefined,
    Object? platformFeePercentage = _undefined,
    Object? version = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$EscrowCommissionPolicySortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (currency != _undefined) 'currency': (currency as Enum$SortEnumType?),
      if (platformFeePercentage != _undefined)
        'platformFeePercentage': (platformFeePercentage as Enum$SortEnumType?),
      if (version != _undefined) 'version': (version as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$EscrowCommissionPolicySortInput<TRes>
    implements CopyWith$Input$EscrowCommissionPolicySortInput<TRes> {
  _CopyWithStubImpl$Input$EscrowCommissionPolicySortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? platformFeePercentage,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$FloatOperationFilterInput {
  factory Input$FloatOperationFilterInput({
    double? eq,
    double? neq,
    List<double?>? $in,
    List<double?>? nin,
    double? gt,
    double? ngt,
    double? gte,
    double? ngte,
    double? lt,
    double? nlt,
    double? lte,
    double? nlte,
  }) => Input$FloatOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
    if (gt != null) r'gt': gt,
    if (ngt != null) r'ngt': ngt,
    if (gte != null) r'gte': gte,
    if (ngte != null) r'ngte': ngte,
    if (lt != null) r'lt': lt,
    if (nlt != null) r'nlt': nlt,
    if (lte != null) r'lte': lte,
    if (nlte != null) r'nlte': nlte,
  });

  Input$FloatOperationFilterInput._(this._$data);

  factory Input$FloatOperationFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as num?)?.toDouble();
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as num?)?.toDouble();
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => (e as num?)?.toDouble())
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => (e as num?)?.toDouble())
          .toList();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as num?)?.toDouble();
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as num?)?.toDouble();
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as num?)?.toDouble();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as num?)?.toDouble();
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as num?)?.toDouble();
    }
    return Input$FloatOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get eq => (_$data['eq'] as double?);

  double? get neq => (_$data['neq'] as double?);

  List<double?>? get $in => (_$data['in'] as List<double?>?);

  List<double?>? get nin => (_$data['nin'] as List<double?>?);

  double? get gt => (_$data['gt'] as double?);

  double? get ngt => (_$data['ngt'] as double?);

  double? get gte => (_$data['gte'] as double?);

  double? get ngte => (_$data['ngte'] as double?);

  double? get lt => (_$data['lt'] as double?);

  double? get nlt => (_$data['nlt'] as double?);

  double? get lte => (_$data['lte'] as double?);

  double? get nlte => (_$data['nlte'] as double?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$FloatOperationFilterInput<Input$FloatOperationFilterInput>
  get copyWith => CopyWith$Input$FloatOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FloatOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    final l$gt = gt;
    final l$ngt = ngt;
    final l$gte = gte;
    final l$ngte = ngte;
    final l$lt = lt;
    final l$nlt = nlt;
    final l$lte = lte;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$FloatOperationFilterInput<TRes> {
  factory CopyWith$Input$FloatOperationFilterInput(
    Input$FloatOperationFilterInput instance,
    TRes Function(Input$FloatOperationFilterInput) then,
  ) = _CopyWithImpl$Input$FloatOperationFilterInput;

  factory CopyWith$Input$FloatOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FloatOperationFilterInput;

  TRes call({
    double? eq,
    double? neq,
    List<double?>? $in,
    List<double?>? nin,
    double? gt,
    double? ngt,
    double? gte,
    double? ngte,
    double? lt,
    double? nlt,
    double? lte,
    double? nlte,
  });
}

class _CopyWithImpl$Input$FloatOperationFilterInput<TRes>
    implements CopyWith$Input$FloatOperationFilterInput<TRes> {
  _CopyWithImpl$Input$FloatOperationFilterInput(this._instance, this._then);

  final Input$FloatOperationFilterInput _instance;

  final TRes Function(Input$FloatOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
    Object? gt = _undefined,
    Object? ngt = _undefined,
    Object? gte = _undefined,
    Object? ngte = _undefined,
    Object? lt = _undefined,
    Object? nlt = _undefined,
    Object? lte = _undefined,
    Object? nlte = _undefined,
  }) => _then(
    Input$FloatOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as double?),
      if (neq != _undefined) 'neq': (neq as double?),
      if ($in != _undefined) 'in': ($in as List<double?>?),
      if (nin != _undefined) 'nin': (nin as List<double?>?),
      if (gt != _undefined) 'gt': (gt as double?),
      if (ngt != _undefined) 'ngt': (ngt as double?),
      if (gte != _undefined) 'gte': (gte as double?),
      if (ngte != _undefined) 'ngte': (ngte as double?),
      if (lt != _undefined) 'lt': (lt as double?),
      if (nlt != _undefined) 'nlt': (nlt as double?),
      if (lte != _undefined) 'lte': (lte as double?),
      if (nlte != _undefined) 'nlte': (nlte as double?),
    }),
  );
}

class _CopyWithStubImpl$Input$FloatOperationFilterInput<TRes>
    implements CopyWith$Input$FloatOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$FloatOperationFilterInput(this._res);

  TRes _res;

  call({
    double? eq,
    double? neq,
    List<double?>? $in,
    List<double?>? nin,
    double? gt,
    double? ngt,
    double? gte,
    double? ngte,
    double? lt,
    double? nlt,
    double? lte,
    double? nlte,
  }) => _res;
}

class Input$HistoryActionTypeOperationFilterInput {
  factory Input$HistoryActionTypeOperationFilterInput({
    Enum$HistoryActionType? eq,
    Enum$HistoryActionType? neq,
    List<Enum$HistoryActionType>? $in,
    List<Enum$HistoryActionType>? nin,
  }) => Input$HistoryActionTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$HistoryActionTypeOperationFilterInput._(this._$data);

  factory Input$HistoryActionTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$HistoryActionType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$HistoryActionType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$HistoryActionType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$HistoryActionType((e as String)))
          .toList();
    }
    return Input$HistoryActionTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$HistoryActionType? get eq => (_$data['eq'] as Enum$HistoryActionType?);

  Enum$HistoryActionType? get neq => (_$data['neq'] as Enum$HistoryActionType?);

  List<Enum$HistoryActionType>? get $in =>
      (_$data['in'] as List<Enum$HistoryActionType>?);

  List<Enum$HistoryActionType>? get nin =>
      (_$data['nin'] as List<Enum$HistoryActionType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$HistoryActionType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$HistoryActionType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$HistoryActionType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$HistoryActionType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$HistoryActionTypeOperationFilterInput<
    Input$HistoryActionTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$HistoryActionTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$HistoryActionTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$HistoryActionTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$HistoryActionTypeOperationFilterInput(
    Input$HistoryActionTypeOperationFilterInput instance,
    TRes Function(Input$HistoryActionTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$HistoryActionTypeOperationFilterInput;

  factory CopyWith$Input$HistoryActionTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$HistoryActionTypeOperationFilterInput;

  TRes call({
    Enum$HistoryActionType? eq,
    Enum$HistoryActionType? neq,
    List<Enum$HistoryActionType>? $in,
    List<Enum$HistoryActionType>? nin,
  });
}

class _CopyWithImpl$Input$HistoryActionTypeOperationFilterInput<TRes>
    implements CopyWith$Input$HistoryActionTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$HistoryActionTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$HistoryActionTypeOperationFilterInput _instance;

  final TRes Function(Input$HistoryActionTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$HistoryActionTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$HistoryActionType?),
      if (neq != _undefined) 'neq': (neq as Enum$HistoryActionType?),
      if ($in != _undefined) 'in': ($in as List<Enum$HistoryActionType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$HistoryActionType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$HistoryActionTypeOperationFilterInput<TRes>
    implements CopyWith$Input$HistoryActionTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$HistoryActionTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$HistoryActionType? eq,
    Enum$HistoryActionType? neq,
    List<Enum$HistoryActionType>? $in,
    List<Enum$HistoryActionType>? nin,
  }) => _res;
}

class Input$IdentityCardFilterInput {
  factory Input$IdentityCardFilterInput({
    List<Input$IdentityCardFilterInput>? and,
    List<Input$IdentityCardFilterInput>? or,
    Input$StringOperationFilterInput? number,
    Input$StringOperationFilterInput? fullName,
    Input$DateTimeOperationFilterInput? dateOfBirth,
    Input$UserGenderOperationFilterInput? gender,
    Input$StringOperationFilterInput? placeOfOrigin,
    Input$StringOperationFilterInput? nationality,
    Input$AddressFilterInput? placeOfResidence,
    Input$StringOperationFilterInput? frontImage,
    Input$StringOperationFilterInput? backImage,
    Input$DateTimeOperationFilterInput? validUntil,
  }) => Input$IdentityCardFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (number != null) r'number': number,
    if (fullName != null) r'fullName': fullName,
    if (dateOfBirth != null) r'dateOfBirth': dateOfBirth,
    if (gender != null) r'gender': gender,
    if (placeOfOrigin != null) r'placeOfOrigin': placeOfOrigin,
    if (nationality != null) r'nationality': nationality,
    if (placeOfResidence != null) r'placeOfResidence': placeOfResidence,
    if (frontImage != null) r'frontImage': frontImage,
    if (backImage != null) r'backImage': backImage,
    if (validUntil != null) r'validUntil': validUntil,
  });

  Input$IdentityCardFilterInput._(this._$data);

  factory Input$IdentityCardFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$IdentityCardFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$IdentityCardFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('number')) {
      final l$number = data['number'];
      result$data['number'] = l$number == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$number as Map<String, dynamic>),
            );
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$fullName as Map<String, dynamic>),
            );
    }
    if (data.containsKey('dateOfBirth')) {
      final l$dateOfBirth = data['dateOfBirth'];
      result$data['dateOfBirth'] = l$dateOfBirth == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$dateOfBirth as Map<String, dynamic>),
            );
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = l$gender == null
          ? null
          : Input$UserGenderOperationFilterInput.fromJson(
              (l$gender as Map<String, dynamic>),
            );
    }
    if (data.containsKey('placeOfOrigin')) {
      final l$placeOfOrigin = data['placeOfOrigin'];
      result$data['placeOfOrigin'] = l$placeOfOrigin == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$placeOfOrigin as Map<String, dynamic>),
            );
    }
    if (data.containsKey('nationality')) {
      final l$nationality = data['nationality'];
      result$data['nationality'] = l$nationality == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$nationality as Map<String, dynamic>),
            );
    }
    if (data.containsKey('placeOfResidence')) {
      final l$placeOfResidence = data['placeOfResidence'];
      result$data['placeOfResidence'] = l$placeOfResidence == null
          ? null
          : Input$AddressFilterInput.fromJson(
              (l$placeOfResidence as Map<String, dynamic>),
            );
    }
    if (data.containsKey('frontImage')) {
      final l$frontImage = data['frontImage'];
      result$data['frontImage'] = l$frontImage == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$frontImage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('backImage')) {
      final l$backImage = data['backImage'];
      result$data['backImage'] = l$backImage == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$backImage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('validUntil')) {
      final l$validUntil = data['validUntil'];
      result$data['validUntil'] = l$validUntil == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$validUntil as Map<String, dynamic>),
            );
    }
    return Input$IdentityCardFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$IdentityCardFilterInput>? get and =>
      (_$data['and'] as List<Input$IdentityCardFilterInput>?);

  List<Input$IdentityCardFilterInput>? get or =>
      (_$data['or'] as List<Input$IdentityCardFilterInput>?);

  Input$StringOperationFilterInput? get number =>
      (_$data['number'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get fullName =>
      (_$data['fullName'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get dateOfBirth =>
      (_$data['dateOfBirth'] as Input$DateTimeOperationFilterInput?);

  Input$UserGenderOperationFilterInput? get gender =>
      (_$data['gender'] as Input$UserGenderOperationFilterInput?);

  Input$StringOperationFilterInput? get placeOfOrigin =>
      (_$data['placeOfOrigin'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get nationality =>
      (_$data['nationality'] as Input$StringOperationFilterInput?);

  Input$AddressFilterInput? get placeOfResidence =>
      (_$data['placeOfResidence'] as Input$AddressFilterInput?);

  Input$StringOperationFilterInput? get frontImage =>
      (_$data['frontImage'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get backImage =>
      (_$data['backImage'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get validUntil =>
      (_$data['validUntil'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('number')) {
      final l$number = number;
      result$data['number'] = l$number?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('dateOfBirth')) {
      final l$dateOfBirth = dateOfBirth;
      result$data['dateOfBirth'] = l$dateOfBirth?.toJson();
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender?.toJson();
    }
    if (_$data.containsKey('placeOfOrigin')) {
      final l$placeOfOrigin = placeOfOrigin;
      result$data['placeOfOrigin'] = l$placeOfOrigin?.toJson();
    }
    if (_$data.containsKey('nationality')) {
      final l$nationality = nationality;
      result$data['nationality'] = l$nationality?.toJson();
    }
    if (_$data.containsKey('placeOfResidence')) {
      final l$placeOfResidence = placeOfResidence;
      result$data['placeOfResidence'] = l$placeOfResidence?.toJson();
    }
    if (_$data.containsKey('frontImage')) {
      final l$frontImage = frontImage;
      result$data['frontImage'] = l$frontImage?.toJson();
    }
    if (_$data.containsKey('backImage')) {
      final l$backImage = backImage;
      result$data['backImage'] = l$backImage?.toJson();
    }
    if (_$data.containsKey('validUntil')) {
      final l$validUntil = validUntil;
      result$data['validUntil'] = l$validUntil?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$IdentityCardFilterInput<Input$IdentityCardFilterInput>
  get copyWith => CopyWith$Input$IdentityCardFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IdentityCardFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (_$data.containsKey('number') != other._$data.containsKey('number')) {
      return false;
    }
    if (l$number != lOther$number) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$dateOfBirth = dateOfBirth;
    final lOther$dateOfBirth = other.dateOfBirth;
    if (_$data.containsKey('dateOfBirth') !=
        other._$data.containsKey('dateOfBirth')) {
      return false;
    }
    if (l$dateOfBirth != lOther$dateOfBirth) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$placeOfOrigin = placeOfOrigin;
    final lOther$placeOfOrigin = other.placeOfOrigin;
    if (_$data.containsKey('placeOfOrigin') !=
        other._$data.containsKey('placeOfOrigin')) {
      return false;
    }
    if (l$placeOfOrigin != lOther$placeOfOrigin) {
      return false;
    }
    final l$nationality = nationality;
    final lOther$nationality = other.nationality;
    if (_$data.containsKey('nationality') !=
        other._$data.containsKey('nationality')) {
      return false;
    }
    if (l$nationality != lOther$nationality) {
      return false;
    }
    final l$placeOfResidence = placeOfResidence;
    final lOther$placeOfResidence = other.placeOfResidence;
    if (_$data.containsKey('placeOfResidence') !=
        other._$data.containsKey('placeOfResidence')) {
      return false;
    }
    if (l$placeOfResidence != lOther$placeOfResidence) {
      return false;
    }
    final l$frontImage = frontImage;
    final lOther$frontImage = other.frontImage;
    if (_$data.containsKey('frontImage') !=
        other._$data.containsKey('frontImage')) {
      return false;
    }
    if (l$frontImage != lOther$frontImage) {
      return false;
    }
    final l$backImage = backImage;
    final lOther$backImage = other.backImage;
    if (_$data.containsKey('backImage') !=
        other._$data.containsKey('backImage')) {
      return false;
    }
    if (l$backImage != lOther$backImage) {
      return false;
    }
    final l$validUntil = validUntil;
    final lOther$validUntil = other.validUntil;
    if (_$data.containsKey('validUntil') !=
        other._$data.containsKey('validUntil')) {
      return false;
    }
    if (l$validUntil != lOther$validUntil) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$number = number;
    final l$fullName = fullName;
    final l$dateOfBirth = dateOfBirth;
    final l$gender = gender;
    final l$placeOfOrigin = placeOfOrigin;
    final l$nationality = nationality;
    final l$placeOfResidence = placeOfResidence;
    final l$frontImage = frontImage;
    final l$backImage = backImage;
    final l$validUntil = validUntil;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('number') ? l$number : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('dateOfBirth') ? l$dateOfBirth : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('placeOfOrigin') ? l$placeOfOrigin : const {},
      _$data.containsKey('nationality') ? l$nationality : const {},
      _$data.containsKey('placeOfResidence') ? l$placeOfResidence : const {},
      _$data.containsKey('frontImage') ? l$frontImage : const {},
      _$data.containsKey('backImage') ? l$backImage : const {},
      _$data.containsKey('validUntil') ? l$validUntil : const {},
    ]);
  }
}

abstract class CopyWith$Input$IdentityCardFilterInput<TRes> {
  factory CopyWith$Input$IdentityCardFilterInput(
    Input$IdentityCardFilterInput instance,
    TRes Function(Input$IdentityCardFilterInput) then,
  ) = _CopyWithImpl$Input$IdentityCardFilterInput;

  factory CopyWith$Input$IdentityCardFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IdentityCardFilterInput;

  TRes call({
    List<Input$IdentityCardFilterInput>? and,
    List<Input$IdentityCardFilterInput>? or,
    Input$StringOperationFilterInput? number,
    Input$StringOperationFilterInput? fullName,
    Input$DateTimeOperationFilterInput? dateOfBirth,
    Input$UserGenderOperationFilterInput? gender,
    Input$StringOperationFilterInput? placeOfOrigin,
    Input$StringOperationFilterInput? nationality,
    Input$AddressFilterInput? placeOfResidence,
    Input$StringOperationFilterInput? frontImage,
    Input$StringOperationFilterInput? backImage,
    Input$DateTimeOperationFilterInput? validUntil,
  });
  TRes and(
    Iterable<Input$IdentityCardFilterInput>? Function(
      Iterable<
        CopyWith$Input$IdentityCardFilterInput<Input$IdentityCardFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$IdentityCardFilterInput>? Function(
      Iterable<
        CopyWith$Input$IdentityCardFilterInput<Input$IdentityCardFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get number;
  CopyWith$Input$StringOperationFilterInput<TRes> get fullName;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get dateOfBirth;
  CopyWith$Input$UserGenderOperationFilterInput<TRes> get gender;
  CopyWith$Input$StringOperationFilterInput<TRes> get placeOfOrigin;
  CopyWith$Input$StringOperationFilterInput<TRes> get nationality;
  CopyWith$Input$AddressFilterInput<TRes> get placeOfResidence;
  CopyWith$Input$StringOperationFilterInput<TRes> get frontImage;
  CopyWith$Input$StringOperationFilterInput<TRes> get backImage;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get validUntil;
}

class _CopyWithImpl$Input$IdentityCardFilterInput<TRes>
    implements CopyWith$Input$IdentityCardFilterInput<TRes> {
  _CopyWithImpl$Input$IdentityCardFilterInput(this._instance, this._then);

  final Input$IdentityCardFilterInput _instance;

  final TRes Function(Input$IdentityCardFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? number = _undefined,
    Object? fullName = _undefined,
    Object? dateOfBirth = _undefined,
    Object? gender = _undefined,
    Object? placeOfOrigin = _undefined,
    Object? nationality = _undefined,
    Object? placeOfResidence = _undefined,
    Object? frontImage = _undefined,
    Object? backImage = _undefined,
    Object? validUntil = _undefined,
  }) => _then(
    Input$IdentityCardFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$IdentityCardFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$IdentityCardFilterInput>?),
      if (number != _undefined)
        'number': (number as Input$StringOperationFilterInput?),
      if (fullName != _undefined)
        'fullName': (fullName as Input$StringOperationFilterInput?),
      if (dateOfBirth != _undefined)
        'dateOfBirth': (dateOfBirth as Input$DateTimeOperationFilterInput?),
      if (gender != _undefined)
        'gender': (gender as Input$UserGenderOperationFilterInput?),
      if (placeOfOrigin != _undefined)
        'placeOfOrigin': (placeOfOrigin as Input$StringOperationFilterInput?),
      if (nationality != _undefined)
        'nationality': (nationality as Input$StringOperationFilterInput?),
      if (placeOfResidence != _undefined)
        'placeOfResidence': (placeOfResidence as Input$AddressFilterInput?),
      if (frontImage != _undefined)
        'frontImage': (frontImage as Input$StringOperationFilterInput?),
      if (backImage != _undefined)
        'backImage': (backImage as Input$StringOperationFilterInput?),
      if (validUntil != _undefined)
        'validUntil': (validUntil as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$IdentityCardFilterInput>? Function(
      Iterable<
        CopyWith$Input$IdentityCardFilterInput<Input$IdentityCardFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$IdentityCardFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$IdentityCardFilterInput>? Function(
      Iterable<
        CopyWith$Input$IdentityCardFilterInput<Input$IdentityCardFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$IdentityCardFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get number {
    final local$number = _instance.number;
    return local$number == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$number,
            (e) => call(number: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$fullName,
            (e) => call(fullName: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get dateOfBirth {
    final local$dateOfBirth = _instance.dateOfBirth;
    return local$dateOfBirth == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$dateOfBirth,
            (e) => call(dateOfBirth: e),
          );
  }

  CopyWith$Input$UserGenderOperationFilterInput<TRes> get gender {
    final local$gender = _instance.gender;
    return local$gender == null
        ? CopyWith$Input$UserGenderOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserGenderOperationFilterInput(
            local$gender,
            (e) => call(gender: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get placeOfOrigin {
    final local$placeOfOrigin = _instance.placeOfOrigin;
    return local$placeOfOrigin == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$placeOfOrigin,
            (e) => call(placeOfOrigin: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get nationality {
    final local$nationality = _instance.nationality;
    return local$nationality == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$nationality,
            (e) => call(nationality: e),
          );
  }

  CopyWith$Input$AddressFilterInput<TRes> get placeOfResidence {
    final local$placeOfResidence = _instance.placeOfResidence;
    return local$placeOfResidence == null
        ? CopyWith$Input$AddressFilterInput.stub(_then(_instance))
        : CopyWith$Input$AddressFilterInput(
            local$placeOfResidence,
            (e) => call(placeOfResidence: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get frontImage {
    final local$frontImage = _instance.frontImage;
    return local$frontImage == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$frontImage,
            (e) => call(frontImage: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get backImage {
    final local$backImage = _instance.backImage;
    return local$backImage == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$backImage,
            (e) => call(backImage: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get validUntil {
    final local$validUntil = _instance.validUntil;
    return local$validUntil == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$validUntil,
            (e) => call(validUntil: e),
          );
  }
}

class _CopyWithStubImpl$Input$IdentityCardFilterInput<TRes>
    implements CopyWith$Input$IdentityCardFilterInput<TRes> {
  _CopyWithStubImpl$Input$IdentityCardFilterInput(this._res);

  TRes _res;

  call({
    List<Input$IdentityCardFilterInput>? and,
    List<Input$IdentityCardFilterInput>? or,
    Input$StringOperationFilterInput? number,
    Input$StringOperationFilterInput? fullName,
    Input$DateTimeOperationFilterInput? dateOfBirth,
    Input$UserGenderOperationFilterInput? gender,
    Input$StringOperationFilterInput? placeOfOrigin,
    Input$StringOperationFilterInput? nationality,
    Input$AddressFilterInput? placeOfResidence,
    Input$StringOperationFilterInput? frontImage,
    Input$StringOperationFilterInput? backImage,
    Input$DateTimeOperationFilterInput? validUntil,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get number =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get fullName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get dateOfBirth =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$UserGenderOperationFilterInput<TRes> get gender =>
      CopyWith$Input$UserGenderOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get placeOfOrigin =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get nationality =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$AddressFilterInput<TRes> get placeOfResidence =>
      CopyWith$Input$AddressFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get frontImage =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get backImage =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get validUntil =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$IdentityCardInput {
  factory Input$IdentityCardInput({
    required String number,
    required String fullName,
    required DateTime dateOfBirth,
    required Enum$UserGender gender,
    required String placeOfOrigin,
    required String nationality,
    required Input$AddressInput placeOfResidence,
    String? frontImage,
    String? backImage,
    DateTime? validUntil,
  }) => Input$IdentityCardInput._({
    r'number': number,
    r'fullName': fullName,
    r'dateOfBirth': dateOfBirth,
    r'gender': gender,
    r'placeOfOrigin': placeOfOrigin,
    r'nationality': nationality,
    r'placeOfResidence': placeOfResidence,
    if (frontImage != null) r'frontImage': frontImage,
    if (backImage != null) r'backImage': backImage,
    if (validUntil != null) r'validUntil': validUntil,
  });

  Input$IdentityCardInput._(this._$data);

  factory Input$IdentityCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$number = data['number'];
    result$data['number'] = (l$number as String);
    final l$fullName = data['fullName'];
    result$data['fullName'] = (l$fullName as String);
    final l$dateOfBirth = data['dateOfBirth'];
    result$data['dateOfBirth'] = DateTime.parse((l$dateOfBirth as String));
    final l$gender = data['gender'];
    result$data['gender'] = fromJson$Enum$UserGender((l$gender as String));
    final l$placeOfOrigin = data['placeOfOrigin'];
    result$data['placeOfOrigin'] = (l$placeOfOrigin as String);
    final l$nationality = data['nationality'];
    result$data['nationality'] = (l$nationality as String);
    final l$placeOfResidence = data['placeOfResidence'];
    result$data['placeOfResidence'] = Input$AddressInput.fromJson(
      (l$placeOfResidence as Map<String, dynamic>),
    );
    if (data.containsKey('frontImage')) {
      final l$frontImage = data['frontImage'];
      result$data['frontImage'] = (l$frontImage as String?);
    }
    if (data.containsKey('backImage')) {
      final l$backImage = data['backImage'];
      result$data['backImage'] = (l$backImage as String?);
    }
    if (data.containsKey('validUntil')) {
      final l$validUntil = data['validUntil'];
      result$data['validUntil'] = l$validUntil == null
          ? null
          : DateTime.parse((l$validUntil as String));
    }
    return Input$IdentityCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get number => (_$data['number'] as String);

  String get fullName => (_$data['fullName'] as String);

  DateTime get dateOfBirth => (_$data['dateOfBirth'] as DateTime);

  Enum$UserGender get gender => (_$data['gender'] as Enum$UserGender);

  String get placeOfOrigin => (_$data['placeOfOrigin'] as String);

  String get nationality => (_$data['nationality'] as String);

  Input$AddressInput get placeOfResidence =>
      (_$data['placeOfResidence'] as Input$AddressInput);

  String? get frontImage => (_$data['frontImage'] as String?);

  String? get backImage => (_$data['backImage'] as String?);

  DateTime? get validUntil => (_$data['validUntil'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$number = number;
    result$data['number'] = l$number;
    final l$fullName = fullName;
    result$data['fullName'] = l$fullName;
    final l$dateOfBirth = dateOfBirth;
    result$data['dateOfBirth'] = l$dateOfBirth.toIso8601String();
    final l$gender = gender;
    result$data['gender'] = toJson$Enum$UserGender(l$gender);
    final l$placeOfOrigin = placeOfOrigin;
    result$data['placeOfOrigin'] = l$placeOfOrigin;
    final l$nationality = nationality;
    result$data['nationality'] = l$nationality;
    final l$placeOfResidence = placeOfResidence;
    result$data['placeOfResidence'] = l$placeOfResidence.toJson();
    if (_$data.containsKey('frontImage')) {
      final l$frontImage = frontImage;
      result$data['frontImage'] = l$frontImage;
    }
    if (_$data.containsKey('backImage')) {
      final l$backImage = backImage;
      result$data['backImage'] = l$backImage;
    }
    if (_$data.containsKey('validUntil')) {
      final l$validUntil = validUntil;
      result$data['validUntil'] = l$validUntil?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$IdentityCardInput<Input$IdentityCardInput> get copyWith =>
      CopyWith$Input$IdentityCardInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IdentityCardInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$dateOfBirth = dateOfBirth;
    final lOther$dateOfBirth = other.dateOfBirth;
    if (l$dateOfBirth != lOther$dateOfBirth) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$placeOfOrigin = placeOfOrigin;
    final lOther$placeOfOrigin = other.placeOfOrigin;
    if (l$placeOfOrigin != lOther$placeOfOrigin) {
      return false;
    }
    final l$nationality = nationality;
    final lOther$nationality = other.nationality;
    if (l$nationality != lOther$nationality) {
      return false;
    }
    final l$placeOfResidence = placeOfResidence;
    final lOther$placeOfResidence = other.placeOfResidence;
    if (l$placeOfResidence != lOther$placeOfResidence) {
      return false;
    }
    final l$frontImage = frontImage;
    final lOther$frontImage = other.frontImage;
    if (_$data.containsKey('frontImage') !=
        other._$data.containsKey('frontImage')) {
      return false;
    }
    if (l$frontImage != lOther$frontImage) {
      return false;
    }
    final l$backImage = backImage;
    final lOther$backImage = other.backImage;
    if (_$data.containsKey('backImage') !=
        other._$data.containsKey('backImage')) {
      return false;
    }
    if (l$backImage != lOther$backImage) {
      return false;
    }
    final l$validUntil = validUntil;
    final lOther$validUntil = other.validUntil;
    if (_$data.containsKey('validUntil') !=
        other._$data.containsKey('validUntil')) {
      return false;
    }
    if (l$validUntil != lOther$validUntil) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$number = number;
    final l$fullName = fullName;
    final l$dateOfBirth = dateOfBirth;
    final l$gender = gender;
    final l$placeOfOrigin = placeOfOrigin;
    final l$nationality = nationality;
    final l$placeOfResidence = placeOfResidence;
    final l$frontImage = frontImage;
    final l$backImage = backImage;
    final l$validUntil = validUntil;
    return Object.hashAll([
      l$number,
      l$fullName,
      l$dateOfBirth,
      l$gender,
      l$placeOfOrigin,
      l$nationality,
      l$placeOfResidence,
      _$data.containsKey('frontImage') ? l$frontImage : const {},
      _$data.containsKey('backImage') ? l$backImage : const {},
      _$data.containsKey('validUntil') ? l$validUntil : const {},
    ]);
  }
}

abstract class CopyWith$Input$IdentityCardInput<TRes> {
  factory CopyWith$Input$IdentityCardInput(
    Input$IdentityCardInput instance,
    TRes Function(Input$IdentityCardInput) then,
  ) = _CopyWithImpl$Input$IdentityCardInput;

  factory CopyWith$Input$IdentityCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IdentityCardInput;

  TRes call({
    String? number,
    String? fullName,
    DateTime? dateOfBirth,
    Enum$UserGender? gender,
    String? placeOfOrigin,
    String? nationality,
    Input$AddressInput? placeOfResidence,
    String? frontImage,
    String? backImage,
    DateTime? validUntil,
  });
  CopyWith$Input$AddressInput<TRes> get placeOfResidence;
}

class _CopyWithImpl$Input$IdentityCardInput<TRes>
    implements CopyWith$Input$IdentityCardInput<TRes> {
  _CopyWithImpl$Input$IdentityCardInput(this._instance, this._then);

  final Input$IdentityCardInput _instance;

  final TRes Function(Input$IdentityCardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? number = _undefined,
    Object? fullName = _undefined,
    Object? dateOfBirth = _undefined,
    Object? gender = _undefined,
    Object? placeOfOrigin = _undefined,
    Object? nationality = _undefined,
    Object? placeOfResidence = _undefined,
    Object? frontImage = _undefined,
    Object? backImage = _undefined,
    Object? validUntil = _undefined,
  }) => _then(
    Input$IdentityCardInput._({
      ..._instance._$data,
      if (number != _undefined && number != null) 'number': (number as String),
      if (fullName != _undefined && fullName != null)
        'fullName': (fullName as String),
      if (dateOfBirth != _undefined && dateOfBirth != null)
        'dateOfBirth': (dateOfBirth as DateTime),
      if (gender != _undefined && gender != null)
        'gender': (gender as Enum$UserGender),
      if (placeOfOrigin != _undefined && placeOfOrigin != null)
        'placeOfOrigin': (placeOfOrigin as String),
      if (nationality != _undefined && nationality != null)
        'nationality': (nationality as String),
      if (placeOfResidence != _undefined && placeOfResidence != null)
        'placeOfResidence': (placeOfResidence as Input$AddressInput),
      if (frontImage != _undefined) 'frontImage': (frontImage as String?),
      if (backImage != _undefined) 'backImage': (backImage as String?),
      if (validUntil != _undefined) 'validUntil': (validUntil as DateTime?),
    }),
  );

  CopyWith$Input$AddressInput<TRes> get placeOfResidence {
    final local$placeOfResidence = _instance.placeOfResidence;
    return CopyWith$Input$AddressInput(
      local$placeOfResidence,
      (e) => call(placeOfResidence: e),
    );
  }
}

class _CopyWithStubImpl$Input$IdentityCardInput<TRes>
    implements CopyWith$Input$IdentityCardInput<TRes> {
  _CopyWithStubImpl$Input$IdentityCardInput(this._res);

  TRes _res;

  call({
    String? number,
    String? fullName,
    DateTime? dateOfBirth,
    Enum$UserGender? gender,
    String? placeOfOrigin,
    String? nationality,
    Input$AddressInput? placeOfResidence,
    String? frontImage,
    String? backImage,
    DateTime? validUntil,
  }) => _res;

  CopyWith$Input$AddressInput<TRes> get placeOfResidence =>
      CopyWith$Input$AddressInput.stub(_res);
}

class Input$IdentityCardSortInput {
  factory Input$IdentityCardSortInput({
    Enum$SortEnumType? number,
    Enum$SortEnumType? fullName,
    Enum$SortEnumType? dateOfBirth,
    Enum$SortEnumType? gender,
    Enum$SortEnumType? placeOfOrigin,
    Enum$SortEnumType? nationality,
    Input$AddressSortInput? placeOfResidence,
    Enum$SortEnumType? frontImage,
    Enum$SortEnumType? backImage,
    Enum$SortEnumType? validUntil,
  }) => Input$IdentityCardSortInput._({
    if (number != null) r'number': number,
    if (fullName != null) r'fullName': fullName,
    if (dateOfBirth != null) r'dateOfBirth': dateOfBirth,
    if (gender != null) r'gender': gender,
    if (placeOfOrigin != null) r'placeOfOrigin': placeOfOrigin,
    if (nationality != null) r'nationality': nationality,
    if (placeOfResidence != null) r'placeOfResidence': placeOfResidence,
    if (frontImage != null) r'frontImage': frontImage,
    if (backImage != null) r'backImage': backImage,
    if (validUntil != null) r'validUntil': validUntil,
  });

  Input$IdentityCardSortInput._(this._$data);

  factory Input$IdentityCardSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('number')) {
      final l$number = data['number'];
      result$data['number'] = l$number == null
          ? null
          : fromJson$Enum$SortEnumType((l$number as String));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : fromJson$Enum$SortEnumType((l$fullName as String));
    }
    if (data.containsKey('dateOfBirth')) {
      final l$dateOfBirth = data['dateOfBirth'];
      result$data['dateOfBirth'] = l$dateOfBirth == null
          ? null
          : fromJson$Enum$SortEnumType((l$dateOfBirth as String));
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = l$gender == null
          ? null
          : fromJson$Enum$SortEnumType((l$gender as String));
    }
    if (data.containsKey('placeOfOrigin')) {
      final l$placeOfOrigin = data['placeOfOrigin'];
      result$data['placeOfOrigin'] = l$placeOfOrigin == null
          ? null
          : fromJson$Enum$SortEnumType((l$placeOfOrigin as String));
    }
    if (data.containsKey('nationality')) {
      final l$nationality = data['nationality'];
      result$data['nationality'] = l$nationality == null
          ? null
          : fromJson$Enum$SortEnumType((l$nationality as String));
    }
    if (data.containsKey('placeOfResidence')) {
      final l$placeOfResidence = data['placeOfResidence'];
      result$data['placeOfResidence'] = l$placeOfResidence == null
          ? null
          : Input$AddressSortInput.fromJson(
              (l$placeOfResidence as Map<String, dynamic>),
            );
    }
    if (data.containsKey('frontImage')) {
      final l$frontImage = data['frontImage'];
      result$data['frontImage'] = l$frontImage == null
          ? null
          : fromJson$Enum$SortEnumType((l$frontImage as String));
    }
    if (data.containsKey('backImage')) {
      final l$backImage = data['backImage'];
      result$data['backImage'] = l$backImage == null
          ? null
          : fromJson$Enum$SortEnumType((l$backImage as String));
    }
    if (data.containsKey('validUntil')) {
      final l$validUntil = data['validUntil'];
      result$data['validUntil'] = l$validUntil == null
          ? null
          : fromJson$Enum$SortEnumType((l$validUntil as String));
    }
    return Input$IdentityCardSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get number => (_$data['number'] as Enum$SortEnumType?);

  Enum$SortEnumType? get fullName => (_$data['fullName'] as Enum$SortEnumType?);

  Enum$SortEnumType? get dateOfBirth =>
      (_$data['dateOfBirth'] as Enum$SortEnumType?);

  Enum$SortEnumType? get gender => (_$data['gender'] as Enum$SortEnumType?);

  Enum$SortEnumType? get placeOfOrigin =>
      (_$data['placeOfOrigin'] as Enum$SortEnumType?);

  Enum$SortEnumType? get nationality =>
      (_$data['nationality'] as Enum$SortEnumType?);

  Input$AddressSortInput? get placeOfResidence =>
      (_$data['placeOfResidence'] as Input$AddressSortInput?);

  Enum$SortEnumType? get frontImage =>
      (_$data['frontImage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get backImage =>
      (_$data['backImage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get validUntil =>
      (_$data['validUntil'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('number')) {
      final l$number = number;
      result$data['number'] = l$number == null
          ? null
          : toJson$Enum$SortEnumType(l$number);
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName == null
          ? null
          : toJson$Enum$SortEnumType(l$fullName);
    }
    if (_$data.containsKey('dateOfBirth')) {
      final l$dateOfBirth = dateOfBirth;
      result$data['dateOfBirth'] = l$dateOfBirth == null
          ? null
          : toJson$Enum$SortEnumType(l$dateOfBirth);
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender == null
          ? null
          : toJson$Enum$SortEnumType(l$gender);
    }
    if (_$data.containsKey('placeOfOrigin')) {
      final l$placeOfOrigin = placeOfOrigin;
      result$data['placeOfOrigin'] = l$placeOfOrigin == null
          ? null
          : toJson$Enum$SortEnumType(l$placeOfOrigin);
    }
    if (_$data.containsKey('nationality')) {
      final l$nationality = nationality;
      result$data['nationality'] = l$nationality == null
          ? null
          : toJson$Enum$SortEnumType(l$nationality);
    }
    if (_$data.containsKey('placeOfResidence')) {
      final l$placeOfResidence = placeOfResidence;
      result$data['placeOfResidence'] = l$placeOfResidence?.toJson();
    }
    if (_$data.containsKey('frontImage')) {
      final l$frontImage = frontImage;
      result$data['frontImage'] = l$frontImage == null
          ? null
          : toJson$Enum$SortEnumType(l$frontImage);
    }
    if (_$data.containsKey('backImage')) {
      final l$backImage = backImage;
      result$data['backImage'] = l$backImage == null
          ? null
          : toJson$Enum$SortEnumType(l$backImage);
    }
    if (_$data.containsKey('validUntil')) {
      final l$validUntil = validUntil;
      result$data['validUntil'] = l$validUntil == null
          ? null
          : toJson$Enum$SortEnumType(l$validUntil);
    }
    return result$data;
  }

  CopyWith$Input$IdentityCardSortInput<Input$IdentityCardSortInput>
  get copyWith => CopyWith$Input$IdentityCardSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IdentityCardSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (_$data.containsKey('number') != other._$data.containsKey('number')) {
      return false;
    }
    if (l$number != lOther$number) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$dateOfBirth = dateOfBirth;
    final lOther$dateOfBirth = other.dateOfBirth;
    if (_$data.containsKey('dateOfBirth') !=
        other._$data.containsKey('dateOfBirth')) {
      return false;
    }
    if (l$dateOfBirth != lOther$dateOfBirth) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$placeOfOrigin = placeOfOrigin;
    final lOther$placeOfOrigin = other.placeOfOrigin;
    if (_$data.containsKey('placeOfOrigin') !=
        other._$data.containsKey('placeOfOrigin')) {
      return false;
    }
    if (l$placeOfOrigin != lOther$placeOfOrigin) {
      return false;
    }
    final l$nationality = nationality;
    final lOther$nationality = other.nationality;
    if (_$data.containsKey('nationality') !=
        other._$data.containsKey('nationality')) {
      return false;
    }
    if (l$nationality != lOther$nationality) {
      return false;
    }
    final l$placeOfResidence = placeOfResidence;
    final lOther$placeOfResidence = other.placeOfResidence;
    if (_$data.containsKey('placeOfResidence') !=
        other._$data.containsKey('placeOfResidence')) {
      return false;
    }
    if (l$placeOfResidence != lOther$placeOfResidence) {
      return false;
    }
    final l$frontImage = frontImage;
    final lOther$frontImage = other.frontImage;
    if (_$data.containsKey('frontImage') !=
        other._$data.containsKey('frontImage')) {
      return false;
    }
    if (l$frontImage != lOther$frontImage) {
      return false;
    }
    final l$backImage = backImage;
    final lOther$backImage = other.backImage;
    if (_$data.containsKey('backImage') !=
        other._$data.containsKey('backImage')) {
      return false;
    }
    if (l$backImage != lOther$backImage) {
      return false;
    }
    final l$validUntil = validUntil;
    final lOther$validUntil = other.validUntil;
    if (_$data.containsKey('validUntil') !=
        other._$data.containsKey('validUntil')) {
      return false;
    }
    if (l$validUntil != lOther$validUntil) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$number = number;
    final l$fullName = fullName;
    final l$dateOfBirth = dateOfBirth;
    final l$gender = gender;
    final l$placeOfOrigin = placeOfOrigin;
    final l$nationality = nationality;
    final l$placeOfResidence = placeOfResidence;
    final l$frontImage = frontImage;
    final l$backImage = backImage;
    final l$validUntil = validUntil;
    return Object.hashAll([
      _$data.containsKey('number') ? l$number : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('dateOfBirth') ? l$dateOfBirth : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('placeOfOrigin') ? l$placeOfOrigin : const {},
      _$data.containsKey('nationality') ? l$nationality : const {},
      _$data.containsKey('placeOfResidence') ? l$placeOfResidence : const {},
      _$data.containsKey('frontImage') ? l$frontImage : const {},
      _$data.containsKey('backImage') ? l$backImage : const {},
      _$data.containsKey('validUntil') ? l$validUntil : const {},
    ]);
  }
}

abstract class CopyWith$Input$IdentityCardSortInput<TRes> {
  factory CopyWith$Input$IdentityCardSortInput(
    Input$IdentityCardSortInput instance,
    TRes Function(Input$IdentityCardSortInput) then,
  ) = _CopyWithImpl$Input$IdentityCardSortInput;

  factory CopyWith$Input$IdentityCardSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IdentityCardSortInput;

  TRes call({
    Enum$SortEnumType? number,
    Enum$SortEnumType? fullName,
    Enum$SortEnumType? dateOfBirth,
    Enum$SortEnumType? gender,
    Enum$SortEnumType? placeOfOrigin,
    Enum$SortEnumType? nationality,
    Input$AddressSortInput? placeOfResidence,
    Enum$SortEnumType? frontImage,
    Enum$SortEnumType? backImage,
    Enum$SortEnumType? validUntil,
  });
  CopyWith$Input$AddressSortInput<TRes> get placeOfResidence;
}

class _CopyWithImpl$Input$IdentityCardSortInput<TRes>
    implements CopyWith$Input$IdentityCardSortInput<TRes> {
  _CopyWithImpl$Input$IdentityCardSortInput(this._instance, this._then);

  final Input$IdentityCardSortInput _instance;

  final TRes Function(Input$IdentityCardSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? number = _undefined,
    Object? fullName = _undefined,
    Object? dateOfBirth = _undefined,
    Object? gender = _undefined,
    Object? placeOfOrigin = _undefined,
    Object? nationality = _undefined,
    Object? placeOfResidence = _undefined,
    Object? frontImage = _undefined,
    Object? backImage = _undefined,
    Object? validUntil = _undefined,
  }) => _then(
    Input$IdentityCardSortInput._({
      ..._instance._$data,
      if (number != _undefined) 'number': (number as Enum$SortEnumType?),
      if (fullName != _undefined) 'fullName': (fullName as Enum$SortEnumType?),
      if (dateOfBirth != _undefined)
        'dateOfBirth': (dateOfBirth as Enum$SortEnumType?),
      if (gender != _undefined) 'gender': (gender as Enum$SortEnumType?),
      if (placeOfOrigin != _undefined)
        'placeOfOrigin': (placeOfOrigin as Enum$SortEnumType?),
      if (nationality != _undefined)
        'nationality': (nationality as Enum$SortEnumType?),
      if (placeOfResidence != _undefined)
        'placeOfResidence': (placeOfResidence as Input$AddressSortInput?),
      if (frontImage != _undefined)
        'frontImage': (frontImage as Enum$SortEnumType?),
      if (backImage != _undefined)
        'backImage': (backImage as Enum$SortEnumType?),
      if (validUntil != _undefined)
        'validUntil': (validUntil as Enum$SortEnumType?),
    }),
  );

  CopyWith$Input$AddressSortInput<TRes> get placeOfResidence {
    final local$placeOfResidence = _instance.placeOfResidence;
    return local$placeOfResidence == null
        ? CopyWith$Input$AddressSortInput.stub(_then(_instance))
        : CopyWith$Input$AddressSortInput(
            local$placeOfResidence,
            (e) => call(placeOfResidence: e),
          );
  }
}

class _CopyWithStubImpl$Input$IdentityCardSortInput<TRes>
    implements CopyWith$Input$IdentityCardSortInput<TRes> {
  _CopyWithStubImpl$Input$IdentityCardSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? number,
    Enum$SortEnumType? fullName,
    Enum$SortEnumType? dateOfBirth,
    Enum$SortEnumType? gender,
    Enum$SortEnumType? placeOfOrigin,
    Enum$SortEnumType? nationality,
    Input$AddressSortInput? placeOfResidence,
    Enum$SortEnumType? frontImage,
    Enum$SortEnumType? backImage,
    Enum$SortEnumType? validUntil,
  }) => _res;

  CopyWith$Input$AddressSortInput<TRes> get placeOfResidence =>
      CopyWith$Input$AddressSortInput.stub(_res);
}

class Input$IntOperationFilterInput {
  factory Input$IntOperationFilterInput({
    int? eq,
    int? neq,
    List<int?>? $in,
    List<int?>? nin,
    int? gt,
    int? ngt,
    int? gte,
    int? ngte,
    int? lt,
    int? nlt,
    int? lte,
    int? nlte,
  }) => Input$IntOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
    if (gt != null) r'gt': gt,
    if (ngt != null) r'ngt': ngt,
    if (gte != null) r'gte': gte,
    if (ngte != null) r'ngte': ngte,
    if (lt != null) r'lt': lt,
    if (nlt != null) r'nlt': nlt,
    if (lte != null) r'lte': lte,
    if (nlte != null) r'nlte': nlte,
  });

  Input$IntOperationFilterInput._(this._$data);

  factory Input$IntOperationFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as int?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => (e as int?))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => (e as int?))
          .toList();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as int?);
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as int?);
    }
    return Input$IntOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get eq => (_$data['eq'] as int?);

  int? get neq => (_$data['neq'] as int?);

  List<int?>? get $in => (_$data['in'] as List<int?>?);

  List<int?>? get nin => (_$data['nin'] as List<int?>?);

  int? get gt => (_$data['gt'] as int?);

  int? get ngt => (_$data['ngt'] as int?);

  int? get gte => (_$data['gte'] as int?);

  int? get ngte => (_$data['ngte'] as int?);

  int? get lt => (_$data['lt'] as int?);

  int? get nlt => (_$data['nlt'] as int?);

  int? get lte => (_$data['lte'] as int?);

  int? get nlte => (_$data['nlte'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$IntOperationFilterInput<Input$IntOperationFilterInput>
  get copyWith => CopyWith$Input$IntOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IntOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    final l$gt = gt;
    final l$ngt = ngt;
    final l$gte = gte;
    final l$ngte = ngte;
    final l$lt = lt;
    final l$nlt = nlt;
    final l$lte = lte;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntOperationFilterInput<TRes> {
  factory CopyWith$Input$IntOperationFilterInput(
    Input$IntOperationFilterInput instance,
    TRes Function(Input$IntOperationFilterInput) then,
  ) = _CopyWithImpl$Input$IntOperationFilterInput;

  factory CopyWith$Input$IntOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IntOperationFilterInput;

  TRes call({
    int? eq,
    int? neq,
    List<int?>? $in,
    List<int?>? nin,
    int? gt,
    int? ngt,
    int? gte,
    int? ngte,
    int? lt,
    int? nlt,
    int? lte,
    int? nlte,
  });
}

class _CopyWithImpl$Input$IntOperationFilterInput<TRes>
    implements CopyWith$Input$IntOperationFilterInput<TRes> {
  _CopyWithImpl$Input$IntOperationFilterInput(this._instance, this._then);

  final Input$IntOperationFilterInput _instance;

  final TRes Function(Input$IntOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
    Object? gt = _undefined,
    Object? ngt = _undefined,
    Object? gte = _undefined,
    Object? ngte = _undefined,
    Object? lt = _undefined,
    Object? nlt = _undefined,
    Object? lte = _undefined,
    Object? nlte = _undefined,
  }) => _then(
    Input$IntOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as int?),
      if (neq != _undefined) 'neq': (neq as int?),
      if ($in != _undefined) 'in': ($in as List<int?>?),
      if (nin != _undefined) 'nin': (nin as List<int?>?),
      if (gt != _undefined) 'gt': (gt as int?),
      if (ngt != _undefined) 'ngt': (ngt as int?),
      if (gte != _undefined) 'gte': (gte as int?),
      if (ngte != _undefined) 'ngte': (ngte as int?),
      if (lt != _undefined) 'lt': (lt as int?),
      if (nlt != _undefined) 'nlt': (nlt as int?),
      if (lte != _undefined) 'lte': (lte as int?),
      if (nlte != _undefined) 'nlte': (nlte as int?),
    }),
  );
}

class _CopyWithStubImpl$Input$IntOperationFilterInput<TRes>
    implements CopyWith$Input$IntOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$IntOperationFilterInput(this._res);

  TRes _res;

  call({
    int? eq,
    int? neq,
    List<int?>? $in,
    List<int?>? nin,
    int? gt,
    int? ngt,
    int? gte,
    int? ngte,
    int? lt,
    int? nlt,
    int? lte,
    int? nlte,
  }) => _res;
}

class Input$InvoiceFilterInput {
  factory Input$InvoiceFilterInput({
    List<Input$InvoiceFilterInput>? and,
    List<Input$InvoiceFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? paymentTransactionId,
    Input$StringOperationFilterInput? stripeInvoiceId,
    Input$OneOffSnapshotFilterInput? oneOffSnapshot,
    Input$SubscriptionSnapshotFilterInput? subscriptionSnapshot,
    Input$StringOperationFilterInput? fullName,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? country,
    Input$DecimalOperationFilterInput? amount,
    Input$StringOperationFilterInput? currency,
    Input$StringOperationFilterInput? from,
    Input$StringOperationFilterInput? to,
    Input$StringOperationFilterInput? originContext,
    Input$DateTimeOperationFilterInput? paidAt,
  }) => Input$InvoiceFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (paymentTransactionId != null)
      r'paymentTransactionId': paymentTransactionId,
    if (stripeInvoiceId != null) r'stripeInvoiceId': stripeInvoiceId,
    if (oneOffSnapshot != null) r'oneOffSnapshot': oneOffSnapshot,
    if (subscriptionSnapshot != null)
      r'subscriptionSnapshot': subscriptionSnapshot,
    if (fullName != null) r'fullName': fullName,
    if (email != null) r'email': email,
    if (country != null) r'country': country,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (from != null) r'from': from,
    if (to != null) r'to': to,
    if (originContext != null) r'originContext': originContext,
    if (paidAt != null) r'paidAt': paidAt,
  });

  Input$InvoiceFilterInput._(this._$data);

  factory Input$InvoiceFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$InvoiceFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$InvoiceFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('paymentTransactionId')) {
      final l$paymentTransactionId = data['paymentTransactionId'];
      result$data['paymentTransactionId'] = l$paymentTransactionId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$paymentTransactionId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeInvoiceId')) {
      final l$stripeInvoiceId = data['stripeInvoiceId'];
      result$data['stripeInvoiceId'] = l$stripeInvoiceId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeInvoiceId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('oneOffSnapshot')) {
      final l$oneOffSnapshot = data['oneOffSnapshot'];
      result$data['oneOffSnapshot'] = l$oneOffSnapshot == null
          ? null
          : Input$OneOffSnapshotFilterInput.fromJson(
              (l$oneOffSnapshot as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionSnapshot')) {
      final l$subscriptionSnapshot = data['subscriptionSnapshot'];
      result$data['subscriptionSnapshot'] = l$subscriptionSnapshot == null
          ? null
          : Input$SubscriptionSnapshotFilterInput.fromJson(
              (l$subscriptionSnapshot as Map<String, dynamic>),
            );
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$fullName as Map<String, dynamic>),
            );
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$email as Map<String, dynamic>),
            );
    }
    if (data.containsKey('country')) {
      final l$country = data['country'];
      result$data['country'] = l$country == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$country as Map<String, dynamic>),
            );
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$amount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$currency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('from')) {
      final l$from = data['from'];
      result$data['from'] = l$from == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$from as Map<String, dynamic>),
            );
    }
    if (data.containsKey('to')) {
      final l$to = data['to'];
      result$data['to'] = l$to == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$to as Map<String, dynamic>),
            );
    }
    if (data.containsKey('originContext')) {
      final l$originContext = data['originContext'];
      result$data['originContext'] = l$originContext == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$originContext as Map<String, dynamic>),
            );
    }
    if (data.containsKey('paidAt')) {
      final l$paidAt = data['paidAt'];
      result$data['paidAt'] = l$paidAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$paidAt as Map<String, dynamic>),
            );
    }
    return Input$InvoiceFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$InvoiceFilterInput>? get and =>
      (_$data['and'] as List<Input$InvoiceFilterInput>?);

  List<Input$InvoiceFilterInput>? get or =>
      (_$data['or'] as List<Input$InvoiceFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get userId =>
      (_$data['userId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get paymentTransactionId =>
      (_$data['paymentTransactionId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeInvoiceId =>
      (_$data['stripeInvoiceId'] as Input$StringOperationFilterInput?);

  Input$OneOffSnapshotFilterInput? get oneOffSnapshot =>
      (_$data['oneOffSnapshot'] as Input$OneOffSnapshotFilterInput?);

  Input$SubscriptionSnapshotFilterInput? get subscriptionSnapshot =>
      (_$data['subscriptionSnapshot']
          as Input$SubscriptionSnapshotFilterInput?);

  Input$StringOperationFilterInput? get fullName =>
      (_$data['fullName'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get email =>
      (_$data['email'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get country =>
      (_$data['country'] as Input$StringOperationFilterInput?);

  Input$DecimalOperationFilterInput? get amount =>
      (_$data['amount'] as Input$DecimalOperationFilterInput?);

  Input$StringOperationFilterInput? get currency =>
      (_$data['currency'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get from =>
      (_$data['from'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get to =>
      (_$data['to'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get originContext =>
      (_$data['originContext'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get paidAt =>
      (_$data['paidAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('paymentTransactionId')) {
      final l$paymentTransactionId = paymentTransactionId;
      result$data['paymentTransactionId'] = l$paymentTransactionId?.toJson();
    }
    if (_$data.containsKey('stripeInvoiceId')) {
      final l$stripeInvoiceId = stripeInvoiceId;
      result$data['stripeInvoiceId'] = l$stripeInvoiceId?.toJson();
    }
    if (_$data.containsKey('oneOffSnapshot')) {
      final l$oneOffSnapshot = oneOffSnapshot;
      result$data['oneOffSnapshot'] = l$oneOffSnapshot?.toJson();
    }
    if (_$data.containsKey('subscriptionSnapshot')) {
      final l$subscriptionSnapshot = subscriptionSnapshot;
      result$data['subscriptionSnapshot'] = l$subscriptionSnapshot?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('country')) {
      final l$country = country;
      result$data['country'] = l$country?.toJson();
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount?.toJson();
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency?.toJson();
    }
    if (_$data.containsKey('from')) {
      final l$from = from;
      result$data['from'] = l$from?.toJson();
    }
    if (_$data.containsKey('to')) {
      final l$to = to;
      result$data['to'] = l$to?.toJson();
    }
    if (_$data.containsKey('originContext')) {
      final l$originContext = originContext;
      result$data['originContext'] = l$originContext?.toJson();
    }
    if (_$data.containsKey('paidAt')) {
      final l$paidAt = paidAt;
      result$data['paidAt'] = l$paidAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvoiceFilterInput<Input$InvoiceFilterInput> get copyWith =>
      CopyWith$Input$InvoiceFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$InvoiceFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$paymentTransactionId = paymentTransactionId;
    final lOther$paymentTransactionId = other.paymentTransactionId;
    if (_$data.containsKey('paymentTransactionId') !=
        other._$data.containsKey('paymentTransactionId')) {
      return false;
    }
    if (l$paymentTransactionId != lOther$paymentTransactionId) {
      return false;
    }
    final l$stripeInvoiceId = stripeInvoiceId;
    final lOther$stripeInvoiceId = other.stripeInvoiceId;
    if (_$data.containsKey('stripeInvoiceId') !=
        other._$data.containsKey('stripeInvoiceId')) {
      return false;
    }
    if (l$stripeInvoiceId != lOther$stripeInvoiceId) {
      return false;
    }
    final l$oneOffSnapshot = oneOffSnapshot;
    final lOther$oneOffSnapshot = other.oneOffSnapshot;
    if (_$data.containsKey('oneOffSnapshot') !=
        other._$data.containsKey('oneOffSnapshot')) {
      return false;
    }
    if (l$oneOffSnapshot != lOther$oneOffSnapshot) {
      return false;
    }
    final l$subscriptionSnapshot = subscriptionSnapshot;
    final lOther$subscriptionSnapshot = other.subscriptionSnapshot;
    if (_$data.containsKey('subscriptionSnapshot') !=
        other._$data.containsKey('subscriptionSnapshot')) {
      return false;
    }
    if (l$subscriptionSnapshot != lOther$subscriptionSnapshot) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$country = country;
    final lOther$country = other.country;
    if (_$data.containsKey('country') != other._$data.containsKey('country')) {
      return false;
    }
    if (l$country != lOther$country) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$from = from;
    final lOther$from = other.from;
    if (_$data.containsKey('from') != other._$data.containsKey('from')) {
      return false;
    }
    if (l$from != lOther$from) {
      return false;
    }
    final l$to = to;
    final lOther$to = other.to;
    if (_$data.containsKey('to') != other._$data.containsKey('to')) {
      return false;
    }
    if (l$to != lOther$to) {
      return false;
    }
    final l$originContext = originContext;
    final lOther$originContext = other.originContext;
    if (_$data.containsKey('originContext') !=
        other._$data.containsKey('originContext')) {
      return false;
    }
    if (l$originContext != lOther$originContext) {
      return false;
    }
    final l$paidAt = paidAt;
    final lOther$paidAt = other.paidAt;
    if (_$data.containsKey('paidAt') != other._$data.containsKey('paidAt')) {
      return false;
    }
    if (l$paidAt != lOther$paidAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$userId = userId;
    final l$paymentTransactionId = paymentTransactionId;
    final l$stripeInvoiceId = stripeInvoiceId;
    final l$oneOffSnapshot = oneOffSnapshot;
    final l$subscriptionSnapshot = subscriptionSnapshot;
    final l$fullName = fullName;
    final l$email = email;
    final l$country = country;
    final l$amount = amount;
    final l$currency = currency;
    final l$from = from;
    final l$to = to;
    final l$originContext = originContext;
    final l$paidAt = paidAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('paymentTransactionId')
          ? l$paymentTransactionId
          : const {},
      _$data.containsKey('stripeInvoiceId') ? l$stripeInvoiceId : const {},
      _$data.containsKey('oneOffSnapshot') ? l$oneOffSnapshot : const {},
      _$data.containsKey('subscriptionSnapshot')
          ? l$subscriptionSnapshot
          : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('country') ? l$country : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('from') ? l$from : const {},
      _$data.containsKey('to') ? l$to : const {},
      _$data.containsKey('originContext') ? l$originContext : const {},
      _$data.containsKey('paidAt') ? l$paidAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvoiceFilterInput<TRes> {
  factory CopyWith$Input$InvoiceFilterInput(
    Input$InvoiceFilterInput instance,
    TRes Function(Input$InvoiceFilterInput) then,
  ) = _CopyWithImpl$Input$InvoiceFilterInput;

  factory CopyWith$Input$InvoiceFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvoiceFilterInput;

  TRes call({
    List<Input$InvoiceFilterInput>? and,
    List<Input$InvoiceFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? paymentTransactionId,
    Input$StringOperationFilterInput? stripeInvoiceId,
    Input$OneOffSnapshotFilterInput? oneOffSnapshot,
    Input$SubscriptionSnapshotFilterInput? subscriptionSnapshot,
    Input$StringOperationFilterInput? fullName,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? country,
    Input$DecimalOperationFilterInput? amount,
    Input$StringOperationFilterInput? currency,
    Input$StringOperationFilterInput? from,
    Input$StringOperationFilterInput? to,
    Input$StringOperationFilterInput? originContext,
    Input$DateTimeOperationFilterInput? paidAt,
  });
  TRes and(
    Iterable<Input$InvoiceFilterInput>? Function(
      Iterable<CopyWith$Input$InvoiceFilterInput<Input$InvoiceFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$InvoiceFilterInput>? Function(
      Iterable<CopyWith$Input$InvoiceFilterInput<Input$InvoiceFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get userId;
  CopyWith$Input$StringOperationFilterInput<TRes> get paymentTransactionId;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeInvoiceId;
  CopyWith$Input$OneOffSnapshotFilterInput<TRes> get oneOffSnapshot;
  CopyWith$Input$SubscriptionSnapshotFilterInput<TRes> get subscriptionSnapshot;
  CopyWith$Input$StringOperationFilterInput<TRes> get fullName;
  CopyWith$Input$StringOperationFilterInput<TRes> get email;
  CopyWith$Input$StringOperationFilterInput<TRes> get country;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount;
  CopyWith$Input$StringOperationFilterInput<TRes> get currency;
  CopyWith$Input$StringOperationFilterInput<TRes> get from;
  CopyWith$Input$StringOperationFilterInput<TRes> get to;
  CopyWith$Input$StringOperationFilterInput<TRes> get originContext;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get paidAt;
}

class _CopyWithImpl$Input$InvoiceFilterInput<TRes>
    implements CopyWith$Input$InvoiceFilterInput<TRes> {
  _CopyWithImpl$Input$InvoiceFilterInput(this._instance, this._then);

  final Input$InvoiceFilterInput _instance;

  final TRes Function(Input$InvoiceFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? paymentTransactionId = _undefined,
    Object? stripeInvoiceId = _undefined,
    Object? oneOffSnapshot = _undefined,
    Object? subscriptionSnapshot = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? country = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? from = _undefined,
    Object? to = _undefined,
    Object? originContext = _undefined,
    Object? paidAt = _undefined,
  }) => _then(
    Input$InvoiceFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$InvoiceFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$InvoiceFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (userId != _undefined)
        'userId': (userId as Input$StringOperationFilterInput?),
      if (paymentTransactionId != _undefined)
        'paymentTransactionId':
            (paymentTransactionId as Input$StringOperationFilterInput?),
      if (stripeInvoiceId != _undefined)
        'stripeInvoiceId':
            (stripeInvoiceId as Input$StringOperationFilterInput?),
      if (oneOffSnapshot != _undefined)
        'oneOffSnapshot': (oneOffSnapshot as Input$OneOffSnapshotFilterInput?),
      if (subscriptionSnapshot != _undefined)
        'subscriptionSnapshot':
            (subscriptionSnapshot as Input$SubscriptionSnapshotFilterInput?),
      if (fullName != _undefined)
        'fullName': (fullName as Input$StringOperationFilterInput?),
      if (email != _undefined)
        'email': (email as Input$StringOperationFilterInput?),
      if (country != _undefined)
        'country': (country as Input$StringOperationFilterInput?),
      if (amount != _undefined)
        'amount': (amount as Input$DecimalOperationFilterInput?),
      if (currency != _undefined)
        'currency': (currency as Input$StringOperationFilterInput?),
      if (from != _undefined)
        'from': (from as Input$StringOperationFilterInput?),
      if (to != _undefined) 'to': (to as Input$StringOperationFilterInput?),
      if (originContext != _undefined)
        'originContext': (originContext as Input$StringOperationFilterInput?),
      if (paidAt != _undefined)
        'paidAt': (paidAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$InvoiceFilterInput>? Function(
      Iterable<CopyWith$Input$InvoiceFilterInput<Input$InvoiceFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$InvoiceFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$InvoiceFilterInput>? Function(
      Iterable<CopyWith$Input$InvoiceFilterInput<Input$InvoiceFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$InvoiceFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userId,
            (e) => call(userId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get paymentTransactionId {
    final local$paymentTransactionId = _instance.paymentTransactionId;
    return local$paymentTransactionId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$paymentTransactionId,
            (e) => call(paymentTransactionId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeInvoiceId {
    final local$stripeInvoiceId = _instance.stripeInvoiceId;
    return local$stripeInvoiceId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeInvoiceId,
            (e) => call(stripeInvoiceId: e),
          );
  }

  CopyWith$Input$OneOffSnapshotFilterInput<TRes> get oneOffSnapshot {
    final local$oneOffSnapshot = _instance.oneOffSnapshot;
    return local$oneOffSnapshot == null
        ? CopyWith$Input$OneOffSnapshotFilterInput.stub(_then(_instance))
        : CopyWith$Input$OneOffSnapshotFilterInput(
            local$oneOffSnapshot,
            (e) => call(oneOffSnapshot: e),
          );
  }

  CopyWith$Input$SubscriptionSnapshotFilterInput<TRes>
  get subscriptionSnapshot {
    final local$subscriptionSnapshot = _instance.subscriptionSnapshot;
    return local$subscriptionSnapshot == null
        ? CopyWith$Input$SubscriptionSnapshotFilterInput.stub(_then(_instance))
        : CopyWith$Input$SubscriptionSnapshotFilterInput(
            local$subscriptionSnapshot,
            (e) => call(subscriptionSnapshot: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$fullName,
            (e) => call(fullName: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$email,
            (e) => call(email: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get country {
    final local$country = _instance.country;
    return local$country == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$country,
            (e) => call(country: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount {
    final local$amount = _instance.amount;
    return local$amount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$amount,
            (e) => call(amount: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get currency {
    final local$currency = _instance.currency;
    return local$currency == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$currency,
            (e) => call(currency: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get from {
    final local$from = _instance.from;
    return local$from == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$from,
            (e) => call(from: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get to {
    final local$to = _instance.to;
    return local$to == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$to,
            (e) => call(to: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get originContext {
    final local$originContext = _instance.originContext;
    return local$originContext == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$originContext,
            (e) => call(originContext: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get paidAt {
    final local$paidAt = _instance.paidAt;
    return local$paidAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$paidAt,
            (e) => call(paidAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$InvoiceFilterInput<TRes>
    implements CopyWith$Input$InvoiceFilterInput<TRes> {
  _CopyWithStubImpl$Input$InvoiceFilterInput(this._res);

  TRes _res;

  call({
    List<Input$InvoiceFilterInput>? and,
    List<Input$InvoiceFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? paymentTransactionId,
    Input$StringOperationFilterInput? stripeInvoiceId,
    Input$OneOffSnapshotFilterInput? oneOffSnapshot,
    Input$SubscriptionSnapshotFilterInput? subscriptionSnapshot,
    Input$StringOperationFilterInput? fullName,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? country,
    Input$DecimalOperationFilterInput? amount,
    Input$StringOperationFilterInput? currency,
    Input$StringOperationFilterInput? from,
    Input$StringOperationFilterInput? to,
    Input$StringOperationFilterInput? originContext,
    Input$DateTimeOperationFilterInput? paidAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get userId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get paymentTransactionId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeInvoiceId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$OneOffSnapshotFilterInput<TRes> get oneOffSnapshot =>
      CopyWith$Input$OneOffSnapshotFilterInput.stub(_res);

  CopyWith$Input$SubscriptionSnapshotFilterInput<TRes>
  get subscriptionSnapshot =>
      CopyWith$Input$SubscriptionSnapshotFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get fullName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get email =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get country =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get currency =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get from =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get to =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get originContext =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get paidAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$InvoiceSortInput {
  factory Input$InvoiceSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? paymentTransactionId,
    Enum$SortEnumType? stripeInvoiceId,
    Input$OneOffSnapshotSortInput? oneOffSnapshot,
    Input$SubscriptionSnapshotSortInput? subscriptionSnapshot,
    Enum$SortEnumType? fullName,
    Enum$SortEnumType? email,
    Enum$SortEnumType? country,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? from,
    Enum$SortEnumType? to,
    Enum$SortEnumType? originContext,
    Enum$SortEnumType? paidAt,
  }) => Input$InvoiceSortInput._({
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (paymentTransactionId != null)
      r'paymentTransactionId': paymentTransactionId,
    if (stripeInvoiceId != null) r'stripeInvoiceId': stripeInvoiceId,
    if (oneOffSnapshot != null) r'oneOffSnapshot': oneOffSnapshot,
    if (subscriptionSnapshot != null)
      r'subscriptionSnapshot': subscriptionSnapshot,
    if (fullName != null) r'fullName': fullName,
    if (email != null) r'email': email,
    if (country != null) r'country': country,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (from != null) r'from': from,
    if (to != null) r'to': to,
    if (originContext != null) r'originContext': originContext,
    if (paidAt != null) r'paidAt': paidAt,
  });

  Input$InvoiceSortInput._(this._$data);

  factory Input$InvoiceSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$SortEnumType((l$userId as String));
    }
    if (data.containsKey('paymentTransactionId')) {
      final l$paymentTransactionId = data['paymentTransactionId'];
      result$data['paymentTransactionId'] = l$paymentTransactionId == null
          ? null
          : fromJson$Enum$SortEnumType((l$paymentTransactionId as String));
    }
    if (data.containsKey('stripeInvoiceId')) {
      final l$stripeInvoiceId = data['stripeInvoiceId'];
      result$data['stripeInvoiceId'] = l$stripeInvoiceId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeInvoiceId as String));
    }
    if (data.containsKey('oneOffSnapshot')) {
      final l$oneOffSnapshot = data['oneOffSnapshot'];
      result$data['oneOffSnapshot'] = l$oneOffSnapshot == null
          ? null
          : Input$OneOffSnapshotSortInput.fromJson(
              (l$oneOffSnapshot as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionSnapshot')) {
      final l$subscriptionSnapshot = data['subscriptionSnapshot'];
      result$data['subscriptionSnapshot'] = l$subscriptionSnapshot == null
          ? null
          : Input$SubscriptionSnapshotSortInput.fromJson(
              (l$subscriptionSnapshot as Map<String, dynamic>),
            );
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : fromJson$Enum$SortEnumType((l$fullName as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : fromJson$Enum$SortEnumType((l$email as String));
    }
    if (data.containsKey('country')) {
      final l$country = data['country'];
      result$data['country'] = l$country == null
          ? null
          : fromJson$Enum$SortEnumType((l$country as String));
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : fromJson$Enum$SortEnumType((l$amount as String));
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$SortEnumType((l$currency as String));
    }
    if (data.containsKey('from')) {
      final l$from = data['from'];
      result$data['from'] = l$from == null
          ? null
          : fromJson$Enum$SortEnumType((l$from as String));
    }
    if (data.containsKey('to')) {
      final l$to = data['to'];
      result$data['to'] = l$to == null
          ? null
          : fromJson$Enum$SortEnumType((l$to as String));
    }
    if (data.containsKey('originContext')) {
      final l$originContext = data['originContext'];
      result$data['originContext'] = l$originContext == null
          ? null
          : fromJson$Enum$SortEnumType((l$originContext as String));
    }
    if (data.containsKey('paidAt')) {
      final l$paidAt = data['paidAt'];
      result$data['paidAt'] = l$paidAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$paidAt as String));
    }
    return Input$InvoiceSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get userId => (_$data['userId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get paymentTransactionId =>
      (_$data['paymentTransactionId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeInvoiceId =>
      (_$data['stripeInvoiceId'] as Enum$SortEnumType?);

  Input$OneOffSnapshotSortInput? get oneOffSnapshot =>
      (_$data['oneOffSnapshot'] as Input$OneOffSnapshotSortInput?);

  Input$SubscriptionSnapshotSortInput? get subscriptionSnapshot =>
      (_$data['subscriptionSnapshot'] as Input$SubscriptionSnapshotSortInput?);

  Enum$SortEnumType? get fullName => (_$data['fullName'] as Enum$SortEnumType?);

  Enum$SortEnumType? get email => (_$data['email'] as Enum$SortEnumType?);

  Enum$SortEnumType? get country => (_$data['country'] as Enum$SortEnumType?);

  Enum$SortEnumType? get amount => (_$data['amount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get currency => (_$data['currency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get from => (_$data['from'] as Enum$SortEnumType?);

  Enum$SortEnumType? get to => (_$data['to'] as Enum$SortEnumType?);

  Enum$SortEnumType? get originContext =>
      (_$data['originContext'] as Enum$SortEnumType?);

  Enum$SortEnumType? get paidAt => (_$data['paidAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId == null
          ? null
          : toJson$Enum$SortEnumType(l$userId);
    }
    if (_$data.containsKey('paymentTransactionId')) {
      final l$paymentTransactionId = paymentTransactionId;
      result$data['paymentTransactionId'] = l$paymentTransactionId == null
          ? null
          : toJson$Enum$SortEnumType(l$paymentTransactionId);
    }
    if (_$data.containsKey('stripeInvoiceId')) {
      final l$stripeInvoiceId = stripeInvoiceId;
      result$data['stripeInvoiceId'] = l$stripeInvoiceId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeInvoiceId);
    }
    if (_$data.containsKey('oneOffSnapshot')) {
      final l$oneOffSnapshot = oneOffSnapshot;
      result$data['oneOffSnapshot'] = l$oneOffSnapshot?.toJson();
    }
    if (_$data.containsKey('subscriptionSnapshot')) {
      final l$subscriptionSnapshot = subscriptionSnapshot;
      result$data['subscriptionSnapshot'] = l$subscriptionSnapshot?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName == null
          ? null
          : toJson$Enum$SortEnumType(l$fullName);
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email == null
          ? null
          : toJson$Enum$SortEnumType(l$email);
    }
    if (_$data.containsKey('country')) {
      final l$country = country;
      result$data['country'] = l$country == null
          ? null
          : toJson$Enum$SortEnumType(l$country);
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount == null
          ? null
          : toJson$Enum$SortEnumType(l$amount);
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$SortEnumType(l$currency);
    }
    if (_$data.containsKey('from')) {
      final l$from = from;
      result$data['from'] = l$from == null
          ? null
          : toJson$Enum$SortEnumType(l$from);
    }
    if (_$data.containsKey('to')) {
      final l$to = to;
      result$data['to'] = l$to == null ? null : toJson$Enum$SortEnumType(l$to);
    }
    if (_$data.containsKey('originContext')) {
      final l$originContext = originContext;
      result$data['originContext'] = l$originContext == null
          ? null
          : toJson$Enum$SortEnumType(l$originContext);
    }
    if (_$data.containsKey('paidAt')) {
      final l$paidAt = paidAt;
      result$data['paidAt'] = l$paidAt == null
          ? null
          : toJson$Enum$SortEnumType(l$paidAt);
    }
    return result$data;
  }

  CopyWith$Input$InvoiceSortInput<Input$InvoiceSortInput> get copyWith =>
      CopyWith$Input$InvoiceSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$InvoiceSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$paymentTransactionId = paymentTransactionId;
    final lOther$paymentTransactionId = other.paymentTransactionId;
    if (_$data.containsKey('paymentTransactionId') !=
        other._$data.containsKey('paymentTransactionId')) {
      return false;
    }
    if (l$paymentTransactionId != lOther$paymentTransactionId) {
      return false;
    }
    final l$stripeInvoiceId = stripeInvoiceId;
    final lOther$stripeInvoiceId = other.stripeInvoiceId;
    if (_$data.containsKey('stripeInvoiceId') !=
        other._$data.containsKey('stripeInvoiceId')) {
      return false;
    }
    if (l$stripeInvoiceId != lOther$stripeInvoiceId) {
      return false;
    }
    final l$oneOffSnapshot = oneOffSnapshot;
    final lOther$oneOffSnapshot = other.oneOffSnapshot;
    if (_$data.containsKey('oneOffSnapshot') !=
        other._$data.containsKey('oneOffSnapshot')) {
      return false;
    }
    if (l$oneOffSnapshot != lOther$oneOffSnapshot) {
      return false;
    }
    final l$subscriptionSnapshot = subscriptionSnapshot;
    final lOther$subscriptionSnapshot = other.subscriptionSnapshot;
    if (_$data.containsKey('subscriptionSnapshot') !=
        other._$data.containsKey('subscriptionSnapshot')) {
      return false;
    }
    if (l$subscriptionSnapshot != lOther$subscriptionSnapshot) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$country = country;
    final lOther$country = other.country;
    if (_$data.containsKey('country') != other._$data.containsKey('country')) {
      return false;
    }
    if (l$country != lOther$country) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$from = from;
    final lOther$from = other.from;
    if (_$data.containsKey('from') != other._$data.containsKey('from')) {
      return false;
    }
    if (l$from != lOther$from) {
      return false;
    }
    final l$to = to;
    final lOther$to = other.to;
    if (_$data.containsKey('to') != other._$data.containsKey('to')) {
      return false;
    }
    if (l$to != lOther$to) {
      return false;
    }
    final l$originContext = originContext;
    final lOther$originContext = other.originContext;
    if (_$data.containsKey('originContext') !=
        other._$data.containsKey('originContext')) {
      return false;
    }
    if (l$originContext != lOther$originContext) {
      return false;
    }
    final l$paidAt = paidAt;
    final lOther$paidAt = other.paidAt;
    if (_$data.containsKey('paidAt') != other._$data.containsKey('paidAt')) {
      return false;
    }
    if (l$paidAt != lOther$paidAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$paymentTransactionId = paymentTransactionId;
    final l$stripeInvoiceId = stripeInvoiceId;
    final l$oneOffSnapshot = oneOffSnapshot;
    final l$subscriptionSnapshot = subscriptionSnapshot;
    final l$fullName = fullName;
    final l$email = email;
    final l$country = country;
    final l$amount = amount;
    final l$currency = currency;
    final l$from = from;
    final l$to = to;
    final l$originContext = originContext;
    final l$paidAt = paidAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('paymentTransactionId')
          ? l$paymentTransactionId
          : const {},
      _$data.containsKey('stripeInvoiceId') ? l$stripeInvoiceId : const {},
      _$data.containsKey('oneOffSnapshot') ? l$oneOffSnapshot : const {},
      _$data.containsKey('subscriptionSnapshot')
          ? l$subscriptionSnapshot
          : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('country') ? l$country : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('from') ? l$from : const {},
      _$data.containsKey('to') ? l$to : const {},
      _$data.containsKey('originContext') ? l$originContext : const {},
      _$data.containsKey('paidAt') ? l$paidAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvoiceSortInput<TRes> {
  factory CopyWith$Input$InvoiceSortInput(
    Input$InvoiceSortInput instance,
    TRes Function(Input$InvoiceSortInput) then,
  ) = _CopyWithImpl$Input$InvoiceSortInput;

  factory CopyWith$Input$InvoiceSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvoiceSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? paymentTransactionId,
    Enum$SortEnumType? stripeInvoiceId,
    Input$OneOffSnapshotSortInput? oneOffSnapshot,
    Input$SubscriptionSnapshotSortInput? subscriptionSnapshot,
    Enum$SortEnumType? fullName,
    Enum$SortEnumType? email,
    Enum$SortEnumType? country,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? from,
    Enum$SortEnumType? to,
    Enum$SortEnumType? originContext,
    Enum$SortEnumType? paidAt,
  });
  CopyWith$Input$OneOffSnapshotSortInput<TRes> get oneOffSnapshot;
  CopyWith$Input$SubscriptionSnapshotSortInput<TRes> get subscriptionSnapshot;
}

class _CopyWithImpl$Input$InvoiceSortInput<TRes>
    implements CopyWith$Input$InvoiceSortInput<TRes> {
  _CopyWithImpl$Input$InvoiceSortInput(this._instance, this._then);

  final Input$InvoiceSortInput _instance;

  final TRes Function(Input$InvoiceSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? paymentTransactionId = _undefined,
    Object? stripeInvoiceId = _undefined,
    Object? oneOffSnapshot = _undefined,
    Object? subscriptionSnapshot = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? country = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? from = _undefined,
    Object? to = _undefined,
    Object? originContext = _undefined,
    Object? paidAt = _undefined,
  }) => _then(
    Input$InvoiceSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (userId != _undefined) 'userId': (userId as Enum$SortEnumType?),
      if (paymentTransactionId != _undefined)
        'paymentTransactionId': (paymentTransactionId as Enum$SortEnumType?),
      if (stripeInvoiceId != _undefined)
        'stripeInvoiceId': (stripeInvoiceId as Enum$SortEnumType?),
      if (oneOffSnapshot != _undefined)
        'oneOffSnapshot': (oneOffSnapshot as Input$OneOffSnapshotSortInput?),
      if (subscriptionSnapshot != _undefined)
        'subscriptionSnapshot':
            (subscriptionSnapshot as Input$SubscriptionSnapshotSortInput?),
      if (fullName != _undefined) 'fullName': (fullName as Enum$SortEnumType?),
      if (email != _undefined) 'email': (email as Enum$SortEnumType?),
      if (country != _undefined) 'country': (country as Enum$SortEnumType?),
      if (amount != _undefined) 'amount': (amount as Enum$SortEnumType?),
      if (currency != _undefined) 'currency': (currency as Enum$SortEnumType?),
      if (from != _undefined) 'from': (from as Enum$SortEnumType?),
      if (to != _undefined) 'to': (to as Enum$SortEnumType?),
      if (originContext != _undefined)
        'originContext': (originContext as Enum$SortEnumType?),
      if (paidAt != _undefined) 'paidAt': (paidAt as Enum$SortEnumType?),
    }),
  );

  CopyWith$Input$OneOffSnapshotSortInput<TRes> get oneOffSnapshot {
    final local$oneOffSnapshot = _instance.oneOffSnapshot;
    return local$oneOffSnapshot == null
        ? CopyWith$Input$OneOffSnapshotSortInput.stub(_then(_instance))
        : CopyWith$Input$OneOffSnapshotSortInput(
            local$oneOffSnapshot,
            (e) => call(oneOffSnapshot: e),
          );
  }

  CopyWith$Input$SubscriptionSnapshotSortInput<TRes> get subscriptionSnapshot {
    final local$subscriptionSnapshot = _instance.subscriptionSnapshot;
    return local$subscriptionSnapshot == null
        ? CopyWith$Input$SubscriptionSnapshotSortInput.stub(_then(_instance))
        : CopyWith$Input$SubscriptionSnapshotSortInput(
            local$subscriptionSnapshot,
            (e) => call(subscriptionSnapshot: e),
          );
  }
}

class _CopyWithStubImpl$Input$InvoiceSortInput<TRes>
    implements CopyWith$Input$InvoiceSortInput<TRes> {
  _CopyWithStubImpl$Input$InvoiceSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? paymentTransactionId,
    Enum$SortEnumType? stripeInvoiceId,
    Input$OneOffSnapshotSortInput? oneOffSnapshot,
    Input$SubscriptionSnapshotSortInput? subscriptionSnapshot,
    Enum$SortEnumType? fullName,
    Enum$SortEnumType? email,
    Enum$SortEnumType? country,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? from,
    Enum$SortEnumType? to,
    Enum$SortEnumType? originContext,
    Enum$SortEnumType? paidAt,
  }) => _res;

  CopyWith$Input$OneOffSnapshotSortInput<TRes> get oneOffSnapshot =>
      CopyWith$Input$OneOffSnapshotSortInput.stub(_res);

  CopyWith$Input$SubscriptionSnapshotSortInput<TRes> get subscriptionSnapshot =>
      CopyWith$Input$SubscriptionSnapshotSortInput.stub(_res);
}

class Input$KeyValuePairOfStringAndStringInput {
  factory Input$KeyValuePairOfStringAndStringInput({
    required String key,
    required String value,
  }) => Input$KeyValuePairOfStringAndStringInput._({
    r'key': key,
    r'value': value,
  });

  Input$KeyValuePairOfStringAndStringInput._(this._$data);

  factory Input$KeyValuePairOfStringAndStringInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$key = data['key'];
    result$data['key'] = (l$key as String);
    final l$value = data['value'];
    result$data['value'] = (l$value as String);
    return Input$KeyValuePairOfStringAndStringInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get key => (_$data['key'] as String);

  String get value => (_$data['value'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$key = key;
    result$data['key'] = l$key;
    final l$value = value;
    result$data['value'] = l$value;
    return result$data;
  }

  CopyWith$Input$KeyValuePairOfStringAndStringInput<
    Input$KeyValuePairOfStringAndStringInput
  >
  get copyWith =>
      CopyWith$Input$KeyValuePairOfStringAndStringInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$KeyValuePairOfStringAndStringInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (l$key != lOther$key) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$key = key;
    final l$value = value;
    return Object.hashAll([l$key, l$value]);
  }
}

abstract class CopyWith$Input$KeyValuePairOfStringAndStringInput<TRes> {
  factory CopyWith$Input$KeyValuePairOfStringAndStringInput(
    Input$KeyValuePairOfStringAndStringInput instance,
    TRes Function(Input$KeyValuePairOfStringAndStringInput) then,
  ) = _CopyWithImpl$Input$KeyValuePairOfStringAndStringInput;

  factory CopyWith$Input$KeyValuePairOfStringAndStringInput.stub(TRes res) =
      _CopyWithStubImpl$Input$KeyValuePairOfStringAndStringInput;

  TRes call({String? key, String? value});
}

class _CopyWithImpl$Input$KeyValuePairOfStringAndStringInput<TRes>
    implements CopyWith$Input$KeyValuePairOfStringAndStringInput<TRes> {
  _CopyWithImpl$Input$KeyValuePairOfStringAndStringInput(
    this._instance,
    this._then,
  );

  final Input$KeyValuePairOfStringAndStringInput _instance;

  final TRes Function(Input$KeyValuePairOfStringAndStringInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? key = _undefined, Object? value = _undefined}) => _then(
    Input$KeyValuePairOfStringAndStringInput._({
      ..._instance._$data,
      if (key != _undefined && key != null) 'key': (key as String),
      if (value != _undefined && value != null) 'value': (value as String),
    }),
  );
}

class _CopyWithStubImpl$Input$KeyValuePairOfStringAndStringInput<TRes>
    implements CopyWith$Input$KeyValuePairOfStringAndStringInput<TRes> {
  _CopyWithStubImpl$Input$KeyValuePairOfStringAndStringInput(this._res);

  TRes _res;

  call({String? key, String? value}) => _res;
}

class Input$LastMessageFilterInput {
  factory Input$LastMessageFilterInput({
    List<Input$LastMessageFilterInput>? and,
    List<Input$LastMessageFilterInput>? or,
    Input$StringOperationFilterInput? text,
    Input$StringOperationFilterInput? senderId,
    Input$DateTimeOperationFilterInput? sentAt,
    Input$ListStringOperationFilterInput? isReadBy,
  }) => Input$LastMessageFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (text != null) r'text': text,
    if (senderId != null) r'senderId': senderId,
    if (sentAt != null) r'sentAt': sentAt,
    if (isReadBy != null) r'isReadBy': isReadBy,
  });

  Input$LastMessageFilterInput._(this._$data);

  factory Input$LastMessageFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$LastMessageFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$LastMessageFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('text')) {
      final l$text = data['text'];
      result$data['text'] = l$text == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$text as Map<String, dynamic>),
            );
    }
    if (data.containsKey('senderId')) {
      final l$senderId = data['senderId'];
      result$data['senderId'] = l$senderId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$senderId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('sentAt')) {
      final l$sentAt = data['sentAt'];
      result$data['sentAt'] = l$sentAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$sentAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isReadBy')) {
      final l$isReadBy = data['isReadBy'];
      result$data['isReadBy'] = l$isReadBy == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$isReadBy as Map<String, dynamic>),
            );
    }
    return Input$LastMessageFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$LastMessageFilterInput>? get and =>
      (_$data['and'] as List<Input$LastMessageFilterInput>?);

  List<Input$LastMessageFilterInput>? get or =>
      (_$data['or'] as List<Input$LastMessageFilterInput>?);

  Input$StringOperationFilterInput? get text =>
      (_$data['text'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get senderId =>
      (_$data['senderId'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get sentAt =>
      (_$data['sentAt'] as Input$DateTimeOperationFilterInput?);

  Input$ListStringOperationFilterInput? get isReadBy =>
      (_$data['isReadBy'] as Input$ListStringOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('text')) {
      final l$text = text;
      result$data['text'] = l$text?.toJson();
    }
    if (_$data.containsKey('senderId')) {
      final l$senderId = senderId;
      result$data['senderId'] = l$senderId?.toJson();
    }
    if (_$data.containsKey('sentAt')) {
      final l$sentAt = sentAt;
      result$data['sentAt'] = l$sentAt?.toJson();
    }
    if (_$data.containsKey('isReadBy')) {
      final l$isReadBy = isReadBy;
      result$data['isReadBy'] = l$isReadBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$LastMessageFilterInput<Input$LastMessageFilterInput>
  get copyWith => CopyWith$Input$LastMessageFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LastMessageFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$text = text;
    final lOther$text = other.text;
    if (_$data.containsKey('text') != other._$data.containsKey('text')) {
      return false;
    }
    if (l$text != lOther$text) {
      return false;
    }
    final l$senderId = senderId;
    final lOther$senderId = other.senderId;
    if (_$data.containsKey('senderId') !=
        other._$data.containsKey('senderId')) {
      return false;
    }
    if (l$senderId != lOther$senderId) {
      return false;
    }
    final l$sentAt = sentAt;
    final lOther$sentAt = other.sentAt;
    if (_$data.containsKey('sentAt') != other._$data.containsKey('sentAt')) {
      return false;
    }
    if (l$sentAt != lOther$sentAt) {
      return false;
    }
    final l$isReadBy = isReadBy;
    final lOther$isReadBy = other.isReadBy;
    if (_$data.containsKey('isReadBy') !=
        other._$data.containsKey('isReadBy')) {
      return false;
    }
    if (l$isReadBy != lOther$isReadBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$text = text;
    final l$senderId = senderId;
    final l$sentAt = sentAt;
    final l$isReadBy = isReadBy;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('text') ? l$text : const {},
      _$data.containsKey('senderId') ? l$senderId : const {},
      _$data.containsKey('sentAt') ? l$sentAt : const {},
      _$data.containsKey('isReadBy') ? l$isReadBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$LastMessageFilterInput<TRes> {
  factory CopyWith$Input$LastMessageFilterInput(
    Input$LastMessageFilterInput instance,
    TRes Function(Input$LastMessageFilterInput) then,
  ) = _CopyWithImpl$Input$LastMessageFilterInput;

  factory CopyWith$Input$LastMessageFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LastMessageFilterInput;

  TRes call({
    List<Input$LastMessageFilterInput>? and,
    List<Input$LastMessageFilterInput>? or,
    Input$StringOperationFilterInput? text,
    Input$StringOperationFilterInput? senderId,
    Input$DateTimeOperationFilterInput? sentAt,
    Input$ListStringOperationFilterInput? isReadBy,
  });
  TRes and(
    Iterable<Input$LastMessageFilterInput>? Function(
      Iterable<
        CopyWith$Input$LastMessageFilterInput<Input$LastMessageFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$LastMessageFilterInput>? Function(
      Iterable<
        CopyWith$Input$LastMessageFilterInput<Input$LastMessageFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get text;
  CopyWith$Input$StringOperationFilterInput<TRes> get senderId;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get sentAt;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get isReadBy;
}

class _CopyWithImpl$Input$LastMessageFilterInput<TRes>
    implements CopyWith$Input$LastMessageFilterInput<TRes> {
  _CopyWithImpl$Input$LastMessageFilterInput(this._instance, this._then);

  final Input$LastMessageFilterInput _instance;

  final TRes Function(Input$LastMessageFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? text = _undefined,
    Object? senderId = _undefined,
    Object? sentAt = _undefined,
    Object? isReadBy = _undefined,
  }) => _then(
    Input$LastMessageFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$LastMessageFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$LastMessageFilterInput>?),
      if (text != _undefined)
        'text': (text as Input$StringOperationFilterInput?),
      if (senderId != _undefined)
        'senderId': (senderId as Input$StringOperationFilterInput?),
      if (sentAt != _undefined)
        'sentAt': (sentAt as Input$DateTimeOperationFilterInput?),
      if (isReadBy != _undefined)
        'isReadBy': (isReadBy as Input$ListStringOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$LastMessageFilterInput>? Function(
      Iterable<
        CopyWith$Input$LastMessageFilterInput<Input$LastMessageFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$LastMessageFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$LastMessageFilterInput>? Function(
      Iterable<
        CopyWith$Input$LastMessageFilterInput<Input$LastMessageFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$LastMessageFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get text {
    final local$text = _instance.text;
    return local$text == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$text,
            (e) => call(text: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get senderId {
    final local$senderId = _instance.senderId;
    return local$senderId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$senderId,
            (e) => call(senderId: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get sentAt {
    final local$sentAt = _instance.sentAt;
    return local$sentAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$sentAt,
            (e) => call(sentAt: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get isReadBy {
    final local$isReadBy = _instance.isReadBy;
    return local$isReadBy == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$isReadBy,
            (e) => call(isReadBy: e),
          );
  }
}

class _CopyWithStubImpl$Input$LastMessageFilterInput<TRes>
    implements CopyWith$Input$LastMessageFilterInput<TRes> {
  _CopyWithStubImpl$Input$LastMessageFilterInput(this._res);

  TRes _res;

  call({
    List<Input$LastMessageFilterInput>? and,
    List<Input$LastMessageFilterInput>? or,
    Input$StringOperationFilterInput? text,
    Input$StringOperationFilterInput? senderId,
    Input$DateTimeOperationFilterInput? sentAt,
    Input$ListStringOperationFilterInput? isReadBy,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get text =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get senderId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get sentAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get isReadBy =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);
}

class Input$LastMessageSortInput {
  factory Input$LastMessageSortInput({
    Enum$SortEnumType? text,
    Enum$SortEnumType? senderId,
    Enum$SortEnumType? sentAt,
  }) => Input$LastMessageSortInput._({
    if (text != null) r'text': text,
    if (senderId != null) r'senderId': senderId,
    if (sentAt != null) r'sentAt': sentAt,
  });

  Input$LastMessageSortInput._(this._$data);

  factory Input$LastMessageSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('text')) {
      final l$text = data['text'];
      result$data['text'] = l$text == null
          ? null
          : fromJson$Enum$SortEnumType((l$text as String));
    }
    if (data.containsKey('senderId')) {
      final l$senderId = data['senderId'];
      result$data['senderId'] = l$senderId == null
          ? null
          : fromJson$Enum$SortEnumType((l$senderId as String));
    }
    if (data.containsKey('sentAt')) {
      final l$sentAt = data['sentAt'];
      result$data['sentAt'] = l$sentAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$sentAt as String));
    }
    return Input$LastMessageSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get text => (_$data['text'] as Enum$SortEnumType?);

  Enum$SortEnumType? get senderId => (_$data['senderId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get sentAt => (_$data['sentAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('text')) {
      final l$text = text;
      result$data['text'] = l$text == null
          ? null
          : toJson$Enum$SortEnumType(l$text);
    }
    if (_$data.containsKey('senderId')) {
      final l$senderId = senderId;
      result$data['senderId'] = l$senderId == null
          ? null
          : toJson$Enum$SortEnumType(l$senderId);
    }
    if (_$data.containsKey('sentAt')) {
      final l$sentAt = sentAt;
      result$data['sentAt'] = l$sentAt == null
          ? null
          : toJson$Enum$SortEnumType(l$sentAt);
    }
    return result$data;
  }

  CopyWith$Input$LastMessageSortInput<Input$LastMessageSortInput>
  get copyWith => CopyWith$Input$LastMessageSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LastMessageSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$text = text;
    final lOther$text = other.text;
    if (_$data.containsKey('text') != other._$data.containsKey('text')) {
      return false;
    }
    if (l$text != lOther$text) {
      return false;
    }
    final l$senderId = senderId;
    final lOther$senderId = other.senderId;
    if (_$data.containsKey('senderId') !=
        other._$data.containsKey('senderId')) {
      return false;
    }
    if (l$senderId != lOther$senderId) {
      return false;
    }
    final l$sentAt = sentAt;
    final lOther$sentAt = other.sentAt;
    if (_$data.containsKey('sentAt') != other._$data.containsKey('sentAt')) {
      return false;
    }
    if (l$sentAt != lOther$sentAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$text = text;
    final l$senderId = senderId;
    final l$sentAt = sentAt;
    return Object.hashAll([
      _$data.containsKey('text') ? l$text : const {},
      _$data.containsKey('senderId') ? l$senderId : const {},
      _$data.containsKey('sentAt') ? l$sentAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$LastMessageSortInput<TRes> {
  factory CopyWith$Input$LastMessageSortInput(
    Input$LastMessageSortInput instance,
    TRes Function(Input$LastMessageSortInput) then,
  ) = _CopyWithImpl$Input$LastMessageSortInput;

  factory CopyWith$Input$LastMessageSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LastMessageSortInput;

  TRes call({
    Enum$SortEnumType? text,
    Enum$SortEnumType? senderId,
    Enum$SortEnumType? sentAt,
  });
}

class _CopyWithImpl$Input$LastMessageSortInput<TRes>
    implements CopyWith$Input$LastMessageSortInput<TRes> {
  _CopyWithImpl$Input$LastMessageSortInput(this._instance, this._then);

  final Input$LastMessageSortInput _instance;

  final TRes Function(Input$LastMessageSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? text = _undefined,
    Object? senderId = _undefined,
    Object? sentAt = _undefined,
  }) => _then(
    Input$LastMessageSortInput._({
      ..._instance._$data,
      if (text != _undefined) 'text': (text as Enum$SortEnumType?),
      if (senderId != _undefined) 'senderId': (senderId as Enum$SortEnumType?),
      if (sentAt != _undefined) 'sentAt': (sentAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$LastMessageSortInput<TRes>
    implements CopyWith$Input$LastMessageSortInput<TRes> {
  _CopyWithStubImpl$Input$LastMessageSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? text,
    Enum$SortEnumType? senderId,
    Enum$SortEnumType? sentAt,
  }) => _res;
}

class Input$LegalDocumentFilterInput {
  factory Input$LegalDocumentFilterInput({
    List<Input$LegalDocumentFilterInput>? and,
    List<Input$LegalDocumentFilterInput>? or,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? documentUrl,
    Input$DocumentTypeOperationFilterInput? documentType,
    Input$StringOperationFilterInput? note,
  }) => Input$LegalDocumentFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (name != null) r'name': name,
    if (documentUrl != null) r'documentUrl': documentUrl,
    if (documentType != null) r'documentType': documentType,
    if (note != null) r'note': note,
  });

  Input$LegalDocumentFilterInput._(this._$data);

  factory Input$LegalDocumentFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$LegalDocumentFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$LegalDocumentFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>),
            );
    }
    if (data.containsKey('documentUrl')) {
      final l$documentUrl = data['documentUrl'];
      result$data['documentUrl'] = l$documentUrl == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$documentUrl as Map<String, dynamic>),
            );
    }
    if (data.containsKey('documentType')) {
      final l$documentType = data['documentType'];
      result$data['documentType'] = l$documentType == null
          ? null
          : Input$DocumentTypeOperationFilterInput.fromJson(
              (l$documentType as Map<String, dynamic>),
            );
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = l$note == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$note as Map<String, dynamic>),
            );
    }
    return Input$LegalDocumentFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$LegalDocumentFilterInput>? get and =>
      (_$data['and'] as List<Input$LegalDocumentFilterInput>?);

  List<Input$LegalDocumentFilterInput>? get or =>
      (_$data['or'] as List<Input$LegalDocumentFilterInput>?);

  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get documentUrl =>
      (_$data['documentUrl'] as Input$StringOperationFilterInput?);

  Input$DocumentTypeOperationFilterInput? get documentType =>
      (_$data['documentType'] as Input$DocumentTypeOperationFilterInput?);

  Input$StringOperationFilterInput? get note =>
      (_$data['note'] as Input$StringOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('documentUrl')) {
      final l$documentUrl = documentUrl;
      result$data['documentUrl'] = l$documentUrl?.toJson();
    }
    if (_$data.containsKey('documentType')) {
      final l$documentType = documentType;
      result$data['documentType'] = l$documentType?.toJson();
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$LegalDocumentFilterInput<Input$LegalDocumentFilterInput>
  get copyWith => CopyWith$Input$LegalDocumentFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LegalDocumentFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$documentUrl = documentUrl;
    final lOther$documentUrl = other.documentUrl;
    if (_$data.containsKey('documentUrl') !=
        other._$data.containsKey('documentUrl')) {
      return false;
    }
    if (l$documentUrl != lOther$documentUrl) {
      return false;
    }
    final l$documentType = documentType;
    final lOther$documentType = other.documentType;
    if (_$data.containsKey('documentType') !=
        other._$data.containsKey('documentType')) {
      return false;
    }
    if (l$documentType != lOther$documentType) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$name = name;
    final l$documentUrl = documentUrl;
    final l$documentType = documentType;
    final l$note = note;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('documentUrl') ? l$documentUrl : const {},
      _$data.containsKey('documentType') ? l$documentType : const {},
      _$data.containsKey('note') ? l$note : const {},
    ]);
  }
}

abstract class CopyWith$Input$LegalDocumentFilterInput<TRes> {
  factory CopyWith$Input$LegalDocumentFilterInput(
    Input$LegalDocumentFilterInput instance,
    TRes Function(Input$LegalDocumentFilterInput) then,
  ) = _CopyWithImpl$Input$LegalDocumentFilterInput;

  factory CopyWith$Input$LegalDocumentFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LegalDocumentFilterInput;

  TRes call({
    List<Input$LegalDocumentFilterInput>? and,
    List<Input$LegalDocumentFilterInput>? or,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? documentUrl,
    Input$DocumentTypeOperationFilterInput? documentType,
    Input$StringOperationFilterInput? note,
  });
  TRes and(
    Iterable<Input$LegalDocumentFilterInput>? Function(
      Iterable<
        CopyWith$Input$LegalDocumentFilterInput<Input$LegalDocumentFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$LegalDocumentFilterInput>? Function(
      Iterable<
        CopyWith$Input$LegalDocumentFilterInput<Input$LegalDocumentFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  CopyWith$Input$StringOperationFilterInput<TRes> get documentUrl;
  CopyWith$Input$DocumentTypeOperationFilterInput<TRes> get documentType;
  CopyWith$Input$StringOperationFilterInput<TRes> get note;
}

class _CopyWithImpl$Input$LegalDocumentFilterInput<TRes>
    implements CopyWith$Input$LegalDocumentFilterInput<TRes> {
  _CopyWithImpl$Input$LegalDocumentFilterInput(this._instance, this._then);

  final Input$LegalDocumentFilterInput _instance;

  final TRes Function(Input$LegalDocumentFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? name = _undefined,
    Object? documentUrl = _undefined,
    Object? documentType = _undefined,
    Object? note = _undefined,
  }) => _then(
    Input$LegalDocumentFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$LegalDocumentFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$LegalDocumentFilterInput>?),
      if (name != _undefined)
        'name': (name as Input$StringOperationFilterInput?),
      if (documentUrl != _undefined)
        'documentUrl': (documentUrl as Input$StringOperationFilterInput?),
      if (documentType != _undefined)
        'documentType':
            (documentType as Input$DocumentTypeOperationFilterInput?),
      if (note != _undefined)
        'note': (note as Input$StringOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$LegalDocumentFilterInput>? Function(
      Iterable<
        CopyWith$Input$LegalDocumentFilterInput<Input$LegalDocumentFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$LegalDocumentFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$LegalDocumentFilterInput>? Function(
      Iterable<
        CopyWith$Input$LegalDocumentFilterInput<Input$LegalDocumentFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$LegalDocumentFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name,
            (e) => call(name: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get documentUrl {
    final local$documentUrl = _instance.documentUrl;
    return local$documentUrl == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$documentUrl,
            (e) => call(documentUrl: e),
          );
  }

  CopyWith$Input$DocumentTypeOperationFilterInput<TRes> get documentType {
    final local$documentType = _instance.documentType;
    return local$documentType == null
        ? CopyWith$Input$DocumentTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DocumentTypeOperationFilterInput(
            local$documentType,
            (e) => call(documentType: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get note {
    final local$note = _instance.note;
    return local$note == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$note,
            (e) => call(note: e),
          );
  }
}

class _CopyWithStubImpl$Input$LegalDocumentFilterInput<TRes>
    implements CopyWith$Input$LegalDocumentFilterInput<TRes> {
  _CopyWithStubImpl$Input$LegalDocumentFilterInput(this._res);

  TRes _res;

  call({
    List<Input$LegalDocumentFilterInput>? and,
    List<Input$LegalDocumentFilterInput>? or,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? documentUrl,
    Input$DocumentTypeOperationFilterInput? documentType,
    Input$StringOperationFilterInput? note,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get documentUrl =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DocumentTypeOperationFilterInput<TRes> get documentType =>
      CopyWith$Input$DocumentTypeOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get note =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
}

class Input$LegalDocumentInput {
  factory Input$LegalDocumentInput({
    required String name,
    required String documentUrl,
    required Enum$DocumentType documentType,
    required String note,
  }) => Input$LegalDocumentInput._({
    r'name': name,
    r'documentUrl': documentUrl,
    r'documentType': documentType,
    r'note': note,
  });

  Input$LegalDocumentInput._(this._$data);

  factory Input$LegalDocumentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$documentUrl = data['documentUrl'];
    result$data['documentUrl'] = (l$documentUrl as String);
    final l$documentType = data['documentType'];
    result$data['documentType'] = fromJson$Enum$DocumentType(
      (l$documentType as String),
    );
    final l$note = data['note'];
    result$data['note'] = (l$note as String);
    return Input$LegalDocumentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String get documentUrl => (_$data['documentUrl'] as String);

  Enum$DocumentType get documentType =>
      (_$data['documentType'] as Enum$DocumentType);

  String get note => (_$data['note'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$documentUrl = documentUrl;
    result$data['documentUrl'] = l$documentUrl;
    final l$documentType = documentType;
    result$data['documentType'] = toJson$Enum$DocumentType(l$documentType);
    final l$note = note;
    result$data['note'] = l$note;
    return result$data;
  }

  CopyWith$Input$LegalDocumentInput<Input$LegalDocumentInput> get copyWith =>
      CopyWith$Input$LegalDocumentInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LegalDocumentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$documentUrl = documentUrl;
    final lOther$documentUrl = other.documentUrl;
    if (l$documentUrl != lOther$documentUrl) {
      return false;
    }
    final l$documentType = documentType;
    final lOther$documentType = other.documentType;
    if (l$documentType != lOther$documentType) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (l$note != lOther$note) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$documentUrl = documentUrl;
    final l$documentType = documentType;
    final l$note = note;
    return Object.hashAll([l$name, l$documentUrl, l$documentType, l$note]);
  }
}

abstract class CopyWith$Input$LegalDocumentInput<TRes> {
  factory CopyWith$Input$LegalDocumentInput(
    Input$LegalDocumentInput instance,
    TRes Function(Input$LegalDocumentInput) then,
  ) = _CopyWithImpl$Input$LegalDocumentInput;

  factory CopyWith$Input$LegalDocumentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LegalDocumentInput;

  TRes call({
    String? name,
    String? documentUrl,
    Enum$DocumentType? documentType,
    String? note,
  });
}

class _CopyWithImpl$Input$LegalDocumentInput<TRes>
    implements CopyWith$Input$LegalDocumentInput<TRes> {
  _CopyWithImpl$Input$LegalDocumentInput(this._instance, this._then);

  final Input$LegalDocumentInput _instance;

  final TRes Function(Input$LegalDocumentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? documentUrl = _undefined,
    Object? documentType = _undefined,
    Object? note = _undefined,
  }) => _then(
    Input$LegalDocumentInput._({
      ..._instance._$data,
      if (name != _undefined && name != null) 'name': (name as String),
      if (documentUrl != _undefined && documentUrl != null)
        'documentUrl': (documentUrl as String),
      if (documentType != _undefined && documentType != null)
        'documentType': (documentType as Enum$DocumentType),
      if (note != _undefined && note != null) 'note': (note as String),
    }),
  );
}

class _CopyWithStubImpl$Input$LegalDocumentInput<TRes>
    implements CopyWith$Input$LegalDocumentInput<TRes> {
  _CopyWithStubImpl$Input$LegalDocumentInput(this._res);

  TRes _res;

  call({
    String? name,
    String? documentUrl,
    Enum$DocumentType? documentType,
    String? note,
  }) => _res;
}

class Input$LegalPolicyFilterInput {
  factory Input$LegalPolicyFilterInput({
    List<Input$LegalPolicyFilterInput>? and,
    List<Input$LegalPolicyFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? content,
    Input$LongOperationFilterInput? version,
    Input$PolicyStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? effectiveAt,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$LegalPolicyFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (content != null) r'content': content,
    if (version != null) r'version': version,
    if (status != null) r'status': status,
    if (effectiveAt != null) r'effectiveAt': effectiveAt,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$LegalPolicyFilterInput._(this._$data);

  factory Input$LegalPolicyFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$LegalPolicyFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$LegalPolicyFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>),
            );
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$content as Map<String, dynamic>),
            );
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$version as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$PolicyStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('effectiveAt')) {
      final l$effectiveAt = data['effectiveAt'];
      result$data['effectiveAt'] = l$effectiveAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$effectiveAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$LegalPolicyFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$LegalPolicyFilterInput>? get and =>
      (_$data['and'] as List<Input$LegalPolicyFilterInput>?);

  List<Input$LegalPolicyFilterInput>? get or =>
      (_$data['or'] as List<Input$LegalPolicyFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get content =>
      (_$data['content'] as Input$StringOperationFilterInput?);

  Input$LongOperationFilterInput? get version =>
      (_$data['version'] as Input$LongOperationFilterInput?);

  Input$PolicyStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$PolicyStatusOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get effectiveAt =>
      (_$data['effectiveAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('effectiveAt')) {
      final l$effectiveAt = effectiveAt;
      result$data['effectiveAt'] = l$effectiveAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$LegalPolicyFilterInput<Input$LegalPolicyFilterInput>
  get copyWith => CopyWith$Input$LegalPolicyFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LegalPolicyFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$effectiveAt = effectiveAt;
    final lOther$effectiveAt = other.effectiveAt;
    if (_$data.containsKey('effectiveAt') !=
        other._$data.containsKey('effectiveAt')) {
      return false;
    }
    if (l$effectiveAt != lOther$effectiveAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$name = name;
    final l$content = content;
    final l$version = version;
    final l$status = status;
    final l$effectiveAt = effectiveAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('effectiveAt') ? l$effectiveAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$LegalPolicyFilterInput<TRes> {
  factory CopyWith$Input$LegalPolicyFilterInput(
    Input$LegalPolicyFilterInput instance,
    TRes Function(Input$LegalPolicyFilterInput) then,
  ) = _CopyWithImpl$Input$LegalPolicyFilterInput;

  factory CopyWith$Input$LegalPolicyFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LegalPolicyFilterInput;

  TRes call({
    List<Input$LegalPolicyFilterInput>? and,
    List<Input$LegalPolicyFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? content,
    Input$LongOperationFilterInput? version,
    Input$PolicyStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? effectiveAt,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$LegalPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$LegalPolicyFilterInput<Input$LegalPolicyFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$LegalPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$LegalPolicyFilterInput<Input$LegalPolicyFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  CopyWith$Input$StringOperationFilterInput<TRes> get content;
  CopyWith$Input$LongOperationFilterInput<TRes> get version;
  CopyWith$Input$PolicyStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get effectiveAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$LegalPolicyFilterInput<TRes>
    implements CopyWith$Input$LegalPolicyFilterInput<TRes> {
  _CopyWithImpl$Input$LegalPolicyFilterInput(this._instance, this._then);

  final Input$LegalPolicyFilterInput _instance;

  final TRes Function(Input$LegalPolicyFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? content = _undefined,
    Object? version = _undefined,
    Object? status = _undefined,
    Object? effectiveAt = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$LegalPolicyFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$LegalPolicyFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$LegalPolicyFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (name != _undefined)
        'name': (name as Input$StringOperationFilterInput?),
      if (content != _undefined)
        'content': (content as Input$StringOperationFilterInput?),
      if (version != _undefined)
        'version': (version as Input$LongOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$PolicyStatusOperationFilterInput?),
      if (effectiveAt != _undefined)
        'effectiveAt': (effectiveAt as Input$DateTimeOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$LegalPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$LegalPolicyFilterInput<Input$LegalPolicyFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$LegalPolicyFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$LegalPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$LegalPolicyFilterInput<Input$LegalPolicyFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$LegalPolicyFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name,
            (e) => call(name: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$content,
            (e) => call(content: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get version {
    final local$version = _instance.version;
    return local$version == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$version,
            (e) => call(version: e),
          );
  }

  CopyWith$Input$PolicyStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$PolicyStatusOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$PolicyStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get effectiveAt {
    final local$effectiveAt = _instance.effectiveAt;
    return local$effectiveAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$effectiveAt,
            (e) => call(effectiveAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$LegalPolicyFilterInput<TRes>
    implements CopyWith$Input$LegalPolicyFilterInput<TRes> {
  _CopyWithStubImpl$Input$LegalPolicyFilterInput(this._res);

  TRes _res;

  call({
    List<Input$LegalPolicyFilterInput>? and,
    List<Input$LegalPolicyFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? content,
    Input$LongOperationFilterInput? version,
    Input$PolicyStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? effectiveAt,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get content =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get version =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$PolicyStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$PolicyStatusOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get effectiveAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$LegalPolicySortInput {
  factory Input$LegalPolicySortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? content,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? effectiveAt,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$LegalPolicySortInput._({
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (content != null) r'content': content,
    if (version != null) r'version': version,
    if (status != null) r'status': status,
    if (effectiveAt != null) r'effectiveAt': effectiveAt,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$LegalPolicySortInput._(this._$data);

  factory Input$LegalPolicySortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : fromJson$Enum$SortEnumType((l$content as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$SortEnumType((l$version as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('effectiveAt')) {
      final l$effectiveAt = data['effectiveAt'];
      result$data['effectiveAt'] = l$effectiveAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$effectiveAt as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$LegalPolicySortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);

  Enum$SortEnumType? get content => (_$data['content'] as Enum$SortEnumType?);

  Enum$SortEnumType? get version => (_$data['version'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get effectiveAt =>
      (_$data['effectiveAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null
          ? null
          : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content == null
          ? null
          : toJson$Enum$SortEnumType(l$content);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version == null
          ? null
          : toJson$Enum$SortEnumType(l$version);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('effectiveAt')) {
      final l$effectiveAt = effectiveAt;
      result$data['effectiveAt'] = l$effectiveAt == null
          ? null
          : toJson$Enum$SortEnumType(l$effectiveAt);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$LegalPolicySortInput<Input$LegalPolicySortInput>
  get copyWith => CopyWith$Input$LegalPolicySortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LegalPolicySortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$effectiveAt = effectiveAt;
    final lOther$effectiveAt = other.effectiveAt;
    if (_$data.containsKey('effectiveAt') !=
        other._$data.containsKey('effectiveAt')) {
      return false;
    }
    if (l$effectiveAt != lOther$effectiveAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$content = content;
    final l$version = version;
    final l$status = status;
    final l$effectiveAt = effectiveAt;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('effectiveAt') ? l$effectiveAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$LegalPolicySortInput<TRes> {
  factory CopyWith$Input$LegalPolicySortInput(
    Input$LegalPolicySortInput instance,
    TRes Function(Input$LegalPolicySortInput) then,
  ) = _CopyWithImpl$Input$LegalPolicySortInput;

  factory CopyWith$Input$LegalPolicySortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LegalPolicySortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? content,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? effectiveAt,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$LegalPolicySortInput<TRes>
    implements CopyWith$Input$LegalPolicySortInput<TRes> {
  _CopyWithImpl$Input$LegalPolicySortInput(this._instance, this._then);

  final Input$LegalPolicySortInput _instance;

  final TRes Function(Input$LegalPolicySortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? content = _undefined,
    Object? version = _undefined,
    Object? status = _undefined,
    Object? effectiveAt = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$LegalPolicySortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      if (content != _undefined) 'content': (content as Enum$SortEnumType?),
      if (version != _undefined) 'version': (version as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (effectiveAt != _undefined)
        'effectiveAt': (effectiveAt as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$LegalPolicySortInput<TRes>
    implements CopyWith$Input$LegalPolicySortInput<TRes> {
  _CopyWithStubImpl$Input$LegalPolicySortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? content,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? effectiveAt,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$ListByteOperationFilterInput {
  factory Input$ListByteOperationFilterInput({
    Input$ByteOperationFilterInput? all,
    Input$ByteOperationFilterInput? none,
    Input$ByteOperationFilterInput? some,
    bool? any,
  }) => Input$ListByteOperationFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListByteOperationFilterInput._(this._$data);

  factory Input$ListByteOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$ByteOperationFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$ByteOperationFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$ByteOperationFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListByteOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ByteOperationFilterInput? get all =>
      (_$data['all'] as Input$ByteOperationFilterInput?);

  Input$ByteOperationFilterInput? get none =>
      (_$data['none'] as Input$ByteOperationFilterInput?);

  Input$ByteOperationFilterInput? get some =>
      (_$data['some'] as Input$ByteOperationFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListByteOperationFilterInput<
    Input$ListByteOperationFilterInput
  >
  get copyWith => CopyWith$Input$ListByteOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListByteOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListByteOperationFilterInput<TRes> {
  factory CopyWith$Input$ListByteOperationFilterInput(
    Input$ListByteOperationFilterInput instance,
    TRes Function(Input$ListByteOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ListByteOperationFilterInput;

  factory CopyWith$Input$ListByteOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ListByteOperationFilterInput;

  TRes call({
    Input$ByteOperationFilterInput? all,
    Input$ByteOperationFilterInput? none,
    Input$ByteOperationFilterInput? some,
    bool? any,
  });
  CopyWith$Input$ByteOperationFilterInput<TRes> get all;
  CopyWith$Input$ByteOperationFilterInput<TRes> get none;
  CopyWith$Input$ByteOperationFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListByteOperationFilterInput<TRes>
    implements CopyWith$Input$ListByteOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ListByteOperationFilterInput(this._instance, this._then);

  final Input$ListByteOperationFilterInput _instance;

  final TRes Function(Input$ListByteOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListByteOperationFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$ByteOperationFilterInput?),
      if (none != _undefined) 'none': (none as Input$ByteOperationFilterInput?),
      if (some != _undefined) 'some': (some as Input$ByteOperationFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$ByteOperationFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$ByteOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ByteOperationFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$ByteOperationFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$ByteOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ByteOperationFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$ByteOperationFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$ByteOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ByteOperationFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListByteOperationFilterInput<TRes>
    implements CopyWith$Input$ListByteOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListByteOperationFilterInput(this._res);

  TRes _res;

  call({
    Input$ByteOperationFilterInput? all,
    Input$ByteOperationFilterInput? none,
    Input$ByteOperationFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$ByteOperationFilterInput<TRes> get all =>
      CopyWith$Input$ByteOperationFilterInput.stub(_res);

  CopyWith$Input$ByteOperationFilterInput<TRes> get none =>
      CopyWith$Input$ByteOperationFilterInput.stub(_res);

  CopyWith$Input$ByteOperationFilterInput<TRes> get some =>
      CopyWith$Input$ByteOperationFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfArtistMemberFilterInput {
  factory Input$ListFilterInputTypeOfArtistMemberFilterInput({
    Input$ArtistMemberFilterInput? all,
    Input$ArtistMemberFilterInput? none,
    Input$ArtistMemberFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfArtistMemberFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfArtistMemberFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfArtistMemberFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$ArtistMemberFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$ArtistMemberFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$ArtistMemberFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfArtistMemberFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ArtistMemberFilterInput? get all =>
      (_$data['all'] as Input$ArtistMemberFilterInput?);

  Input$ArtistMemberFilterInput? get none =>
      (_$data['none'] as Input$ArtistMemberFilterInput?);

  Input$ArtistMemberFilterInput? get some =>
      (_$data['some'] as Input$ArtistMemberFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput<
    Input$ListFilterInputTypeOfArtistMemberFilterInput
  >
  get copyWith => CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfArtistMemberFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput(
    Input$ListFilterInputTypeOfArtistMemberFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfArtistMemberFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfArtistMemberFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfArtistMemberFilterInput;

  TRes call({
    Input$ArtistMemberFilterInput? all,
    Input$ArtistMemberFilterInput? none,
    Input$ArtistMemberFilterInput? some,
    bool? any,
  });
  CopyWith$Input$ArtistMemberFilterInput<TRes> get all;
  CopyWith$Input$ArtistMemberFilterInput<TRes> get none;
  CopyWith$Input$ArtistMemberFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfArtistMemberFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfArtistMemberFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfArtistMemberFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfArtistMemberFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfArtistMemberFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$ArtistMemberFilterInput?),
      if (none != _undefined) 'none': (none as Input$ArtistMemberFilterInput?),
      if (some != _undefined) 'some': (some as Input$ArtistMemberFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$ArtistMemberFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$ArtistMemberFilterInput.stub(_then(_instance))
        : CopyWith$Input$ArtistMemberFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$ArtistMemberFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$ArtistMemberFilterInput.stub(_then(_instance))
        : CopyWith$Input$ArtistMemberFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$ArtistMemberFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$ArtistMemberFilterInput.stub(_then(_instance))
        : CopyWith$Input$ArtistMemberFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfArtistMemberFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfArtistMemberFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfArtistMemberFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$ArtistMemberFilterInput? all,
    Input$ArtistMemberFilterInput? none,
    Input$ArtistMemberFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$ArtistMemberFilterInput<TRes> get all =>
      CopyWith$Input$ArtistMemberFilterInput.stub(_res);

  CopyWith$Input$ArtistMemberFilterInput<TRes> get none =>
      CopyWith$Input$ArtistMemberFilterInput.stub(_res);

  CopyWith$Input$ArtistMemberFilterInput<TRes> get some =>
      CopyWith$Input$ArtistMemberFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfContributingArtistFilterInput {
  factory Input$ListFilterInputTypeOfContributingArtistFilterInput({
    Input$ContributingArtistFilterInput? all,
    Input$ContributingArtistFilterInput? none,
    Input$ContributingArtistFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfContributingArtistFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfContributingArtistFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfContributingArtistFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$ContributingArtistFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$ContributingArtistFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$ContributingArtistFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfContributingArtistFilterInput._(
      result$data,
    );
  }

  Map<String, dynamic> _$data;

  Input$ContributingArtistFilterInput? get all =>
      (_$data['all'] as Input$ContributingArtistFilterInput?);

  Input$ContributingArtistFilterInput? get none =>
      (_$data['none'] as Input$ContributingArtistFilterInput?);

  Input$ContributingArtistFilterInput? get some =>
      (_$data['some'] as Input$ContributingArtistFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput<
    Input$ListFilterInputTypeOfContributingArtistFilterInput
  >
  get copyWith =>
      CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfContributingArtistFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput(
    Input$ListFilterInputTypeOfContributingArtistFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfContributingArtistFilterInput)
    then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfContributingArtistFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfContributingArtistFilterInput;

  TRes call({
    Input$ContributingArtistFilterInput? all,
    Input$ContributingArtistFilterInput? none,
    Input$ContributingArtistFilterInput? some,
    bool? any,
  });
  CopyWith$Input$ContributingArtistFilterInput<TRes> get all;
  CopyWith$Input$ContributingArtistFilterInput<TRes> get none;
  CopyWith$Input$ContributingArtistFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfContributingArtistFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput<
          TRes
        > {
  _CopyWithImpl$Input$ListFilterInputTypeOfContributingArtistFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfContributingArtistFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfContributingArtistFilterInput)
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfContributingArtistFilterInput._({
      ..._instance._$data,
      if (all != _undefined)
        'all': (all as Input$ContributingArtistFilterInput?),
      if (none != _undefined)
        'none': (none as Input$ContributingArtistFilterInput?),
      if (some != _undefined)
        'some': (some as Input$ContributingArtistFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$ContributingArtistFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$ContributingArtistFilterInput.stub(_then(_instance))
        : CopyWith$Input$ContributingArtistFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$ContributingArtistFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$ContributingArtistFilterInput.stub(_then(_instance))
        : CopyWith$Input$ContributingArtistFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$ContributingArtistFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$ContributingArtistFilterInput.stub(_then(_instance))
        : CopyWith$Input$ContributingArtistFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfContributingArtistFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfContributingArtistFilterInput<
          TRes
        > {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfContributingArtistFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$ContributingArtistFilterInput? all,
    Input$ContributingArtistFilterInput? none,
    Input$ContributingArtistFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$ContributingArtistFilterInput<TRes> get all =>
      CopyWith$Input$ContributingArtistFilterInput.stub(_res);

  CopyWith$Input$ContributingArtistFilterInput<TRes> get none =>
      CopyWith$Input$ContributingArtistFilterInput.stub(_res);

  CopyWith$Input$ContributingArtistFilterInput<TRes> get some =>
      CopyWith$Input$ContributingArtistFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfDeletedForEntryFilterInput {
  factory Input$ListFilterInputTypeOfDeletedForEntryFilterInput({
    Input$DeletedForEntryFilterInput? all,
    Input$DeletedForEntryFilterInput? none,
    Input$DeletedForEntryFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfDeletedForEntryFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfDeletedForEntryFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfDeletedForEntryFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$DeletedForEntryFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$DeletedForEntryFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$DeletedForEntryFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfDeletedForEntryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DeletedForEntryFilterInput? get all =>
      (_$data['all'] as Input$DeletedForEntryFilterInput?);

  Input$DeletedForEntryFilterInput? get none =>
      (_$data['none'] as Input$DeletedForEntryFilterInput?);

  Input$DeletedForEntryFilterInput? get some =>
      (_$data['some'] as Input$DeletedForEntryFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput<
    Input$ListFilterInputTypeOfDeletedForEntryFilterInput
  >
  get copyWith =>
      CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfDeletedForEntryFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput(
    Input$ListFilterInputTypeOfDeletedForEntryFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfDeletedForEntryFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfDeletedForEntryFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfDeletedForEntryFilterInput;

  TRes call({
    Input$DeletedForEntryFilterInput? all,
    Input$DeletedForEntryFilterInput? none,
    Input$DeletedForEntryFilterInput? some,
    bool? any,
  });
  CopyWith$Input$DeletedForEntryFilterInput<TRes> get all;
  CopyWith$Input$DeletedForEntryFilterInput<TRes> get none;
  CopyWith$Input$DeletedForEntryFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfDeletedForEntryFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfDeletedForEntryFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfDeletedForEntryFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfDeletedForEntryFilterInput)
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfDeletedForEntryFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$DeletedForEntryFilterInput?),
      if (none != _undefined)
        'none': (none as Input$DeletedForEntryFilterInput?),
      if (some != _undefined)
        'some': (some as Input$DeletedForEntryFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$DeletedForEntryFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$DeletedForEntryFilterInput.stub(_then(_instance))
        : CopyWith$Input$DeletedForEntryFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$DeletedForEntryFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$DeletedForEntryFilterInput.stub(_then(_instance))
        : CopyWith$Input$DeletedForEntryFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$DeletedForEntryFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$DeletedForEntryFilterInput.stub(_then(_instance))
        : CopyWith$Input$DeletedForEntryFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfDeletedForEntryFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfDeletedForEntryFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfDeletedForEntryFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$DeletedForEntryFilterInput? all,
    Input$DeletedForEntryFilterInput? none,
    Input$DeletedForEntryFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$DeletedForEntryFilterInput<TRes> get all =>
      CopyWith$Input$DeletedForEntryFilterInput.stub(_res);

  CopyWith$Input$DeletedForEntryFilterInput<TRes> get none =>
      CopyWith$Input$DeletedForEntryFilterInput.stub(_res);

  CopyWith$Input$DeletedForEntryFilterInput<TRes> get some =>
      CopyWith$Input$DeletedForEntryFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput {
  factory Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput({
    Input$EntitlementRoleDefaultFilterInput? all,
    Input$EntitlementRoleDefaultFilterInput? none,
    Input$EntitlementRoleDefaultFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$EntitlementRoleDefaultFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$EntitlementRoleDefaultFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$EntitlementRoleDefaultFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput._(
      result$data,
    );
  }

  Map<String, dynamic> _$data;

  Input$EntitlementRoleDefaultFilterInput? get all =>
      (_$data['all'] as Input$EntitlementRoleDefaultFilterInput?);

  Input$EntitlementRoleDefaultFilterInput? get none =>
      (_$data['none'] as Input$EntitlementRoleDefaultFilterInput?);

  Input$EntitlementRoleDefaultFilterInput? get some =>
      (_$data['some'] as Input$EntitlementRoleDefaultFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput<
    Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput
  >
  get copyWith =>
      CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput(
    Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput)
    then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput;

  TRes call({
    Input$EntitlementRoleDefaultFilterInput? all,
    Input$EntitlementRoleDefaultFilterInput? none,
    Input$EntitlementRoleDefaultFilterInput? some,
    bool? any,
  });
  CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> get all;
  CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> get none;
  CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput<
          TRes
        > {
  _CopyWithImpl$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput _instance;

  final TRes Function(
    Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput,
  )
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput._({
      ..._instance._$data,
      if (all != _undefined)
        'all': (all as Input$EntitlementRoleDefaultFilterInput?),
      if (none != _undefined)
        'none': (none as Input$EntitlementRoleDefaultFilterInput?),
      if (some != _undefined)
        'some': (some as Input$EntitlementRoleDefaultFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$EntitlementRoleDefaultFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$EntitlementRoleDefaultFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$EntitlementRoleDefaultFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$EntitlementRoleDefaultFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$EntitlementRoleDefaultFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$EntitlementRoleDefaultFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput<
          TRes
        > {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfEntitlementRoleDefaultFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$EntitlementRoleDefaultFilterInput? all,
    Input$EntitlementRoleDefaultFilterInput? none,
    Input$EntitlementRoleDefaultFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> get all =>
      CopyWith$Input$EntitlementRoleDefaultFilterInput.stub(_res);

  CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> get none =>
      CopyWith$Input$EntitlementRoleDefaultFilterInput.stub(_res);

  CopyWith$Input$EntitlementRoleDefaultFilterInput<TRes> get some =>
      CopyWith$Input$EntitlementRoleDefaultFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput {
  factory Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput({
    Input$EntitlementSubscriptionOverrideFilterInput? all,
    Input$EntitlementSubscriptionOverrideFilterInput? none,
    Input$EntitlementSubscriptionOverrideFilterInput? some,
    bool? any,
  }) =>
      Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput._({
        if (all != null) r'all': all,
        if (none != null) r'none': none,
        if (some != null) r'some': some,
        if (any != null) r'any': any,
      });

  Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput._(
    this._$data,
  );

  factory Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$EntitlementSubscriptionOverrideFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$EntitlementSubscriptionOverrideFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$EntitlementSubscriptionOverrideFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput._(
      result$data,
    );
  }

  Map<String, dynamic> _$data;

  Input$EntitlementSubscriptionOverrideFilterInput? get all =>
      (_$data['all'] as Input$EntitlementSubscriptionOverrideFilterInput?);

  Input$EntitlementSubscriptionOverrideFilterInput? get none =>
      (_$data['none'] as Input$EntitlementSubscriptionOverrideFilterInput?);

  Input$EntitlementSubscriptionOverrideFilterInput? get some =>
      (_$data['some'] as Input$EntitlementSubscriptionOverrideFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput<
    Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput
  >
  get copyWith =>
      CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput(
    Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput
    instance,
    TRes Function(
      Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput,
    )
    then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput;

  TRes call({
    Input$EntitlementSubscriptionOverrideFilterInput? all,
    Input$EntitlementSubscriptionOverrideFilterInput? none,
    Input$EntitlementSubscriptionOverrideFilterInput? some,
    bool? any,
  });
  CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> get all;
  CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> get none;
  CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput<
          TRes
        > {
  _CopyWithImpl$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput
  _instance;

  final TRes Function(
    Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput,
  )
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput._({
      ..._instance._$data,
      if (all != _undefined)
        'all': (all as Input$EntitlementSubscriptionOverrideFilterInput?),
      if (none != _undefined)
        'none': (none as Input$EntitlementSubscriptionOverrideFilterInput?),
      if (some != _undefined)
        'some': (some as Input$EntitlementSubscriptionOverrideFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$EntitlementSubscriptionOverrideFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$EntitlementSubscriptionOverrideFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$EntitlementSubscriptionOverrideFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$EntitlementSubscriptionOverrideFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$EntitlementSubscriptionOverrideFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$EntitlementSubscriptionOverrideFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput<
          TRes
        > {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfEntitlementSubscriptionOverrideFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$EntitlementSubscriptionOverrideFilterInput? all,
    Input$EntitlementSubscriptionOverrideFilterInput? none,
    Input$EntitlementSubscriptionOverrideFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> get all =>
      CopyWith$Input$EntitlementSubscriptionOverrideFilterInput.stub(_res);

  CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> get none =>
      CopyWith$Input$EntitlementSubscriptionOverrideFilterInput.stub(_res);

  CopyWith$Input$EntitlementSubscriptionOverrideFilterInput<TRes> get some =>
      CopyWith$Input$EntitlementSubscriptionOverrideFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfLegalDocumentFilterInput {
  factory Input$ListFilterInputTypeOfLegalDocumentFilterInput({
    Input$LegalDocumentFilterInput? all,
    Input$LegalDocumentFilterInput? none,
    Input$LegalDocumentFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfLegalDocumentFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfLegalDocumentFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfLegalDocumentFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$LegalDocumentFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$LegalDocumentFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$LegalDocumentFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfLegalDocumentFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$LegalDocumentFilterInput? get all =>
      (_$data['all'] as Input$LegalDocumentFilterInput?);

  Input$LegalDocumentFilterInput? get none =>
      (_$data['none'] as Input$LegalDocumentFilterInput?);

  Input$LegalDocumentFilterInput? get some =>
      (_$data['some'] as Input$LegalDocumentFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput<
    Input$ListFilterInputTypeOfLegalDocumentFilterInput
  >
  get copyWith => CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfLegalDocumentFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput(
    Input$ListFilterInputTypeOfLegalDocumentFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfLegalDocumentFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfLegalDocumentFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfLegalDocumentFilterInput;

  TRes call({
    Input$LegalDocumentFilterInput? all,
    Input$LegalDocumentFilterInput? none,
    Input$LegalDocumentFilterInput? some,
    bool? any,
  });
  CopyWith$Input$LegalDocumentFilterInput<TRes> get all;
  CopyWith$Input$LegalDocumentFilterInput<TRes> get none;
  CopyWith$Input$LegalDocumentFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfLegalDocumentFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfLegalDocumentFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfLegalDocumentFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfLegalDocumentFilterInput)
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfLegalDocumentFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$LegalDocumentFilterInput?),
      if (none != _undefined) 'none': (none as Input$LegalDocumentFilterInput?),
      if (some != _undefined) 'some': (some as Input$LegalDocumentFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$LegalDocumentFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$LegalDocumentFilterInput.stub(_then(_instance))
        : CopyWith$Input$LegalDocumentFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$LegalDocumentFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$LegalDocumentFilterInput.stub(_then(_instance))
        : CopyWith$Input$LegalDocumentFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$LegalDocumentFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$LegalDocumentFilterInput.stub(_then(_instance))
        : CopyWith$Input$LegalDocumentFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfLegalDocumentFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfLegalDocumentFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$LegalDocumentFilterInput? all,
    Input$LegalDocumentFilterInput? none,
    Input$LegalDocumentFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$LegalDocumentFilterInput<TRes> get all =>
      CopyWith$Input$LegalDocumentFilterInput.stub(_res);

  CopyWith$Input$LegalDocumentFilterInput<TRes> get none =>
      CopyWith$Input$LegalDocumentFilterInput.stub(_res);

  CopyWith$Input$LegalDocumentFilterInput<TRes> get some =>
      CopyWith$Input$LegalDocumentFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfMetadataFilterInput {
  factory Input$ListFilterInputTypeOfMetadataFilterInput({
    Input$MetadataFilterInput? all,
    Input$MetadataFilterInput? none,
    Input$MetadataFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfMetadataFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfMetadataFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfMetadataFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$MetadataFilterInput.fromJson((l$all as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$MetadataFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$MetadataFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfMetadataFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$MetadataFilterInput? get all =>
      (_$data['all'] as Input$MetadataFilterInput?);

  Input$MetadataFilterInput? get none =>
      (_$data['none'] as Input$MetadataFilterInput?);

  Input$MetadataFilterInput? get some =>
      (_$data['some'] as Input$MetadataFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<
    Input$ListFilterInputTypeOfMetadataFilterInput
  >
  get copyWith =>
      CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfMetadataFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput(
    Input$ListFilterInputTypeOfMetadataFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfMetadataFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfMetadataFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfMetadataFilterInput;

  TRes call({
    Input$MetadataFilterInput? all,
    Input$MetadataFilterInput? none,
    Input$MetadataFilterInput? some,
    bool? any,
  });
  CopyWith$Input$MetadataFilterInput<TRes> get all;
  CopyWith$Input$MetadataFilterInput<TRes> get none;
  CopyWith$Input$MetadataFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfMetadataFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfMetadataFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfMetadataFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfMetadataFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$MetadataFilterInput?),
      if (none != _undefined) 'none': (none as Input$MetadataFilterInput?),
      if (some != _undefined) 'some': (some as Input$MetadataFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$MetadataFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$MetadataFilterInput.stub(_then(_instance))
        : CopyWith$Input$MetadataFilterInput(local$all, (e) => call(all: e));
  }

  CopyWith$Input$MetadataFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$MetadataFilterInput.stub(_then(_instance))
        : CopyWith$Input$MetadataFilterInput(local$none, (e) => call(none: e));
  }

  CopyWith$Input$MetadataFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$MetadataFilterInput.stub(_then(_instance))
        : CopyWith$Input$MetadataFilterInput(local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfMetadataFilterInput(this._res);

  TRes _res;

  call({
    Input$MetadataFilterInput? all,
    Input$MetadataFilterInput? none,
    Input$MetadataFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$MetadataFilterInput<TRes> get all =>
      CopyWith$Input$MetadataFilterInput.stub(_res);

  CopyWith$Input$MetadataFilterInput<TRes> get none =>
      CopyWith$Input$MetadataFilterInput.stub(_res);

  CopyWith$Input$MetadataFilterInput<TRes> get some =>
      CopyWith$Input$MetadataFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput {
  factory Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput({
    Input$PackageOrderDeliveryFilterInput? all,
    Input$PackageOrderDeliveryFilterInput? none,
    Input$PackageOrderDeliveryFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$PackageOrderDeliveryFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$PackageOrderDeliveryFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$PackageOrderDeliveryFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput._(
      result$data,
    );
  }

  Map<String, dynamic> _$data;

  Input$PackageOrderDeliveryFilterInput? get all =>
      (_$data['all'] as Input$PackageOrderDeliveryFilterInput?);

  Input$PackageOrderDeliveryFilterInput? get none =>
      (_$data['none'] as Input$PackageOrderDeliveryFilterInput?);

  Input$PackageOrderDeliveryFilterInput? get some =>
      (_$data['some'] as Input$PackageOrderDeliveryFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput<
    Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput
  >
  get copyWith =>
      CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput(
    Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput)
    then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput;

  TRes call({
    Input$PackageOrderDeliveryFilterInput? all,
    Input$PackageOrderDeliveryFilterInput? none,
    Input$PackageOrderDeliveryFilterInput? some,
    bool? any,
  });
  CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> get all;
  CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> get none;
  CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput<
          TRes
        > {
  _CopyWithImpl$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput _instance;

  final TRes Function(
    Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput,
  )
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput._({
      ..._instance._$data,
      if (all != _undefined)
        'all': (all as Input$PackageOrderDeliveryFilterInput?),
      if (none != _undefined)
        'none': (none as Input$PackageOrderDeliveryFilterInput?),
      if (some != _undefined)
        'some': (some as Input$PackageOrderDeliveryFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$PackageOrderDeliveryFilterInput.stub(_then(_instance))
        : CopyWith$Input$PackageOrderDeliveryFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$PackageOrderDeliveryFilterInput.stub(_then(_instance))
        : CopyWith$Input$PackageOrderDeliveryFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$PackageOrderDeliveryFilterInput.stub(_then(_instance))
        : CopyWith$Input$PackageOrderDeliveryFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput<
          TRes
        > {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$PackageOrderDeliveryFilterInput? all,
    Input$PackageOrderDeliveryFilterInput? none,
    Input$PackageOrderDeliveryFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> get all =>
      CopyWith$Input$PackageOrderDeliveryFilterInput.stub(_res);

  CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> get none =>
      CopyWith$Input$PackageOrderDeliveryFilterInput.stub(_res);

  CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> get some =>
      CopyWith$Input$PackageOrderDeliveryFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput {
  factory Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput({
    Input$PlaylistTracksInfoFilterInput? all,
    Input$PlaylistTracksInfoFilterInput? none,
    Input$PlaylistTracksInfoFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$PlaylistTracksInfoFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$PlaylistTracksInfoFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$PlaylistTracksInfoFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput._(
      result$data,
    );
  }

  Map<String, dynamic> _$data;

  Input$PlaylistTracksInfoFilterInput? get all =>
      (_$data['all'] as Input$PlaylistTracksInfoFilterInput?);

  Input$PlaylistTracksInfoFilterInput? get none =>
      (_$data['none'] as Input$PlaylistTracksInfoFilterInput?);

  Input$PlaylistTracksInfoFilterInput? get some =>
      (_$data['some'] as Input$PlaylistTracksInfoFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput<
    Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput
  >
  get copyWith =>
      CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput(
    Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput)
    then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput;

  TRes call({
    Input$PlaylistTracksInfoFilterInput? all,
    Input$PlaylistTracksInfoFilterInput? none,
    Input$PlaylistTracksInfoFilterInput? some,
    bool? any,
  });
  CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> get all;
  CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> get none;
  CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput<
          TRes
        > {
  _CopyWithImpl$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput)
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput._({
      ..._instance._$data,
      if (all != _undefined)
        'all': (all as Input$PlaylistTracksInfoFilterInput?),
      if (none != _undefined)
        'none': (none as Input$PlaylistTracksInfoFilterInput?),
      if (some != _undefined)
        'some': (some as Input$PlaylistTracksInfoFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$PlaylistTracksInfoFilterInput.stub(_then(_instance))
        : CopyWith$Input$PlaylistTracksInfoFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$PlaylistTracksInfoFilterInput.stub(_then(_instance))
        : CopyWith$Input$PlaylistTracksInfoFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$PlaylistTracksInfoFilterInput.stub(_then(_instance))
        : CopyWith$Input$PlaylistTracksInfoFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput<
          TRes
        > {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$PlaylistTracksInfoFilterInput? all,
    Input$PlaylistTracksInfoFilterInput? none,
    Input$PlaylistTracksInfoFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> get all =>
      CopyWith$Input$PlaylistTracksInfoFilterInput.stub(_res);

  CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> get none =>
      CopyWith$Input$PlaylistTracksInfoFilterInput.stub(_res);

  CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> get some =>
      CopyWith$Input$PlaylistTracksInfoFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfRecordingSplitFilterInput {
  factory Input$ListFilterInputTypeOfRecordingSplitFilterInput({
    Input$RecordingSplitFilterInput? all,
    Input$RecordingSplitFilterInput? none,
    Input$RecordingSplitFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfRecordingSplitFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfRecordingSplitFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfRecordingSplitFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$RecordingSplitFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$RecordingSplitFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$RecordingSplitFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfRecordingSplitFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$RecordingSplitFilterInput? get all =>
      (_$data['all'] as Input$RecordingSplitFilterInput?);

  Input$RecordingSplitFilterInput? get none =>
      (_$data['none'] as Input$RecordingSplitFilterInput?);

  Input$RecordingSplitFilterInput? get some =>
      (_$data['some'] as Input$RecordingSplitFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput<
    Input$ListFilterInputTypeOfRecordingSplitFilterInput
  >
  get copyWith => CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfRecordingSplitFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput(
    Input$ListFilterInputTypeOfRecordingSplitFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfRecordingSplitFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfRecordingSplitFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfRecordingSplitFilterInput;

  TRes call({
    Input$RecordingSplitFilterInput? all,
    Input$RecordingSplitFilterInput? none,
    Input$RecordingSplitFilterInput? some,
    bool? any,
  });
  CopyWith$Input$RecordingSplitFilterInput<TRes> get all;
  CopyWith$Input$RecordingSplitFilterInput<TRes> get none;
  CopyWith$Input$RecordingSplitFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfRecordingSplitFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfRecordingSplitFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfRecordingSplitFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfRecordingSplitFilterInput)
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfRecordingSplitFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$RecordingSplitFilterInput?),
      if (none != _undefined)
        'none': (none as Input$RecordingSplitFilterInput?),
      if (some != _undefined)
        'some': (some as Input$RecordingSplitFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$RecordingSplitFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$RecordingSplitFilterInput.stub(_then(_instance))
        : CopyWith$Input$RecordingSplitFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$RecordingSplitFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$RecordingSplitFilterInput.stub(_then(_instance))
        : CopyWith$Input$RecordingSplitFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$RecordingSplitFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$RecordingSplitFilterInput.stub(_then(_instance))
        : CopyWith$Input$RecordingSplitFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfRecordingSplitFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfRecordingSplitFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$RecordingSplitFilterInput? all,
    Input$RecordingSplitFilterInput? none,
    Input$RecordingSplitFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$RecordingSplitFilterInput<TRes> get all =>
      CopyWith$Input$RecordingSplitFilterInput.stub(_res);

  CopyWith$Input$RecordingSplitFilterInput<TRes> get none =>
      CopyWith$Input$RecordingSplitFilterInput.stub(_res);

  CopyWith$Input$RecordingSplitFilterInput<TRes> get some =>
      CopyWith$Input$RecordingSplitFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfRestrictionFilterInput {
  factory Input$ListFilterInputTypeOfRestrictionFilterInput({
    Input$RestrictionFilterInput? all,
    Input$RestrictionFilterInput? none,
    Input$RestrictionFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfRestrictionFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfRestrictionFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfRestrictionFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$RestrictionFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$RestrictionFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$RestrictionFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfRestrictionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$RestrictionFilterInput? get all =>
      (_$data['all'] as Input$RestrictionFilterInput?);

  Input$RestrictionFilterInput? get none =>
      (_$data['none'] as Input$RestrictionFilterInput?);

  Input$RestrictionFilterInput? get some =>
      (_$data['some'] as Input$RestrictionFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput<
    Input$ListFilterInputTypeOfRestrictionFilterInput
  >
  get copyWith => CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfRestrictionFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput(
    Input$ListFilterInputTypeOfRestrictionFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfRestrictionFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfRestrictionFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfRestrictionFilterInput;

  TRes call({
    Input$RestrictionFilterInput? all,
    Input$RestrictionFilterInput? none,
    Input$RestrictionFilterInput? some,
    bool? any,
  });
  CopyWith$Input$RestrictionFilterInput<TRes> get all;
  CopyWith$Input$RestrictionFilterInput<TRes> get none;
  CopyWith$Input$RestrictionFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfRestrictionFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfRestrictionFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfRestrictionFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfRestrictionFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfRestrictionFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$RestrictionFilterInput?),
      if (none != _undefined) 'none': (none as Input$RestrictionFilterInput?),
      if (some != _undefined) 'some': (some as Input$RestrictionFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$RestrictionFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$RestrictionFilterInput.stub(_then(_instance))
        : CopyWith$Input$RestrictionFilterInput(local$all, (e) => call(all: e));
  }

  CopyWith$Input$RestrictionFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$RestrictionFilterInput.stub(_then(_instance))
        : CopyWith$Input$RestrictionFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$RestrictionFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$RestrictionFilterInput.stub(_then(_instance))
        : CopyWith$Input$RestrictionFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfRestrictionFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfRestrictionFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$RestrictionFilterInput? all,
    Input$RestrictionFilterInput? none,
    Input$RestrictionFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$RestrictionFilterInput<TRes> get all =>
      CopyWith$Input$RestrictionFilterInput.stub(_res);

  CopyWith$Input$RestrictionFilterInput<TRes> get none =>
      CopyWith$Input$RestrictionFilterInput.stub(_res);

  CopyWith$Input$RestrictionFilterInput<TRes> get some =>
      CopyWith$Input$RestrictionFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfRoyaltySplitFilterInput {
  factory Input$ListFilterInputTypeOfRoyaltySplitFilterInput({
    Input$RoyaltySplitFilterInput? all,
    Input$RoyaltySplitFilterInput? none,
    Input$RoyaltySplitFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfRoyaltySplitFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfRoyaltySplitFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfRoyaltySplitFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$RoyaltySplitFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$RoyaltySplitFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$RoyaltySplitFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfRoyaltySplitFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$RoyaltySplitFilterInput? get all =>
      (_$data['all'] as Input$RoyaltySplitFilterInput?);

  Input$RoyaltySplitFilterInput? get none =>
      (_$data['none'] as Input$RoyaltySplitFilterInput?);

  Input$RoyaltySplitFilterInput? get some =>
      (_$data['some'] as Input$RoyaltySplitFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput<
    Input$ListFilterInputTypeOfRoyaltySplitFilterInput
  >
  get copyWith => CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfRoyaltySplitFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput(
    Input$ListFilterInputTypeOfRoyaltySplitFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfRoyaltySplitFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfRoyaltySplitFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfRoyaltySplitFilterInput;

  TRes call({
    Input$RoyaltySplitFilterInput? all,
    Input$RoyaltySplitFilterInput? none,
    Input$RoyaltySplitFilterInput? some,
    bool? any,
  });
  CopyWith$Input$RoyaltySplitFilterInput<TRes> get all;
  CopyWith$Input$RoyaltySplitFilterInput<TRes> get none;
  CopyWith$Input$RoyaltySplitFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfRoyaltySplitFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfRoyaltySplitFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfRoyaltySplitFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfRoyaltySplitFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfRoyaltySplitFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$RoyaltySplitFilterInput?),
      if (none != _undefined) 'none': (none as Input$RoyaltySplitFilterInput?),
      if (some != _undefined) 'some': (some as Input$RoyaltySplitFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$RoyaltySplitFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$RoyaltySplitFilterInput.stub(_then(_instance))
        : CopyWith$Input$RoyaltySplitFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$RoyaltySplitFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$RoyaltySplitFilterInput.stub(_then(_instance))
        : CopyWith$Input$RoyaltySplitFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$RoyaltySplitFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$RoyaltySplitFilterInput.stub(_then(_instance))
        : CopyWith$Input$RoyaltySplitFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfRoyaltySplitFilterInput<TRes>
    implements
        CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfRoyaltySplitFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$RoyaltySplitFilterInput? all,
    Input$RoyaltySplitFilterInput? none,
    Input$RoyaltySplitFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$RoyaltySplitFilterInput<TRes> get all =>
      CopyWith$Input$RoyaltySplitFilterInput.stub(_res);

  CopyWith$Input$RoyaltySplitFilterInput<TRes> get none =>
      CopyWith$Input$RoyaltySplitFilterInput.stub(_res);

  CopyWith$Input$RoyaltySplitFilterInput<TRes> get some =>
      CopyWith$Input$RoyaltySplitFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput {
  factory Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput({
    Input$SubscriptionPlanPriceFilterInput? all,
    Input$SubscriptionPlanPriceFilterInput? none,
    Input$SubscriptionPlanPriceFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$SubscriptionPlanPriceFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$SubscriptionPlanPriceFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$SubscriptionPlanPriceFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput._(
      result$data,
    );
  }

  Map<String, dynamic> _$data;

  Input$SubscriptionPlanPriceFilterInput? get all =>
      (_$data['all'] as Input$SubscriptionPlanPriceFilterInput?);

  Input$SubscriptionPlanPriceFilterInput? get none =>
      (_$data['none'] as Input$SubscriptionPlanPriceFilterInput?);

  Input$SubscriptionPlanPriceFilterInput? get some =>
      (_$data['some'] as Input$SubscriptionPlanPriceFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<
    Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput
  >
  get copyWith =>
      CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<
  TRes
> {
  factory CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput(
    Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput)
    then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput;

  TRes call({
    Input$SubscriptionPlanPriceFilterInput? all,
    Input$SubscriptionPlanPriceFilterInput? none,
    Input$SubscriptionPlanPriceFilterInput? some,
    bool? any,
  });
  CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> get all;
  CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> get none;
  CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<
          TRes
        > {
  _CopyWithImpl$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput _instance;

  final TRes Function(
    Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput,
  )
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput._({
      ..._instance._$data,
      if (all != _undefined)
        'all': (all as Input$SubscriptionPlanPriceFilterInput?),
      if (none != _undefined)
        'none': (none as Input$SubscriptionPlanPriceFilterInput?),
      if (some != _undefined)
        'some': (some as Input$SubscriptionPlanPriceFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$SubscriptionPlanPriceFilterInput.stub(_then(_instance))
        : CopyWith$Input$SubscriptionPlanPriceFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$SubscriptionPlanPriceFilterInput.stub(_then(_instance))
        : CopyWith$Input$SubscriptionPlanPriceFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$SubscriptionPlanPriceFilterInput.stub(_then(_instance))
        : CopyWith$Input$SubscriptionPlanPriceFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<
  TRes
>
    implements
        CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<
          TRes
        > {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Input$SubscriptionPlanPriceFilterInput? all,
    Input$SubscriptionPlanPriceFilterInput? none,
    Input$SubscriptionPlanPriceFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> get all =>
      CopyWith$Input$SubscriptionPlanPriceFilterInput.stub(_res);

  CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> get none =>
      CopyWith$Input$SubscriptionPlanPriceFilterInput.stub(_res);

  CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> get some =>
      CopyWith$Input$SubscriptionPlanPriceFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfSyncedLineFilterInput {
  factory Input$ListFilterInputTypeOfSyncedLineFilterInput({
    Input$SyncedLineFilterInput? all,
    Input$SyncedLineFilterInput? none,
    Input$SyncedLineFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfSyncedLineFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfSyncedLineFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfSyncedLineFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$SyncedLineFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$SyncedLineFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$SyncedLineFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfSyncedLineFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$SyncedLineFilterInput? get all =>
      (_$data['all'] as Input$SyncedLineFilterInput?);

  Input$SyncedLineFilterInput? get none =>
      (_$data['none'] as Input$SyncedLineFilterInput?);

  Input$SyncedLineFilterInput? get some =>
      (_$data['some'] as Input$SyncedLineFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput<
    Input$ListFilterInputTypeOfSyncedLineFilterInput
  >
  get copyWith =>
      CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfSyncedLineFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput<TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput(
    Input$ListFilterInputTypeOfSyncedLineFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfSyncedLineFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfSyncedLineFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfSyncedLineFilterInput;

  TRes call({
    Input$SyncedLineFilterInput? all,
    Input$SyncedLineFilterInput? none,
    Input$SyncedLineFilterInput? some,
    bool? any,
  });
  CopyWith$Input$SyncedLineFilterInput<TRes> get all;
  CopyWith$Input$SyncedLineFilterInput<TRes> get none;
  CopyWith$Input$SyncedLineFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfSyncedLineFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfSyncedLineFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfSyncedLineFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfSyncedLineFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfSyncedLineFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$SyncedLineFilterInput?),
      if (none != _undefined) 'none': (none as Input$SyncedLineFilterInput?),
      if (some != _undefined) 'some': (some as Input$SyncedLineFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$SyncedLineFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$SyncedLineFilterInput.stub(_then(_instance))
        : CopyWith$Input$SyncedLineFilterInput(local$all, (e) => call(all: e));
  }

  CopyWith$Input$SyncedLineFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$SyncedLineFilterInput.stub(_then(_instance))
        : CopyWith$Input$SyncedLineFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$SyncedLineFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$SyncedLineFilterInput.stub(_then(_instance))
        : CopyWith$Input$SyncedLineFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfSyncedLineFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfSyncedLineFilterInput(this._res);

  TRes _res;

  call({
    Input$SyncedLineFilterInput? all,
    Input$SyncedLineFilterInput? none,
    Input$SyncedLineFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$SyncedLineFilterInput<TRes> get all =>
      CopyWith$Input$SyncedLineFilterInput.stub(_res);

  CopyWith$Input$SyncedLineFilterInput<TRes> get none =>
      CopyWith$Input$SyncedLineFilterInput.stub(_res);

  CopyWith$Input$SyncedLineFilterInput<TRes> get some =>
      CopyWith$Input$SyncedLineFilterInput.stub(_res);
}

class Input$ListFilterInputTypeOfWorkSplitFilterInput {
  factory Input$ListFilterInputTypeOfWorkSplitFilterInput({
    Input$WorkSplitFilterInput? all,
    Input$WorkSplitFilterInput? none,
    Input$WorkSplitFilterInput? some,
    bool? any,
  }) => Input$ListFilterInputTypeOfWorkSplitFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFilterInputTypeOfWorkSplitFilterInput._(this._$data);

  factory Input$ListFilterInputTypeOfWorkSplitFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$WorkSplitFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$WorkSplitFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$WorkSplitFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFilterInputTypeOfWorkSplitFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$WorkSplitFilterInput? get all =>
      (_$data['all'] as Input$WorkSplitFilterInput?);

  Input$WorkSplitFilterInput? get none =>
      (_$data['none'] as Input$WorkSplitFilterInput?);

  Input$WorkSplitFilterInput? get some =>
      (_$data['some'] as Input$WorkSplitFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput<
    Input$ListFilterInputTypeOfWorkSplitFilterInput
  >
  get copyWith =>
      CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFilterInputTypeOfWorkSplitFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput<TRes> {
  factory CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput(
    Input$ListFilterInputTypeOfWorkSplitFilterInput instance,
    TRes Function(Input$ListFilterInputTypeOfWorkSplitFilterInput) then,
  ) = _CopyWithImpl$Input$ListFilterInputTypeOfWorkSplitFilterInput;

  factory CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$ListFilterInputTypeOfWorkSplitFilterInput;

  TRes call({
    Input$WorkSplitFilterInput? all,
    Input$WorkSplitFilterInput? none,
    Input$WorkSplitFilterInput? some,
    bool? any,
  });
  CopyWith$Input$WorkSplitFilterInput<TRes> get all;
  CopyWith$Input$WorkSplitFilterInput<TRes> get none;
  CopyWith$Input$WorkSplitFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFilterInputTypeOfWorkSplitFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput<TRes> {
  _CopyWithImpl$Input$ListFilterInputTypeOfWorkSplitFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListFilterInputTypeOfWorkSplitFilterInput _instance;

  final TRes Function(Input$ListFilterInputTypeOfWorkSplitFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFilterInputTypeOfWorkSplitFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$WorkSplitFilterInput?),
      if (none != _undefined) 'none': (none as Input$WorkSplitFilterInput?),
      if (some != _undefined) 'some': (some as Input$WorkSplitFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$WorkSplitFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$WorkSplitFilterInput.stub(_then(_instance))
        : CopyWith$Input$WorkSplitFilterInput(local$all, (e) => call(all: e));
  }

  CopyWith$Input$WorkSplitFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$WorkSplitFilterInput.stub(_then(_instance))
        : CopyWith$Input$WorkSplitFilterInput(local$none, (e) => call(none: e));
  }

  CopyWith$Input$WorkSplitFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$WorkSplitFilterInput.stub(_then(_instance))
        : CopyWith$Input$WorkSplitFilterInput(local$some, (e) => call(some: e));
  }
}

class _CopyWithStubImpl$Input$ListFilterInputTypeOfWorkSplitFilterInput<TRes>
    implements CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFilterInputTypeOfWorkSplitFilterInput(this._res);

  TRes _res;

  call({
    Input$WorkSplitFilterInput? all,
    Input$WorkSplitFilterInput? none,
    Input$WorkSplitFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$WorkSplitFilterInput<TRes> get all =>
      CopyWith$Input$WorkSplitFilterInput.stub(_res);

  CopyWith$Input$WorkSplitFilterInput<TRes> get none =>
      CopyWith$Input$WorkSplitFilterInput.stub(_res);

  CopyWith$Input$WorkSplitFilterInput<TRes> get some =>
      CopyWith$Input$WorkSplitFilterInput.stub(_res);
}

class Input$ListFloatOperationFilterInput {
  factory Input$ListFloatOperationFilterInput({
    Input$FloatOperationFilterInput? all,
    Input$FloatOperationFilterInput? none,
    Input$FloatOperationFilterInput? some,
    bool? any,
  }) => Input$ListFloatOperationFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListFloatOperationFilterInput._(this._$data);

  factory Input$ListFloatOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListFloatOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$FloatOperationFilterInput? get all =>
      (_$data['all'] as Input$FloatOperationFilterInput?);

  Input$FloatOperationFilterInput? get none =>
      (_$data['none'] as Input$FloatOperationFilterInput?);

  Input$FloatOperationFilterInput? get some =>
      (_$data['some'] as Input$FloatOperationFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListFloatOperationFilterInput<
    Input$ListFloatOperationFilterInput
  >
  get copyWith => CopyWith$Input$ListFloatOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListFloatOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListFloatOperationFilterInput<TRes> {
  factory CopyWith$Input$ListFloatOperationFilterInput(
    Input$ListFloatOperationFilterInput instance,
    TRes Function(Input$ListFloatOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ListFloatOperationFilterInput;

  factory CopyWith$Input$ListFloatOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ListFloatOperationFilterInput;

  TRes call({
    Input$FloatOperationFilterInput? all,
    Input$FloatOperationFilterInput? none,
    Input$FloatOperationFilterInput? some,
    bool? any,
  });
  CopyWith$Input$FloatOperationFilterInput<TRes> get all;
  CopyWith$Input$FloatOperationFilterInput<TRes> get none;
  CopyWith$Input$FloatOperationFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListFloatOperationFilterInput<TRes>
    implements CopyWith$Input$ListFloatOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ListFloatOperationFilterInput(this._instance, this._then);

  final Input$ListFloatOperationFilterInput _instance;

  final TRes Function(Input$ListFloatOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListFloatOperationFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$FloatOperationFilterInput?),
      if (none != _undefined)
        'none': (none as Input$FloatOperationFilterInput?),
      if (some != _undefined)
        'some': (some as Input$FloatOperationFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$FloatOperationFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$FloatOperationFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$FloatOperationFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListFloatOperationFilterInput<TRes>
    implements CopyWith$Input$ListFloatOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListFloatOperationFilterInput(this._res);

  TRes _res;

  call({
    Input$FloatOperationFilterInput? all,
    Input$FloatOperationFilterInput? none,
    Input$FloatOperationFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$FloatOperationFilterInput<TRes> get all =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);

  CopyWith$Input$FloatOperationFilterInput<TRes> get none =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);

  CopyWith$Input$FloatOperationFilterInput<TRes> get some =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);
}

class Input$ListListByteOperationFilterInput {
  factory Input$ListListByteOperationFilterInput({
    Input$ListByteOperationFilterInput? all,
    Input$ListByteOperationFilterInput? none,
    Input$ListByteOperationFilterInput? some,
    bool? any,
  }) => Input$ListListByteOperationFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListListByteOperationFilterInput._(this._$data);

  factory Input$ListListByteOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$ListByteOperationFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$ListByteOperationFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$ListByteOperationFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListListByteOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ListByteOperationFilterInput? get all =>
      (_$data['all'] as Input$ListByteOperationFilterInput?);

  Input$ListByteOperationFilterInput? get none =>
      (_$data['none'] as Input$ListByteOperationFilterInput?);

  Input$ListByteOperationFilterInput? get some =>
      (_$data['some'] as Input$ListByteOperationFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListListByteOperationFilterInput<
    Input$ListListByteOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$ListListByteOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListListByteOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListListByteOperationFilterInput<TRes> {
  factory CopyWith$Input$ListListByteOperationFilterInput(
    Input$ListListByteOperationFilterInput instance,
    TRes Function(Input$ListListByteOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ListListByteOperationFilterInput;

  factory CopyWith$Input$ListListByteOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ListListByteOperationFilterInput;

  TRes call({
    Input$ListByteOperationFilterInput? all,
    Input$ListByteOperationFilterInput? none,
    Input$ListByteOperationFilterInput? some,
    bool? any,
  });
  CopyWith$Input$ListByteOperationFilterInput<TRes> get all;
  CopyWith$Input$ListByteOperationFilterInput<TRes> get none;
  CopyWith$Input$ListByteOperationFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListListByteOperationFilterInput<TRes>
    implements CopyWith$Input$ListListByteOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ListListByteOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListListByteOperationFilterInput _instance;

  final TRes Function(Input$ListListByteOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListListByteOperationFilterInput._({
      ..._instance._$data,
      if (all != _undefined)
        'all': (all as Input$ListByteOperationFilterInput?),
      if (none != _undefined)
        'none': (none as Input$ListByteOperationFilterInput?),
      if (some != _undefined)
        'some': (some as Input$ListByteOperationFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$ListByteOperationFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$ListByteOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListByteOperationFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$ListByteOperationFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$ListByteOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListByteOperationFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$ListByteOperationFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$ListByteOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListByteOperationFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListListByteOperationFilterInput<TRes>
    implements CopyWith$Input$ListListByteOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListListByteOperationFilterInput(this._res);

  TRes _res;

  call({
    Input$ListByteOperationFilterInput? all,
    Input$ListByteOperationFilterInput? none,
    Input$ListByteOperationFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$ListByteOperationFilterInput<TRes> get all =>
      CopyWith$Input$ListByteOperationFilterInput.stub(_res);

  CopyWith$Input$ListByteOperationFilterInput<TRes> get none =>
      CopyWith$Input$ListByteOperationFilterInput.stub(_res);

  CopyWith$Input$ListByteOperationFilterInput<TRes> get some =>
      CopyWith$Input$ListByteOperationFilterInput.stub(_res);
}

class Input$ListOfUInt32FilterInput {
  factory Input$ListOfUInt32FilterInput({
    List<Input$ListOfUInt32FilterInput>? and,
    List<Input$ListOfUInt32FilterInput>? or,
    Input$IntOperationFilterInput? capacity,
    Input$IntOperationFilterInput? count,
  }) => Input$ListOfUInt32FilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (capacity != null) r'capacity': capacity,
    if (count != null) r'count': count,
  });

  Input$ListOfUInt32FilterInput._(this._$data);

  factory Input$ListOfUInt32FilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$ListOfUInt32FilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$ListOfUInt32FilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('capacity')) {
      final l$capacity = data['capacity'];
      result$data['capacity'] = l$capacity == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$capacity as Map<String, dynamic>),
            );
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] = l$count == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$count as Map<String, dynamic>),
            );
    }
    return Input$ListOfUInt32FilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ListOfUInt32FilterInput>? get and =>
      (_$data['and'] as List<Input$ListOfUInt32FilterInput>?);

  List<Input$ListOfUInt32FilterInput>? get or =>
      (_$data['or'] as List<Input$ListOfUInt32FilterInput>?);

  Input$IntOperationFilterInput? get capacity =>
      (_$data['capacity'] as Input$IntOperationFilterInput?);

  Input$IntOperationFilterInput? get count =>
      (_$data['count'] as Input$IntOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('capacity')) {
      final l$capacity = capacity;
      result$data['capacity'] = l$capacity?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] = l$count?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListOfUInt32FilterInput<Input$ListOfUInt32FilterInput>
  get copyWith => CopyWith$Input$ListOfUInt32FilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListOfUInt32FilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$capacity = capacity;
    final lOther$capacity = other.capacity;
    if (_$data.containsKey('capacity') !=
        other._$data.containsKey('capacity')) {
      return false;
    }
    if (l$capacity != lOther$capacity) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$capacity = capacity;
    final l$count = count;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('capacity') ? l$capacity : const {},
      _$data.containsKey('count') ? l$count : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListOfUInt32FilterInput<TRes> {
  factory CopyWith$Input$ListOfUInt32FilterInput(
    Input$ListOfUInt32FilterInput instance,
    TRes Function(Input$ListOfUInt32FilterInput) then,
  ) = _CopyWithImpl$Input$ListOfUInt32FilterInput;

  factory CopyWith$Input$ListOfUInt32FilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ListOfUInt32FilterInput;

  TRes call({
    List<Input$ListOfUInt32FilterInput>? and,
    List<Input$ListOfUInt32FilterInput>? or,
    Input$IntOperationFilterInput? capacity,
    Input$IntOperationFilterInput? count,
  });
  TRes and(
    Iterable<Input$ListOfUInt32FilterInput>? Function(
      Iterable<
        CopyWith$Input$ListOfUInt32FilterInput<Input$ListOfUInt32FilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$ListOfUInt32FilterInput>? Function(
      Iterable<
        CopyWith$Input$ListOfUInt32FilterInput<Input$ListOfUInt32FilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$IntOperationFilterInput<TRes> get capacity;
  CopyWith$Input$IntOperationFilterInput<TRes> get count;
}

class _CopyWithImpl$Input$ListOfUInt32FilterInput<TRes>
    implements CopyWith$Input$ListOfUInt32FilterInput<TRes> {
  _CopyWithImpl$Input$ListOfUInt32FilterInput(this._instance, this._then);

  final Input$ListOfUInt32FilterInput _instance;

  final TRes Function(Input$ListOfUInt32FilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? capacity = _undefined,
    Object? count = _undefined,
  }) => _then(
    Input$ListOfUInt32FilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$ListOfUInt32FilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$ListOfUInt32FilterInput>?),
      if (capacity != _undefined)
        'capacity': (capacity as Input$IntOperationFilterInput?),
      if (count != _undefined)
        'count': (count as Input$IntOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$ListOfUInt32FilterInput>? Function(
      Iterable<
        CopyWith$Input$ListOfUInt32FilterInput<Input$ListOfUInt32FilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$ListOfUInt32FilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$ListOfUInt32FilterInput>? Function(
      Iterable<
        CopyWith$Input$ListOfUInt32FilterInput<Input$ListOfUInt32FilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$ListOfUInt32FilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$IntOperationFilterInput<TRes> get capacity {
    final local$capacity = _instance.capacity;
    return local$capacity == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$capacity,
            (e) => call(capacity: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get count {
    final local$count = _instance.count;
    return local$count == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$count,
            (e) => call(count: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListOfUInt32FilterInput<TRes>
    implements CopyWith$Input$ListOfUInt32FilterInput<TRes> {
  _CopyWithStubImpl$Input$ListOfUInt32FilterInput(this._res);

  TRes _res;

  call({
    List<Input$ListOfUInt32FilterInput>? and,
    List<Input$ListOfUInt32FilterInput>? or,
    Input$IntOperationFilterInput? capacity,
    Input$IntOperationFilterInput? count,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$IntOperationFilterInput<TRes> get capacity =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get count =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);
}

class Input$ListStringOperationFilterInput {
  factory Input$ListStringOperationFilterInput({
    Input$StringOperationFilterInput? all,
    Input$StringOperationFilterInput? none,
    Input$StringOperationFilterInput? some,
    bool? any,
  }) => Input$ListStringOperationFilterInput._({
    if (all != null) r'all': all,
    if (none != null) r'none': none,
    if (some != null) r'some': some,
    if (any != null) r'any': any,
  });

  Input$ListStringOperationFilterInput._(this._$data);

  factory Input$ListStringOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('all')) {
      final l$all = data['all'];
      result$data['all'] = l$all == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$all as Map<String, dynamic>),
            );
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$none as Map<String, dynamic>),
            );
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$some as Map<String, dynamic>),
            );
    }
    if (data.containsKey('any')) {
      final l$any = data['any'];
      result$data['any'] = (l$any as bool?);
    }
    return Input$ListStringOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringOperationFilterInput? get all =>
      (_$data['all'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get none =>
      (_$data['none'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get some =>
      (_$data['some'] as Input$StringOperationFilterInput?);

  bool? get any => (_$data['any'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('all')) {
      final l$all = all;
      result$data['all'] = l$all?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('any')) {
      final l$any = any;
      result$data['any'] = l$any;
    }
    return result$data;
  }

  CopyWith$Input$ListStringOperationFilterInput<
    Input$ListStringOperationFilterInput
  >
  get copyWith => CopyWith$Input$ListStringOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListStringOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$all = all;
    final lOther$all = other.all;
    if (_$data.containsKey('all') != other._$data.containsKey('all')) {
      return false;
    }
    if (l$all != lOther$all) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$any = any;
    final lOther$any = other.any;
    if (_$data.containsKey('any') != other._$data.containsKey('any')) {
      return false;
    }
    if (l$any != lOther$any) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$all = all;
    final l$none = none;
    final l$some = some;
    final l$any = any;
    return Object.hashAll([
      _$data.containsKey('all') ? l$all : const {},
      _$data.containsKey('none') ? l$none : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('any') ? l$any : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListStringOperationFilterInput<TRes> {
  factory CopyWith$Input$ListStringOperationFilterInput(
    Input$ListStringOperationFilterInput instance,
    TRes Function(Input$ListStringOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ListStringOperationFilterInput;

  factory CopyWith$Input$ListStringOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ListStringOperationFilterInput;

  TRes call({
    Input$StringOperationFilterInput? all,
    Input$StringOperationFilterInput? none,
    Input$StringOperationFilterInput? some,
    bool? any,
  });
  CopyWith$Input$StringOperationFilterInput<TRes> get all;
  CopyWith$Input$StringOperationFilterInput<TRes> get none;
  CopyWith$Input$StringOperationFilterInput<TRes> get some;
}

class _CopyWithImpl$Input$ListStringOperationFilterInput<TRes>
    implements CopyWith$Input$ListStringOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ListStringOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ListStringOperationFilterInput _instance;

  final TRes Function(Input$ListStringOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? all = _undefined,
    Object? none = _undefined,
    Object? some = _undefined,
    Object? any = _undefined,
  }) => _then(
    Input$ListStringOperationFilterInput._({
      ..._instance._$data,
      if (all != _undefined) 'all': (all as Input$StringOperationFilterInput?),
      if (none != _undefined)
        'none': (none as Input$StringOperationFilterInput?),
      if (some != _undefined)
        'some': (some as Input$StringOperationFilterInput?),
      if (any != _undefined) 'any': (any as bool?),
    }),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get all {
    final local$all = _instance.all;
    return local$all == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$all,
            (e) => call(all: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$none,
            (e) => call(none: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$some,
            (e) => call(some: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListStringOperationFilterInput<TRes>
    implements CopyWith$Input$ListStringOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListStringOperationFilterInput(this._res);

  TRes _res;

  call({
    Input$StringOperationFilterInput? all,
    Input$StringOperationFilterInput? none,
    Input$StringOperationFilterInput? some,
    bool? any,
  }) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get all =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get none =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get some =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
}

class Input$ListenerFilterInput {
  factory Input$ListenerFilterInput({
    List<Input$ListenerFilterInput>? and,
    List<Input$ListenerFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? displayName,
    Input$StringOperationFilterInput? displayNameUnsigned,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? avatarImage,
    Input$StringOperationFilterInput? bannerImage,
    Input$BooleanOperationFilterInput? isVerified,
    Input$DateTimeOperationFilterInput? verifiedAt,
    Input$LongOperationFilterInput? followerCount,
    Input$LongOperationFilterInput? followingCount,
    Input$ListStringOperationFilterInput? lastFollowers,
    Input$ListStringOperationFilterInput? lastFollowings,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$ListenerFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (displayName != null) r'displayName': displayName,
    if (displayNameUnsigned != null)
      r'displayNameUnsigned': displayNameUnsigned,
    if (email != null) r'email': email,
    if (avatarImage != null) r'avatarImage': avatarImage,
    if (bannerImage != null) r'bannerImage': bannerImage,
    if (isVerified != null) r'isVerified': isVerified,
    if (verifiedAt != null) r'verifiedAt': verifiedAt,
    if (followerCount != null) r'followerCount': followerCount,
    if (followingCount != null) r'followingCount': followingCount,
    if (lastFollowers != null) r'lastFollowers': lastFollowers,
    if (lastFollowings != null) r'lastFollowings': lastFollowings,
    if (isVisible != null) r'isVisible': isVisible,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ListenerFilterInput._(this._$data);

  factory Input$ListenerFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$ListenerFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$ListenerFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = l$displayName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$displayName as Map<String, dynamic>),
            );
    }
    if (data.containsKey('displayNameUnsigned')) {
      final l$displayNameUnsigned = data['displayNameUnsigned'];
      result$data['displayNameUnsigned'] = l$displayNameUnsigned == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$displayNameUnsigned as Map<String, dynamic>),
            );
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$email as Map<String, dynamic>),
            );
    }
    if (data.containsKey('avatarImage')) {
      final l$avatarImage = data['avatarImage'];
      result$data['avatarImage'] = l$avatarImage == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$avatarImage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('bannerImage')) {
      final l$bannerImage = data['bannerImage'];
      result$data['bannerImage'] = l$bannerImage == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$bannerImage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isVerified')) {
      final l$isVerified = data['isVerified'];
      result$data['isVerified'] = l$isVerified == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isVerified as Map<String, dynamic>),
            );
    }
    if (data.containsKey('verifiedAt')) {
      final l$verifiedAt = data['verifiedAt'];
      result$data['verifiedAt'] = l$verifiedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$verifiedAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('followerCount')) {
      final l$followerCount = data['followerCount'];
      result$data['followerCount'] = l$followerCount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$followerCount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('followingCount')) {
      final l$followingCount = data['followingCount'];
      result$data['followingCount'] = l$followingCount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$followingCount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('lastFollowers')) {
      final l$lastFollowers = data['lastFollowers'];
      result$data['lastFollowers'] = l$lastFollowers == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$lastFollowers as Map<String, dynamic>),
            );
    }
    if (data.containsKey('lastFollowings')) {
      final l$lastFollowings = data['lastFollowings'];
      result$data['lastFollowings'] = l$lastFollowings == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$lastFollowings as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isVisible as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$ListenerFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ListenerFilterInput>? get and =>
      (_$data['and'] as List<Input$ListenerFilterInput>?);

  List<Input$ListenerFilterInput>? get or =>
      (_$data['or'] as List<Input$ListenerFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get userId =>
      (_$data['userId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get displayName =>
      (_$data['displayName'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get displayNameUnsigned =>
      (_$data['displayNameUnsigned'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get email =>
      (_$data['email'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get avatarImage =>
      (_$data['avatarImage'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get bannerImage =>
      (_$data['bannerImage'] as Input$StringOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isVerified =>
      (_$data['isVerified'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get verifiedAt =>
      (_$data['verifiedAt'] as Input$DateTimeOperationFilterInput?);

  Input$LongOperationFilterInput? get followerCount =>
      (_$data['followerCount'] as Input$LongOperationFilterInput?);

  Input$LongOperationFilterInput? get followingCount =>
      (_$data['followingCount'] as Input$LongOperationFilterInput?);

  Input$ListStringOperationFilterInput? get lastFollowers =>
      (_$data['lastFollowers'] as Input$ListStringOperationFilterInput?);

  Input$ListStringOperationFilterInput? get lastFollowings =>
      (_$data['lastFollowings'] as Input$ListStringOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isVisible =>
      (_$data['isVisible'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] = l$displayName?.toJson();
    }
    if (_$data.containsKey('displayNameUnsigned')) {
      final l$displayNameUnsigned = displayNameUnsigned;
      result$data['displayNameUnsigned'] = l$displayNameUnsigned?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('avatarImage')) {
      final l$avatarImage = avatarImage;
      result$data['avatarImage'] = l$avatarImage?.toJson();
    }
    if (_$data.containsKey('bannerImage')) {
      final l$bannerImage = bannerImage;
      result$data['bannerImage'] = l$bannerImage?.toJson();
    }
    if (_$data.containsKey('isVerified')) {
      final l$isVerified = isVerified;
      result$data['isVerified'] = l$isVerified?.toJson();
    }
    if (_$data.containsKey('verifiedAt')) {
      final l$verifiedAt = verifiedAt;
      result$data['verifiedAt'] = l$verifiedAt?.toJson();
    }
    if (_$data.containsKey('followerCount')) {
      final l$followerCount = followerCount;
      result$data['followerCount'] = l$followerCount?.toJson();
    }
    if (_$data.containsKey('followingCount')) {
      final l$followingCount = followingCount;
      result$data['followingCount'] = l$followingCount?.toJson();
    }
    if (_$data.containsKey('lastFollowers')) {
      final l$lastFollowers = lastFollowers;
      result$data['lastFollowers'] = l$lastFollowers?.toJson();
    }
    if (_$data.containsKey('lastFollowings')) {
      final l$lastFollowings = lastFollowings;
      result$data['lastFollowings'] = l$lastFollowings?.toJson();
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ListenerFilterInput<Input$ListenerFilterInput> get copyWith =>
      CopyWith$Input$ListenerFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListenerFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$displayNameUnsigned = displayNameUnsigned;
    final lOther$displayNameUnsigned = other.displayNameUnsigned;
    if (_$data.containsKey('displayNameUnsigned') !=
        other._$data.containsKey('displayNameUnsigned')) {
      return false;
    }
    if (l$displayNameUnsigned != lOther$displayNameUnsigned) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$avatarImage = avatarImage;
    final lOther$avatarImage = other.avatarImage;
    if (_$data.containsKey('avatarImage') !=
        other._$data.containsKey('avatarImage')) {
      return false;
    }
    if (l$avatarImage != lOther$avatarImage) {
      return false;
    }
    final l$bannerImage = bannerImage;
    final lOther$bannerImage = other.bannerImage;
    if (_$data.containsKey('bannerImage') !=
        other._$data.containsKey('bannerImage')) {
      return false;
    }
    if (l$bannerImage != lOther$bannerImage) {
      return false;
    }
    final l$isVerified = isVerified;
    final lOther$isVerified = other.isVerified;
    if (_$data.containsKey('isVerified') !=
        other._$data.containsKey('isVerified')) {
      return false;
    }
    if (l$isVerified != lOther$isVerified) {
      return false;
    }
    final l$verifiedAt = verifiedAt;
    final lOther$verifiedAt = other.verifiedAt;
    if (_$data.containsKey('verifiedAt') !=
        other._$data.containsKey('verifiedAt')) {
      return false;
    }
    if (l$verifiedAt != lOther$verifiedAt) {
      return false;
    }
    final l$followerCount = followerCount;
    final lOther$followerCount = other.followerCount;
    if (_$data.containsKey('followerCount') !=
        other._$data.containsKey('followerCount')) {
      return false;
    }
    if (l$followerCount != lOther$followerCount) {
      return false;
    }
    final l$followingCount = followingCount;
    final lOther$followingCount = other.followingCount;
    if (_$data.containsKey('followingCount') !=
        other._$data.containsKey('followingCount')) {
      return false;
    }
    if (l$followingCount != lOther$followingCount) {
      return false;
    }
    final l$lastFollowers = lastFollowers;
    final lOther$lastFollowers = other.lastFollowers;
    if (_$data.containsKey('lastFollowers') !=
        other._$data.containsKey('lastFollowers')) {
      return false;
    }
    if (l$lastFollowers != lOther$lastFollowers) {
      return false;
    }
    final l$lastFollowings = lastFollowings;
    final lOther$lastFollowings = other.lastFollowings;
    if (_$data.containsKey('lastFollowings') !=
        other._$data.containsKey('lastFollowings')) {
      return false;
    }
    if (l$lastFollowings != lOther$lastFollowings) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$userId = userId;
    final l$displayName = displayName;
    final l$displayNameUnsigned = displayNameUnsigned;
    final l$email = email;
    final l$avatarImage = avatarImage;
    final l$bannerImage = bannerImage;
    final l$isVerified = isVerified;
    final l$verifiedAt = verifiedAt;
    final l$followerCount = followerCount;
    final l$followingCount = followingCount;
    final l$lastFollowers = lastFollowers;
    final l$lastFollowings = lastFollowings;
    final l$isVisible = isVisible;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('displayNameUnsigned')
          ? l$displayNameUnsigned
          : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('avatarImage') ? l$avatarImage : const {},
      _$data.containsKey('bannerImage') ? l$bannerImage : const {},
      _$data.containsKey('isVerified') ? l$isVerified : const {},
      _$data.containsKey('verifiedAt') ? l$verifiedAt : const {},
      _$data.containsKey('followerCount') ? l$followerCount : const {},
      _$data.containsKey('followingCount') ? l$followingCount : const {},
      _$data.containsKey('lastFollowers') ? l$lastFollowers : const {},
      _$data.containsKey('lastFollowings') ? l$lastFollowings : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListenerFilterInput<TRes> {
  factory CopyWith$Input$ListenerFilterInput(
    Input$ListenerFilterInput instance,
    TRes Function(Input$ListenerFilterInput) then,
  ) = _CopyWithImpl$Input$ListenerFilterInput;

  factory CopyWith$Input$ListenerFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ListenerFilterInput;

  TRes call({
    List<Input$ListenerFilterInput>? and,
    List<Input$ListenerFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? displayName,
    Input$StringOperationFilterInput? displayNameUnsigned,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? avatarImage,
    Input$StringOperationFilterInput? bannerImage,
    Input$BooleanOperationFilterInput? isVerified,
    Input$DateTimeOperationFilterInput? verifiedAt,
    Input$LongOperationFilterInput? followerCount,
    Input$LongOperationFilterInput? followingCount,
    Input$ListStringOperationFilterInput? lastFollowers,
    Input$ListStringOperationFilterInput? lastFollowings,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$ListenerFilterInput>? Function(
      Iterable<CopyWith$Input$ListenerFilterInput<Input$ListenerFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$ListenerFilterInput>? Function(
      Iterable<CopyWith$Input$ListenerFilterInput<Input$ListenerFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get userId;
  CopyWith$Input$StringOperationFilterInput<TRes> get displayName;
  CopyWith$Input$StringOperationFilterInput<TRes> get displayNameUnsigned;
  CopyWith$Input$StringOperationFilterInput<TRes> get email;
  CopyWith$Input$StringOperationFilterInput<TRes> get avatarImage;
  CopyWith$Input$StringOperationFilterInput<TRes> get bannerImage;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVerified;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get verifiedAt;
  CopyWith$Input$LongOperationFilterInput<TRes> get followerCount;
  CopyWith$Input$LongOperationFilterInput<TRes> get followingCount;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get lastFollowers;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get lastFollowings;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$ListenerFilterInput<TRes>
    implements CopyWith$Input$ListenerFilterInput<TRes> {
  _CopyWithImpl$Input$ListenerFilterInput(this._instance, this._then);

  final Input$ListenerFilterInput _instance;

  final TRes Function(Input$ListenerFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? displayName = _undefined,
    Object? displayNameUnsigned = _undefined,
    Object? email = _undefined,
    Object? avatarImage = _undefined,
    Object? bannerImage = _undefined,
    Object? isVerified = _undefined,
    Object? verifiedAt = _undefined,
    Object? followerCount = _undefined,
    Object? followingCount = _undefined,
    Object? lastFollowers = _undefined,
    Object? lastFollowings = _undefined,
    Object? isVisible = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ListenerFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$ListenerFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$ListenerFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (userId != _undefined)
        'userId': (userId as Input$StringOperationFilterInput?),
      if (displayName != _undefined)
        'displayName': (displayName as Input$StringOperationFilterInput?),
      if (displayNameUnsigned != _undefined)
        'displayNameUnsigned':
            (displayNameUnsigned as Input$StringOperationFilterInput?),
      if (email != _undefined)
        'email': (email as Input$StringOperationFilterInput?),
      if (avatarImage != _undefined)
        'avatarImage': (avatarImage as Input$StringOperationFilterInput?),
      if (bannerImage != _undefined)
        'bannerImage': (bannerImage as Input$StringOperationFilterInput?),
      if (isVerified != _undefined)
        'isVerified': (isVerified as Input$BooleanOperationFilterInput?),
      if (verifiedAt != _undefined)
        'verifiedAt': (verifiedAt as Input$DateTimeOperationFilterInput?),
      if (followerCount != _undefined)
        'followerCount': (followerCount as Input$LongOperationFilterInput?),
      if (followingCount != _undefined)
        'followingCount': (followingCount as Input$LongOperationFilterInput?),
      if (lastFollowers != _undefined)
        'lastFollowers':
            (lastFollowers as Input$ListStringOperationFilterInput?),
      if (lastFollowings != _undefined)
        'lastFollowings':
            (lastFollowings as Input$ListStringOperationFilterInput?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Input$BooleanOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$ListenerFilterInput>? Function(
      Iterable<CopyWith$Input$ListenerFilterInput<Input$ListenerFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$ListenerFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$ListenerFilterInput>? Function(
      Iterable<CopyWith$Input$ListenerFilterInput<Input$ListenerFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$ListenerFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userId,
            (e) => call(userId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get displayName {
    final local$displayName = _instance.displayName;
    return local$displayName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$displayName,
            (e) => call(displayName: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get displayNameUnsigned {
    final local$displayNameUnsigned = _instance.displayNameUnsigned;
    return local$displayNameUnsigned == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$displayNameUnsigned,
            (e) => call(displayNameUnsigned: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$email,
            (e) => call(email: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get avatarImage {
    final local$avatarImage = _instance.avatarImage;
    return local$avatarImage == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$avatarImage,
            (e) => call(avatarImage: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get bannerImage {
    final local$bannerImage = _instance.bannerImage;
    return local$bannerImage == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$bannerImage,
            (e) => call(bannerImage: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVerified {
    final local$isVerified = _instance.isVerified;
    return local$isVerified == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isVerified,
            (e) => call(isVerified: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get verifiedAt {
    final local$verifiedAt = _instance.verifiedAt;
    return local$verifiedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$verifiedAt,
            (e) => call(verifiedAt: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get followerCount {
    final local$followerCount = _instance.followerCount;
    return local$followerCount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$followerCount,
            (e) => call(followerCount: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get followingCount {
    final local$followingCount = _instance.followingCount;
    return local$followingCount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$followingCount,
            (e) => call(followingCount: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get lastFollowers {
    final local$lastFollowers = _instance.lastFollowers;
    return local$lastFollowers == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$lastFollowers,
            (e) => call(lastFollowers: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get lastFollowings {
    final local$lastFollowings = _instance.lastFollowings;
    return local$lastFollowings == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$lastFollowings,
            (e) => call(lastFollowings: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible {
    final local$isVisible = _instance.isVisible;
    return local$isVisible == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isVisible,
            (e) => call(isVisible: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$ListenerFilterInput<TRes>
    implements CopyWith$Input$ListenerFilterInput<TRes> {
  _CopyWithStubImpl$Input$ListenerFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ListenerFilterInput>? and,
    List<Input$ListenerFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? displayName,
    Input$StringOperationFilterInput? displayNameUnsigned,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? avatarImage,
    Input$StringOperationFilterInput? bannerImage,
    Input$BooleanOperationFilterInput? isVerified,
    Input$DateTimeOperationFilterInput? verifiedAt,
    Input$LongOperationFilterInput? followerCount,
    Input$LongOperationFilterInput? followingCount,
    Input$ListStringOperationFilterInput? lastFollowers,
    Input$ListStringOperationFilterInput? lastFollowings,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get userId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get displayName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get displayNameUnsigned =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get email =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get avatarImage =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get bannerImage =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVerified =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get verifiedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get followerCount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get followingCount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get lastFollowers =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get lastFollowings =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$ListenerSortInput {
  factory Input$ListenerSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? displayName,
    Enum$SortEnumType? displayNameUnsigned,
    Enum$SortEnumType? email,
    Enum$SortEnumType? avatarImage,
    Enum$SortEnumType? bannerImage,
    Enum$SortEnumType? isVerified,
    Enum$SortEnumType? verifiedAt,
    Enum$SortEnumType? followerCount,
    Enum$SortEnumType? followingCount,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$ListenerSortInput._({
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (displayName != null) r'displayName': displayName,
    if (displayNameUnsigned != null)
      r'displayNameUnsigned': displayNameUnsigned,
    if (email != null) r'email': email,
    if (avatarImage != null) r'avatarImage': avatarImage,
    if (bannerImage != null) r'bannerImage': bannerImage,
    if (isVerified != null) r'isVerified': isVerified,
    if (verifiedAt != null) r'verifiedAt': verifiedAt,
    if (followerCount != null) r'followerCount': followerCount,
    if (followingCount != null) r'followingCount': followingCount,
    if (isVisible != null) r'isVisible': isVisible,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ListenerSortInput._(this._$data);

  factory Input$ListenerSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$SortEnumType((l$userId as String));
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = l$displayName == null
          ? null
          : fromJson$Enum$SortEnumType((l$displayName as String));
    }
    if (data.containsKey('displayNameUnsigned')) {
      final l$displayNameUnsigned = data['displayNameUnsigned'];
      result$data['displayNameUnsigned'] = l$displayNameUnsigned == null
          ? null
          : fromJson$Enum$SortEnumType((l$displayNameUnsigned as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : fromJson$Enum$SortEnumType((l$email as String));
    }
    if (data.containsKey('avatarImage')) {
      final l$avatarImage = data['avatarImage'];
      result$data['avatarImage'] = l$avatarImage == null
          ? null
          : fromJson$Enum$SortEnumType((l$avatarImage as String));
    }
    if (data.containsKey('bannerImage')) {
      final l$bannerImage = data['bannerImage'];
      result$data['bannerImage'] = l$bannerImage == null
          ? null
          : fromJson$Enum$SortEnumType((l$bannerImage as String));
    }
    if (data.containsKey('isVerified')) {
      final l$isVerified = data['isVerified'];
      result$data['isVerified'] = l$isVerified == null
          ? null
          : fromJson$Enum$SortEnumType((l$isVerified as String));
    }
    if (data.containsKey('verifiedAt')) {
      final l$verifiedAt = data['verifiedAt'];
      result$data['verifiedAt'] = l$verifiedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$verifiedAt as String));
    }
    if (data.containsKey('followerCount')) {
      final l$followerCount = data['followerCount'];
      result$data['followerCount'] = l$followerCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$followerCount as String));
    }
    if (data.containsKey('followingCount')) {
      final l$followingCount = data['followingCount'];
      result$data['followingCount'] = l$followingCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$followingCount as String));
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : fromJson$Enum$SortEnumType((l$isVisible as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$ListenerSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get userId => (_$data['userId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get displayName =>
      (_$data['displayName'] as Enum$SortEnumType?);

  Enum$SortEnumType? get displayNameUnsigned =>
      (_$data['displayNameUnsigned'] as Enum$SortEnumType?);

  Enum$SortEnumType? get email => (_$data['email'] as Enum$SortEnumType?);

  Enum$SortEnumType? get avatarImage =>
      (_$data['avatarImage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get bannerImage =>
      (_$data['bannerImage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isVerified =>
      (_$data['isVerified'] as Enum$SortEnumType?);

  Enum$SortEnumType? get verifiedAt =>
      (_$data['verifiedAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get followerCount =>
      (_$data['followerCount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get followingCount =>
      (_$data['followingCount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isVisible =>
      (_$data['isVisible'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId == null
          ? null
          : toJson$Enum$SortEnumType(l$userId);
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] = l$displayName == null
          ? null
          : toJson$Enum$SortEnumType(l$displayName);
    }
    if (_$data.containsKey('displayNameUnsigned')) {
      final l$displayNameUnsigned = displayNameUnsigned;
      result$data['displayNameUnsigned'] = l$displayNameUnsigned == null
          ? null
          : toJson$Enum$SortEnumType(l$displayNameUnsigned);
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email == null
          ? null
          : toJson$Enum$SortEnumType(l$email);
    }
    if (_$data.containsKey('avatarImage')) {
      final l$avatarImage = avatarImage;
      result$data['avatarImage'] = l$avatarImage == null
          ? null
          : toJson$Enum$SortEnumType(l$avatarImage);
    }
    if (_$data.containsKey('bannerImage')) {
      final l$bannerImage = bannerImage;
      result$data['bannerImage'] = l$bannerImage == null
          ? null
          : toJson$Enum$SortEnumType(l$bannerImage);
    }
    if (_$data.containsKey('isVerified')) {
      final l$isVerified = isVerified;
      result$data['isVerified'] = l$isVerified == null
          ? null
          : toJson$Enum$SortEnumType(l$isVerified);
    }
    if (_$data.containsKey('verifiedAt')) {
      final l$verifiedAt = verifiedAt;
      result$data['verifiedAt'] = l$verifiedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$verifiedAt);
    }
    if (_$data.containsKey('followerCount')) {
      final l$followerCount = followerCount;
      result$data['followerCount'] = l$followerCount == null
          ? null
          : toJson$Enum$SortEnumType(l$followerCount);
    }
    if (_$data.containsKey('followingCount')) {
      final l$followingCount = followingCount;
      result$data['followingCount'] = l$followingCount == null
          ? null
          : toJson$Enum$SortEnumType(l$followingCount);
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible == null
          ? null
          : toJson$Enum$SortEnumType(l$isVisible);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$ListenerSortInput<Input$ListenerSortInput> get copyWith =>
      CopyWith$Input$ListenerSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ListenerSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$displayNameUnsigned = displayNameUnsigned;
    final lOther$displayNameUnsigned = other.displayNameUnsigned;
    if (_$data.containsKey('displayNameUnsigned') !=
        other._$data.containsKey('displayNameUnsigned')) {
      return false;
    }
    if (l$displayNameUnsigned != lOther$displayNameUnsigned) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$avatarImage = avatarImage;
    final lOther$avatarImage = other.avatarImage;
    if (_$data.containsKey('avatarImage') !=
        other._$data.containsKey('avatarImage')) {
      return false;
    }
    if (l$avatarImage != lOther$avatarImage) {
      return false;
    }
    final l$bannerImage = bannerImage;
    final lOther$bannerImage = other.bannerImage;
    if (_$data.containsKey('bannerImage') !=
        other._$data.containsKey('bannerImage')) {
      return false;
    }
    if (l$bannerImage != lOther$bannerImage) {
      return false;
    }
    final l$isVerified = isVerified;
    final lOther$isVerified = other.isVerified;
    if (_$data.containsKey('isVerified') !=
        other._$data.containsKey('isVerified')) {
      return false;
    }
    if (l$isVerified != lOther$isVerified) {
      return false;
    }
    final l$verifiedAt = verifiedAt;
    final lOther$verifiedAt = other.verifiedAt;
    if (_$data.containsKey('verifiedAt') !=
        other._$data.containsKey('verifiedAt')) {
      return false;
    }
    if (l$verifiedAt != lOther$verifiedAt) {
      return false;
    }
    final l$followerCount = followerCount;
    final lOther$followerCount = other.followerCount;
    if (_$data.containsKey('followerCount') !=
        other._$data.containsKey('followerCount')) {
      return false;
    }
    if (l$followerCount != lOther$followerCount) {
      return false;
    }
    final l$followingCount = followingCount;
    final lOther$followingCount = other.followingCount;
    if (_$data.containsKey('followingCount') !=
        other._$data.containsKey('followingCount')) {
      return false;
    }
    if (l$followingCount != lOther$followingCount) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$displayName = displayName;
    final l$displayNameUnsigned = displayNameUnsigned;
    final l$email = email;
    final l$avatarImage = avatarImage;
    final l$bannerImage = bannerImage;
    final l$isVerified = isVerified;
    final l$verifiedAt = verifiedAt;
    final l$followerCount = followerCount;
    final l$followingCount = followingCount;
    final l$isVisible = isVisible;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('displayNameUnsigned')
          ? l$displayNameUnsigned
          : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('avatarImage') ? l$avatarImage : const {},
      _$data.containsKey('bannerImage') ? l$bannerImage : const {},
      _$data.containsKey('isVerified') ? l$isVerified : const {},
      _$data.containsKey('verifiedAt') ? l$verifiedAt : const {},
      _$data.containsKey('followerCount') ? l$followerCount : const {},
      _$data.containsKey('followingCount') ? l$followingCount : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ListenerSortInput<TRes> {
  factory CopyWith$Input$ListenerSortInput(
    Input$ListenerSortInput instance,
    TRes Function(Input$ListenerSortInput) then,
  ) = _CopyWithImpl$Input$ListenerSortInput;

  factory CopyWith$Input$ListenerSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ListenerSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? displayName,
    Enum$SortEnumType? displayNameUnsigned,
    Enum$SortEnumType? email,
    Enum$SortEnumType? avatarImage,
    Enum$SortEnumType? bannerImage,
    Enum$SortEnumType? isVerified,
    Enum$SortEnumType? verifiedAt,
    Enum$SortEnumType? followerCount,
    Enum$SortEnumType? followingCount,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$ListenerSortInput<TRes>
    implements CopyWith$Input$ListenerSortInput<TRes> {
  _CopyWithImpl$Input$ListenerSortInput(this._instance, this._then);

  final Input$ListenerSortInput _instance;

  final TRes Function(Input$ListenerSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? displayName = _undefined,
    Object? displayNameUnsigned = _undefined,
    Object? email = _undefined,
    Object? avatarImage = _undefined,
    Object? bannerImage = _undefined,
    Object? isVerified = _undefined,
    Object? verifiedAt = _undefined,
    Object? followerCount = _undefined,
    Object? followingCount = _undefined,
    Object? isVisible = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ListenerSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (userId != _undefined) 'userId': (userId as Enum$SortEnumType?),
      if (displayName != _undefined)
        'displayName': (displayName as Enum$SortEnumType?),
      if (displayNameUnsigned != _undefined)
        'displayNameUnsigned': (displayNameUnsigned as Enum$SortEnumType?),
      if (email != _undefined) 'email': (email as Enum$SortEnumType?),
      if (avatarImage != _undefined)
        'avatarImage': (avatarImage as Enum$SortEnumType?),
      if (bannerImage != _undefined)
        'bannerImage': (bannerImage as Enum$SortEnumType?),
      if (isVerified != _undefined)
        'isVerified': (isVerified as Enum$SortEnumType?),
      if (verifiedAt != _undefined)
        'verifiedAt': (verifiedAt as Enum$SortEnumType?),
      if (followerCount != _undefined)
        'followerCount': (followerCount as Enum$SortEnumType?),
      if (followingCount != _undefined)
        'followingCount': (followingCount as Enum$SortEnumType?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$ListenerSortInput<TRes>
    implements CopyWith$Input$ListenerSortInput<TRes> {
  _CopyWithStubImpl$Input$ListenerSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? displayName,
    Enum$SortEnumType? displayNameUnsigned,
    Enum$SortEnumType? email,
    Enum$SortEnumType? avatarImage,
    Enum$SortEnumType? bannerImage,
    Enum$SortEnumType? isVerified,
    Enum$SortEnumType? verifiedAt,
    Enum$SortEnumType? followerCount,
    Enum$SortEnumType? followingCount,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$LongOperationFilterInput {
  factory Input$LongOperationFilterInput({
    int? eq,
    int? neq,
    List<int?>? $in,
    List<int?>? nin,
    int? gt,
    int? ngt,
    int? gte,
    int? ngte,
    int? lt,
    int? nlt,
    int? lte,
    int? nlte,
  }) => Input$LongOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
    if (gt != null) r'gt': gt,
    if (ngt != null) r'ngt': ngt,
    if (gte != null) r'gte': gte,
    if (ngte != null) r'ngte': ngte,
    if (lt != null) r'lt': lt,
    if (nlt != null) r'nlt': nlt,
    if (lte != null) r'lte': lte,
    if (nlte != null) r'nlte': nlte,
  });

  Input$LongOperationFilterInput._(this._$data);

  factory Input$LongOperationFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as int?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => (e as int?))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => (e as int?))
          .toList();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('ngt')) {
      final l$ngt = data['ngt'];
      result$data['ngt'] = (l$ngt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('ngte')) {
      final l$ngte = data['ngte'];
      result$data['ngte'] = (l$ngte as int?);
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('nlt')) {
      final l$nlt = data['nlt'];
      result$data['nlt'] = (l$nlt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('nlte')) {
      final l$nlte = data['nlte'];
      result$data['nlte'] = (l$nlte as int?);
    }
    return Input$LongOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get eq => (_$data['eq'] as int?);

  int? get neq => (_$data['neq'] as int?);

  List<int?>? get $in => (_$data['in'] as List<int?>?);

  List<int?>? get nin => (_$data['nin'] as List<int?>?);

  int? get gt => (_$data['gt'] as int?);

  int? get ngt => (_$data['ngt'] as int?);

  int? get gte => (_$data['gte'] as int?);

  int? get ngte => (_$data['ngte'] as int?);

  int? get lt => (_$data['lt'] as int?);

  int? get nlt => (_$data['nlt'] as int?);

  int? get lte => (_$data['lte'] as int?);

  int? get nlte => (_$data['nlte'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('ngt')) {
      final l$ngt = ngt;
      result$data['ngt'] = l$ngt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('ngte')) {
      final l$ngte = ngte;
      result$data['ngte'] = l$ngte;
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('nlt')) {
      final l$nlt = nlt;
      result$data['nlt'] = l$nlt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('nlte')) {
      final l$nlte = nlte;
      result$data['nlte'] = l$nlte;
    }
    return result$data;
  }

  CopyWith$Input$LongOperationFilterInput<Input$LongOperationFilterInput>
  get copyWith => CopyWith$Input$LongOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LongOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$ngt = ngt;
    final lOther$ngt = other.ngt;
    if (_$data.containsKey('ngt') != other._$data.containsKey('ngt')) {
      return false;
    }
    if (l$ngt != lOther$ngt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$ngte = ngte;
    final lOther$ngte = other.ngte;
    if (_$data.containsKey('ngte') != other._$data.containsKey('ngte')) {
      return false;
    }
    if (l$ngte != lOther$ngte) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$nlt = nlt;
    final lOther$nlt = other.nlt;
    if (_$data.containsKey('nlt') != other._$data.containsKey('nlt')) {
      return false;
    }
    if (l$nlt != lOther$nlt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$nlte = nlte;
    final lOther$nlte = other.nlte;
    if (_$data.containsKey('nlte') != other._$data.containsKey('nlte')) {
      return false;
    }
    if (l$nlte != lOther$nlte) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    final l$gt = gt;
    final l$ngt = ngt;
    final l$gte = gte;
    final l$ngte = ngte;
    final l$lt = lt;
    final l$nlt = nlt;
    final l$lte = lte;
    final l$nlte = nlte;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('ngt') ? l$ngt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('ngte') ? l$ngte : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('nlt') ? l$nlt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('nlte') ? l$nlte : const {},
    ]);
  }
}

abstract class CopyWith$Input$LongOperationFilterInput<TRes> {
  factory CopyWith$Input$LongOperationFilterInput(
    Input$LongOperationFilterInput instance,
    TRes Function(Input$LongOperationFilterInput) then,
  ) = _CopyWithImpl$Input$LongOperationFilterInput;

  factory CopyWith$Input$LongOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LongOperationFilterInput;

  TRes call({
    int? eq,
    int? neq,
    List<int?>? $in,
    List<int?>? nin,
    int? gt,
    int? ngt,
    int? gte,
    int? ngte,
    int? lt,
    int? nlt,
    int? lte,
    int? nlte,
  });
}

class _CopyWithImpl$Input$LongOperationFilterInput<TRes>
    implements CopyWith$Input$LongOperationFilterInput<TRes> {
  _CopyWithImpl$Input$LongOperationFilterInput(this._instance, this._then);

  final Input$LongOperationFilterInput _instance;

  final TRes Function(Input$LongOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
    Object? gt = _undefined,
    Object? ngt = _undefined,
    Object? gte = _undefined,
    Object? ngte = _undefined,
    Object? lt = _undefined,
    Object? nlt = _undefined,
    Object? lte = _undefined,
    Object? nlte = _undefined,
  }) => _then(
    Input$LongOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as int?),
      if (neq != _undefined) 'neq': (neq as int?),
      if ($in != _undefined) 'in': ($in as List<int?>?),
      if (nin != _undefined) 'nin': (nin as List<int?>?),
      if (gt != _undefined) 'gt': (gt as int?),
      if (ngt != _undefined) 'ngt': (ngt as int?),
      if (gte != _undefined) 'gte': (gte as int?),
      if (ngte != _undefined) 'ngte': (ngte as int?),
      if (lt != _undefined) 'lt': (lt as int?),
      if (nlt != _undefined) 'nlt': (nlt as int?),
      if (lte != _undefined) 'lte': (lte as int?),
      if (nlte != _undefined) 'nlte': (nlte as int?),
    }),
  );
}

class _CopyWithStubImpl$Input$LongOperationFilterInput<TRes>
    implements CopyWith$Input$LongOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$LongOperationFilterInput(this._res);

  TRes _res;

  call({
    int? eq,
    int? neq,
    List<int?>? $in,
    List<int?>? nin,
    int? gt,
    int? ngt,
    int? gte,
    int? ngte,
    int? lt,
    int? nlt,
    int? lte,
    int? nlte,
  }) => _res;
}

class Input$MessageFilterInput {
  factory Input$MessageFilterInput({
    List<Input$MessageFilterInput>? and,
    List<Input$MessageFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? conversationId,
    Input$StringOperationFilterInput? senderId,
    Input$StringOperationFilterInput? receiverId,
    Input$StringOperationFilterInput? text,
    Input$BooleanOperationFilterInput? isRead,
    Input$ListStringOperationFilterInput? deletedForIds,
    Input$DateTimeOperationFilterInput? sentAt,
  }) => Input$MessageFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (conversationId != null) r'conversationId': conversationId,
    if (senderId != null) r'senderId': senderId,
    if (receiverId != null) r'receiverId': receiverId,
    if (text != null) r'text': text,
    if (isRead != null) r'isRead': isRead,
    if (deletedForIds != null) r'deletedForIds': deletedForIds,
    if (sentAt != null) r'sentAt': sentAt,
  });

  Input$MessageFilterInput._(this._$data);

  factory Input$MessageFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$MessageFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$MessageFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('conversationId')) {
      final l$conversationId = data['conversationId'];
      result$data['conversationId'] = l$conversationId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$conversationId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('senderId')) {
      final l$senderId = data['senderId'];
      result$data['senderId'] = l$senderId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$senderId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('receiverId')) {
      final l$receiverId = data['receiverId'];
      result$data['receiverId'] = l$receiverId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$receiverId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('text')) {
      final l$text = data['text'];
      result$data['text'] = l$text == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$text as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isRead')) {
      final l$isRead = data['isRead'];
      result$data['isRead'] = l$isRead == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isRead as Map<String, dynamic>),
            );
    }
    if (data.containsKey('deletedForIds')) {
      final l$deletedForIds = data['deletedForIds'];
      result$data['deletedForIds'] = l$deletedForIds == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$deletedForIds as Map<String, dynamic>),
            );
    }
    if (data.containsKey('sentAt')) {
      final l$sentAt = data['sentAt'];
      result$data['sentAt'] = l$sentAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$sentAt as Map<String, dynamic>),
            );
    }
    return Input$MessageFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MessageFilterInput>? get and =>
      (_$data['and'] as List<Input$MessageFilterInput>?);

  List<Input$MessageFilterInput>? get or =>
      (_$data['or'] as List<Input$MessageFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get conversationId =>
      (_$data['conversationId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get senderId =>
      (_$data['senderId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get receiverId =>
      (_$data['receiverId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get text =>
      (_$data['text'] as Input$StringOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isRead =>
      (_$data['isRead'] as Input$BooleanOperationFilterInput?);

  Input$ListStringOperationFilterInput? get deletedForIds =>
      (_$data['deletedForIds'] as Input$ListStringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get sentAt =>
      (_$data['sentAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('conversationId')) {
      final l$conversationId = conversationId;
      result$data['conversationId'] = l$conversationId?.toJson();
    }
    if (_$data.containsKey('senderId')) {
      final l$senderId = senderId;
      result$data['senderId'] = l$senderId?.toJson();
    }
    if (_$data.containsKey('receiverId')) {
      final l$receiverId = receiverId;
      result$data['receiverId'] = l$receiverId?.toJson();
    }
    if (_$data.containsKey('text')) {
      final l$text = text;
      result$data['text'] = l$text?.toJson();
    }
    if (_$data.containsKey('isRead')) {
      final l$isRead = isRead;
      result$data['isRead'] = l$isRead?.toJson();
    }
    if (_$data.containsKey('deletedForIds')) {
      final l$deletedForIds = deletedForIds;
      result$data['deletedForIds'] = l$deletedForIds?.toJson();
    }
    if (_$data.containsKey('sentAt')) {
      final l$sentAt = sentAt;
      result$data['sentAt'] = l$sentAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$MessageFilterInput<Input$MessageFilterInput> get copyWith =>
      CopyWith$Input$MessageFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MessageFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$conversationId = conversationId;
    final lOther$conversationId = other.conversationId;
    if (_$data.containsKey('conversationId') !=
        other._$data.containsKey('conversationId')) {
      return false;
    }
    if (l$conversationId != lOther$conversationId) {
      return false;
    }
    final l$senderId = senderId;
    final lOther$senderId = other.senderId;
    if (_$data.containsKey('senderId') !=
        other._$data.containsKey('senderId')) {
      return false;
    }
    if (l$senderId != lOther$senderId) {
      return false;
    }
    final l$receiverId = receiverId;
    final lOther$receiverId = other.receiverId;
    if (_$data.containsKey('receiverId') !=
        other._$data.containsKey('receiverId')) {
      return false;
    }
    if (l$receiverId != lOther$receiverId) {
      return false;
    }
    final l$text = text;
    final lOther$text = other.text;
    if (_$data.containsKey('text') != other._$data.containsKey('text')) {
      return false;
    }
    if (l$text != lOther$text) {
      return false;
    }
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (_$data.containsKey('isRead') != other._$data.containsKey('isRead')) {
      return false;
    }
    if (l$isRead != lOther$isRead) {
      return false;
    }
    final l$deletedForIds = deletedForIds;
    final lOther$deletedForIds = other.deletedForIds;
    if (_$data.containsKey('deletedForIds') !=
        other._$data.containsKey('deletedForIds')) {
      return false;
    }
    if (l$deletedForIds != lOther$deletedForIds) {
      return false;
    }
    final l$sentAt = sentAt;
    final lOther$sentAt = other.sentAt;
    if (_$data.containsKey('sentAt') != other._$data.containsKey('sentAt')) {
      return false;
    }
    if (l$sentAt != lOther$sentAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$conversationId = conversationId;
    final l$senderId = senderId;
    final l$receiverId = receiverId;
    final l$text = text;
    final l$isRead = isRead;
    final l$deletedForIds = deletedForIds;
    final l$sentAt = sentAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('conversationId') ? l$conversationId : const {},
      _$data.containsKey('senderId') ? l$senderId : const {},
      _$data.containsKey('receiverId') ? l$receiverId : const {},
      _$data.containsKey('text') ? l$text : const {},
      _$data.containsKey('isRead') ? l$isRead : const {},
      _$data.containsKey('deletedForIds') ? l$deletedForIds : const {},
      _$data.containsKey('sentAt') ? l$sentAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$MessageFilterInput<TRes> {
  factory CopyWith$Input$MessageFilterInput(
    Input$MessageFilterInput instance,
    TRes Function(Input$MessageFilterInput) then,
  ) = _CopyWithImpl$Input$MessageFilterInput;

  factory CopyWith$Input$MessageFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MessageFilterInput;

  TRes call({
    List<Input$MessageFilterInput>? and,
    List<Input$MessageFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? conversationId,
    Input$StringOperationFilterInput? senderId,
    Input$StringOperationFilterInput? receiverId,
    Input$StringOperationFilterInput? text,
    Input$BooleanOperationFilterInput? isRead,
    Input$ListStringOperationFilterInput? deletedForIds,
    Input$DateTimeOperationFilterInput? sentAt,
  });
  TRes and(
    Iterable<Input$MessageFilterInput>? Function(
      Iterable<CopyWith$Input$MessageFilterInput<Input$MessageFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$MessageFilterInput>? Function(
      Iterable<CopyWith$Input$MessageFilterInput<Input$MessageFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get conversationId;
  CopyWith$Input$StringOperationFilterInput<TRes> get senderId;
  CopyWith$Input$StringOperationFilterInput<TRes> get receiverId;
  CopyWith$Input$StringOperationFilterInput<TRes> get text;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isRead;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get deletedForIds;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get sentAt;
}

class _CopyWithImpl$Input$MessageFilterInput<TRes>
    implements CopyWith$Input$MessageFilterInput<TRes> {
  _CopyWithImpl$Input$MessageFilterInput(this._instance, this._then);

  final Input$MessageFilterInput _instance;

  final TRes Function(Input$MessageFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? conversationId = _undefined,
    Object? senderId = _undefined,
    Object? receiverId = _undefined,
    Object? text = _undefined,
    Object? isRead = _undefined,
    Object? deletedForIds = _undefined,
    Object? sentAt = _undefined,
  }) => _then(
    Input$MessageFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$MessageFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$MessageFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (conversationId != _undefined)
        'conversationId': (conversationId as Input$StringOperationFilterInput?),
      if (senderId != _undefined)
        'senderId': (senderId as Input$StringOperationFilterInput?),
      if (receiverId != _undefined)
        'receiverId': (receiverId as Input$StringOperationFilterInput?),
      if (text != _undefined)
        'text': (text as Input$StringOperationFilterInput?),
      if (isRead != _undefined)
        'isRead': (isRead as Input$BooleanOperationFilterInput?),
      if (deletedForIds != _undefined)
        'deletedForIds':
            (deletedForIds as Input$ListStringOperationFilterInput?),
      if (sentAt != _undefined)
        'sentAt': (sentAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$MessageFilterInput>? Function(
      Iterable<CopyWith$Input$MessageFilterInput<Input$MessageFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$MessageFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$MessageFilterInput>? Function(
      Iterable<CopyWith$Input$MessageFilterInput<Input$MessageFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$MessageFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get conversationId {
    final local$conversationId = _instance.conversationId;
    return local$conversationId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$conversationId,
            (e) => call(conversationId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get senderId {
    final local$senderId = _instance.senderId;
    return local$senderId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$senderId,
            (e) => call(senderId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get receiverId {
    final local$receiverId = _instance.receiverId;
    return local$receiverId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$receiverId,
            (e) => call(receiverId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get text {
    final local$text = _instance.text;
    return local$text == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$text,
            (e) => call(text: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isRead {
    final local$isRead = _instance.isRead;
    return local$isRead == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isRead,
            (e) => call(isRead: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get deletedForIds {
    final local$deletedForIds = _instance.deletedForIds;
    return local$deletedForIds == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$deletedForIds,
            (e) => call(deletedForIds: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get sentAt {
    final local$sentAt = _instance.sentAt;
    return local$sentAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$sentAt,
            (e) => call(sentAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$MessageFilterInput<TRes>
    implements CopyWith$Input$MessageFilterInput<TRes> {
  _CopyWithStubImpl$Input$MessageFilterInput(this._res);

  TRes _res;

  call({
    List<Input$MessageFilterInput>? and,
    List<Input$MessageFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? conversationId,
    Input$StringOperationFilterInput? senderId,
    Input$StringOperationFilterInput? receiverId,
    Input$StringOperationFilterInput? text,
    Input$BooleanOperationFilterInput? isRead,
    Input$ListStringOperationFilterInput? deletedForIds,
    Input$DateTimeOperationFilterInput? sentAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get conversationId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get senderId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get receiverId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get text =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isRead =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get deletedForIds =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get sentAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$MessageSortInput {
  factory Input$MessageSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? conversationId,
    Enum$SortEnumType? senderId,
    Enum$SortEnumType? receiverId,
    Enum$SortEnumType? text,
    Enum$SortEnumType? isRead,
    Enum$SortEnumType? sentAt,
  }) => Input$MessageSortInput._({
    if (id != null) r'id': id,
    if (conversationId != null) r'conversationId': conversationId,
    if (senderId != null) r'senderId': senderId,
    if (receiverId != null) r'receiverId': receiverId,
    if (text != null) r'text': text,
    if (isRead != null) r'isRead': isRead,
    if (sentAt != null) r'sentAt': sentAt,
  });

  Input$MessageSortInput._(this._$data);

  factory Input$MessageSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('conversationId')) {
      final l$conversationId = data['conversationId'];
      result$data['conversationId'] = l$conversationId == null
          ? null
          : fromJson$Enum$SortEnumType((l$conversationId as String));
    }
    if (data.containsKey('senderId')) {
      final l$senderId = data['senderId'];
      result$data['senderId'] = l$senderId == null
          ? null
          : fromJson$Enum$SortEnumType((l$senderId as String));
    }
    if (data.containsKey('receiverId')) {
      final l$receiverId = data['receiverId'];
      result$data['receiverId'] = l$receiverId == null
          ? null
          : fromJson$Enum$SortEnumType((l$receiverId as String));
    }
    if (data.containsKey('text')) {
      final l$text = data['text'];
      result$data['text'] = l$text == null
          ? null
          : fromJson$Enum$SortEnumType((l$text as String));
    }
    if (data.containsKey('isRead')) {
      final l$isRead = data['isRead'];
      result$data['isRead'] = l$isRead == null
          ? null
          : fromJson$Enum$SortEnumType((l$isRead as String));
    }
    if (data.containsKey('sentAt')) {
      final l$sentAt = data['sentAt'];
      result$data['sentAt'] = l$sentAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$sentAt as String));
    }
    return Input$MessageSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get conversationId =>
      (_$data['conversationId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get senderId => (_$data['senderId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get receiverId =>
      (_$data['receiverId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get text => (_$data['text'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isRead => (_$data['isRead'] as Enum$SortEnumType?);

  Enum$SortEnumType? get sentAt => (_$data['sentAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('conversationId')) {
      final l$conversationId = conversationId;
      result$data['conversationId'] = l$conversationId == null
          ? null
          : toJson$Enum$SortEnumType(l$conversationId);
    }
    if (_$data.containsKey('senderId')) {
      final l$senderId = senderId;
      result$data['senderId'] = l$senderId == null
          ? null
          : toJson$Enum$SortEnumType(l$senderId);
    }
    if (_$data.containsKey('receiverId')) {
      final l$receiverId = receiverId;
      result$data['receiverId'] = l$receiverId == null
          ? null
          : toJson$Enum$SortEnumType(l$receiverId);
    }
    if (_$data.containsKey('text')) {
      final l$text = text;
      result$data['text'] = l$text == null
          ? null
          : toJson$Enum$SortEnumType(l$text);
    }
    if (_$data.containsKey('isRead')) {
      final l$isRead = isRead;
      result$data['isRead'] = l$isRead == null
          ? null
          : toJson$Enum$SortEnumType(l$isRead);
    }
    if (_$data.containsKey('sentAt')) {
      final l$sentAt = sentAt;
      result$data['sentAt'] = l$sentAt == null
          ? null
          : toJson$Enum$SortEnumType(l$sentAt);
    }
    return result$data;
  }

  CopyWith$Input$MessageSortInput<Input$MessageSortInput> get copyWith =>
      CopyWith$Input$MessageSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MessageSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$conversationId = conversationId;
    final lOther$conversationId = other.conversationId;
    if (_$data.containsKey('conversationId') !=
        other._$data.containsKey('conversationId')) {
      return false;
    }
    if (l$conversationId != lOther$conversationId) {
      return false;
    }
    final l$senderId = senderId;
    final lOther$senderId = other.senderId;
    if (_$data.containsKey('senderId') !=
        other._$data.containsKey('senderId')) {
      return false;
    }
    if (l$senderId != lOther$senderId) {
      return false;
    }
    final l$receiverId = receiverId;
    final lOther$receiverId = other.receiverId;
    if (_$data.containsKey('receiverId') !=
        other._$data.containsKey('receiverId')) {
      return false;
    }
    if (l$receiverId != lOther$receiverId) {
      return false;
    }
    final l$text = text;
    final lOther$text = other.text;
    if (_$data.containsKey('text') != other._$data.containsKey('text')) {
      return false;
    }
    if (l$text != lOther$text) {
      return false;
    }
    final l$isRead = isRead;
    final lOther$isRead = other.isRead;
    if (_$data.containsKey('isRead') != other._$data.containsKey('isRead')) {
      return false;
    }
    if (l$isRead != lOther$isRead) {
      return false;
    }
    final l$sentAt = sentAt;
    final lOther$sentAt = other.sentAt;
    if (_$data.containsKey('sentAt') != other._$data.containsKey('sentAt')) {
      return false;
    }
    if (l$sentAt != lOther$sentAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$conversationId = conversationId;
    final l$senderId = senderId;
    final l$receiverId = receiverId;
    final l$text = text;
    final l$isRead = isRead;
    final l$sentAt = sentAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('conversationId') ? l$conversationId : const {},
      _$data.containsKey('senderId') ? l$senderId : const {},
      _$data.containsKey('receiverId') ? l$receiverId : const {},
      _$data.containsKey('text') ? l$text : const {},
      _$data.containsKey('isRead') ? l$isRead : const {},
      _$data.containsKey('sentAt') ? l$sentAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$MessageSortInput<TRes> {
  factory CopyWith$Input$MessageSortInput(
    Input$MessageSortInput instance,
    TRes Function(Input$MessageSortInput) then,
  ) = _CopyWithImpl$Input$MessageSortInput;

  factory CopyWith$Input$MessageSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MessageSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? conversationId,
    Enum$SortEnumType? senderId,
    Enum$SortEnumType? receiverId,
    Enum$SortEnumType? text,
    Enum$SortEnumType? isRead,
    Enum$SortEnumType? sentAt,
  });
}

class _CopyWithImpl$Input$MessageSortInput<TRes>
    implements CopyWith$Input$MessageSortInput<TRes> {
  _CopyWithImpl$Input$MessageSortInput(this._instance, this._then);

  final Input$MessageSortInput _instance;

  final TRes Function(Input$MessageSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? conversationId = _undefined,
    Object? senderId = _undefined,
    Object? receiverId = _undefined,
    Object? text = _undefined,
    Object? isRead = _undefined,
    Object? sentAt = _undefined,
  }) => _then(
    Input$MessageSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (conversationId != _undefined)
        'conversationId': (conversationId as Enum$SortEnumType?),
      if (senderId != _undefined) 'senderId': (senderId as Enum$SortEnumType?),
      if (receiverId != _undefined)
        'receiverId': (receiverId as Enum$SortEnumType?),
      if (text != _undefined) 'text': (text as Enum$SortEnumType?),
      if (isRead != _undefined) 'isRead': (isRead as Enum$SortEnumType?),
      if (sentAt != _undefined) 'sentAt': (sentAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$MessageSortInput<TRes>
    implements CopyWith$Input$MessageSortInput<TRes> {
  _CopyWithStubImpl$Input$MessageSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? conversationId,
    Enum$SortEnumType? senderId,
    Enum$SortEnumType? receiverId,
    Enum$SortEnumType? text,
    Enum$SortEnumType? isRead,
    Enum$SortEnumType? sentAt,
  }) => _res;
}

class Input$MetadataFilterInput {
  factory Input$MetadataFilterInput({
    List<Input$MetadataFilterInput>? and,
    List<Input$MetadataFilterInput>? or,
    Input$StringOperationFilterInput? key,
    Input$StringOperationFilterInput? value,
  }) => Input$MetadataFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (key != null) r'key': key,
    if (value != null) r'value': value,
  });

  Input$MetadataFilterInput._(this._$data);

  factory Input$MetadataFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$MetadataFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$MetadataFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('key')) {
      final l$key = data['key'];
      result$data['key'] = l$key == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$key as Map<String, dynamic>),
            );
    }
    if (data.containsKey('value')) {
      final l$value = data['value'];
      result$data['value'] = l$value == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$value as Map<String, dynamic>),
            );
    }
    return Input$MetadataFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MetadataFilterInput>? get and =>
      (_$data['and'] as List<Input$MetadataFilterInput>?);

  List<Input$MetadataFilterInput>? get or =>
      (_$data['or'] as List<Input$MetadataFilterInput>?);

  Input$StringOperationFilterInput? get key =>
      (_$data['key'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get value =>
      (_$data['value'] as Input$StringOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('key')) {
      final l$key = key;
      result$data['key'] = l$key?.toJson();
    }
    if (_$data.containsKey('value')) {
      final l$value = value;
      result$data['value'] = l$value?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$MetadataFilterInput<Input$MetadataFilterInput> get copyWith =>
      CopyWith$Input$MetadataFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MetadataFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (_$data.containsKey('key') != other._$data.containsKey('key')) {
      return false;
    }
    if (l$key != lOther$key) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (_$data.containsKey('value') != other._$data.containsKey('value')) {
      return false;
    }
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$key = key;
    final l$value = value;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('key') ? l$key : const {},
      _$data.containsKey('value') ? l$value : const {},
    ]);
  }
}

abstract class CopyWith$Input$MetadataFilterInput<TRes> {
  factory CopyWith$Input$MetadataFilterInput(
    Input$MetadataFilterInput instance,
    TRes Function(Input$MetadataFilterInput) then,
  ) = _CopyWithImpl$Input$MetadataFilterInput;

  factory CopyWith$Input$MetadataFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MetadataFilterInput;

  TRes call({
    List<Input$MetadataFilterInput>? and,
    List<Input$MetadataFilterInput>? or,
    Input$StringOperationFilterInput? key,
    Input$StringOperationFilterInput? value,
  });
  TRes and(
    Iterable<Input$MetadataFilterInput>? Function(
      Iterable<CopyWith$Input$MetadataFilterInput<Input$MetadataFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$MetadataFilterInput>? Function(
      Iterable<CopyWith$Input$MetadataFilterInput<Input$MetadataFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get key;
  CopyWith$Input$StringOperationFilterInput<TRes> get value;
}

class _CopyWithImpl$Input$MetadataFilterInput<TRes>
    implements CopyWith$Input$MetadataFilterInput<TRes> {
  _CopyWithImpl$Input$MetadataFilterInput(this._instance, this._then);

  final Input$MetadataFilterInput _instance;

  final TRes Function(Input$MetadataFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? key = _undefined,
    Object? value = _undefined,
  }) => _then(
    Input$MetadataFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$MetadataFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$MetadataFilterInput>?),
      if (key != _undefined) 'key': (key as Input$StringOperationFilterInput?),
      if (value != _undefined)
        'value': (value as Input$StringOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$MetadataFilterInput>? Function(
      Iterable<CopyWith$Input$MetadataFilterInput<Input$MetadataFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$MetadataFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$MetadataFilterInput>? Function(
      Iterable<CopyWith$Input$MetadataFilterInput<Input$MetadataFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$MetadataFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get key {
    final local$key = _instance.key;
    return local$key == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$key,
            (e) => call(key: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get value {
    final local$value = _instance.value;
    return local$value == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$value,
            (e) => call(value: e),
          );
  }
}

class _CopyWithStubImpl$Input$MetadataFilterInput<TRes>
    implements CopyWith$Input$MetadataFilterInput<TRes> {
  _CopyWithStubImpl$Input$MetadataFilterInput(this._res);

  TRes _res;

  call({
    List<Input$MetadataFilterInput>? and,
    List<Input$MetadataFilterInput>? or,
    Input$StringOperationFilterInput? key,
    Input$StringOperationFilterInput? value,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get key =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get value =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
}

class Input$MetadataInput {
  factory Input$MetadataInput({required String key, required String value}) =>
      Input$MetadataInput._({r'key': key, r'value': value});

  Input$MetadataInput._(this._$data);

  factory Input$MetadataInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$key = data['key'];
    result$data['key'] = (l$key as String);
    final l$value = data['value'];
    result$data['value'] = (l$value as String);
    return Input$MetadataInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get key => (_$data['key'] as String);

  String get value => (_$data['value'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$key = key;
    result$data['key'] = l$key;
    final l$value = value;
    result$data['value'] = l$value;
    return result$data;
  }

  CopyWith$Input$MetadataInput<Input$MetadataInput> get copyWith =>
      CopyWith$Input$MetadataInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MetadataInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$key = key;
    final lOther$key = other.key;
    if (l$key != lOther$key) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$key = key;
    final l$value = value;
    return Object.hashAll([l$key, l$value]);
  }
}

abstract class CopyWith$Input$MetadataInput<TRes> {
  factory CopyWith$Input$MetadataInput(
    Input$MetadataInput instance,
    TRes Function(Input$MetadataInput) then,
  ) = _CopyWithImpl$Input$MetadataInput;

  factory CopyWith$Input$MetadataInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MetadataInput;

  TRes call({String? key, String? value});
}

class _CopyWithImpl$Input$MetadataInput<TRes>
    implements CopyWith$Input$MetadataInput<TRes> {
  _CopyWithImpl$Input$MetadataInput(this._instance, this._then);

  final Input$MetadataInput _instance;

  final TRes Function(Input$MetadataInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? key = _undefined, Object? value = _undefined}) => _then(
    Input$MetadataInput._({
      ..._instance._$data,
      if (key != _undefined && key != null) 'key': (key as String),
      if (value != _undefined && value != null) 'value': (value as String),
    }),
  );
}

class _CopyWithStubImpl$Input$MetadataInput<TRes>
    implements CopyWith$Input$MetadataInput<TRes> {
  _CopyWithStubImpl$Input$MetadataInput(this._res);

  TRes _res;

  call({String? key, String? value}) => _res;
}

class Input$MonthlyStreamCountFilterInput {
  factory Input$MonthlyStreamCountFilterInput({
    List<Input$MonthlyStreamCountFilterInput>? and,
    List<Input$MonthlyStreamCountFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$IntOperationFilterInput? month,
    Input$IntOperationFilterInput? year,
    Input$LongOperationFilterInput? streamCount,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? processedAt,
  }) => Input$MonthlyStreamCountFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (trackId != null) r'trackId': trackId,
    if (month != null) r'month': month,
    if (year != null) r'year': year,
    if (streamCount != null) r'streamCount': streamCount,
    if (createdAt != null) r'createdAt': createdAt,
    if (processedAt != null) r'processedAt': processedAt,
  });

  Input$MonthlyStreamCountFilterInput._(this._$data);

  factory Input$MonthlyStreamCountFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$MonthlyStreamCountFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$MonthlyStreamCountFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('trackId')) {
      final l$trackId = data['trackId'];
      result$data['trackId'] = l$trackId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$trackId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('month')) {
      final l$month = data['month'];
      result$data['month'] = l$month == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$month as Map<String, dynamic>),
            );
    }
    if (data.containsKey('year')) {
      final l$year = data['year'];
      result$data['year'] = l$year == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$year as Map<String, dynamic>),
            );
    }
    if (data.containsKey('streamCount')) {
      final l$streamCount = data['streamCount'];
      result$data['streamCount'] = l$streamCount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$streamCount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('processedAt')) {
      final l$processedAt = data['processedAt'];
      result$data['processedAt'] = l$processedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$processedAt as Map<String, dynamic>),
            );
    }
    return Input$MonthlyStreamCountFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$MonthlyStreamCountFilterInput>? get and =>
      (_$data['and'] as List<Input$MonthlyStreamCountFilterInput>?);

  List<Input$MonthlyStreamCountFilterInput>? get or =>
      (_$data['or'] as List<Input$MonthlyStreamCountFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get trackId =>
      (_$data['trackId'] as Input$StringOperationFilterInput?);

  Input$IntOperationFilterInput? get month =>
      (_$data['month'] as Input$IntOperationFilterInput?);

  Input$IntOperationFilterInput? get year =>
      (_$data['year'] as Input$IntOperationFilterInput?);

  Input$LongOperationFilterInput? get streamCount =>
      (_$data['streamCount'] as Input$LongOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get processedAt =>
      (_$data['processedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('trackId')) {
      final l$trackId = trackId;
      result$data['trackId'] = l$trackId?.toJson();
    }
    if (_$data.containsKey('month')) {
      final l$month = month;
      result$data['month'] = l$month?.toJson();
    }
    if (_$data.containsKey('year')) {
      final l$year = year;
      result$data['year'] = l$year?.toJson();
    }
    if (_$data.containsKey('streamCount')) {
      final l$streamCount = streamCount;
      result$data['streamCount'] = l$streamCount?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('processedAt')) {
      final l$processedAt = processedAt;
      result$data['processedAt'] = l$processedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$MonthlyStreamCountFilterInput<
    Input$MonthlyStreamCountFilterInput
  >
  get copyWith => CopyWith$Input$MonthlyStreamCountFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MonthlyStreamCountFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (_$data.containsKey('trackId') != other._$data.containsKey('trackId')) {
      return false;
    }
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$month = month;
    final lOther$month = other.month;
    if (_$data.containsKey('month') != other._$data.containsKey('month')) {
      return false;
    }
    if (l$month != lOther$month) {
      return false;
    }
    final l$year = year;
    final lOther$year = other.year;
    if (_$data.containsKey('year') != other._$data.containsKey('year')) {
      return false;
    }
    if (l$year != lOther$year) {
      return false;
    }
    final l$streamCount = streamCount;
    final lOther$streamCount = other.streamCount;
    if (_$data.containsKey('streamCount') !=
        other._$data.containsKey('streamCount')) {
      return false;
    }
    if (l$streamCount != lOther$streamCount) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$processedAt = processedAt;
    final lOther$processedAt = other.processedAt;
    if (_$data.containsKey('processedAt') !=
        other._$data.containsKey('processedAt')) {
      return false;
    }
    if (l$processedAt != lOther$processedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$trackId = trackId;
    final l$month = month;
    final l$year = year;
    final l$streamCount = streamCount;
    final l$createdAt = createdAt;
    final l$processedAt = processedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('trackId') ? l$trackId : const {},
      _$data.containsKey('month') ? l$month : const {},
      _$data.containsKey('year') ? l$year : const {},
      _$data.containsKey('streamCount') ? l$streamCount : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('processedAt') ? l$processedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$MonthlyStreamCountFilterInput<TRes> {
  factory CopyWith$Input$MonthlyStreamCountFilterInput(
    Input$MonthlyStreamCountFilterInput instance,
    TRes Function(Input$MonthlyStreamCountFilterInput) then,
  ) = _CopyWithImpl$Input$MonthlyStreamCountFilterInput;

  factory CopyWith$Input$MonthlyStreamCountFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MonthlyStreamCountFilterInput;

  TRes call({
    List<Input$MonthlyStreamCountFilterInput>? and,
    List<Input$MonthlyStreamCountFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$IntOperationFilterInput? month,
    Input$IntOperationFilterInput? year,
    Input$LongOperationFilterInput? streamCount,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? processedAt,
  });
  TRes and(
    Iterable<Input$MonthlyStreamCountFilterInput>? Function(
      Iterable<
        CopyWith$Input$MonthlyStreamCountFilterInput<
          Input$MonthlyStreamCountFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$MonthlyStreamCountFilterInput>? Function(
      Iterable<
        CopyWith$Input$MonthlyStreamCountFilterInput<
          Input$MonthlyStreamCountFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get trackId;
  CopyWith$Input$IntOperationFilterInput<TRes> get month;
  CopyWith$Input$IntOperationFilterInput<TRes> get year;
  CopyWith$Input$LongOperationFilterInput<TRes> get streamCount;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get processedAt;
}

class _CopyWithImpl$Input$MonthlyStreamCountFilterInput<TRes>
    implements CopyWith$Input$MonthlyStreamCountFilterInput<TRes> {
  _CopyWithImpl$Input$MonthlyStreamCountFilterInput(this._instance, this._then);

  final Input$MonthlyStreamCountFilterInput _instance;

  final TRes Function(Input$MonthlyStreamCountFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? trackId = _undefined,
    Object? month = _undefined,
    Object? year = _undefined,
    Object? streamCount = _undefined,
    Object? createdAt = _undefined,
    Object? processedAt = _undefined,
  }) => _then(
    Input$MonthlyStreamCountFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$MonthlyStreamCountFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$MonthlyStreamCountFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (trackId != _undefined)
        'trackId': (trackId as Input$StringOperationFilterInput?),
      if (month != _undefined)
        'month': (month as Input$IntOperationFilterInput?),
      if (year != _undefined) 'year': (year as Input$IntOperationFilterInput?),
      if (streamCount != _undefined)
        'streamCount': (streamCount as Input$LongOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (processedAt != _undefined)
        'processedAt': (processedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$MonthlyStreamCountFilterInput>? Function(
      Iterable<
        CopyWith$Input$MonthlyStreamCountFilterInput<
          Input$MonthlyStreamCountFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$MonthlyStreamCountFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$MonthlyStreamCountFilterInput>? Function(
      Iterable<
        CopyWith$Input$MonthlyStreamCountFilterInput<
          Input$MonthlyStreamCountFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$MonthlyStreamCountFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get trackId {
    final local$trackId = _instance.trackId;
    return local$trackId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$trackId,
            (e) => call(trackId: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get month {
    final local$month = _instance.month;
    return local$month == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$month,
            (e) => call(month: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get year {
    final local$year = _instance.year;
    return local$year == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$year,
            (e) => call(year: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get streamCount {
    final local$streamCount = _instance.streamCount;
    return local$streamCount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$streamCount,
            (e) => call(streamCount: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get processedAt {
    final local$processedAt = _instance.processedAt;
    return local$processedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$processedAt,
            (e) => call(processedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$MonthlyStreamCountFilterInput<TRes>
    implements CopyWith$Input$MonthlyStreamCountFilterInput<TRes> {
  _CopyWithStubImpl$Input$MonthlyStreamCountFilterInput(this._res);

  TRes _res;

  call({
    List<Input$MonthlyStreamCountFilterInput>? and,
    List<Input$MonthlyStreamCountFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$IntOperationFilterInput? month,
    Input$IntOperationFilterInput? year,
    Input$LongOperationFilterInput? streamCount,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? processedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get trackId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get month =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get year =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get streamCount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get processedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$MonthlyStreamCountSortInput {
  factory Input$MonthlyStreamCountSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? month,
    Enum$SortEnumType? year,
    Enum$SortEnumType? streamCount,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? processedAt,
  }) => Input$MonthlyStreamCountSortInput._({
    if (id != null) r'id': id,
    if (trackId != null) r'trackId': trackId,
    if (month != null) r'month': month,
    if (year != null) r'year': year,
    if (streamCount != null) r'streamCount': streamCount,
    if (createdAt != null) r'createdAt': createdAt,
    if (processedAt != null) r'processedAt': processedAt,
  });

  Input$MonthlyStreamCountSortInput._(this._$data);

  factory Input$MonthlyStreamCountSortInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('trackId')) {
      final l$trackId = data['trackId'];
      result$data['trackId'] = l$trackId == null
          ? null
          : fromJson$Enum$SortEnumType((l$trackId as String));
    }
    if (data.containsKey('month')) {
      final l$month = data['month'];
      result$data['month'] = l$month == null
          ? null
          : fromJson$Enum$SortEnumType((l$month as String));
    }
    if (data.containsKey('year')) {
      final l$year = data['year'];
      result$data['year'] = l$year == null
          ? null
          : fromJson$Enum$SortEnumType((l$year as String));
    }
    if (data.containsKey('streamCount')) {
      final l$streamCount = data['streamCount'];
      result$data['streamCount'] = l$streamCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$streamCount as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('processedAt')) {
      final l$processedAt = data['processedAt'];
      result$data['processedAt'] = l$processedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$processedAt as String));
    }
    return Input$MonthlyStreamCountSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get trackId => (_$data['trackId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get month => (_$data['month'] as Enum$SortEnumType?);

  Enum$SortEnumType? get year => (_$data['year'] as Enum$SortEnumType?);

  Enum$SortEnumType? get streamCount =>
      (_$data['streamCount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get processedAt =>
      (_$data['processedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('trackId')) {
      final l$trackId = trackId;
      result$data['trackId'] = l$trackId == null
          ? null
          : toJson$Enum$SortEnumType(l$trackId);
    }
    if (_$data.containsKey('month')) {
      final l$month = month;
      result$data['month'] = l$month == null
          ? null
          : toJson$Enum$SortEnumType(l$month);
    }
    if (_$data.containsKey('year')) {
      final l$year = year;
      result$data['year'] = l$year == null
          ? null
          : toJson$Enum$SortEnumType(l$year);
    }
    if (_$data.containsKey('streamCount')) {
      final l$streamCount = streamCount;
      result$data['streamCount'] = l$streamCount == null
          ? null
          : toJson$Enum$SortEnumType(l$streamCount);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('processedAt')) {
      final l$processedAt = processedAt;
      result$data['processedAt'] = l$processedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$processedAt);
    }
    return result$data;
  }

  CopyWith$Input$MonthlyStreamCountSortInput<Input$MonthlyStreamCountSortInput>
  get copyWith => CopyWith$Input$MonthlyStreamCountSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MonthlyStreamCountSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (_$data.containsKey('trackId') != other._$data.containsKey('trackId')) {
      return false;
    }
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$month = month;
    final lOther$month = other.month;
    if (_$data.containsKey('month') != other._$data.containsKey('month')) {
      return false;
    }
    if (l$month != lOther$month) {
      return false;
    }
    final l$year = year;
    final lOther$year = other.year;
    if (_$data.containsKey('year') != other._$data.containsKey('year')) {
      return false;
    }
    if (l$year != lOther$year) {
      return false;
    }
    final l$streamCount = streamCount;
    final lOther$streamCount = other.streamCount;
    if (_$data.containsKey('streamCount') !=
        other._$data.containsKey('streamCount')) {
      return false;
    }
    if (l$streamCount != lOther$streamCount) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$processedAt = processedAt;
    final lOther$processedAt = other.processedAt;
    if (_$data.containsKey('processedAt') !=
        other._$data.containsKey('processedAt')) {
      return false;
    }
    if (l$processedAt != lOther$processedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$trackId = trackId;
    final l$month = month;
    final l$year = year;
    final l$streamCount = streamCount;
    final l$createdAt = createdAt;
    final l$processedAt = processedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('trackId') ? l$trackId : const {},
      _$data.containsKey('month') ? l$month : const {},
      _$data.containsKey('year') ? l$year : const {},
      _$data.containsKey('streamCount') ? l$streamCount : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('processedAt') ? l$processedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$MonthlyStreamCountSortInput<TRes> {
  factory CopyWith$Input$MonthlyStreamCountSortInput(
    Input$MonthlyStreamCountSortInput instance,
    TRes Function(Input$MonthlyStreamCountSortInput) then,
  ) = _CopyWithImpl$Input$MonthlyStreamCountSortInput;

  factory CopyWith$Input$MonthlyStreamCountSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MonthlyStreamCountSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? month,
    Enum$SortEnumType? year,
    Enum$SortEnumType? streamCount,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? processedAt,
  });
}

class _CopyWithImpl$Input$MonthlyStreamCountSortInput<TRes>
    implements CopyWith$Input$MonthlyStreamCountSortInput<TRes> {
  _CopyWithImpl$Input$MonthlyStreamCountSortInput(this._instance, this._then);

  final Input$MonthlyStreamCountSortInput _instance;

  final TRes Function(Input$MonthlyStreamCountSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? trackId = _undefined,
    Object? month = _undefined,
    Object? year = _undefined,
    Object? streamCount = _undefined,
    Object? createdAt = _undefined,
    Object? processedAt = _undefined,
  }) => _then(
    Input$MonthlyStreamCountSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (trackId != _undefined) 'trackId': (trackId as Enum$SortEnumType?),
      if (month != _undefined) 'month': (month as Enum$SortEnumType?),
      if (year != _undefined) 'year': (year as Enum$SortEnumType?),
      if (streamCount != _undefined)
        'streamCount': (streamCount as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (processedAt != _undefined)
        'processedAt': (processedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$MonthlyStreamCountSortInput<TRes>
    implements CopyWith$Input$MonthlyStreamCountSortInput<TRes> {
  _CopyWithStubImpl$Input$MonthlyStreamCountSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? month,
    Enum$SortEnumType? year,
    Enum$SortEnumType? streamCount,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? processedAt,
  }) => _res;
}

class Input$NullableOfAggregationLevelOperationFilterInput {
  factory Input$NullableOfAggregationLevelOperationFilterInput({
    Enum$AggregationLevel? eq,
    Enum$AggregationLevel? neq,
    List<Enum$AggregationLevel?>? $in,
    List<Enum$AggregationLevel?>? nin,
  }) => Input$NullableOfAggregationLevelOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$NullableOfAggregationLevelOperationFilterInput._(this._$data);

  factory Input$NullableOfAggregationLevelOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$AggregationLevel((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$AggregationLevel((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map(
            (e) => e == null
                ? null
                : fromJson$Enum$AggregationLevel((e as String)),
          )
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map(
            (e) => e == null
                ? null
                : fromJson$Enum$AggregationLevel((e as String)),
          )
          .toList();
    }
    return Input$NullableOfAggregationLevelOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$AggregationLevel? get eq => (_$data['eq'] as Enum$AggregationLevel?);

  Enum$AggregationLevel? get neq => (_$data['neq'] as Enum$AggregationLevel?);

  List<Enum$AggregationLevel?>? get $in =>
      (_$data['in'] as List<Enum$AggregationLevel?>?);

  List<Enum$AggregationLevel?>? get nin =>
      (_$data['nin'] as List<Enum$AggregationLevel?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$AggregationLevel(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$AggregationLevel(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => e == null ? null : toJson$Enum$AggregationLevel(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => e == null ? null : toJson$Enum$AggregationLevel(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$NullableOfAggregationLevelOperationFilterInput<
    Input$NullableOfAggregationLevelOperationFilterInput
  >
  get copyWith => CopyWith$Input$NullableOfAggregationLevelOperationFilterInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$NullableOfAggregationLevelOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NullableOfAggregationLevelOperationFilterInput<
  TRes
> {
  factory CopyWith$Input$NullableOfAggregationLevelOperationFilterInput(
    Input$NullableOfAggregationLevelOperationFilterInput instance,
    TRes Function(Input$NullableOfAggregationLevelOperationFilterInput) then,
  ) = _CopyWithImpl$Input$NullableOfAggregationLevelOperationFilterInput;

  factory CopyWith$Input$NullableOfAggregationLevelOperationFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$NullableOfAggregationLevelOperationFilterInput;

  TRes call({
    Enum$AggregationLevel? eq,
    Enum$AggregationLevel? neq,
    List<Enum$AggregationLevel?>? $in,
    List<Enum$AggregationLevel?>? nin,
  });
}

class _CopyWithImpl$Input$NullableOfAggregationLevelOperationFilterInput<TRes>
    implements
        CopyWith$Input$NullableOfAggregationLevelOperationFilterInput<TRes> {
  _CopyWithImpl$Input$NullableOfAggregationLevelOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$NullableOfAggregationLevelOperationFilterInput _instance;

  final TRes Function(Input$NullableOfAggregationLevelOperationFilterInput)
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$NullableOfAggregationLevelOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$AggregationLevel?),
      if (neq != _undefined) 'neq': (neq as Enum$AggregationLevel?),
      if ($in != _undefined) 'in': ($in as List<Enum$AggregationLevel?>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$AggregationLevel?>?),
    }),
  );
}

class _CopyWithStubImpl$Input$NullableOfAggregationLevelOperationFilterInput<
  TRes
>
    implements
        CopyWith$Input$NullableOfAggregationLevelOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$NullableOfAggregationLevelOperationFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Enum$AggregationLevel? eq,
    Enum$AggregationLevel? neq,
    List<Enum$AggregationLevel?>? $in,
    List<Enum$AggregationLevel?>? nin,
  }) => _res;
}

class Input$NullableOfReportActionOperationFilterInput {
  factory Input$NullableOfReportActionOperationFilterInput({
    Enum$ReportAction? eq,
    Enum$ReportAction? neq,
    List<Enum$ReportAction?>? $in,
    List<Enum$ReportAction?>? nin,
  }) => Input$NullableOfReportActionOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$NullableOfReportActionOperationFilterInput._(this._$data);

  factory Input$NullableOfReportActionOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$ReportAction((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$ReportAction((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map(
            (e) => e == null ? null : fromJson$Enum$ReportAction((e as String)),
          )
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map(
            (e) => e == null ? null : fromJson$Enum$ReportAction((e as String)),
          )
          .toList();
    }
    return Input$NullableOfReportActionOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ReportAction? get eq => (_$data['eq'] as Enum$ReportAction?);

  Enum$ReportAction? get neq => (_$data['neq'] as Enum$ReportAction?);

  List<Enum$ReportAction?>? get $in =>
      (_$data['in'] as List<Enum$ReportAction?>?);

  List<Enum$ReportAction?>? get nin =>
      (_$data['nin'] as List<Enum$ReportAction?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$ReportAction(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$ReportAction(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => e == null ? null : toJson$Enum$ReportAction(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => e == null ? null : toJson$Enum$ReportAction(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$NullableOfReportActionOperationFilterInput<
    Input$NullableOfReportActionOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$NullableOfReportActionOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$NullableOfReportActionOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NullableOfReportActionOperationFilterInput<TRes> {
  factory CopyWith$Input$NullableOfReportActionOperationFilterInput(
    Input$NullableOfReportActionOperationFilterInput instance,
    TRes Function(Input$NullableOfReportActionOperationFilterInput) then,
  ) = _CopyWithImpl$Input$NullableOfReportActionOperationFilterInput;

  factory CopyWith$Input$NullableOfReportActionOperationFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$NullableOfReportActionOperationFilterInput;

  TRes call({
    Enum$ReportAction? eq,
    Enum$ReportAction? neq,
    List<Enum$ReportAction?>? $in,
    List<Enum$ReportAction?>? nin,
  });
}

class _CopyWithImpl$Input$NullableOfReportActionOperationFilterInput<TRes>
    implements CopyWith$Input$NullableOfReportActionOperationFilterInput<TRes> {
  _CopyWithImpl$Input$NullableOfReportActionOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$NullableOfReportActionOperationFilterInput _instance;

  final TRes Function(Input$NullableOfReportActionOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$NullableOfReportActionOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$ReportAction?),
      if (neq != _undefined) 'neq': (neq as Enum$ReportAction?),
      if ($in != _undefined) 'in': ($in as List<Enum$ReportAction?>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$ReportAction?>?),
    }),
  );
}

class _CopyWithStubImpl$Input$NullableOfReportActionOperationFilterInput<TRes>
    implements CopyWith$Input$NullableOfReportActionOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$NullableOfReportActionOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$ReportAction? eq,
    Enum$ReportAction? neq,
    List<Enum$ReportAction?>? $in,
    List<Enum$ReportAction?>? nin,
  }) => _res;
}

class Input$NullableOfReportRelatedContentTypeOperationFilterInput {
  factory Input$NullableOfReportRelatedContentTypeOperationFilterInput({
    Enum$ReportRelatedContentType? eq,
    Enum$ReportRelatedContentType? neq,
    List<Enum$ReportRelatedContentType?>? $in,
    List<Enum$ReportRelatedContentType?>? nin,
  }) => Input$NullableOfReportRelatedContentTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$NullableOfReportRelatedContentTypeOperationFilterInput._(this._$data);

  factory Input$NullableOfReportRelatedContentTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$ReportRelatedContentType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$ReportRelatedContentType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map(
            (e) => e == null
                ? null
                : fromJson$Enum$ReportRelatedContentType((e as String)),
          )
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map(
            (e) => e == null
                ? null
                : fromJson$Enum$ReportRelatedContentType((e as String)),
          )
          .toList();
    }
    return Input$NullableOfReportRelatedContentTypeOperationFilterInput._(
      result$data,
    );
  }

  Map<String, dynamic> _$data;

  Enum$ReportRelatedContentType? get eq =>
      (_$data['eq'] as Enum$ReportRelatedContentType?);

  Enum$ReportRelatedContentType? get neq =>
      (_$data['neq'] as Enum$ReportRelatedContentType?);

  List<Enum$ReportRelatedContentType?>? get $in =>
      (_$data['in'] as List<Enum$ReportRelatedContentType?>?);

  List<Enum$ReportRelatedContentType?>? get nin =>
      (_$data['nin'] as List<Enum$ReportRelatedContentType?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$ReportRelatedContentType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$ReportRelatedContentType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map(
            (e) => e == null ? null : toJson$Enum$ReportRelatedContentType(e),
          )
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map(
            (e) => e == null ? null : toJson$Enum$ReportRelatedContentType(e),
          )
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput<
    Input$NullableOfReportRelatedContentTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$NullableOfReportRelatedContentTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput<
  TRes
> {
  factory CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput(
    Input$NullableOfReportRelatedContentTypeOperationFilterInput instance,
    TRes Function(Input$NullableOfReportRelatedContentTypeOperationFilterInput)
    then,
  ) = _CopyWithImpl$Input$NullableOfReportRelatedContentTypeOperationFilterInput;

  factory CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$NullableOfReportRelatedContentTypeOperationFilterInput;

  TRes call({
    Enum$ReportRelatedContentType? eq,
    Enum$ReportRelatedContentType? neq,
    List<Enum$ReportRelatedContentType?>? $in,
    List<Enum$ReportRelatedContentType?>? nin,
  });
}

class _CopyWithImpl$Input$NullableOfReportRelatedContentTypeOperationFilterInput<
  TRes
>
    implements
        CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput<
          TRes
        > {
  _CopyWithImpl$Input$NullableOfReportRelatedContentTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$NullableOfReportRelatedContentTypeOperationFilterInput _instance;

  final TRes Function(
    Input$NullableOfReportRelatedContentTypeOperationFilterInput,
  )
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$NullableOfReportRelatedContentTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$ReportRelatedContentType?),
      if (neq != _undefined) 'neq': (neq as Enum$ReportRelatedContentType?),
      if ($in != _undefined)
        'in': ($in as List<Enum$ReportRelatedContentType?>?),
      if (nin != _undefined)
        'nin': (nin as List<Enum$ReportRelatedContentType?>?),
    }),
  );
}

class _CopyWithStubImpl$Input$NullableOfReportRelatedContentTypeOperationFilterInput<
  TRes
>
    implements
        CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput<
          TRes
        > {
  _CopyWithStubImpl$Input$NullableOfReportRelatedContentTypeOperationFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Enum$ReportRelatedContentType? eq,
    Enum$ReportRelatedContentType? neq,
    List<Enum$ReportRelatedContentType?>? $in,
    List<Enum$ReportRelatedContentType?>? nin,
  }) => _res;
}

class Input$NullableOfRestrictionActionOperationFilterInput {
  factory Input$NullableOfRestrictionActionOperationFilterInput({
    Enum$RestrictionAction? eq,
    Enum$RestrictionAction? neq,
    List<Enum$RestrictionAction?>? $in,
    List<Enum$RestrictionAction?>? nin,
  }) => Input$NullableOfRestrictionActionOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$NullableOfRestrictionActionOperationFilterInput._(this._$data);

  factory Input$NullableOfRestrictionActionOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$RestrictionAction((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$RestrictionAction((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map(
            (e) => e == null
                ? null
                : fromJson$Enum$RestrictionAction((e as String)),
          )
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map(
            (e) => e == null
                ? null
                : fromJson$Enum$RestrictionAction((e as String)),
          )
          .toList();
    }
    return Input$NullableOfRestrictionActionOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RestrictionAction? get eq => (_$data['eq'] as Enum$RestrictionAction?);

  Enum$RestrictionAction? get neq => (_$data['neq'] as Enum$RestrictionAction?);

  List<Enum$RestrictionAction?>? get $in =>
      (_$data['in'] as List<Enum$RestrictionAction?>?);

  List<Enum$RestrictionAction?>? get nin =>
      (_$data['nin'] as List<Enum$RestrictionAction?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$RestrictionAction(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$RestrictionAction(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => e == null ? null : toJson$Enum$RestrictionAction(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => e == null ? null : toJson$Enum$RestrictionAction(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$NullableOfRestrictionActionOperationFilterInput<
    Input$NullableOfRestrictionActionOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$NullableOfRestrictionActionOperationFilterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$NullableOfRestrictionActionOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NullableOfRestrictionActionOperationFilterInput<
  TRes
> {
  factory CopyWith$Input$NullableOfRestrictionActionOperationFilterInput(
    Input$NullableOfRestrictionActionOperationFilterInput instance,
    TRes Function(Input$NullableOfRestrictionActionOperationFilterInput) then,
  ) = _CopyWithImpl$Input$NullableOfRestrictionActionOperationFilterInput;

  factory CopyWith$Input$NullableOfRestrictionActionOperationFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$NullableOfRestrictionActionOperationFilterInput;

  TRes call({
    Enum$RestrictionAction? eq,
    Enum$RestrictionAction? neq,
    List<Enum$RestrictionAction?>? $in,
    List<Enum$RestrictionAction?>? nin,
  });
}

class _CopyWithImpl$Input$NullableOfRestrictionActionOperationFilterInput<TRes>
    implements
        CopyWith$Input$NullableOfRestrictionActionOperationFilterInput<TRes> {
  _CopyWithImpl$Input$NullableOfRestrictionActionOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$NullableOfRestrictionActionOperationFilterInput _instance;

  final TRes Function(Input$NullableOfRestrictionActionOperationFilterInput)
  _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$NullableOfRestrictionActionOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$RestrictionAction?),
      if (neq != _undefined) 'neq': (neq as Enum$RestrictionAction?),
      if ($in != _undefined) 'in': ($in as List<Enum$RestrictionAction?>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$RestrictionAction?>?),
    }),
  );
}

class _CopyWithStubImpl$Input$NullableOfRestrictionActionOperationFilterInput<
  TRes
>
    implements
        CopyWith$Input$NullableOfRestrictionActionOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$NullableOfRestrictionActionOperationFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Enum$RestrictionAction? eq,
    Enum$RestrictionAction? neq,
    List<Enum$RestrictionAction?>? $in,
    List<Enum$RestrictionAction?>? nin,
  }) => _res;
}

class Input$OneOffSnapshotFilterInput {
  factory Input$OneOffSnapshotFilterInput({
    List<Input$OneOffSnapshotFilterInput>? and,
    List<Input$OneOffSnapshotFilterInput>? or,
    Input$StringOperationFilterInput? packageName,
    Input$DecimalOperationFilterInput? packageAmount,
    Input$CurrencyTypeOperationFilterInput? packageCurrency,
    Input$IntOperationFilterInput? estimateDeliveryDays,
    Input$StringOperationFilterInput? packageDescription,
    Input$IntOperationFilterInput? maxRevision,
    Input$ListFilterInputTypeOfMetadataFilterInput? serviceDetails,
    Input$ArtistPackageStatusOperationFilterInput? artistPackageStatus,
    Input$DateTimeOperationFilterInput? deadline,
    Input$DecimalOperationFilterInput? platformFeePercentage,
    Input$DecimalOperationFilterInput? artistFeePercentage,
    Input$OneOffTypeOperationFilterInput? oneOffType,
  }) => Input$OneOffSnapshotFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (packageName != null) r'packageName': packageName,
    if (packageAmount != null) r'packageAmount': packageAmount,
    if (packageCurrency != null) r'packageCurrency': packageCurrency,
    if (estimateDeliveryDays != null)
      r'estimateDeliveryDays': estimateDeliveryDays,
    if (packageDescription != null) r'packageDescription': packageDescription,
    if (maxRevision != null) r'maxRevision': maxRevision,
    if (serviceDetails != null) r'serviceDetails': serviceDetails,
    if (artistPackageStatus != null)
      r'artistPackageStatus': artistPackageStatus,
    if (deadline != null) r'deadline': deadline,
    if (platformFeePercentage != null)
      r'platformFeePercentage': platformFeePercentage,
    if (artistFeePercentage != null)
      r'artistFeePercentage': artistFeePercentage,
    if (oneOffType != null) r'oneOffType': oneOffType,
  });

  Input$OneOffSnapshotFilterInput._(this._$data);

  factory Input$OneOffSnapshotFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$OneOffSnapshotFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$OneOffSnapshotFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('packageName')) {
      final l$packageName = data['packageName'];
      result$data['packageName'] = l$packageName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$packageName as Map<String, dynamic>),
            );
    }
    if (data.containsKey('packageAmount')) {
      final l$packageAmount = data['packageAmount'];
      result$data['packageAmount'] = l$packageAmount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$packageAmount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('packageCurrency')) {
      final l$packageCurrency = data['packageCurrency'];
      result$data['packageCurrency'] = l$packageCurrency == null
          ? null
          : Input$CurrencyTypeOperationFilterInput.fromJson(
              (l$packageCurrency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('estimateDeliveryDays')) {
      final l$estimateDeliveryDays = data['estimateDeliveryDays'];
      result$data['estimateDeliveryDays'] = l$estimateDeliveryDays == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$estimateDeliveryDays as Map<String, dynamic>),
            );
    }
    if (data.containsKey('packageDescription')) {
      final l$packageDescription = data['packageDescription'];
      result$data['packageDescription'] = l$packageDescription == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$packageDescription as Map<String, dynamic>),
            );
    }
    if (data.containsKey('maxRevision')) {
      final l$maxRevision = data['maxRevision'];
      result$data['maxRevision'] = l$maxRevision == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$maxRevision as Map<String, dynamic>),
            );
    }
    if (data.containsKey('serviceDetails')) {
      final l$serviceDetails = data['serviceDetails'];
      result$data['serviceDetails'] = l$serviceDetails == null
          ? null
          : Input$ListFilterInputTypeOfMetadataFilterInput.fromJson(
              (l$serviceDetails as Map<String, dynamic>),
            );
    }
    if (data.containsKey('artistPackageStatus')) {
      final l$artistPackageStatus = data['artistPackageStatus'];
      result$data['artistPackageStatus'] = l$artistPackageStatus == null
          ? null
          : Input$ArtistPackageStatusOperationFilterInput.fromJson(
              (l$artistPackageStatus as Map<String, dynamic>),
            );
    }
    if (data.containsKey('deadline')) {
      final l$deadline = data['deadline'];
      result$data['deadline'] = l$deadline == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$deadline as Map<String, dynamic>),
            );
    }
    if (data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = data['platformFeePercentage'];
      result$data['platformFeePercentage'] = l$platformFeePercentage == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$platformFeePercentage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('artistFeePercentage')) {
      final l$artistFeePercentage = data['artistFeePercentage'];
      result$data['artistFeePercentage'] = l$artistFeePercentage == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$artistFeePercentage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('oneOffType')) {
      final l$oneOffType = data['oneOffType'];
      result$data['oneOffType'] = l$oneOffType == null
          ? null
          : Input$OneOffTypeOperationFilterInput.fromJson(
              (l$oneOffType as Map<String, dynamic>),
            );
    }
    return Input$OneOffSnapshotFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$OneOffSnapshotFilterInput>? get and =>
      (_$data['and'] as List<Input$OneOffSnapshotFilterInput>?);

  List<Input$OneOffSnapshotFilterInput>? get or =>
      (_$data['or'] as List<Input$OneOffSnapshotFilterInput>?);

  Input$StringOperationFilterInput? get packageName =>
      (_$data['packageName'] as Input$StringOperationFilterInput?);

  Input$DecimalOperationFilterInput? get packageAmount =>
      (_$data['packageAmount'] as Input$DecimalOperationFilterInput?);

  Input$CurrencyTypeOperationFilterInput? get packageCurrency =>
      (_$data['packageCurrency'] as Input$CurrencyTypeOperationFilterInput?);

  Input$IntOperationFilterInput? get estimateDeliveryDays =>
      (_$data['estimateDeliveryDays'] as Input$IntOperationFilterInput?);

  Input$StringOperationFilterInput? get packageDescription =>
      (_$data['packageDescription'] as Input$StringOperationFilterInput?);

  Input$IntOperationFilterInput? get maxRevision =>
      (_$data['maxRevision'] as Input$IntOperationFilterInput?);

  Input$ListFilterInputTypeOfMetadataFilterInput? get serviceDetails =>
      (_$data['serviceDetails']
          as Input$ListFilterInputTypeOfMetadataFilterInput?);

  Input$ArtistPackageStatusOperationFilterInput? get artistPackageStatus =>
      (_$data['artistPackageStatus']
          as Input$ArtistPackageStatusOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get deadline =>
      (_$data['deadline'] as Input$DateTimeOperationFilterInput?);

  Input$DecimalOperationFilterInput? get platformFeePercentage =>
      (_$data['platformFeePercentage'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get artistFeePercentage =>
      (_$data['artistFeePercentage'] as Input$DecimalOperationFilterInput?);

  Input$OneOffTypeOperationFilterInput? get oneOffType =>
      (_$data['oneOffType'] as Input$OneOffTypeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('packageName')) {
      final l$packageName = packageName;
      result$data['packageName'] = l$packageName?.toJson();
    }
    if (_$data.containsKey('packageAmount')) {
      final l$packageAmount = packageAmount;
      result$data['packageAmount'] = l$packageAmount?.toJson();
    }
    if (_$data.containsKey('packageCurrency')) {
      final l$packageCurrency = packageCurrency;
      result$data['packageCurrency'] = l$packageCurrency?.toJson();
    }
    if (_$data.containsKey('estimateDeliveryDays')) {
      final l$estimateDeliveryDays = estimateDeliveryDays;
      result$data['estimateDeliveryDays'] = l$estimateDeliveryDays?.toJson();
    }
    if (_$data.containsKey('packageDescription')) {
      final l$packageDescription = packageDescription;
      result$data['packageDescription'] = l$packageDescription?.toJson();
    }
    if (_$data.containsKey('maxRevision')) {
      final l$maxRevision = maxRevision;
      result$data['maxRevision'] = l$maxRevision?.toJson();
    }
    if (_$data.containsKey('serviceDetails')) {
      final l$serviceDetails = serviceDetails;
      result$data['serviceDetails'] = l$serviceDetails?.toJson();
    }
    if (_$data.containsKey('artistPackageStatus')) {
      final l$artistPackageStatus = artistPackageStatus;
      result$data['artistPackageStatus'] = l$artistPackageStatus?.toJson();
    }
    if (_$data.containsKey('deadline')) {
      final l$deadline = deadline;
      result$data['deadline'] = l$deadline?.toJson();
    }
    if (_$data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = platformFeePercentage;
      result$data['platformFeePercentage'] = l$platformFeePercentage?.toJson();
    }
    if (_$data.containsKey('artistFeePercentage')) {
      final l$artistFeePercentage = artistFeePercentage;
      result$data['artistFeePercentage'] = l$artistFeePercentage?.toJson();
    }
    if (_$data.containsKey('oneOffType')) {
      final l$oneOffType = oneOffType;
      result$data['oneOffType'] = l$oneOffType?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$OneOffSnapshotFilterInput<Input$OneOffSnapshotFilterInput>
  get copyWith => CopyWith$Input$OneOffSnapshotFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OneOffSnapshotFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$packageName = packageName;
    final lOther$packageName = other.packageName;
    if (_$data.containsKey('packageName') !=
        other._$data.containsKey('packageName')) {
      return false;
    }
    if (l$packageName != lOther$packageName) {
      return false;
    }
    final l$packageAmount = packageAmount;
    final lOther$packageAmount = other.packageAmount;
    if (_$data.containsKey('packageAmount') !=
        other._$data.containsKey('packageAmount')) {
      return false;
    }
    if (l$packageAmount != lOther$packageAmount) {
      return false;
    }
    final l$packageCurrency = packageCurrency;
    final lOther$packageCurrency = other.packageCurrency;
    if (_$data.containsKey('packageCurrency') !=
        other._$data.containsKey('packageCurrency')) {
      return false;
    }
    if (l$packageCurrency != lOther$packageCurrency) {
      return false;
    }
    final l$estimateDeliveryDays = estimateDeliveryDays;
    final lOther$estimateDeliveryDays = other.estimateDeliveryDays;
    if (_$data.containsKey('estimateDeliveryDays') !=
        other._$data.containsKey('estimateDeliveryDays')) {
      return false;
    }
    if (l$estimateDeliveryDays != lOther$estimateDeliveryDays) {
      return false;
    }
    final l$packageDescription = packageDescription;
    final lOther$packageDescription = other.packageDescription;
    if (_$data.containsKey('packageDescription') !=
        other._$data.containsKey('packageDescription')) {
      return false;
    }
    if (l$packageDescription != lOther$packageDescription) {
      return false;
    }
    final l$maxRevision = maxRevision;
    final lOther$maxRevision = other.maxRevision;
    if (_$data.containsKey('maxRevision') !=
        other._$data.containsKey('maxRevision')) {
      return false;
    }
    if (l$maxRevision != lOther$maxRevision) {
      return false;
    }
    final l$serviceDetails = serviceDetails;
    final lOther$serviceDetails = other.serviceDetails;
    if (_$data.containsKey('serviceDetails') !=
        other._$data.containsKey('serviceDetails')) {
      return false;
    }
    if (l$serviceDetails != lOther$serviceDetails) {
      return false;
    }
    final l$artistPackageStatus = artistPackageStatus;
    final lOther$artistPackageStatus = other.artistPackageStatus;
    if (_$data.containsKey('artistPackageStatus') !=
        other._$data.containsKey('artistPackageStatus')) {
      return false;
    }
    if (l$artistPackageStatus != lOther$artistPackageStatus) {
      return false;
    }
    final l$deadline = deadline;
    final lOther$deadline = other.deadline;
    if (_$data.containsKey('deadline') !=
        other._$data.containsKey('deadline')) {
      return false;
    }
    if (l$deadline != lOther$deadline) {
      return false;
    }
    final l$platformFeePercentage = platformFeePercentage;
    final lOther$platformFeePercentage = other.platformFeePercentage;
    if (_$data.containsKey('platformFeePercentage') !=
        other._$data.containsKey('platformFeePercentage')) {
      return false;
    }
    if (l$platformFeePercentage != lOther$platformFeePercentage) {
      return false;
    }
    final l$artistFeePercentage = artistFeePercentage;
    final lOther$artistFeePercentage = other.artistFeePercentage;
    if (_$data.containsKey('artistFeePercentage') !=
        other._$data.containsKey('artistFeePercentage')) {
      return false;
    }
    if (l$artistFeePercentage != lOther$artistFeePercentage) {
      return false;
    }
    final l$oneOffType = oneOffType;
    final lOther$oneOffType = other.oneOffType;
    if (_$data.containsKey('oneOffType') !=
        other._$data.containsKey('oneOffType')) {
      return false;
    }
    if (l$oneOffType != lOther$oneOffType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$packageName = packageName;
    final l$packageAmount = packageAmount;
    final l$packageCurrency = packageCurrency;
    final l$estimateDeliveryDays = estimateDeliveryDays;
    final l$packageDescription = packageDescription;
    final l$maxRevision = maxRevision;
    final l$serviceDetails = serviceDetails;
    final l$artistPackageStatus = artistPackageStatus;
    final l$deadline = deadline;
    final l$platformFeePercentage = platformFeePercentage;
    final l$artistFeePercentage = artistFeePercentage;
    final l$oneOffType = oneOffType;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('packageName') ? l$packageName : const {},
      _$data.containsKey('packageAmount') ? l$packageAmount : const {},
      _$data.containsKey('packageCurrency') ? l$packageCurrency : const {},
      _$data.containsKey('estimateDeliveryDays')
          ? l$estimateDeliveryDays
          : const {},
      _$data.containsKey('packageDescription')
          ? l$packageDescription
          : const {},
      _$data.containsKey('maxRevision') ? l$maxRevision : const {},
      _$data.containsKey('serviceDetails') ? l$serviceDetails : const {},
      _$data.containsKey('artistPackageStatus')
          ? l$artistPackageStatus
          : const {},
      _$data.containsKey('deadline') ? l$deadline : const {},
      _$data.containsKey('platformFeePercentage')
          ? l$platformFeePercentage
          : const {},
      _$data.containsKey('artistFeePercentage')
          ? l$artistFeePercentage
          : const {},
      _$data.containsKey('oneOffType') ? l$oneOffType : const {},
    ]);
  }
}

abstract class CopyWith$Input$OneOffSnapshotFilterInput<TRes> {
  factory CopyWith$Input$OneOffSnapshotFilterInput(
    Input$OneOffSnapshotFilterInput instance,
    TRes Function(Input$OneOffSnapshotFilterInput) then,
  ) = _CopyWithImpl$Input$OneOffSnapshotFilterInput;

  factory CopyWith$Input$OneOffSnapshotFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OneOffSnapshotFilterInput;

  TRes call({
    List<Input$OneOffSnapshotFilterInput>? and,
    List<Input$OneOffSnapshotFilterInput>? or,
    Input$StringOperationFilterInput? packageName,
    Input$DecimalOperationFilterInput? packageAmount,
    Input$CurrencyTypeOperationFilterInput? packageCurrency,
    Input$IntOperationFilterInput? estimateDeliveryDays,
    Input$StringOperationFilterInput? packageDescription,
    Input$IntOperationFilterInput? maxRevision,
    Input$ListFilterInputTypeOfMetadataFilterInput? serviceDetails,
    Input$ArtistPackageStatusOperationFilterInput? artistPackageStatus,
    Input$DateTimeOperationFilterInput? deadline,
    Input$DecimalOperationFilterInput? platformFeePercentage,
    Input$DecimalOperationFilterInput? artistFeePercentage,
    Input$OneOffTypeOperationFilterInput? oneOffType,
  });
  TRes and(
    Iterable<Input$OneOffSnapshotFilterInput>? Function(
      Iterable<
        CopyWith$Input$OneOffSnapshotFilterInput<
          Input$OneOffSnapshotFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$OneOffSnapshotFilterInput>? Function(
      Iterable<
        CopyWith$Input$OneOffSnapshotFilterInput<
          Input$OneOffSnapshotFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get packageName;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get packageAmount;
  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get packageCurrency;
  CopyWith$Input$IntOperationFilterInput<TRes> get estimateDeliveryDays;
  CopyWith$Input$StringOperationFilterInput<TRes> get packageDescription;
  CopyWith$Input$IntOperationFilterInput<TRes> get maxRevision;
  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get serviceDetails;
  CopyWith$Input$ArtistPackageStatusOperationFilterInput<TRes>
  get artistPackageStatus;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deadline;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get platformFeePercentage;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get artistFeePercentage;
  CopyWith$Input$OneOffTypeOperationFilterInput<TRes> get oneOffType;
}

class _CopyWithImpl$Input$OneOffSnapshotFilterInput<TRes>
    implements CopyWith$Input$OneOffSnapshotFilterInput<TRes> {
  _CopyWithImpl$Input$OneOffSnapshotFilterInput(this._instance, this._then);

  final Input$OneOffSnapshotFilterInput _instance;

  final TRes Function(Input$OneOffSnapshotFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? packageName = _undefined,
    Object? packageAmount = _undefined,
    Object? packageCurrency = _undefined,
    Object? estimateDeliveryDays = _undefined,
    Object? packageDescription = _undefined,
    Object? maxRevision = _undefined,
    Object? serviceDetails = _undefined,
    Object? artistPackageStatus = _undefined,
    Object? deadline = _undefined,
    Object? platformFeePercentage = _undefined,
    Object? artistFeePercentage = _undefined,
    Object? oneOffType = _undefined,
  }) => _then(
    Input$OneOffSnapshotFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$OneOffSnapshotFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$OneOffSnapshotFilterInput>?),
      if (packageName != _undefined)
        'packageName': (packageName as Input$StringOperationFilterInput?),
      if (packageAmount != _undefined)
        'packageAmount': (packageAmount as Input$DecimalOperationFilterInput?),
      if (packageCurrency != _undefined)
        'packageCurrency':
            (packageCurrency as Input$CurrencyTypeOperationFilterInput?),
      if (estimateDeliveryDays != _undefined)
        'estimateDeliveryDays':
            (estimateDeliveryDays as Input$IntOperationFilterInput?),
      if (packageDescription != _undefined)
        'packageDescription':
            (packageDescription as Input$StringOperationFilterInput?),
      if (maxRevision != _undefined)
        'maxRevision': (maxRevision as Input$IntOperationFilterInput?),
      if (serviceDetails != _undefined)
        'serviceDetails':
            (serviceDetails as Input$ListFilterInputTypeOfMetadataFilterInput?),
      if (artistPackageStatus != _undefined)
        'artistPackageStatus':
            (artistPackageStatus
                as Input$ArtistPackageStatusOperationFilterInput?),
      if (deadline != _undefined)
        'deadline': (deadline as Input$DateTimeOperationFilterInput?),
      if (platformFeePercentage != _undefined)
        'platformFeePercentage':
            (platformFeePercentage as Input$DecimalOperationFilterInput?),
      if (artistFeePercentage != _undefined)
        'artistFeePercentage':
            (artistFeePercentage as Input$DecimalOperationFilterInput?),
      if (oneOffType != _undefined)
        'oneOffType': (oneOffType as Input$OneOffTypeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$OneOffSnapshotFilterInput>? Function(
      Iterable<
        CopyWith$Input$OneOffSnapshotFilterInput<
          Input$OneOffSnapshotFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$OneOffSnapshotFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$OneOffSnapshotFilterInput>? Function(
      Iterable<
        CopyWith$Input$OneOffSnapshotFilterInput<
          Input$OneOffSnapshotFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$OneOffSnapshotFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get packageName {
    final local$packageName = _instance.packageName;
    return local$packageName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$packageName,
            (e) => call(packageName: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get packageAmount {
    final local$packageAmount = _instance.packageAmount;
    return local$packageAmount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$packageAmount,
            (e) => call(packageAmount: e),
          );
  }

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get packageCurrency {
    final local$packageCurrency = _instance.packageCurrency;
    return local$packageCurrency == null
        ? CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CurrencyTypeOperationFilterInput(
            local$packageCurrency,
            (e) => call(packageCurrency: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get estimateDeliveryDays {
    final local$estimateDeliveryDays = _instance.estimateDeliveryDays;
    return local$estimateDeliveryDays == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$estimateDeliveryDays,
            (e) => call(estimateDeliveryDays: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get packageDescription {
    final local$packageDescription = _instance.packageDescription;
    return local$packageDescription == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$packageDescription,
            (e) => call(packageDescription: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get maxRevision {
    final local$maxRevision = _instance.maxRevision;
    return local$maxRevision == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$maxRevision,
            (e) => call(maxRevision: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get serviceDetails {
    final local$serviceDetails = _instance.serviceDetails;
    return local$serviceDetails == null
        ? CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput(
            local$serviceDetails,
            (e) => call(serviceDetails: e),
          );
  }

  CopyWith$Input$ArtistPackageStatusOperationFilterInput<TRes>
  get artistPackageStatus {
    final local$artistPackageStatus = _instance.artistPackageStatus;
    return local$artistPackageStatus == null
        ? CopyWith$Input$ArtistPackageStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ArtistPackageStatusOperationFilterInput(
            local$artistPackageStatus,
            (e) => call(artistPackageStatus: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deadline {
    final local$deadline = _instance.deadline;
    return local$deadline == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$deadline,
            (e) => call(deadline: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get platformFeePercentage {
    final local$platformFeePercentage = _instance.platformFeePercentage;
    return local$platformFeePercentage == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$platformFeePercentage,
            (e) => call(platformFeePercentage: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get artistFeePercentage {
    final local$artistFeePercentage = _instance.artistFeePercentage;
    return local$artistFeePercentage == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$artistFeePercentage,
            (e) => call(artistFeePercentage: e),
          );
  }

  CopyWith$Input$OneOffTypeOperationFilterInput<TRes> get oneOffType {
    final local$oneOffType = _instance.oneOffType;
    return local$oneOffType == null
        ? CopyWith$Input$OneOffTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$OneOffTypeOperationFilterInput(
            local$oneOffType,
            (e) => call(oneOffType: e),
          );
  }
}

class _CopyWithStubImpl$Input$OneOffSnapshotFilterInput<TRes>
    implements CopyWith$Input$OneOffSnapshotFilterInput<TRes> {
  _CopyWithStubImpl$Input$OneOffSnapshotFilterInput(this._res);

  TRes _res;

  call({
    List<Input$OneOffSnapshotFilterInput>? and,
    List<Input$OneOffSnapshotFilterInput>? or,
    Input$StringOperationFilterInput? packageName,
    Input$DecimalOperationFilterInput? packageAmount,
    Input$CurrencyTypeOperationFilterInput? packageCurrency,
    Input$IntOperationFilterInput? estimateDeliveryDays,
    Input$StringOperationFilterInput? packageDescription,
    Input$IntOperationFilterInput? maxRevision,
    Input$ListFilterInputTypeOfMetadataFilterInput? serviceDetails,
    Input$ArtistPackageStatusOperationFilterInput? artistPackageStatus,
    Input$DateTimeOperationFilterInput? deadline,
    Input$DecimalOperationFilterInput? platformFeePercentage,
    Input$DecimalOperationFilterInput? artistFeePercentage,
    Input$OneOffTypeOperationFilterInput? oneOffType,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get packageName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get packageAmount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get packageCurrency =>
      CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get estimateDeliveryDays =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get packageDescription =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get maxRevision =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get serviceDetails =>
      CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput.stub(_res);

  CopyWith$Input$ArtistPackageStatusOperationFilterInput<TRes>
  get artistPackageStatus =>
      CopyWith$Input$ArtistPackageStatusOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deadline =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get platformFeePercentage =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get artistFeePercentage =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$OneOffTypeOperationFilterInput<TRes> get oneOffType =>
      CopyWith$Input$OneOffTypeOperationFilterInput.stub(_res);
}

class Input$OneOffSnapshotSortInput {
  factory Input$OneOffSnapshotSortInput({
    Enum$SortEnumType? packageName,
    Enum$SortEnumType? packageAmount,
    Enum$SortEnumType? packageCurrency,
    Enum$SortEnumType? estimateDeliveryDays,
    Enum$SortEnumType? packageDescription,
    Enum$SortEnumType? maxRevision,
    Enum$SortEnumType? artistPackageStatus,
    Enum$SortEnumType? deadline,
    Enum$SortEnumType? platformFeePercentage,
    Enum$SortEnumType? artistFeePercentage,
    Enum$SortEnumType? oneOffType,
  }) => Input$OneOffSnapshotSortInput._({
    if (packageName != null) r'packageName': packageName,
    if (packageAmount != null) r'packageAmount': packageAmount,
    if (packageCurrency != null) r'packageCurrency': packageCurrency,
    if (estimateDeliveryDays != null)
      r'estimateDeliveryDays': estimateDeliveryDays,
    if (packageDescription != null) r'packageDescription': packageDescription,
    if (maxRevision != null) r'maxRevision': maxRevision,
    if (artistPackageStatus != null)
      r'artistPackageStatus': artistPackageStatus,
    if (deadline != null) r'deadline': deadline,
    if (platformFeePercentage != null)
      r'platformFeePercentage': platformFeePercentage,
    if (artistFeePercentage != null)
      r'artistFeePercentage': artistFeePercentage,
    if (oneOffType != null) r'oneOffType': oneOffType,
  });

  Input$OneOffSnapshotSortInput._(this._$data);

  factory Input$OneOffSnapshotSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('packageName')) {
      final l$packageName = data['packageName'];
      result$data['packageName'] = l$packageName == null
          ? null
          : fromJson$Enum$SortEnumType((l$packageName as String));
    }
    if (data.containsKey('packageAmount')) {
      final l$packageAmount = data['packageAmount'];
      result$data['packageAmount'] = l$packageAmount == null
          ? null
          : fromJson$Enum$SortEnumType((l$packageAmount as String));
    }
    if (data.containsKey('packageCurrency')) {
      final l$packageCurrency = data['packageCurrency'];
      result$data['packageCurrency'] = l$packageCurrency == null
          ? null
          : fromJson$Enum$SortEnumType((l$packageCurrency as String));
    }
    if (data.containsKey('estimateDeliveryDays')) {
      final l$estimateDeliveryDays = data['estimateDeliveryDays'];
      result$data['estimateDeliveryDays'] = l$estimateDeliveryDays == null
          ? null
          : fromJson$Enum$SortEnumType((l$estimateDeliveryDays as String));
    }
    if (data.containsKey('packageDescription')) {
      final l$packageDescription = data['packageDescription'];
      result$data['packageDescription'] = l$packageDescription == null
          ? null
          : fromJson$Enum$SortEnumType((l$packageDescription as String));
    }
    if (data.containsKey('maxRevision')) {
      final l$maxRevision = data['maxRevision'];
      result$data['maxRevision'] = l$maxRevision == null
          ? null
          : fromJson$Enum$SortEnumType((l$maxRevision as String));
    }
    if (data.containsKey('artistPackageStatus')) {
      final l$artistPackageStatus = data['artistPackageStatus'];
      result$data['artistPackageStatus'] = l$artistPackageStatus == null
          ? null
          : fromJson$Enum$SortEnumType((l$artistPackageStatus as String));
    }
    if (data.containsKey('deadline')) {
      final l$deadline = data['deadline'];
      result$data['deadline'] = l$deadline == null
          ? null
          : fromJson$Enum$SortEnumType((l$deadline as String));
    }
    if (data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = data['platformFeePercentage'];
      result$data['platformFeePercentage'] = l$platformFeePercentage == null
          ? null
          : fromJson$Enum$SortEnumType((l$platformFeePercentage as String));
    }
    if (data.containsKey('artistFeePercentage')) {
      final l$artistFeePercentage = data['artistFeePercentage'];
      result$data['artistFeePercentage'] = l$artistFeePercentage == null
          ? null
          : fromJson$Enum$SortEnumType((l$artistFeePercentage as String));
    }
    if (data.containsKey('oneOffType')) {
      final l$oneOffType = data['oneOffType'];
      result$data['oneOffType'] = l$oneOffType == null
          ? null
          : fromJson$Enum$SortEnumType((l$oneOffType as String));
    }
    return Input$OneOffSnapshotSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get packageName =>
      (_$data['packageName'] as Enum$SortEnumType?);

  Enum$SortEnumType? get packageAmount =>
      (_$data['packageAmount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get packageCurrency =>
      (_$data['packageCurrency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get estimateDeliveryDays =>
      (_$data['estimateDeliveryDays'] as Enum$SortEnumType?);

  Enum$SortEnumType? get packageDescription =>
      (_$data['packageDescription'] as Enum$SortEnumType?);

  Enum$SortEnumType? get maxRevision =>
      (_$data['maxRevision'] as Enum$SortEnumType?);

  Enum$SortEnumType? get artistPackageStatus =>
      (_$data['artistPackageStatus'] as Enum$SortEnumType?);

  Enum$SortEnumType? get deadline => (_$data['deadline'] as Enum$SortEnumType?);

  Enum$SortEnumType? get platformFeePercentage =>
      (_$data['platformFeePercentage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get artistFeePercentage =>
      (_$data['artistFeePercentage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get oneOffType =>
      (_$data['oneOffType'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('packageName')) {
      final l$packageName = packageName;
      result$data['packageName'] = l$packageName == null
          ? null
          : toJson$Enum$SortEnumType(l$packageName);
    }
    if (_$data.containsKey('packageAmount')) {
      final l$packageAmount = packageAmount;
      result$data['packageAmount'] = l$packageAmount == null
          ? null
          : toJson$Enum$SortEnumType(l$packageAmount);
    }
    if (_$data.containsKey('packageCurrency')) {
      final l$packageCurrency = packageCurrency;
      result$data['packageCurrency'] = l$packageCurrency == null
          ? null
          : toJson$Enum$SortEnumType(l$packageCurrency);
    }
    if (_$data.containsKey('estimateDeliveryDays')) {
      final l$estimateDeliveryDays = estimateDeliveryDays;
      result$data['estimateDeliveryDays'] = l$estimateDeliveryDays == null
          ? null
          : toJson$Enum$SortEnumType(l$estimateDeliveryDays);
    }
    if (_$data.containsKey('packageDescription')) {
      final l$packageDescription = packageDescription;
      result$data['packageDescription'] = l$packageDescription == null
          ? null
          : toJson$Enum$SortEnumType(l$packageDescription);
    }
    if (_$data.containsKey('maxRevision')) {
      final l$maxRevision = maxRevision;
      result$data['maxRevision'] = l$maxRevision == null
          ? null
          : toJson$Enum$SortEnumType(l$maxRevision);
    }
    if (_$data.containsKey('artistPackageStatus')) {
      final l$artistPackageStatus = artistPackageStatus;
      result$data['artistPackageStatus'] = l$artistPackageStatus == null
          ? null
          : toJson$Enum$SortEnumType(l$artistPackageStatus);
    }
    if (_$data.containsKey('deadline')) {
      final l$deadline = deadline;
      result$data['deadline'] = l$deadline == null
          ? null
          : toJson$Enum$SortEnumType(l$deadline);
    }
    if (_$data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = platformFeePercentage;
      result$data['platformFeePercentage'] = l$platformFeePercentage == null
          ? null
          : toJson$Enum$SortEnumType(l$platformFeePercentage);
    }
    if (_$data.containsKey('artistFeePercentage')) {
      final l$artistFeePercentage = artistFeePercentage;
      result$data['artistFeePercentage'] = l$artistFeePercentage == null
          ? null
          : toJson$Enum$SortEnumType(l$artistFeePercentage);
    }
    if (_$data.containsKey('oneOffType')) {
      final l$oneOffType = oneOffType;
      result$data['oneOffType'] = l$oneOffType == null
          ? null
          : toJson$Enum$SortEnumType(l$oneOffType);
    }
    return result$data;
  }

  CopyWith$Input$OneOffSnapshotSortInput<Input$OneOffSnapshotSortInput>
  get copyWith => CopyWith$Input$OneOffSnapshotSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OneOffSnapshotSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$packageName = packageName;
    final lOther$packageName = other.packageName;
    if (_$data.containsKey('packageName') !=
        other._$data.containsKey('packageName')) {
      return false;
    }
    if (l$packageName != lOther$packageName) {
      return false;
    }
    final l$packageAmount = packageAmount;
    final lOther$packageAmount = other.packageAmount;
    if (_$data.containsKey('packageAmount') !=
        other._$data.containsKey('packageAmount')) {
      return false;
    }
    if (l$packageAmount != lOther$packageAmount) {
      return false;
    }
    final l$packageCurrency = packageCurrency;
    final lOther$packageCurrency = other.packageCurrency;
    if (_$data.containsKey('packageCurrency') !=
        other._$data.containsKey('packageCurrency')) {
      return false;
    }
    if (l$packageCurrency != lOther$packageCurrency) {
      return false;
    }
    final l$estimateDeliveryDays = estimateDeliveryDays;
    final lOther$estimateDeliveryDays = other.estimateDeliveryDays;
    if (_$data.containsKey('estimateDeliveryDays') !=
        other._$data.containsKey('estimateDeliveryDays')) {
      return false;
    }
    if (l$estimateDeliveryDays != lOther$estimateDeliveryDays) {
      return false;
    }
    final l$packageDescription = packageDescription;
    final lOther$packageDescription = other.packageDescription;
    if (_$data.containsKey('packageDescription') !=
        other._$data.containsKey('packageDescription')) {
      return false;
    }
    if (l$packageDescription != lOther$packageDescription) {
      return false;
    }
    final l$maxRevision = maxRevision;
    final lOther$maxRevision = other.maxRevision;
    if (_$data.containsKey('maxRevision') !=
        other._$data.containsKey('maxRevision')) {
      return false;
    }
    if (l$maxRevision != lOther$maxRevision) {
      return false;
    }
    final l$artistPackageStatus = artistPackageStatus;
    final lOther$artistPackageStatus = other.artistPackageStatus;
    if (_$data.containsKey('artistPackageStatus') !=
        other._$data.containsKey('artistPackageStatus')) {
      return false;
    }
    if (l$artistPackageStatus != lOther$artistPackageStatus) {
      return false;
    }
    final l$deadline = deadline;
    final lOther$deadline = other.deadline;
    if (_$data.containsKey('deadline') !=
        other._$data.containsKey('deadline')) {
      return false;
    }
    if (l$deadline != lOther$deadline) {
      return false;
    }
    final l$platformFeePercentage = platformFeePercentage;
    final lOther$platformFeePercentage = other.platformFeePercentage;
    if (_$data.containsKey('platformFeePercentage') !=
        other._$data.containsKey('platformFeePercentage')) {
      return false;
    }
    if (l$platformFeePercentage != lOther$platformFeePercentage) {
      return false;
    }
    final l$artistFeePercentage = artistFeePercentage;
    final lOther$artistFeePercentage = other.artistFeePercentage;
    if (_$data.containsKey('artistFeePercentage') !=
        other._$data.containsKey('artistFeePercentage')) {
      return false;
    }
    if (l$artistFeePercentage != lOther$artistFeePercentage) {
      return false;
    }
    final l$oneOffType = oneOffType;
    final lOther$oneOffType = other.oneOffType;
    if (_$data.containsKey('oneOffType') !=
        other._$data.containsKey('oneOffType')) {
      return false;
    }
    if (l$oneOffType != lOther$oneOffType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$packageName = packageName;
    final l$packageAmount = packageAmount;
    final l$packageCurrency = packageCurrency;
    final l$estimateDeliveryDays = estimateDeliveryDays;
    final l$packageDescription = packageDescription;
    final l$maxRevision = maxRevision;
    final l$artistPackageStatus = artistPackageStatus;
    final l$deadline = deadline;
    final l$platformFeePercentage = platformFeePercentage;
    final l$artistFeePercentage = artistFeePercentage;
    final l$oneOffType = oneOffType;
    return Object.hashAll([
      _$data.containsKey('packageName') ? l$packageName : const {},
      _$data.containsKey('packageAmount') ? l$packageAmount : const {},
      _$data.containsKey('packageCurrency') ? l$packageCurrency : const {},
      _$data.containsKey('estimateDeliveryDays')
          ? l$estimateDeliveryDays
          : const {},
      _$data.containsKey('packageDescription')
          ? l$packageDescription
          : const {},
      _$data.containsKey('maxRevision') ? l$maxRevision : const {},
      _$data.containsKey('artistPackageStatus')
          ? l$artistPackageStatus
          : const {},
      _$data.containsKey('deadline') ? l$deadline : const {},
      _$data.containsKey('platformFeePercentage')
          ? l$platformFeePercentage
          : const {},
      _$data.containsKey('artistFeePercentage')
          ? l$artistFeePercentage
          : const {},
      _$data.containsKey('oneOffType') ? l$oneOffType : const {},
    ]);
  }
}

abstract class CopyWith$Input$OneOffSnapshotSortInput<TRes> {
  factory CopyWith$Input$OneOffSnapshotSortInput(
    Input$OneOffSnapshotSortInput instance,
    TRes Function(Input$OneOffSnapshotSortInput) then,
  ) = _CopyWithImpl$Input$OneOffSnapshotSortInput;

  factory CopyWith$Input$OneOffSnapshotSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OneOffSnapshotSortInput;

  TRes call({
    Enum$SortEnumType? packageName,
    Enum$SortEnumType? packageAmount,
    Enum$SortEnumType? packageCurrency,
    Enum$SortEnumType? estimateDeliveryDays,
    Enum$SortEnumType? packageDescription,
    Enum$SortEnumType? maxRevision,
    Enum$SortEnumType? artistPackageStatus,
    Enum$SortEnumType? deadline,
    Enum$SortEnumType? platformFeePercentage,
    Enum$SortEnumType? artistFeePercentage,
    Enum$SortEnumType? oneOffType,
  });
}

class _CopyWithImpl$Input$OneOffSnapshotSortInput<TRes>
    implements CopyWith$Input$OneOffSnapshotSortInput<TRes> {
  _CopyWithImpl$Input$OneOffSnapshotSortInput(this._instance, this._then);

  final Input$OneOffSnapshotSortInput _instance;

  final TRes Function(Input$OneOffSnapshotSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? packageName = _undefined,
    Object? packageAmount = _undefined,
    Object? packageCurrency = _undefined,
    Object? estimateDeliveryDays = _undefined,
    Object? packageDescription = _undefined,
    Object? maxRevision = _undefined,
    Object? artistPackageStatus = _undefined,
    Object? deadline = _undefined,
    Object? platformFeePercentage = _undefined,
    Object? artistFeePercentage = _undefined,
    Object? oneOffType = _undefined,
  }) => _then(
    Input$OneOffSnapshotSortInput._({
      ..._instance._$data,
      if (packageName != _undefined)
        'packageName': (packageName as Enum$SortEnumType?),
      if (packageAmount != _undefined)
        'packageAmount': (packageAmount as Enum$SortEnumType?),
      if (packageCurrency != _undefined)
        'packageCurrency': (packageCurrency as Enum$SortEnumType?),
      if (estimateDeliveryDays != _undefined)
        'estimateDeliveryDays': (estimateDeliveryDays as Enum$SortEnumType?),
      if (packageDescription != _undefined)
        'packageDescription': (packageDescription as Enum$SortEnumType?),
      if (maxRevision != _undefined)
        'maxRevision': (maxRevision as Enum$SortEnumType?),
      if (artistPackageStatus != _undefined)
        'artistPackageStatus': (artistPackageStatus as Enum$SortEnumType?),
      if (deadline != _undefined) 'deadline': (deadline as Enum$SortEnumType?),
      if (platformFeePercentage != _undefined)
        'platformFeePercentage': (platformFeePercentage as Enum$SortEnumType?),
      if (artistFeePercentage != _undefined)
        'artistFeePercentage': (artistFeePercentage as Enum$SortEnumType?),
      if (oneOffType != _undefined)
        'oneOffType': (oneOffType as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$OneOffSnapshotSortInput<TRes>
    implements CopyWith$Input$OneOffSnapshotSortInput<TRes> {
  _CopyWithStubImpl$Input$OneOffSnapshotSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? packageName,
    Enum$SortEnumType? packageAmount,
    Enum$SortEnumType? packageCurrency,
    Enum$SortEnumType? estimateDeliveryDays,
    Enum$SortEnumType? packageDescription,
    Enum$SortEnumType? maxRevision,
    Enum$SortEnumType? artistPackageStatus,
    Enum$SortEnumType? deadline,
    Enum$SortEnumType? platformFeePercentage,
    Enum$SortEnumType? artistFeePercentage,
    Enum$SortEnumType? oneOffType,
  }) => _res;
}

class Input$OneOffTypeOperationFilterInput {
  factory Input$OneOffTypeOperationFilterInput({
    Enum$OneOffType? eq,
    Enum$OneOffType? neq,
    List<Enum$OneOffType>? $in,
    List<Enum$OneOffType>? nin,
  }) => Input$OneOffTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$OneOffTypeOperationFilterInput._(this._$data);

  factory Input$OneOffTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$OneOffType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$OneOffType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$OneOffType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$OneOffType((e as String)))
          .toList();
    }
    return Input$OneOffTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OneOffType? get eq => (_$data['eq'] as Enum$OneOffType?);

  Enum$OneOffType? get neq => (_$data['neq'] as Enum$OneOffType?);

  List<Enum$OneOffType>? get $in => (_$data['in'] as List<Enum$OneOffType>?);

  List<Enum$OneOffType>? get nin => (_$data['nin'] as List<Enum$OneOffType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$OneOffType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$OneOffType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$OneOffType(e)).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$OneOffType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$OneOffTypeOperationFilterInput<
    Input$OneOffTypeOperationFilterInput
  >
  get copyWith => CopyWith$Input$OneOffTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OneOffTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OneOffTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$OneOffTypeOperationFilterInput(
    Input$OneOffTypeOperationFilterInput instance,
    TRes Function(Input$OneOffTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$OneOffTypeOperationFilterInput;

  factory CopyWith$Input$OneOffTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OneOffTypeOperationFilterInput;

  TRes call({
    Enum$OneOffType? eq,
    Enum$OneOffType? neq,
    List<Enum$OneOffType>? $in,
    List<Enum$OneOffType>? nin,
  });
}

class _CopyWithImpl$Input$OneOffTypeOperationFilterInput<TRes>
    implements CopyWith$Input$OneOffTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$OneOffTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$OneOffTypeOperationFilterInput _instance;

  final TRes Function(Input$OneOffTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$OneOffTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$OneOffType?),
      if (neq != _undefined) 'neq': (neq as Enum$OneOffType?),
      if ($in != _undefined) 'in': ($in as List<Enum$OneOffType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$OneOffType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$OneOffTypeOperationFilterInput<TRes>
    implements CopyWith$Input$OneOffTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$OneOffTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$OneOffType? eq,
    Enum$OneOffType? neq,
    List<Enum$OneOffType>? $in,
    List<Enum$OneOffType>? nin,
  }) => _res;
}

class Input$PackageOrderDeliveryFilterInput {
  factory Input$PackageOrderDeliveryFilterInput({
    List<Input$PackageOrderDeliveryFilterInput>? and,
    List<Input$PackageOrderDeliveryFilterInput>? or,
    Input$StringOperationFilterInput? deliveryFileUrl,
    Input$StringOperationFilterInput? notes,
    Input$IntOperationFilterInput? revisionNumber,
    Input$StringOperationFilterInput? clientFeedback,
    Input$DateTimeOperationFilterInput? requestedAt,
    Input$DateTimeOperationFilterInput? deliveredAt,
  }) => Input$PackageOrderDeliveryFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (deliveryFileUrl != null) r'deliveryFileUrl': deliveryFileUrl,
    if (notes != null) r'notes': notes,
    if (revisionNumber != null) r'revisionNumber': revisionNumber,
    if (clientFeedback != null) r'clientFeedback': clientFeedback,
    if (requestedAt != null) r'requestedAt': requestedAt,
    if (deliveredAt != null) r'deliveredAt': deliveredAt,
  });

  Input$PackageOrderDeliveryFilterInput._(this._$data);

  factory Input$PackageOrderDeliveryFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$PackageOrderDeliveryFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$PackageOrderDeliveryFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('deliveryFileUrl')) {
      final l$deliveryFileUrl = data['deliveryFileUrl'];
      result$data['deliveryFileUrl'] = l$deliveryFileUrl == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$deliveryFileUrl as Map<String, dynamic>),
            );
    }
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = l$notes == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$notes as Map<String, dynamic>),
            );
    }
    if (data.containsKey('revisionNumber')) {
      final l$revisionNumber = data['revisionNumber'];
      result$data['revisionNumber'] = l$revisionNumber == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$revisionNumber as Map<String, dynamic>),
            );
    }
    if (data.containsKey('clientFeedback')) {
      final l$clientFeedback = data['clientFeedback'];
      result$data['clientFeedback'] = l$clientFeedback == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$clientFeedback as Map<String, dynamic>),
            );
    }
    if (data.containsKey('requestedAt')) {
      final l$requestedAt = data['requestedAt'];
      result$data['requestedAt'] = l$requestedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$requestedAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('deliveredAt')) {
      final l$deliveredAt = data['deliveredAt'];
      result$data['deliveredAt'] = l$deliveredAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$deliveredAt as Map<String, dynamic>),
            );
    }
    return Input$PackageOrderDeliveryFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PackageOrderDeliveryFilterInput>? get and =>
      (_$data['and'] as List<Input$PackageOrderDeliveryFilterInput>?);

  List<Input$PackageOrderDeliveryFilterInput>? get or =>
      (_$data['or'] as List<Input$PackageOrderDeliveryFilterInput>?);

  Input$StringOperationFilterInput? get deliveryFileUrl =>
      (_$data['deliveryFileUrl'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get notes =>
      (_$data['notes'] as Input$StringOperationFilterInput?);

  Input$IntOperationFilterInput? get revisionNumber =>
      (_$data['revisionNumber'] as Input$IntOperationFilterInput?);

  Input$StringOperationFilterInput? get clientFeedback =>
      (_$data['clientFeedback'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get requestedAt =>
      (_$data['requestedAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get deliveredAt =>
      (_$data['deliveredAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deliveryFileUrl')) {
      final l$deliveryFileUrl = deliveryFileUrl;
      result$data['deliveryFileUrl'] = l$deliveryFileUrl?.toJson();
    }
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] = l$notes?.toJson();
    }
    if (_$data.containsKey('revisionNumber')) {
      final l$revisionNumber = revisionNumber;
      result$data['revisionNumber'] = l$revisionNumber?.toJson();
    }
    if (_$data.containsKey('clientFeedback')) {
      final l$clientFeedback = clientFeedback;
      result$data['clientFeedback'] = l$clientFeedback?.toJson();
    }
    if (_$data.containsKey('requestedAt')) {
      final l$requestedAt = requestedAt;
      result$data['requestedAt'] = l$requestedAt?.toJson();
    }
    if (_$data.containsKey('deliveredAt')) {
      final l$deliveredAt = deliveredAt;
      result$data['deliveredAt'] = l$deliveredAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PackageOrderDeliveryFilterInput<
    Input$PackageOrderDeliveryFilterInput
  >
  get copyWith =>
      CopyWith$Input$PackageOrderDeliveryFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PackageOrderDeliveryFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$deliveryFileUrl = deliveryFileUrl;
    final lOther$deliveryFileUrl = other.deliveryFileUrl;
    if (_$data.containsKey('deliveryFileUrl') !=
        other._$data.containsKey('deliveryFileUrl')) {
      return false;
    }
    if (l$deliveryFileUrl != lOther$deliveryFileUrl) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != lOther$notes) {
      return false;
    }
    final l$revisionNumber = revisionNumber;
    final lOther$revisionNumber = other.revisionNumber;
    if (_$data.containsKey('revisionNumber') !=
        other._$data.containsKey('revisionNumber')) {
      return false;
    }
    if (l$revisionNumber != lOther$revisionNumber) {
      return false;
    }
    final l$clientFeedback = clientFeedback;
    final lOther$clientFeedback = other.clientFeedback;
    if (_$data.containsKey('clientFeedback') !=
        other._$data.containsKey('clientFeedback')) {
      return false;
    }
    if (l$clientFeedback != lOther$clientFeedback) {
      return false;
    }
    final l$requestedAt = requestedAt;
    final lOther$requestedAt = other.requestedAt;
    if (_$data.containsKey('requestedAt') !=
        other._$data.containsKey('requestedAt')) {
      return false;
    }
    if (l$requestedAt != lOther$requestedAt) {
      return false;
    }
    final l$deliveredAt = deliveredAt;
    final lOther$deliveredAt = other.deliveredAt;
    if (_$data.containsKey('deliveredAt') !=
        other._$data.containsKey('deliveredAt')) {
      return false;
    }
    if (l$deliveredAt != lOther$deliveredAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$deliveryFileUrl = deliveryFileUrl;
    final l$notes = notes;
    final l$revisionNumber = revisionNumber;
    final l$clientFeedback = clientFeedback;
    final l$requestedAt = requestedAt;
    final l$deliveredAt = deliveredAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('deliveryFileUrl') ? l$deliveryFileUrl : const {},
      _$data.containsKey('notes') ? l$notes : const {},
      _$data.containsKey('revisionNumber') ? l$revisionNumber : const {},
      _$data.containsKey('clientFeedback') ? l$clientFeedback : const {},
      _$data.containsKey('requestedAt') ? l$requestedAt : const {},
      _$data.containsKey('deliveredAt') ? l$deliveredAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> {
  factory CopyWith$Input$PackageOrderDeliveryFilterInput(
    Input$PackageOrderDeliveryFilterInput instance,
    TRes Function(Input$PackageOrderDeliveryFilterInput) then,
  ) = _CopyWithImpl$Input$PackageOrderDeliveryFilterInput;

  factory CopyWith$Input$PackageOrderDeliveryFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageOrderDeliveryFilterInput;

  TRes call({
    List<Input$PackageOrderDeliveryFilterInput>? and,
    List<Input$PackageOrderDeliveryFilterInput>? or,
    Input$StringOperationFilterInput? deliveryFileUrl,
    Input$StringOperationFilterInput? notes,
    Input$IntOperationFilterInput? revisionNumber,
    Input$StringOperationFilterInput? clientFeedback,
    Input$DateTimeOperationFilterInput? requestedAt,
    Input$DateTimeOperationFilterInput? deliveredAt,
  });
  TRes and(
    Iterable<Input$PackageOrderDeliveryFilterInput>? Function(
      Iterable<
        CopyWith$Input$PackageOrderDeliveryFilterInput<
          Input$PackageOrderDeliveryFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$PackageOrderDeliveryFilterInput>? Function(
      Iterable<
        CopyWith$Input$PackageOrderDeliveryFilterInput<
          Input$PackageOrderDeliveryFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get deliveryFileUrl;
  CopyWith$Input$StringOperationFilterInput<TRes> get notes;
  CopyWith$Input$IntOperationFilterInput<TRes> get revisionNumber;
  CopyWith$Input$StringOperationFilterInput<TRes> get clientFeedback;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get requestedAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deliveredAt;
}

class _CopyWithImpl$Input$PackageOrderDeliveryFilterInput<TRes>
    implements CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> {
  _CopyWithImpl$Input$PackageOrderDeliveryFilterInput(
    this._instance,
    this._then,
  );

  final Input$PackageOrderDeliveryFilterInput _instance;

  final TRes Function(Input$PackageOrderDeliveryFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? deliveryFileUrl = _undefined,
    Object? notes = _undefined,
    Object? revisionNumber = _undefined,
    Object? clientFeedback = _undefined,
    Object? requestedAt = _undefined,
    Object? deliveredAt = _undefined,
  }) => _then(
    Input$PackageOrderDeliveryFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$PackageOrderDeliveryFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$PackageOrderDeliveryFilterInput>?),
      if (deliveryFileUrl != _undefined)
        'deliveryFileUrl':
            (deliveryFileUrl as Input$StringOperationFilterInput?),
      if (notes != _undefined)
        'notes': (notes as Input$StringOperationFilterInput?),
      if (revisionNumber != _undefined)
        'revisionNumber': (revisionNumber as Input$IntOperationFilterInput?),
      if (clientFeedback != _undefined)
        'clientFeedback': (clientFeedback as Input$StringOperationFilterInput?),
      if (requestedAt != _undefined)
        'requestedAt': (requestedAt as Input$DateTimeOperationFilterInput?),
      if (deliveredAt != _undefined)
        'deliveredAt': (deliveredAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$PackageOrderDeliveryFilterInput>? Function(
      Iterable<
        CopyWith$Input$PackageOrderDeliveryFilterInput<
          Input$PackageOrderDeliveryFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$PackageOrderDeliveryFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$PackageOrderDeliveryFilterInput>? Function(
      Iterable<
        CopyWith$Input$PackageOrderDeliveryFilterInput<
          Input$PackageOrderDeliveryFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$PackageOrderDeliveryFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get deliveryFileUrl {
    final local$deliveryFileUrl = _instance.deliveryFileUrl;
    return local$deliveryFileUrl == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$deliveryFileUrl,
            (e) => call(deliveryFileUrl: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get notes {
    final local$notes = _instance.notes;
    return local$notes == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$notes,
            (e) => call(notes: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get revisionNumber {
    final local$revisionNumber = _instance.revisionNumber;
    return local$revisionNumber == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$revisionNumber,
            (e) => call(revisionNumber: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get clientFeedback {
    final local$clientFeedback = _instance.clientFeedback;
    return local$clientFeedback == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$clientFeedback,
            (e) => call(clientFeedback: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get requestedAt {
    final local$requestedAt = _instance.requestedAt;
    return local$requestedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$requestedAt,
            (e) => call(requestedAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deliveredAt {
    final local$deliveredAt = _instance.deliveredAt;
    return local$deliveredAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$deliveredAt,
            (e) => call(deliveredAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$PackageOrderDeliveryFilterInput<TRes>
    implements CopyWith$Input$PackageOrderDeliveryFilterInput<TRes> {
  _CopyWithStubImpl$Input$PackageOrderDeliveryFilterInput(this._res);

  TRes _res;

  call({
    List<Input$PackageOrderDeliveryFilterInput>? and,
    List<Input$PackageOrderDeliveryFilterInput>? or,
    Input$StringOperationFilterInput? deliveryFileUrl,
    Input$StringOperationFilterInput? notes,
    Input$IntOperationFilterInput? revisionNumber,
    Input$StringOperationFilterInput? clientFeedback,
    Input$DateTimeOperationFilterInput? requestedAt,
    Input$DateTimeOperationFilterInput? deliveredAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get deliveryFileUrl =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get notes =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get revisionNumber =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get clientFeedback =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get requestedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deliveredAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$PackageOrderDeliveryInput {
  factory Input$PackageOrderDeliveryInput({
    required String deliveryFileUrl,
    String? notes,
    required int revisionNumber,
    String? clientFeedback,
    DateTime? requestedAt,
    DateTime? deliveredAt,
  }) => Input$PackageOrderDeliveryInput._({
    r'deliveryFileUrl': deliveryFileUrl,
    if (notes != null) r'notes': notes,
    r'revisionNumber': revisionNumber,
    if (clientFeedback != null) r'clientFeedback': clientFeedback,
    if (requestedAt != null) r'requestedAt': requestedAt,
    if (deliveredAt != null) r'deliveredAt': deliveredAt,
  });

  Input$PackageOrderDeliveryInput._(this._$data);

  factory Input$PackageOrderDeliveryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$deliveryFileUrl = data['deliveryFileUrl'];
    result$data['deliveryFileUrl'] = (l$deliveryFileUrl as String);
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = (l$notes as String?);
    }
    final l$revisionNumber = data['revisionNumber'];
    result$data['revisionNumber'] = (l$revisionNumber as int);
    if (data.containsKey('clientFeedback')) {
      final l$clientFeedback = data['clientFeedback'];
      result$data['clientFeedback'] = (l$clientFeedback as String?);
    }
    if (data.containsKey('requestedAt')) {
      final l$requestedAt = data['requestedAt'];
      result$data['requestedAt'] = l$requestedAt == null
          ? null
          : DateTime.parse((l$requestedAt as String));
    }
    if (data.containsKey('deliveredAt')) {
      final l$deliveredAt = data['deliveredAt'];
      result$data['deliveredAt'] = l$deliveredAt == null
          ? null
          : DateTime.parse((l$deliveredAt as String));
    }
    return Input$PackageOrderDeliveryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get deliveryFileUrl => (_$data['deliveryFileUrl'] as String);

  String? get notes => (_$data['notes'] as String?);

  int get revisionNumber => (_$data['revisionNumber'] as int);

  String? get clientFeedback => (_$data['clientFeedback'] as String?);

  DateTime? get requestedAt => (_$data['requestedAt'] as DateTime?);

  DateTime? get deliveredAt => (_$data['deliveredAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$deliveryFileUrl = deliveryFileUrl;
    result$data['deliveryFileUrl'] = l$deliveryFileUrl;
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] = l$notes;
    }
    final l$revisionNumber = revisionNumber;
    result$data['revisionNumber'] = l$revisionNumber;
    if (_$data.containsKey('clientFeedback')) {
      final l$clientFeedback = clientFeedback;
      result$data['clientFeedback'] = l$clientFeedback;
    }
    if (_$data.containsKey('requestedAt')) {
      final l$requestedAt = requestedAt;
      result$data['requestedAt'] = l$requestedAt?.toIso8601String();
    }
    if (_$data.containsKey('deliveredAt')) {
      final l$deliveredAt = deliveredAt;
      result$data['deliveredAt'] = l$deliveredAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$PackageOrderDeliveryInput<Input$PackageOrderDeliveryInput>
  get copyWith => CopyWith$Input$PackageOrderDeliveryInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PackageOrderDeliveryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$deliveryFileUrl = deliveryFileUrl;
    final lOther$deliveryFileUrl = other.deliveryFileUrl;
    if (l$deliveryFileUrl != lOther$deliveryFileUrl) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != lOther$notes) {
      return false;
    }
    final l$revisionNumber = revisionNumber;
    final lOther$revisionNumber = other.revisionNumber;
    if (l$revisionNumber != lOther$revisionNumber) {
      return false;
    }
    final l$clientFeedback = clientFeedback;
    final lOther$clientFeedback = other.clientFeedback;
    if (_$data.containsKey('clientFeedback') !=
        other._$data.containsKey('clientFeedback')) {
      return false;
    }
    if (l$clientFeedback != lOther$clientFeedback) {
      return false;
    }
    final l$requestedAt = requestedAt;
    final lOther$requestedAt = other.requestedAt;
    if (_$data.containsKey('requestedAt') !=
        other._$data.containsKey('requestedAt')) {
      return false;
    }
    if (l$requestedAt != lOther$requestedAt) {
      return false;
    }
    final l$deliveredAt = deliveredAt;
    final lOther$deliveredAt = other.deliveredAt;
    if (_$data.containsKey('deliveredAt') !=
        other._$data.containsKey('deliveredAt')) {
      return false;
    }
    if (l$deliveredAt != lOther$deliveredAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$deliveryFileUrl = deliveryFileUrl;
    final l$notes = notes;
    final l$revisionNumber = revisionNumber;
    final l$clientFeedback = clientFeedback;
    final l$requestedAt = requestedAt;
    final l$deliveredAt = deliveredAt;
    return Object.hashAll([
      l$deliveryFileUrl,
      _$data.containsKey('notes') ? l$notes : const {},
      l$revisionNumber,
      _$data.containsKey('clientFeedback') ? l$clientFeedback : const {},
      _$data.containsKey('requestedAt') ? l$requestedAt : const {},
      _$data.containsKey('deliveredAt') ? l$deliveredAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageOrderDeliveryInput<TRes> {
  factory CopyWith$Input$PackageOrderDeliveryInput(
    Input$PackageOrderDeliveryInput instance,
    TRes Function(Input$PackageOrderDeliveryInput) then,
  ) = _CopyWithImpl$Input$PackageOrderDeliveryInput;

  factory CopyWith$Input$PackageOrderDeliveryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageOrderDeliveryInput;

  TRes call({
    String? deliveryFileUrl,
    String? notes,
    int? revisionNumber,
    String? clientFeedback,
    DateTime? requestedAt,
    DateTime? deliveredAt,
  });
}

class _CopyWithImpl$Input$PackageOrderDeliveryInput<TRes>
    implements CopyWith$Input$PackageOrderDeliveryInput<TRes> {
  _CopyWithImpl$Input$PackageOrderDeliveryInput(this._instance, this._then);

  final Input$PackageOrderDeliveryInput _instance;

  final TRes Function(Input$PackageOrderDeliveryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? deliveryFileUrl = _undefined,
    Object? notes = _undefined,
    Object? revisionNumber = _undefined,
    Object? clientFeedback = _undefined,
    Object? requestedAt = _undefined,
    Object? deliveredAt = _undefined,
  }) => _then(
    Input$PackageOrderDeliveryInput._({
      ..._instance._$data,
      if (deliveryFileUrl != _undefined && deliveryFileUrl != null)
        'deliveryFileUrl': (deliveryFileUrl as String),
      if (notes != _undefined) 'notes': (notes as String?),
      if (revisionNumber != _undefined && revisionNumber != null)
        'revisionNumber': (revisionNumber as int),
      if (clientFeedback != _undefined)
        'clientFeedback': (clientFeedback as String?),
      if (requestedAt != _undefined) 'requestedAt': (requestedAt as DateTime?),
      if (deliveredAt != _undefined) 'deliveredAt': (deliveredAt as DateTime?),
    }),
  );
}

class _CopyWithStubImpl$Input$PackageOrderDeliveryInput<TRes>
    implements CopyWith$Input$PackageOrderDeliveryInput<TRes> {
  _CopyWithStubImpl$Input$PackageOrderDeliveryInput(this._res);

  TRes _res;

  call({
    String? deliveryFileUrl,
    String? notes,
    int? revisionNumber,
    String? clientFeedback,
    DateTime? requestedAt,
    DateTime? deliveredAt,
  }) => _res;
}

class Input$PackageOrderFilterInput {
  factory Input$PackageOrderFilterInput({
    List<Input$PackageOrderFilterInput>? and,
    List<Input$PackageOrderFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? clientId,
    Input$StringOperationFilterInput? providerId,
    Input$StringOperationFilterInput? artistPackageId,
    Input$StringOperationFilterInput? paymentTransactionId,
    Input$StringOperationFilterInput? conversationId,
    Input$PackageOrderStatusOperationFilterInput? status,
    Input$IntOperationFilterInput? revisionCount,
    Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput? deliveries,
    Input$DateTimeOperationFilterInput? deadline,
    Input$DateTimeOperationFilterInput? completedAt,
    Input$BooleanOperationFilterInput? isEscrowReleased,
    Input$DecimalOperationFilterInput? platformFeePercentage,
    Input$DecimalOperationFilterInput? artistFeePercentage,
    Input$ReviewFilterInput? review,
    Input$StringOperationFilterInput? backgroundJobId,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$PackageOrderFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (clientId != null) r'clientId': clientId,
    if (providerId != null) r'providerId': providerId,
    if (artistPackageId != null) r'artistPackageId': artistPackageId,
    if (paymentTransactionId != null)
      r'paymentTransactionId': paymentTransactionId,
    if (conversationId != null) r'conversationId': conversationId,
    if (status != null) r'status': status,
    if (revisionCount != null) r'revisionCount': revisionCount,
    if (deliveries != null) r'deliveries': deliveries,
    if (deadline != null) r'deadline': deadline,
    if (completedAt != null) r'completedAt': completedAt,
    if (isEscrowReleased != null) r'isEscrowReleased': isEscrowReleased,
    if (platformFeePercentage != null)
      r'platformFeePercentage': platformFeePercentage,
    if (artistFeePercentage != null)
      r'artistFeePercentage': artistFeePercentage,
    if (review != null) r'review': review,
    if (backgroundJobId != null) r'backgroundJobId': backgroundJobId,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$PackageOrderFilterInput._(this._$data);

  factory Input$PackageOrderFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$PackageOrderFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$PackageOrderFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('clientId')) {
      final l$clientId = data['clientId'];
      result$data['clientId'] = l$clientId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$clientId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('providerId')) {
      final l$providerId = data['providerId'];
      result$data['providerId'] = l$providerId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$providerId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('artistPackageId')) {
      final l$artistPackageId = data['artistPackageId'];
      result$data['artistPackageId'] = l$artistPackageId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$artistPackageId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('paymentTransactionId')) {
      final l$paymentTransactionId = data['paymentTransactionId'];
      result$data['paymentTransactionId'] = l$paymentTransactionId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$paymentTransactionId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('conversationId')) {
      final l$conversationId = data['conversationId'];
      result$data['conversationId'] = l$conversationId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$conversationId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$PackageOrderStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('revisionCount')) {
      final l$revisionCount = data['revisionCount'];
      result$data['revisionCount'] = l$revisionCount == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$revisionCount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('deliveries')) {
      final l$deliveries = data['deliveries'];
      result$data['deliveries'] = l$deliveries == null
          ? null
          : Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput.fromJson(
              (l$deliveries as Map<String, dynamic>),
            );
    }
    if (data.containsKey('deadline')) {
      final l$deadline = data['deadline'];
      result$data['deadline'] = l$deadline == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$deadline as Map<String, dynamic>),
            );
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$completedAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isEscrowReleased')) {
      final l$isEscrowReleased = data['isEscrowReleased'];
      result$data['isEscrowReleased'] = l$isEscrowReleased == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isEscrowReleased as Map<String, dynamic>),
            );
    }
    if (data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = data['platformFeePercentage'];
      result$data['platformFeePercentage'] = l$platformFeePercentage == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$platformFeePercentage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('artistFeePercentage')) {
      final l$artistFeePercentage = data['artistFeePercentage'];
      result$data['artistFeePercentage'] = l$artistFeePercentage == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$artistFeePercentage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('review')) {
      final l$review = data['review'];
      result$data['review'] = l$review == null
          ? null
          : Input$ReviewFilterInput.fromJson(
              (l$review as Map<String, dynamic>),
            );
    }
    if (data.containsKey('backgroundJobId')) {
      final l$backgroundJobId = data['backgroundJobId'];
      result$data['backgroundJobId'] = l$backgroundJobId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$backgroundJobId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$PackageOrderFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PackageOrderFilterInput>? get and =>
      (_$data['and'] as List<Input$PackageOrderFilterInput>?);

  List<Input$PackageOrderFilterInput>? get or =>
      (_$data['or'] as List<Input$PackageOrderFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get clientId =>
      (_$data['clientId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get providerId =>
      (_$data['providerId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get artistPackageId =>
      (_$data['artistPackageId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get paymentTransactionId =>
      (_$data['paymentTransactionId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get conversationId =>
      (_$data['conversationId'] as Input$StringOperationFilterInput?);

  Input$PackageOrderStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$PackageOrderStatusOperationFilterInput?);

  Input$IntOperationFilterInput? get revisionCount =>
      (_$data['revisionCount'] as Input$IntOperationFilterInput?);

  Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput? get deliveries =>
      (_$data['deliveries']
          as Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput?);

  Input$DateTimeOperationFilterInput? get deadline =>
      (_$data['deadline'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get completedAt =>
      (_$data['completedAt'] as Input$DateTimeOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isEscrowReleased =>
      (_$data['isEscrowReleased'] as Input$BooleanOperationFilterInput?);

  Input$DecimalOperationFilterInput? get platformFeePercentage =>
      (_$data['platformFeePercentage'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get artistFeePercentage =>
      (_$data['artistFeePercentage'] as Input$DecimalOperationFilterInput?);

  Input$ReviewFilterInput? get review =>
      (_$data['review'] as Input$ReviewFilterInput?);

  Input$StringOperationFilterInput? get backgroundJobId =>
      (_$data['backgroundJobId'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('clientId')) {
      final l$clientId = clientId;
      result$data['clientId'] = l$clientId?.toJson();
    }
    if (_$data.containsKey('providerId')) {
      final l$providerId = providerId;
      result$data['providerId'] = l$providerId?.toJson();
    }
    if (_$data.containsKey('artistPackageId')) {
      final l$artistPackageId = artistPackageId;
      result$data['artistPackageId'] = l$artistPackageId?.toJson();
    }
    if (_$data.containsKey('paymentTransactionId')) {
      final l$paymentTransactionId = paymentTransactionId;
      result$data['paymentTransactionId'] = l$paymentTransactionId?.toJson();
    }
    if (_$data.containsKey('conversationId')) {
      final l$conversationId = conversationId;
      result$data['conversationId'] = l$conversationId?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('revisionCount')) {
      final l$revisionCount = revisionCount;
      result$data['revisionCount'] = l$revisionCount?.toJson();
    }
    if (_$data.containsKey('deliveries')) {
      final l$deliveries = deliveries;
      result$data['deliveries'] = l$deliveries?.toJson();
    }
    if (_$data.containsKey('deadline')) {
      final l$deadline = deadline;
      result$data['deadline'] = l$deadline?.toJson();
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toJson();
    }
    if (_$data.containsKey('isEscrowReleased')) {
      final l$isEscrowReleased = isEscrowReleased;
      result$data['isEscrowReleased'] = l$isEscrowReleased?.toJson();
    }
    if (_$data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = platformFeePercentage;
      result$data['platformFeePercentage'] = l$platformFeePercentage?.toJson();
    }
    if (_$data.containsKey('artistFeePercentage')) {
      final l$artistFeePercentage = artistFeePercentage;
      result$data['artistFeePercentage'] = l$artistFeePercentage?.toJson();
    }
    if (_$data.containsKey('review')) {
      final l$review = review;
      result$data['review'] = l$review?.toJson();
    }
    if (_$data.containsKey('backgroundJobId')) {
      final l$backgroundJobId = backgroundJobId;
      result$data['backgroundJobId'] = l$backgroundJobId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PackageOrderFilterInput<Input$PackageOrderFilterInput>
  get copyWith => CopyWith$Input$PackageOrderFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PackageOrderFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientId = clientId;
    final lOther$clientId = other.clientId;
    if (_$data.containsKey('clientId') !=
        other._$data.containsKey('clientId')) {
      return false;
    }
    if (l$clientId != lOther$clientId) {
      return false;
    }
    final l$providerId = providerId;
    final lOther$providerId = other.providerId;
    if (_$data.containsKey('providerId') !=
        other._$data.containsKey('providerId')) {
      return false;
    }
    if (l$providerId != lOther$providerId) {
      return false;
    }
    final l$artistPackageId = artistPackageId;
    final lOther$artistPackageId = other.artistPackageId;
    if (_$data.containsKey('artistPackageId') !=
        other._$data.containsKey('artistPackageId')) {
      return false;
    }
    if (l$artistPackageId != lOther$artistPackageId) {
      return false;
    }
    final l$paymentTransactionId = paymentTransactionId;
    final lOther$paymentTransactionId = other.paymentTransactionId;
    if (_$data.containsKey('paymentTransactionId') !=
        other._$data.containsKey('paymentTransactionId')) {
      return false;
    }
    if (l$paymentTransactionId != lOther$paymentTransactionId) {
      return false;
    }
    final l$conversationId = conversationId;
    final lOther$conversationId = other.conversationId;
    if (_$data.containsKey('conversationId') !=
        other._$data.containsKey('conversationId')) {
      return false;
    }
    if (l$conversationId != lOther$conversationId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$revisionCount = revisionCount;
    final lOther$revisionCount = other.revisionCount;
    if (_$data.containsKey('revisionCount') !=
        other._$data.containsKey('revisionCount')) {
      return false;
    }
    if (l$revisionCount != lOther$revisionCount) {
      return false;
    }
    final l$deliveries = deliveries;
    final lOther$deliveries = other.deliveries;
    if (_$data.containsKey('deliveries') !=
        other._$data.containsKey('deliveries')) {
      return false;
    }
    if (l$deliveries != lOther$deliveries) {
      return false;
    }
    final l$deadline = deadline;
    final lOther$deadline = other.deadline;
    if (_$data.containsKey('deadline') !=
        other._$data.containsKey('deadline')) {
      return false;
    }
    if (l$deadline != lOther$deadline) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$isEscrowReleased = isEscrowReleased;
    final lOther$isEscrowReleased = other.isEscrowReleased;
    if (_$data.containsKey('isEscrowReleased') !=
        other._$data.containsKey('isEscrowReleased')) {
      return false;
    }
    if (l$isEscrowReleased != lOther$isEscrowReleased) {
      return false;
    }
    final l$platformFeePercentage = platformFeePercentage;
    final lOther$platformFeePercentage = other.platformFeePercentage;
    if (_$data.containsKey('platformFeePercentage') !=
        other._$data.containsKey('platformFeePercentage')) {
      return false;
    }
    if (l$platformFeePercentage != lOther$platformFeePercentage) {
      return false;
    }
    final l$artistFeePercentage = artistFeePercentage;
    final lOther$artistFeePercentage = other.artistFeePercentage;
    if (_$data.containsKey('artistFeePercentage') !=
        other._$data.containsKey('artistFeePercentage')) {
      return false;
    }
    if (l$artistFeePercentage != lOther$artistFeePercentage) {
      return false;
    }
    final l$review = review;
    final lOther$review = other.review;
    if (_$data.containsKey('review') != other._$data.containsKey('review')) {
      return false;
    }
    if (l$review != lOther$review) {
      return false;
    }
    final l$backgroundJobId = backgroundJobId;
    final lOther$backgroundJobId = other.backgroundJobId;
    if (_$data.containsKey('backgroundJobId') !=
        other._$data.containsKey('backgroundJobId')) {
      return false;
    }
    if (l$backgroundJobId != lOther$backgroundJobId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$clientId = clientId;
    final l$providerId = providerId;
    final l$artistPackageId = artistPackageId;
    final l$paymentTransactionId = paymentTransactionId;
    final l$conversationId = conversationId;
    final l$status = status;
    final l$revisionCount = revisionCount;
    final l$deliveries = deliveries;
    final l$deadline = deadline;
    final l$completedAt = completedAt;
    final l$isEscrowReleased = isEscrowReleased;
    final l$platformFeePercentage = platformFeePercentage;
    final l$artistFeePercentage = artistFeePercentage;
    final l$review = review;
    final l$backgroundJobId = backgroundJobId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('clientId') ? l$clientId : const {},
      _$data.containsKey('providerId') ? l$providerId : const {},
      _$data.containsKey('artistPackageId') ? l$artistPackageId : const {},
      _$data.containsKey('paymentTransactionId')
          ? l$paymentTransactionId
          : const {},
      _$data.containsKey('conversationId') ? l$conversationId : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('revisionCount') ? l$revisionCount : const {},
      _$data.containsKey('deliveries') ? l$deliveries : const {},
      _$data.containsKey('deadline') ? l$deadline : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('isEscrowReleased') ? l$isEscrowReleased : const {},
      _$data.containsKey('platformFeePercentage')
          ? l$platformFeePercentage
          : const {},
      _$data.containsKey('artistFeePercentage')
          ? l$artistFeePercentage
          : const {},
      _$data.containsKey('review') ? l$review : const {},
      _$data.containsKey('backgroundJobId') ? l$backgroundJobId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageOrderFilterInput<TRes> {
  factory CopyWith$Input$PackageOrderFilterInput(
    Input$PackageOrderFilterInput instance,
    TRes Function(Input$PackageOrderFilterInput) then,
  ) = _CopyWithImpl$Input$PackageOrderFilterInput;

  factory CopyWith$Input$PackageOrderFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageOrderFilterInput;

  TRes call({
    List<Input$PackageOrderFilterInput>? and,
    List<Input$PackageOrderFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? clientId,
    Input$StringOperationFilterInput? providerId,
    Input$StringOperationFilterInput? artistPackageId,
    Input$StringOperationFilterInput? paymentTransactionId,
    Input$StringOperationFilterInput? conversationId,
    Input$PackageOrderStatusOperationFilterInput? status,
    Input$IntOperationFilterInput? revisionCount,
    Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput? deliveries,
    Input$DateTimeOperationFilterInput? deadline,
    Input$DateTimeOperationFilterInput? completedAt,
    Input$BooleanOperationFilterInput? isEscrowReleased,
    Input$DecimalOperationFilterInput? platformFeePercentage,
    Input$DecimalOperationFilterInput? artistFeePercentage,
    Input$ReviewFilterInput? review,
    Input$StringOperationFilterInput? backgroundJobId,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$PackageOrderFilterInput>? Function(
      Iterable<
        CopyWith$Input$PackageOrderFilterInput<Input$PackageOrderFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$PackageOrderFilterInput>? Function(
      Iterable<
        CopyWith$Input$PackageOrderFilterInput<Input$PackageOrderFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get clientId;
  CopyWith$Input$StringOperationFilterInput<TRes> get providerId;
  CopyWith$Input$StringOperationFilterInput<TRes> get artistPackageId;
  CopyWith$Input$StringOperationFilterInput<TRes> get paymentTransactionId;
  CopyWith$Input$StringOperationFilterInput<TRes> get conversationId;
  CopyWith$Input$PackageOrderStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$IntOperationFilterInput<TRes> get revisionCount;
  CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput<TRes>
  get deliveries;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deadline;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get completedAt;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isEscrowReleased;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get platformFeePercentage;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get artistFeePercentage;
  CopyWith$Input$ReviewFilterInput<TRes> get review;
  CopyWith$Input$StringOperationFilterInput<TRes> get backgroundJobId;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$PackageOrderFilterInput<TRes>
    implements CopyWith$Input$PackageOrderFilterInput<TRes> {
  _CopyWithImpl$Input$PackageOrderFilterInput(this._instance, this._then);

  final Input$PackageOrderFilterInput _instance;

  final TRes Function(Input$PackageOrderFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? clientId = _undefined,
    Object? providerId = _undefined,
    Object? artistPackageId = _undefined,
    Object? paymentTransactionId = _undefined,
    Object? conversationId = _undefined,
    Object? status = _undefined,
    Object? revisionCount = _undefined,
    Object? deliveries = _undefined,
    Object? deadline = _undefined,
    Object? completedAt = _undefined,
    Object? isEscrowReleased = _undefined,
    Object? platformFeePercentage = _undefined,
    Object? artistFeePercentage = _undefined,
    Object? review = _undefined,
    Object? backgroundJobId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$PackageOrderFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$PackageOrderFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$PackageOrderFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (clientId != _undefined)
        'clientId': (clientId as Input$StringOperationFilterInput?),
      if (providerId != _undefined)
        'providerId': (providerId as Input$StringOperationFilterInput?),
      if (artistPackageId != _undefined)
        'artistPackageId':
            (artistPackageId as Input$StringOperationFilterInput?),
      if (paymentTransactionId != _undefined)
        'paymentTransactionId':
            (paymentTransactionId as Input$StringOperationFilterInput?),
      if (conversationId != _undefined)
        'conversationId': (conversationId as Input$StringOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$PackageOrderStatusOperationFilterInput?),
      if (revisionCount != _undefined)
        'revisionCount': (revisionCount as Input$IntOperationFilterInput?),
      if (deliveries != _undefined)
        'deliveries':
            (deliveries
                as Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput?),
      if (deadline != _undefined)
        'deadline': (deadline as Input$DateTimeOperationFilterInput?),
      if (completedAt != _undefined)
        'completedAt': (completedAt as Input$DateTimeOperationFilterInput?),
      if (isEscrowReleased != _undefined)
        'isEscrowReleased':
            (isEscrowReleased as Input$BooleanOperationFilterInput?),
      if (platformFeePercentage != _undefined)
        'platformFeePercentage':
            (platformFeePercentage as Input$DecimalOperationFilterInput?),
      if (artistFeePercentage != _undefined)
        'artistFeePercentage':
            (artistFeePercentage as Input$DecimalOperationFilterInput?),
      if (review != _undefined) 'review': (review as Input$ReviewFilterInput?),
      if (backgroundJobId != _undefined)
        'backgroundJobId':
            (backgroundJobId as Input$StringOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$PackageOrderFilterInput>? Function(
      Iterable<
        CopyWith$Input$PackageOrderFilterInput<Input$PackageOrderFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$PackageOrderFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$PackageOrderFilterInput>? Function(
      Iterable<
        CopyWith$Input$PackageOrderFilterInput<Input$PackageOrderFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$PackageOrderFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get clientId {
    final local$clientId = _instance.clientId;
    return local$clientId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$clientId,
            (e) => call(clientId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get providerId {
    final local$providerId = _instance.providerId;
    return local$providerId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$providerId,
            (e) => call(providerId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get artistPackageId {
    final local$artistPackageId = _instance.artistPackageId;
    return local$artistPackageId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$artistPackageId,
            (e) => call(artistPackageId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get paymentTransactionId {
    final local$paymentTransactionId = _instance.paymentTransactionId;
    return local$paymentTransactionId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$paymentTransactionId,
            (e) => call(paymentTransactionId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get conversationId {
    final local$conversationId = _instance.conversationId;
    return local$conversationId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$conversationId,
            (e) => call(conversationId: e),
          );
  }

  CopyWith$Input$PackageOrderStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$PackageOrderStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$PackageOrderStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get revisionCount {
    final local$revisionCount = _instance.revisionCount;
    return local$revisionCount == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$revisionCount,
            (e) => call(revisionCount: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput<TRes>
  get deliveries {
    final local$deliveries = _instance.deliveries;
    return local$deliveries == null
        ? CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput(
            local$deliveries,
            (e) => call(deliveries: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deadline {
    final local$deadline = _instance.deadline;
    return local$deadline == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$deadline,
            (e) => call(deadline: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get completedAt {
    final local$completedAt = _instance.completedAt;
    return local$completedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$completedAt,
            (e) => call(completedAt: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isEscrowReleased {
    final local$isEscrowReleased = _instance.isEscrowReleased;
    return local$isEscrowReleased == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isEscrowReleased,
            (e) => call(isEscrowReleased: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get platformFeePercentage {
    final local$platformFeePercentage = _instance.platformFeePercentage;
    return local$platformFeePercentage == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$platformFeePercentage,
            (e) => call(platformFeePercentage: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get artistFeePercentage {
    final local$artistFeePercentage = _instance.artistFeePercentage;
    return local$artistFeePercentage == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$artistFeePercentage,
            (e) => call(artistFeePercentage: e),
          );
  }

  CopyWith$Input$ReviewFilterInput<TRes> get review {
    final local$review = _instance.review;
    return local$review == null
        ? CopyWith$Input$ReviewFilterInput.stub(_then(_instance))
        : CopyWith$Input$ReviewFilterInput(
            local$review,
            (e) => call(review: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get backgroundJobId {
    final local$backgroundJobId = _instance.backgroundJobId;
    return local$backgroundJobId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$backgroundJobId,
            (e) => call(backgroundJobId: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$PackageOrderFilterInput<TRes>
    implements CopyWith$Input$PackageOrderFilterInput<TRes> {
  _CopyWithStubImpl$Input$PackageOrderFilterInput(this._res);

  TRes _res;

  call({
    List<Input$PackageOrderFilterInput>? and,
    List<Input$PackageOrderFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? clientId,
    Input$StringOperationFilterInput? providerId,
    Input$StringOperationFilterInput? artistPackageId,
    Input$StringOperationFilterInput? paymentTransactionId,
    Input$StringOperationFilterInput? conversationId,
    Input$PackageOrderStatusOperationFilterInput? status,
    Input$IntOperationFilterInput? revisionCount,
    Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput? deliveries,
    Input$DateTimeOperationFilterInput? deadline,
    Input$DateTimeOperationFilterInput? completedAt,
    Input$BooleanOperationFilterInput? isEscrowReleased,
    Input$DecimalOperationFilterInput? platformFeePercentage,
    Input$DecimalOperationFilterInput? artistFeePercentage,
    Input$ReviewFilterInput? review,
    Input$StringOperationFilterInput? backgroundJobId,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get clientId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get providerId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get artistPackageId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get paymentTransactionId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get conversationId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$PackageOrderStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$PackageOrderStatusOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get revisionCount =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput<TRes>
  get deliveries =>
      CopyWith$Input$ListFilterInputTypeOfPackageOrderDeliveryFilterInput.stub(
        _res,
      );

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deadline =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get completedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isEscrowReleased =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get platformFeePercentage =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get artistFeePercentage =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$ReviewFilterInput<TRes> get review =>
      CopyWith$Input$ReviewFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get backgroundJobId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$PackageOrderRefundRequestInput {
  factory Input$PackageOrderRefundRequestInput({
    required String id,
    required double artistPercentageAmount,
    required double requestorPercentageAmount,
  }) => Input$PackageOrderRefundRequestInput._({
    r'id': id,
    r'artistPercentageAmount': artistPercentageAmount,
    r'requestorPercentageAmount': requestorPercentageAmount,
  });

  Input$PackageOrderRefundRequestInput._(this._$data);

  factory Input$PackageOrderRefundRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$artistPercentageAmount = data['artistPercentageAmount'];
    result$data['artistPercentageAmount'] = (l$artistPercentageAmount as num)
        .toDouble();
    final l$requestorPercentageAmount = data['requestorPercentageAmount'];
    result$data['requestorPercentageAmount'] =
        (l$requestorPercentageAmount as num).toDouble();
    return Input$PackageOrderRefundRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  double get artistPercentageAmount =>
      (_$data['artistPercentageAmount'] as double);

  double get requestorPercentageAmount =>
      (_$data['requestorPercentageAmount'] as double);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$artistPercentageAmount = artistPercentageAmount;
    result$data['artistPercentageAmount'] = l$artistPercentageAmount;
    final l$requestorPercentageAmount = requestorPercentageAmount;
    result$data['requestorPercentageAmount'] = l$requestorPercentageAmount;
    return result$data;
  }

  CopyWith$Input$PackageOrderRefundRequestInput<
    Input$PackageOrderRefundRequestInput
  >
  get copyWith => CopyWith$Input$PackageOrderRefundRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PackageOrderRefundRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$artistPercentageAmount = artistPercentageAmount;
    final lOther$artistPercentageAmount = other.artistPercentageAmount;
    if (l$artistPercentageAmount != lOther$artistPercentageAmount) {
      return false;
    }
    final l$requestorPercentageAmount = requestorPercentageAmount;
    final lOther$requestorPercentageAmount = other.requestorPercentageAmount;
    if (l$requestorPercentageAmount != lOther$requestorPercentageAmount) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$artistPercentageAmount = artistPercentageAmount;
    final l$requestorPercentageAmount = requestorPercentageAmount;
    return Object.hashAll([
      l$id,
      l$artistPercentageAmount,
      l$requestorPercentageAmount,
    ]);
  }
}

abstract class CopyWith$Input$PackageOrderRefundRequestInput<TRes> {
  factory CopyWith$Input$PackageOrderRefundRequestInput(
    Input$PackageOrderRefundRequestInput instance,
    TRes Function(Input$PackageOrderRefundRequestInput) then,
  ) = _CopyWithImpl$Input$PackageOrderRefundRequestInput;

  factory CopyWith$Input$PackageOrderRefundRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageOrderRefundRequestInput;

  TRes call({
    String? id,
    double? artistPercentageAmount,
    double? requestorPercentageAmount,
  });
}

class _CopyWithImpl$Input$PackageOrderRefundRequestInput<TRes>
    implements CopyWith$Input$PackageOrderRefundRequestInput<TRes> {
  _CopyWithImpl$Input$PackageOrderRefundRequestInput(
    this._instance,
    this._then,
  );

  final Input$PackageOrderRefundRequestInput _instance;

  final TRes Function(Input$PackageOrderRefundRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? artistPercentageAmount = _undefined,
    Object? requestorPercentageAmount = _undefined,
  }) => _then(
    Input$PackageOrderRefundRequestInput._({
      ..._instance._$data,
      if (id != _undefined && id != null) 'id': (id as String),
      if (artistPercentageAmount != _undefined &&
          artistPercentageAmount != null)
        'artistPercentageAmount': (artistPercentageAmount as double),
      if (requestorPercentageAmount != _undefined &&
          requestorPercentageAmount != null)
        'requestorPercentageAmount': (requestorPercentageAmount as double),
    }),
  );
}

class _CopyWithStubImpl$Input$PackageOrderRefundRequestInput<TRes>
    implements CopyWith$Input$PackageOrderRefundRequestInput<TRes> {
  _CopyWithStubImpl$Input$PackageOrderRefundRequestInput(this._res);

  TRes _res;

  call({
    String? id,
    double? artistPercentageAmount,
    double? requestorPercentageAmount,
  }) => _res;
}

class Input$PackageOrderSortInput {
  factory Input$PackageOrderSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? clientId,
    Enum$SortEnumType? providerId,
    Enum$SortEnumType? artistPackageId,
    Enum$SortEnumType? paymentTransactionId,
    Enum$SortEnumType? conversationId,
    Enum$SortEnumType? status,
    Enum$SortEnumType? revisionCount,
    Enum$SortEnumType? deadline,
    Enum$SortEnumType? completedAt,
    Enum$SortEnumType? isEscrowReleased,
    Enum$SortEnumType? platformFeePercentage,
    Enum$SortEnumType? artistFeePercentage,
    Input$ReviewSortInput? review,
    Enum$SortEnumType? backgroundJobId,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$PackageOrderSortInput._({
    if (id != null) r'id': id,
    if (clientId != null) r'clientId': clientId,
    if (providerId != null) r'providerId': providerId,
    if (artistPackageId != null) r'artistPackageId': artistPackageId,
    if (paymentTransactionId != null)
      r'paymentTransactionId': paymentTransactionId,
    if (conversationId != null) r'conversationId': conversationId,
    if (status != null) r'status': status,
    if (revisionCount != null) r'revisionCount': revisionCount,
    if (deadline != null) r'deadline': deadline,
    if (completedAt != null) r'completedAt': completedAt,
    if (isEscrowReleased != null) r'isEscrowReleased': isEscrowReleased,
    if (platformFeePercentage != null)
      r'platformFeePercentage': platformFeePercentage,
    if (artistFeePercentage != null)
      r'artistFeePercentage': artistFeePercentage,
    if (review != null) r'review': review,
    if (backgroundJobId != null) r'backgroundJobId': backgroundJobId,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$PackageOrderSortInput._(this._$data);

  factory Input$PackageOrderSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('clientId')) {
      final l$clientId = data['clientId'];
      result$data['clientId'] = l$clientId == null
          ? null
          : fromJson$Enum$SortEnumType((l$clientId as String));
    }
    if (data.containsKey('providerId')) {
      final l$providerId = data['providerId'];
      result$data['providerId'] = l$providerId == null
          ? null
          : fromJson$Enum$SortEnumType((l$providerId as String));
    }
    if (data.containsKey('artistPackageId')) {
      final l$artistPackageId = data['artistPackageId'];
      result$data['artistPackageId'] = l$artistPackageId == null
          ? null
          : fromJson$Enum$SortEnumType((l$artistPackageId as String));
    }
    if (data.containsKey('paymentTransactionId')) {
      final l$paymentTransactionId = data['paymentTransactionId'];
      result$data['paymentTransactionId'] = l$paymentTransactionId == null
          ? null
          : fromJson$Enum$SortEnumType((l$paymentTransactionId as String));
    }
    if (data.containsKey('conversationId')) {
      final l$conversationId = data['conversationId'];
      result$data['conversationId'] = l$conversationId == null
          ? null
          : fromJson$Enum$SortEnumType((l$conversationId as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('revisionCount')) {
      final l$revisionCount = data['revisionCount'];
      result$data['revisionCount'] = l$revisionCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$revisionCount as String));
    }
    if (data.containsKey('deadline')) {
      final l$deadline = data['deadline'];
      result$data['deadline'] = l$deadline == null
          ? null
          : fromJson$Enum$SortEnumType((l$deadline as String));
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$completedAt as String));
    }
    if (data.containsKey('isEscrowReleased')) {
      final l$isEscrowReleased = data['isEscrowReleased'];
      result$data['isEscrowReleased'] = l$isEscrowReleased == null
          ? null
          : fromJson$Enum$SortEnumType((l$isEscrowReleased as String));
    }
    if (data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = data['platformFeePercentage'];
      result$data['platformFeePercentage'] = l$platformFeePercentage == null
          ? null
          : fromJson$Enum$SortEnumType((l$platformFeePercentage as String));
    }
    if (data.containsKey('artistFeePercentage')) {
      final l$artistFeePercentage = data['artistFeePercentage'];
      result$data['artistFeePercentage'] = l$artistFeePercentage == null
          ? null
          : fromJson$Enum$SortEnumType((l$artistFeePercentage as String));
    }
    if (data.containsKey('review')) {
      final l$review = data['review'];
      result$data['review'] = l$review == null
          ? null
          : Input$ReviewSortInput.fromJson((l$review as Map<String, dynamic>));
    }
    if (data.containsKey('backgroundJobId')) {
      final l$backgroundJobId = data['backgroundJobId'];
      result$data['backgroundJobId'] = l$backgroundJobId == null
          ? null
          : fromJson$Enum$SortEnumType((l$backgroundJobId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$PackageOrderSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get clientId => (_$data['clientId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get providerId =>
      (_$data['providerId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get artistPackageId =>
      (_$data['artistPackageId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get paymentTransactionId =>
      (_$data['paymentTransactionId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get conversationId =>
      (_$data['conversationId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get revisionCount =>
      (_$data['revisionCount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get deadline => (_$data['deadline'] as Enum$SortEnumType?);

  Enum$SortEnumType? get completedAt =>
      (_$data['completedAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isEscrowReleased =>
      (_$data['isEscrowReleased'] as Enum$SortEnumType?);

  Enum$SortEnumType? get platformFeePercentage =>
      (_$data['platformFeePercentage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get artistFeePercentage =>
      (_$data['artistFeePercentage'] as Enum$SortEnumType?);

  Input$ReviewSortInput? get review =>
      (_$data['review'] as Input$ReviewSortInput?);

  Enum$SortEnumType? get backgroundJobId =>
      (_$data['backgroundJobId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('clientId')) {
      final l$clientId = clientId;
      result$data['clientId'] = l$clientId == null
          ? null
          : toJson$Enum$SortEnumType(l$clientId);
    }
    if (_$data.containsKey('providerId')) {
      final l$providerId = providerId;
      result$data['providerId'] = l$providerId == null
          ? null
          : toJson$Enum$SortEnumType(l$providerId);
    }
    if (_$data.containsKey('artistPackageId')) {
      final l$artistPackageId = artistPackageId;
      result$data['artistPackageId'] = l$artistPackageId == null
          ? null
          : toJson$Enum$SortEnumType(l$artistPackageId);
    }
    if (_$data.containsKey('paymentTransactionId')) {
      final l$paymentTransactionId = paymentTransactionId;
      result$data['paymentTransactionId'] = l$paymentTransactionId == null
          ? null
          : toJson$Enum$SortEnumType(l$paymentTransactionId);
    }
    if (_$data.containsKey('conversationId')) {
      final l$conversationId = conversationId;
      result$data['conversationId'] = l$conversationId == null
          ? null
          : toJson$Enum$SortEnumType(l$conversationId);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('revisionCount')) {
      final l$revisionCount = revisionCount;
      result$data['revisionCount'] = l$revisionCount == null
          ? null
          : toJson$Enum$SortEnumType(l$revisionCount);
    }
    if (_$data.containsKey('deadline')) {
      final l$deadline = deadline;
      result$data['deadline'] = l$deadline == null
          ? null
          : toJson$Enum$SortEnumType(l$deadline);
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$completedAt);
    }
    if (_$data.containsKey('isEscrowReleased')) {
      final l$isEscrowReleased = isEscrowReleased;
      result$data['isEscrowReleased'] = l$isEscrowReleased == null
          ? null
          : toJson$Enum$SortEnumType(l$isEscrowReleased);
    }
    if (_$data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = platformFeePercentage;
      result$data['platformFeePercentage'] = l$platformFeePercentage == null
          ? null
          : toJson$Enum$SortEnumType(l$platformFeePercentage);
    }
    if (_$data.containsKey('artistFeePercentage')) {
      final l$artistFeePercentage = artistFeePercentage;
      result$data['artistFeePercentage'] = l$artistFeePercentage == null
          ? null
          : toJson$Enum$SortEnumType(l$artistFeePercentage);
    }
    if (_$data.containsKey('review')) {
      final l$review = review;
      result$data['review'] = l$review?.toJson();
    }
    if (_$data.containsKey('backgroundJobId')) {
      final l$backgroundJobId = backgroundJobId;
      result$data['backgroundJobId'] = l$backgroundJobId == null
          ? null
          : toJson$Enum$SortEnumType(l$backgroundJobId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$PackageOrderSortInput<Input$PackageOrderSortInput>
  get copyWith => CopyWith$Input$PackageOrderSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PackageOrderSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientId = clientId;
    final lOther$clientId = other.clientId;
    if (_$data.containsKey('clientId') !=
        other._$data.containsKey('clientId')) {
      return false;
    }
    if (l$clientId != lOther$clientId) {
      return false;
    }
    final l$providerId = providerId;
    final lOther$providerId = other.providerId;
    if (_$data.containsKey('providerId') !=
        other._$data.containsKey('providerId')) {
      return false;
    }
    if (l$providerId != lOther$providerId) {
      return false;
    }
    final l$artistPackageId = artistPackageId;
    final lOther$artistPackageId = other.artistPackageId;
    if (_$data.containsKey('artistPackageId') !=
        other._$data.containsKey('artistPackageId')) {
      return false;
    }
    if (l$artistPackageId != lOther$artistPackageId) {
      return false;
    }
    final l$paymentTransactionId = paymentTransactionId;
    final lOther$paymentTransactionId = other.paymentTransactionId;
    if (_$data.containsKey('paymentTransactionId') !=
        other._$data.containsKey('paymentTransactionId')) {
      return false;
    }
    if (l$paymentTransactionId != lOther$paymentTransactionId) {
      return false;
    }
    final l$conversationId = conversationId;
    final lOther$conversationId = other.conversationId;
    if (_$data.containsKey('conversationId') !=
        other._$data.containsKey('conversationId')) {
      return false;
    }
    if (l$conversationId != lOther$conversationId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$revisionCount = revisionCount;
    final lOther$revisionCount = other.revisionCount;
    if (_$data.containsKey('revisionCount') !=
        other._$data.containsKey('revisionCount')) {
      return false;
    }
    if (l$revisionCount != lOther$revisionCount) {
      return false;
    }
    final l$deadline = deadline;
    final lOther$deadline = other.deadline;
    if (_$data.containsKey('deadline') !=
        other._$data.containsKey('deadline')) {
      return false;
    }
    if (l$deadline != lOther$deadline) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$isEscrowReleased = isEscrowReleased;
    final lOther$isEscrowReleased = other.isEscrowReleased;
    if (_$data.containsKey('isEscrowReleased') !=
        other._$data.containsKey('isEscrowReleased')) {
      return false;
    }
    if (l$isEscrowReleased != lOther$isEscrowReleased) {
      return false;
    }
    final l$platformFeePercentage = platformFeePercentage;
    final lOther$platformFeePercentage = other.platformFeePercentage;
    if (_$data.containsKey('platformFeePercentage') !=
        other._$data.containsKey('platformFeePercentage')) {
      return false;
    }
    if (l$platformFeePercentage != lOther$platformFeePercentage) {
      return false;
    }
    final l$artistFeePercentage = artistFeePercentage;
    final lOther$artistFeePercentage = other.artistFeePercentage;
    if (_$data.containsKey('artistFeePercentage') !=
        other._$data.containsKey('artistFeePercentage')) {
      return false;
    }
    if (l$artistFeePercentage != lOther$artistFeePercentage) {
      return false;
    }
    final l$review = review;
    final lOther$review = other.review;
    if (_$data.containsKey('review') != other._$data.containsKey('review')) {
      return false;
    }
    if (l$review != lOther$review) {
      return false;
    }
    final l$backgroundJobId = backgroundJobId;
    final lOther$backgroundJobId = other.backgroundJobId;
    if (_$data.containsKey('backgroundJobId') !=
        other._$data.containsKey('backgroundJobId')) {
      return false;
    }
    if (l$backgroundJobId != lOther$backgroundJobId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientId = clientId;
    final l$providerId = providerId;
    final l$artistPackageId = artistPackageId;
    final l$paymentTransactionId = paymentTransactionId;
    final l$conversationId = conversationId;
    final l$status = status;
    final l$revisionCount = revisionCount;
    final l$deadline = deadline;
    final l$completedAt = completedAt;
    final l$isEscrowReleased = isEscrowReleased;
    final l$platformFeePercentage = platformFeePercentage;
    final l$artistFeePercentage = artistFeePercentage;
    final l$review = review;
    final l$backgroundJobId = backgroundJobId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('clientId') ? l$clientId : const {},
      _$data.containsKey('providerId') ? l$providerId : const {},
      _$data.containsKey('artistPackageId') ? l$artistPackageId : const {},
      _$data.containsKey('paymentTransactionId')
          ? l$paymentTransactionId
          : const {},
      _$data.containsKey('conversationId') ? l$conversationId : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('revisionCount') ? l$revisionCount : const {},
      _$data.containsKey('deadline') ? l$deadline : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('isEscrowReleased') ? l$isEscrowReleased : const {},
      _$data.containsKey('platformFeePercentage')
          ? l$platformFeePercentage
          : const {},
      _$data.containsKey('artistFeePercentage')
          ? l$artistFeePercentage
          : const {},
      _$data.containsKey('review') ? l$review : const {},
      _$data.containsKey('backgroundJobId') ? l$backgroundJobId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageOrderSortInput<TRes> {
  factory CopyWith$Input$PackageOrderSortInput(
    Input$PackageOrderSortInput instance,
    TRes Function(Input$PackageOrderSortInput) then,
  ) = _CopyWithImpl$Input$PackageOrderSortInput;

  factory CopyWith$Input$PackageOrderSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageOrderSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? clientId,
    Enum$SortEnumType? providerId,
    Enum$SortEnumType? artistPackageId,
    Enum$SortEnumType? paymentTransactionId,
    Enum$SortEnumType? conversationId,
    Enum$SortEnumType? status,
    Enum$SortEnumType? revisionCount,
    Enum$SortEnumType? deadline,
    Enum$SortEnumType? completedAt,
    Enum$SortEnumType? isEscrowReleased,
    Enum$SortEnumType? platformFeePercentage,
    Enum$SortEnumType? artistFeePercentage,
    Input$ReviewSortInput? review,
    Enum$SortEnumType? backgroundJobId,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
  CopyWith$Input$ReviewSortInput<TRes> get review;
}

class _CopyWithImpl$Input$PackageOrderSortInput<TRes>
    implements CopyWith$Input$PackageOrderSortInput<TRes> {
  _CopyWithImpl$Input$PackageOrderSortInput(this._instance, this._then);

  final Input$PackageOrderSortInput _instance;

  final TRes Function(Input$PackageOrderSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? clientId = _undefined,
    Object? providerId = _undefined,
    Object? artistPackageId = _undefined,
    Object? paymentTransactionId = _undefined,
    Object? conversationId = _undefined,
    Object? status = _undefined,
    Object? revisionCount = _undefined,
    Object? deadline = _undefined,
    Object? completedAt = _undefined,
    Object? isEscrowReleased = _undefined,
    Object? platformFeePercentage = _undefined,
    Object? artistFeePercentage = _undefined,
    Object? review = _undefined,
    Object? backgroundJobId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$PackageOrderSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (clientId != _undefined) 'clientId': (clientId as Enum$SortEnumType?),
      if (providerId != _undefined)
        'providerId': (providerId as Enum$SortEnumType?),
      if (artistPackageId != _undefined)
        'artistPackageId': (artistPackageId as Enum$SortEnumType?),
      if (paymentTransactionId != _undefined)
        'paymentTransactionId': (paymentTransactionId as Enum$SortEnumType?),
      if (conversationId != _undefined)
        'conversationId': (conversationId as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (revisionCount != _undefined)
        'revisionCount': (revisionCount as Enum$SortEnumType?),
      if (deadline != _undefined) 'deadline': (deadline as Enum$SortEnumType?),
      if (completedAt != _undefined)
        'completedAt': (completedAt as Enum$SortEnumType?),
      if (isEscrowReleased != _undefined)
        'isEscrowReleased': (isEscrowReleased as Enum$SortEnumType?),
      if (platformFeePercentage != _undefined)
        'platformFeePercentage': (platformFeePercentage as Enum$SortEnumType?),
      if (artistFeePercentage != _undefined)
        'artistFeePercentage': (artistFeePercentage as Enum$SortEnumType?),
      if (review != _undefined) 'review': (review as Input$ReviewSortInput?),
      if (backgroundJobId != _undefined)
        'backgroundJobId': (backgroundJobId as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );

  CopyWith$Input$ReviewSortInput<TRes> get review {
    final local$review = _instance.review;
    return local$review == null
        ? CopyWith$Input$ReviewSortInput.stub(_then(_instance))
        : CopyWith$Input$ReviewSortInput(local$review, (e) => call(review: e));
  }
}

class _CopyWithStubImpl$Input$PackageOrderSortInput<TRes>
    implements CopyWith$Input$PackageOrderSortInput<TRes> {
  _CopyWithStubImpl$Input$PackageOrderSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? clientId,
    Enum$SortEnumType? providerId,
    Enum$SortEnumType? artistPackageId,
    Enum$SortEnumType? paymentTransactionId,
    Enum$SortEnumType? conversationId,
    Enum$SortEnumType? status,
    Enum$SortEnumType? revisionCount,
    Enum$SortEnumType? deadline,
    Enum$SortEnumType? completedAt,
    Enum$SortEnumType? isEscrowReleased,
    Enum$SortEnumType? platformFeePercentage,
    Enum$SortEnumType? artistFeePercentage,
    Input$ReviewSortInput? review,
    Enum$SortEnumType? backgroundJobId,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;

  CopyWith$Input$ReviewSortInput<TRes> get review =>
      CopyWith$Input$ReviewSortInput.stub(_res);
}

class Input$PackageOrderStatusOperationFilterInput {
  factory Input$PackageOrderStatusOperationFilterInput({
    Enum$PackageOrderStatus? eq,
    Enum$PackageOrderStatus? neq,
    List<Enum$PackageOrderStatus>? $in,
    List<Enum$PackageOrderStatus>? nin,
  }) => Input$PackageOrderStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$PackageOrderStatusOperationFilterInput._(this._$data);

  factory Input$PackageOrderStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$PackageOrderStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$PackageOrderStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PackageOrderStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PackageOrderStatus((e as String)))
          .toList();
    }
    return Input$PackageOrderStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PackageOrderStatus? get eq => (_$data['eq'] as Enum$PackageOrderStatus?);

  Enum$PackageOrderStatus? get neq =>
      (_$data['neq'] as Enum$PackageOrderStatus?);

  List<Enum$PackageOrderStatus>? get $in =>
      (_$data['in'] as List<Enum$PackageOrderStatus>?);

  List<Enum$PackageOrderStatus>? get nin =>
      (_$data['nin'] as List<Enum$PackageOrderStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$PackageOrderStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$PackageOrderStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$PackageOrderStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$PackageOrderStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$PackageOrderStatusOperationFilterInput<
    Input$PackageOrderStatusOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$PackageOrderStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PackageOrderStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageOrderStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$PackageOrderStatusOperationFilterInput(
    Input$PackageOrderStatusOperationFilterInput instance,
    TRes Function(Input$PackageOrderStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$PackageOrderStatusOperationFilterInput;

  factory CopyWith$Input$PackageOrderStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageOrderStatusOperationFilterInput;

  TRes call({
    Enum$PackageOrderStatus? eq,
    Enum$PackageOrderStatus? neq,
    List<Enum$PackageOrderStatus>? $in,
    List<Enum$PackageOrderStatus>? nin,
  });
}

class _CopyWithImpl$Input$PackageOrderStatusOperationFilterInput<TRes>
    implements CopyWith$Input$PackageOrderStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$PackageOrderStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$PackageOrderStatusOperationFilterInput _instance;

  final TRes Function(Input$PackageOrderStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$PackageOrderStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$PackageOrderStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$PackageOrderStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$PackageOrderStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$PackageOrderStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$PackageOrderStatusOperationFilterInput<TRes>
    implements CopyWith$Input$PackageOrderStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$PackageOrderStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$PackageOrderStatus? eq,
    Enum$PackageOrderStatus? neq,
    List<Enum$PackageOrderStatus>? $in,
    List<Enum$PackageOrderStatus>? nin,
  }) => _res;
}

class Input$PaymentTransactionFilterInput {
  factory Input$PaymentTransactionFilterInput({
    List<Input$PaymentTransactionFilterInput>? and,
    List<Input$PaymentTransactionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? stripeCheckoutSessionId,
    Input$StringOperationFilterInput? stripeSubscriptionId,
    Input$StringOperationFilterInput? stripeInvoiceId,
    Input$StringOperationFilterInput? stripePaymentId,
    Input$ListStringOperationFilterInput? stripePaymentMethod,
    Input$DecimalOperationFilterInput? amount,
    Input$StringOperationFilterInput? currency,
    Input$PaymentTransactionStatusOperationFilterInput? paymentStatus,
    Input$TransactionStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$PaymentTransactionFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (stripeCheckoutSessionId != null)
      r'stripeCheckoutSessionId': stripeCheckoutSessionId,
    if (stripeSubscriptionId != null)
      r'stripeSubscriptionId': stripeSubscriptionId,
    if (stripeInvoiceId != null) r'stripeInvoiceId': stripeInvoiceId,
    if (stripePaymentId != null) r'stripePaymentId': stripePaymentId,
    if (stripePaymentMethod != null)
      r'stripePaymentMethod': stripePaymentMethod,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (paymentStatus != null) r'paymentStatus': paymentStatus,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$PaymentTransactionFilterInput._(this._$data);

  factory Input$PaymentTransactionFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$PaymentTransactionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$PaymentTransactionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeCheckoutSessionId')) {
      final l$stripeCheckoutSessionId = data['stripeCheckoutSessionId'];
      result$data['stripeCheckoutSessionId'] = l$stripeCheckoutSessionId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeCheckoutSessionId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeSubscriptionId')) {
      final l$stripeSubscriptionId = data['stripeSubscriptionId'];
      result$data['stripeSubscriptionId'] = l$stripeSubscriptionId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeSubscriptionId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeInvoiceId')) {
      final l$stripeInvoiceId = data['stripeInvoiceId'];
      result$data['stripeInvoiceId'] = l$stripeInvoiceId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeInvoiceId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripePaymentId')) {
      final l$stripePaymentId = data['stripePaymentId'];
      result$data['stripePaymentId'] = l$stripePaymentId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripePaymentId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripePaymentMethod')) {
      final l$stripePaymentMethod = data['stripePaymentMethod'];
      result$data['stripePaymentMethod'] = l$stripePaymentMethod == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$stripePaymentMethod as Map<String, dynamic>),
            );
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$amount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$currency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('paymentStatus')) {
      final l$paymentStatus = data['paymentStatus'];
      result$data['paymentStatus'] = l$paymentStatus == null
          ? null
          : Input$PaymentTransactionStatusOperationFilterInput.fromJson(
              (l$paymentStatus as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$PaymentTransactionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PaymentTransactionFilterInput>? get and =>
      (_$data['and'] as List<Input$PaymentTransactionFilterInput>?);

  List<Input$PaymentTransactionFilterInput>? get or =>
      (_$data['or'] as List<Input$PaymentTransactionFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get userId =>
      (_$data['userId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeCheckoutSessionId =>
      (_$data['stripeCheckoutSessionId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeSubscriptionId =>
      (_$data['stripeSubscriptionId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeInvoiceId =>
      (_$data['stripeInvoiceId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripePaymentId =>
      (_$data['stripePaymentId'] as Input$StringOperationFilterInput?);

  Input$ListStringOperationFilterInput? get stripePaymentMethod =>
      (_$data['stripePaymentMethod'] as Input$ListStringOperationFilterInput?);

  Input$DecimalOperationFilterInput? get amount =>
      (_$data['amount'] as Input$DecimalOperationFilterInput?);

  Input$StringOperationFilterInput? get currency =>
      (_$data['currency'] as Input$StringOperationFilterInput?);

  Input$PaymentTransactionStatusOperationFilterInput? get paymentStatus =>
      (_$data['paymentStatus']
          as Input$PaymentTransactionStatusOperationFilterInput?);

  Input$TransactionStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$TransactionStatusOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('stripeCheckoutSessionId')) {
      final l$stripeCheckoutSessionId = stripeCheckoutSessionId;
      result$data['stripeCheckoutSessionId'] = l$stripeCheckoutSessionId
          ?.toJson();
    }
    if (_$data.containsKey('stripeSubscriptionId')) {
      final l$stripeSubscriptionId = stripeSubscriptionId;
      result$data['stripeSubscriptionId'] = l$stripeSubscriptionId?.toJson();
    }
    if (_$data.containsKey('stripeInvoiceId')) {
      final l$stripeInvoiceId = stripeInvoiceId;
      result$data['stripeInvoiceId'] = l$stripeInvoiceId?.toJson();
    }
    if (_$data.containsKey('stripePaymentId')) {
      final l$stripePaymentId = stripePaymentId;
      result$data['stripePaymentId'] = l$stripePaymentId?.toJson();
    }
    if (_$data.containsKey('stripePaymentMethod')) {
      final l$stripePaymentMethod = stripePaymentMethod;
      result$data['stripePaymentMethod'] = l$stripePaymentMethod?.toJson();
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount?.toJson();
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency?.toJson();
    }
    if (_$data.containsKey('paymentStatus')) {
      final l$paymentStatus = paymentStatus;
      result$data['paymentStatus'] = l$paymentStatus?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PaymentTransactionFilterInput<
    Input$PaymentTransactionFilterInput
  >
  get copyWith => CopyWith$Input$PaymentTransactionFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PaymentTransactionFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$stripeCheckoutSessionId = stripeCheckoutSessionId;
    final lOther$stripeCheckoutSessionId = other.stripeCheckoutSessionId;
    if (_$data.containsKey('stripeCheckoutSessionId') !=
        other._$data.containsKey('stripeCheckoutSessionId')) {
      return false;
    }
    if (l$stripeCheckoutSessionId != lOther$stripeCheckoutSessionId) {
      return false;
    }
    final l$stripeSubscriptionId = stripeSubscriptionId;
    final lOther$stripeSubscriptionId = other.stripeSubscriptionId;
    if (_$data.containsKey('stripeSubscriptionId') !=
        other._$data.containsKey('stripeSubscriptionId')) {
      return false;
    }
    if (l$stripeSubscriptionId != lOther$stripeSubscriptionId) {
      return false;
    }
    final l$stripeInvoiceId = stripeInvoiceId;
    final lOther$stripeInvoiceId = other.stripeInvoiceId;
    if (_$data.containsKey('stripeInvoiceId') !=
        other._$data.containsKey('stripeInvoiceId')) {
      return false;
    }
    if (l$stripeInvoiceId != lOther$stripeInvoiceId) {
      return false;
    }
    final l$stripePaymentId = stripePaymentId;
    final lOther$stripePaymentId = other.stripePaymentId;
    if (_$data.containsKey('stripePaymentId') !=
        other._$data.containsKey('stripePaymentId')) {
      return false;
    }
    if (l$stripePaymentId != lOther$stripePaymentId) {
      return false;
    }
    final l$stripePaymentMethod = stripePaymentMethod;
    final lOther$stripePaymentMethod = other.stripePaymentMethod;
    if (_$data.containsKey('stripePaymentMethod') !=
        other._$data.containsKey('stripePaymentMethod')) {
      return false;
    }
    if (l$stripePaymentMethod != lOther$stripePaymentMethod) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$paymentStatus = paymentStatus;
    final lOther$paymentStatus = other.paymentStatus;
    if (_$data.containsKey('paymentStatus') !=
        other._$data.containsKey('paymentStatus')) {
      return false;
    }
    if (l$paymentStatus != lOther$paymentStatus) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$userId = userId;
    final l$stripeCheckoutSessionId = stripeCheckoutSessionId;
    final l$stripeSubscriptionId = stripeSubscriptionId;
    final l$stripeInvoiceId = stripeInvoiceId;
    final l$stripePaymentId = stripePaymentId;
    final l$stripePaymentMethod = stripePaymentMethod;
    final l$amount = amount;
    final l$currency = currency;
    final l$paymentStatus = paymentStatus;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('stripeCheckoutSessionId')
          ? l$stripeCheckoutSessionId
          : const {},
      _$data.containsKey('stripeSubscriptionId')
          ? l$stripeSubscriptionId
          : const {},
      _$data.containsKey('stripeInvoiceId') ? l$stripeInvoiceId : const {},
      _$data.containsKey('stripePaymentId') ? l$stripePaymentId : const {},
      _$data.containsKey('stripePaymentMethod')
          ? l$stripePaymentMethod
          : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('paymentStatus') ? l$paymentStatus : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PaymentTransactionFilterInput<TRes> {
  factory CopyWith$Input$PaymentTransactionFilterInput(
    Input$PaymentTransactionFilterInput instance,
    TRes Function(Input$PaymentTransactionFilterInput) then,
  ) = _CopyWithImpl$Input$PaymentTransactionFilterInput;

  factory CopyWith$Input$PaymentTransactionFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PaymentTransactionFilterInput;

  TRes call({
    List<Input$PaymentTransactionFilterInput>? and,
    List<Input$PaymentTransactionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? stripeCheckoutSessionId,
    Input$StringOperationFilterInput? stripeSubscriptionId,
    Input$StringOperationFilterInput? stripeInvoiceId,
    Input$StringOperationFilterInput? stripePaymentId,
    Input$ListStringOperationFilterInput? stripePaymentMethod,
    Input$DecimalOperationFilterInput? amount,
    Input$StringOperationFilterInput? currency,
    Input$PaymentTransactionStatusOperationFilterInput? paymentStatus,
    Input$TransactionStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$PaymentTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$PaymentTransactionFilterInput<
          Input$PaymentTransactionFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$PaymentTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$PaymentTransactionFilterInput<
          Input$PaymentTransactionFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get userId;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeCheckoutSessionId;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeSubscriptionId;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeInvoiceId;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripePaymentId;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get stripePaymentMethod;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount;
  CopyWith$Input$StringOperationFilterInput<TRes> get currency;
  CopyWith$Input$PaymentTransactionStatusOperationFilterInput<TRes>
  get paymentStatus;
  CopyWith$Input$TransactionStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$PaymentTransactionFilterInput<TRes>
    implements CopyWith$Input$PaymentTransactionFilterInput<TRes> {
  _CopyWithImpl$Input$PaymentTransactionFilterInput(this._instance, this._then);

  final Input$PaymentTransactionFilterInput _instance;

  final TRes Function(Input$PaymentTransactionFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? stripeCheckoutSessionId = _undefined,
    Object? stripeSubscriptionId = _undefined,
    Object? stripeInvoiceId = _undefined,
    Object? stripePaymentId = _undefined,
    Object? stripePaymentMethod = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? paymentStatus = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$PaymentTransactionFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$PaymentTransactionFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$PaymentTransactionFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (userId != _undefined)
        'userId': (userId as Input$StringOperationFilterInput?),
      if (stripeCheckoutSessionId != _undefined)
        'stripeCheckoutSessionId':
            (stripeCheckoutSessionId as Input$StringOperationFilterInput?),
      if (stripeSubscriptionId != _undefined)
        'stripeSubscriptionId':
            (stripeSubscriptionId as Input$StringOperationFilterInput?),
      if (stripeInvoiceId != _undefined)
        'stripeInvoiceId':
            (stripeInvoiceId as Input$StringOperationFilterInput?),
      if (stripePaymentId != _undefined)
        'stripePaymentId':
            (stripePaymentId as Input$StringOperationFilterInput?),
      if (stripePaymentMethod != _undefined)
        'stripePaymentMethod':
            (stripePaymentMethod as Input$ListStringOperationFilterInput?),
      if (amount != _undefined)
        'amount': (amount as Input$DecimalOperationFilterInput?),
      if (currency != _undefined)
        'currency': (currency as Input$StringOperationFilterInput?),
      if (paymentStatus != _undefined)
        'paymentStatus':
            (paymentStatus
                as Input$PaymentTransactionStatusOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$TransactionStatusOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$PaymentTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$PaymentTransactionFilterInput<
          Input$PaymentTransactionFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$PaymentTransactionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$PaymentTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$PaymentTransactionFilterInput<
          Input$PaymentTransactionFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$PaymentTransactionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userId,
            (e) => call(userId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeCheckoutSessionId {
    final local$stripeCheckoutSessionId = _instance.stripeCheckoutSessionId;
    return local$stripeCheckoutSessionId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeCheckoutSessionId,
            (e) => call(stripeCheckoutSessionId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeSubscriptionId {
    final local$stripeSubscriptionId = _instance.stripeSubscriptionId;
    return local$stripeSubscriptionId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeSubscriptionId,
            (e) => call(stripeSubscriptionId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeInvoiceId {
    final local$stripeInvoiceId = _instance.stripeInvoiceId;
    return local$stripeInvoiceId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeInvoiceId,
            (e) => call(stripeInvoiceId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePaymentId {
    final local$stripePaymentId = _instance.stripePaymentId;
    return local$stripePaymentId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripePaymentId,
            (e) => call(stripePaymentId: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get stripePaymentMethod {
    final local$stripePaymentMethod = _instance.stripePaymentMethod;
    return local$stripePaymentMethod == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$stripePaymentMethod,
            (e) => call(stripePaymentMethod: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount {
    final local$amount = _instance.amount;
    return local$amount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$amount,
            (e) => call(amount: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get currency {
    final local$currency = _instance.currency;
    return local$currency == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$currency,
            (e) => call(currency: e),
          );
  }

  CopyWith$Input$PaymentTransactionStatusOperationFilterInput<TRes>
  get paymentStatus {
    final local$paymentStatus = _instance.paymentStatus;
    return local$paymentStatus == null
        ? CopyWith$Input$PaymentTransactionStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$PaymentTransactionStatusOperationFilterInput(
            local$paymentStatus,
            (e) => call(paymentStatus: e),
          );
  }

  CopyWith$Input$TransactionStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$TransactionStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$PaymentTransactionFilterInput<TRes>
    implements CopyWith$Input$PaymentTransactionFilterInput<TRes> {
  _CopyWithStubImpl$Input$PaymentTransactionFilterInput(this._res);

  TRes _res;

  call({
    List<Input$PaymentTransactionFilterInput>? and,
    List<Input$PaymentTransactionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? stripeCheckoutSessionId,
    Input$StringOperationFilterInput? stripeSubscriptionId,
    Input$StringOperationFilterInput? stripeInvoiceId,
    Input$StringOperationFilterInput? stripePaymentId,
    Input$ListStringOperationFilterInput? stripePaymentMethod,
    Input$DecimalOperationFilterInput? amount,
    Input$StringOperationFilterInput? currency,
    Input$PaymentTransactionStatusOperationFilterInput? paymentStatus,
    Input$TransactionStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get userId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeCheckoutSessionId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeSubscriptionId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeInvoiceId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePaymentId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get stripePaymentMethod =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get currency =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$PaymentTransactionStatusOperationFilterInput<TRes>
  get paymentStatus =>
      CopyWith$Input$PaymentTransactionStatusOperationFilterInput.stub(_res);

  CopyWith$Input$TransactionStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$TransactionStatusOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$PaymentTransactionSortInput {
  factory Input$PaymentTransactionSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? stripeCheckoutSessionId,
    Enum$SortEnumType? stripeSubscriptionId,
    Enum$SortEnumType? stripeInvoiceId,
    Enum$SortEnumType? stripePaymentId,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? paymentStatus,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$PaymentTransactionSortInput._({
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (stripeCheckoutSessionId != null)
      r'stripeCheckoutSessionId': stripeCheckoutSessionId,
    if (stripeSubscriptionId != null)
      r'stripeSubscriptionId': stripeSubscriptionId,
    if (stripeInvoiceId != null) r'stripeInvoiceId': stripeInvoiceId,
    if (stripePaymentId != null) r'stripePaymentId': stripePaymentId,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (paymentStatus != null) r'paymentStatus': paymentStatus,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$PaymentTransactionSortInput._(this._$data);

  factory Input$PaymentTransactionSortInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$SortEnumType((l$userId as String));
    }
    if (data.containsKey('stripeCheckoutSessionId')) {
      final l$stripeCheckoutSessionId = data['stripeCheckoutSessionId'];
      result$data['stripeCheckoutSessionId'] = l$stripeCheckoutSessionId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeCheckoutSessionId as String));
    }
    if (data.containsKey('stripeSubscriptionId')) {
      final l$stripeSubscriptionId = data['stripeSubscriptionId'];
      result$data['stripeSubscriptionId'] = l$stripeSubscriptionId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeSubscriptionId as String));
    }
    if (data.containsKey('stripeInvoiceId')) {
      final l$stripeInvoiceId = data['stripeInvoiceId'];
      result$data['stripeInvoiceId'] = l$stripeInvoiceId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeInvoiceId as String));
    }
    if (data.containsKey('stripePaymentId')) {
      final l$stripePaymentId = data['stripePaymentId'];
      result$data['stripePaymentId'] = l$stripePaymentId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripePaymentId as String));
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : fromJson$Enum$SortEnumType((l$amount as String));
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$SortEnumType((l$currency as String));
    }
    if (data.containsKey('paymentStatus')) {
      final l$paymentStatus = data['paymentStatus'];
      result$data['paymentStatus'] = l$paymentStatus == null
          ? null
          : fromJson$Enum$SortEnumType((l$paymentStatus as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$PaymentTransactionSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get userId => (_$data['userId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeCheckoutSessionId =>
      (_$data['stripeCheckoutSessionId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeSubscriptionId =>
      (_$data['stripeSubscriptionId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeInvoiceId =>
      (_$data['stripeInvoiceId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripePaymentId =>
      (_$data['stripePaymentId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get amount => (_$data['amount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get currency => (_$data['currency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get paymentStatus =>
      (_$data['paymentStatus'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId == null
          ? null
          : toJson$Enum$SortEnumType(l$userId);
    }
    if (_$data.containsKey('stripeCheckoutSessionId')) {
      final l$stripeCheckoutSessionId = stripeCheckoutSessionId;
      result$data['stripeCheckoutSessionId'] = l$stripeCheckoutSessionId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeCheckoutSessionId);
    }
    if (_$data.containsKey('stripeSubscriptionId')) {
      final l$stripeSubscriptionId = stripeSubscriptionId;
      result$data['stripeSubscriptionId'] = l$stripeSubscriptionId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeSubscriptionId);
    }
    if (_$data.containsKey('stripeInvoiceId')) {
      final l$stripeInvoiceId = stripeInvoiceId;
      result$data['stripeInvoiceId'] = l$stripeInvoiceId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeInvoiceId);
    }
    if (_$data.containsKey('stripePaymentId')) {
      final l$stripePaymentId = stripePaymentId;
      result$data['stripePaymentId'] = l$stripePaymentId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripePaymentId);
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount == null
          ? null
          : toJson$Enum$SortEnumType(l$amount);
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$SortEnumType(l$currency);
    }
    if (_$data.containsKey('paymentStatus')) {
      final l$paymentStatus = paymentStatus;
      result$data['paymentStatus'] = l$paymentStatus == null
          ? null
          : toJson$Enum$SortEnumType(l$paymentStatus);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$PaymentTransactionSortInput<Input$PaymentTransactionSortInput>
  get copyWith => CopyWith$Input$PaymentTransactionSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PaymentTransactionSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$stripeCheckoutSessionId = stripeCheckoutSessionId;
    final lOther$stripeCheckoutSessionId = other.stripeCheckoutSessionId;
    if (_$data.containsKey('stripeCheckoutSessionId') !=
        other._$data.containsKey('stripeCheckoutSessionId')) {
      return false;
    }
    if (l$stripeCheckoutSessionId != lOther$stripeCheckoutSessionId) {
      return false;
    }
    final l$stripeSubscriptionId = stripeSubscriptionId;
    final lOther$stripeSubscriptionId = other.stripeSubscriptionId;
    if (_$data.containsKey('stripeSubscriptionId') !=
        other._$data.containsKey('stripeSubscriptionId')) {
      return false;
    }
    if (l$stripeSubscriptionId != lOther$stripeSubscriptionId) {
      return false;
    }
    final l$stripeInvoiceId = stripeInvoiceId;
    final lOther$stripeInvoiceId = other.stripeInvoiceId;
    if (_$data.containsKey('stripeInvoiceId') !=
        other._$data.containsKey('stripeInvoiceId')) {
      return false;
    }
    if (l$stripeInvoiceId != lOther$stripeInvoiceId) {
      return false;
    }
    final l$stripePaymentId = stripePaymentId;
    final lOther$stripePaymentId = other.stripePaymentId;
    if (_$data.containsKey('stripePaymentId') !=
        other._$data.containsKey('stripePaymentId')) {
      return false;
    }
    if (l$stripePaymentId != lOther$stripePaymentId) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$paymentStatus = paymentStatus;
    final lOther$paymentStatus = other.paymentStatus;
    if (_$data.containsKey('paymentStatus') !=
        other._$data.containsKey('paymentStatus')) {
      return false;
    }
    if (l$paymentStatus != lOther$paymentStatus) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$stripeCheckoutSessionId = stripeCheckoutSessionId;
    final l$stripeSubscriptionId = stripeSubscriptionId;
    final l$stripeInvoiceId = stripeInvoiceId;
    final l$stripePaymentId = stripePaymentId;
    final l$amount = amount;
    final l$currency = currency;
    final l$paymentStatus = paymentStatus;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('stripeCheckoutSessionId')
          ? l$stripeCheckoutSessionId
          : const {},
      _$data.containsKey('stripeSubscriptionId')
          ? l$stripeSubscriptionId
          : const {},
      _$data.containsKey('stripeInvoiceId') ? l$stripeInvoiceId : const {},
      _$data.containsKey('stripePaymentId') ? l$stripePaymentId : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('paymentStatus') ? l$paymentStatus : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PaymentTransactionSortInput<TRes> {
  factory CopyWith$Input$PaymentTransactionSortInput(
    Input$PaymentTransactionSortInput instance,
    TRes Function(Input$PaymentTransactionSortInput) then,
  ) = _CopyWithImpl$Input$PaymentTransactionSortInput;

  factory CopyWith$Input$PaymentTransactionSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PaymentTransactionSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? stripeCheckoutSessionId,
    Enum$SortEnumType? stripeSubscriptionId,
    Enum$SortEnumType? stripeInvoiceId,
    Enum$SortEnumType? stripePaymentId,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? paymentStatus,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$PaymentTransactionSortInput<TRes>
    implements CopyWith$Input$PaymentTransactionSortInput<TRes> {
  _CopyWithImpl$Input$PaymentTransactionSortInput(this._instance, this._then);

  final Input$PaymentTransactionSortInput _instance;

  final TRes Function(Input$PaymentTransactionSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? stripeCheckoutSessionId = _undefined,
    Object? stripeSubscriptionId = _undefined,
    Object? stripeInvoiceId = _undefined,
    Object? stripePaymentId = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? paymentStatus = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$PaymentTransactionSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (userId != _undefined) 'userId': (userId as Enum$SortEnumType?),
      if (stripeCheckoutSessionId != _undefined)
        'stripeCheckoutSessionId':
            (stripeCheckoutSessionId as Enum$SortEnumType?),
      if (stripeSubscriptionId != _undefined)
        'stripeSubscriptionId': (stripeSubscriptionId as Enum$SortEnumType?),
      if (stripeInvoiceId != _undefined)
        'stripeInvoiceId': (stripeInvoiceId as Enum$SortEnumType?),
      if (stripePaymentId != _undefined)
        'stripePaymentId': (stripePaymentId as Enum$SortEnumType?),
      if (amount != _undefined) 'amount': (amount as Enum$SortEnumType?),
      if (currency != _undefined) 'currency': (currency as Enum$SortEnumType?),
      if (paymentStatus != _undefined)
        'paymentStatus': (paymentStatus as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$PaymentTransactionSortInput<TRes>
    implements CopyWith$Input$PaymentTransactionSortInput<TRes> {
  _CopyWithStubImpl$Input$PaymentTransactionSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? stripeCheckoutSessionId,
    Enum$SortEnumType? stripeSubscriptionId,
    Enum$SortEnumType? stripeInvoiceId,
    Enum$SortEnumType? stripePaymentId,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? paymentStatus,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$PaymentTransactionStatusOperationFilterInput {
  factory Input$PaymentTransactionStatusOperationFilterInput({
    Enum$PaymentTransactionStatus? eq,
    Enum$PaymentTransactionStatus? neq,
    List<Enum$PaymentTransactionStatus>? $in,
    List<Enum$PaymentTransactionStatus>? nin,
  }) => Input$PaymentTransactionStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$PaymentTransactionStatusOperationFilterInput._(this._$data);

  factory Input$PaymentTransactionStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$PaymentTransactionStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$PaymentTransactionStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PaymentTransactionStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PaymentTransactionStatus((e as String)))
          .toList();
    }
    return Input$PaymentTransactionStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PaymentTransactionStatus? get eq =>
      (_$data['eq'] as Enum$PaymentTransactionStatus?);

  Enum$PaymentTransactionStatus? get neq =>
      (_$data['neq'] as Enum$PaymentTransactionStatus?);

  List<Enum$PaymentTransactionStatus>? get $in =>
      (_$data['in'] as List<Enum$PaymentTransactionStatus>?);

  List<Enum$PaymentTransactionStatus>? get nin =>
      (_$data['nin'] as List<Enum$PaymentTransactionStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$PaymentTransactionStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$PaymentTransactionStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$PaymentTransactionStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$PaymentTransactionStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$PaymentTransactionStatusOperationFilterInput<
    Input$PaymentTransactionStatusOperationFilterInput
  >
  get copyWith => CopyWith$Input$PaymentTransactionStatusOperationFilterInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PaymentTransactionStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PaymentTransactionStatusOperationFilterInput<
  TRes
> {
  factory CopyWith$Input$PaymentTransactionStatusOperationFilterInput(
    Input$PaymentTransactionStatusOperationFilterInput instance,
    TRes Function(Input$PaymentTransactionStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$PaymentTransactionStatusOperationFilterInput;

  factory CopyWith$Input$PaymentTransactionStatusOperationFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$PaymentTransactionStatusOperationFilterInput;

  TRes call({
    Enum$PaymentTransactionStatus? eq,
    Enum$PaymentTransactionStatus? neq,
    List<Enum$PaymentTransactionStatus>? $in,
    List<Enum$PaymentTransactionStatus>? nin,
  });
}

class _CopyWithImpl$Input$PaymentTransactionStatusOperationFilterInput<TRes>
    implements
        CopyWith$Input$PaymentTransactionStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$PaymentTransactionStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$PaymentTransactionStatusOperationFilterInput _instance;

  final TRes Function(Input$PaymentTransactionStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$PaymentTransactionStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$PaymentTransactionStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$PaymentTransactionStatus?),
      if ($in != _undefined)
        'in': ($in as List<Enum$PaymentTransactionStatus>?),
      if (nin != _undefined)
        'nin': (nin as List<Enum$PaymentTransactionStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$PaymentTransactionStatusOperationFilterInput<TRes>
    implements
        CopyWith$Input$PaymentTransactionStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$PaymentTransactionStatusOperationFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Enum$PaymentTransactionStatus? eq,
    Enum$PaymentTransactionStatus? neq,
    List<Enum$PaymentTransactionStatus>? $in,
    List<Enum$PaymentTransactionStatus>? nin,
  }) => _res;
}

class Input$PayoutTransactionFilterInput {
  factory Input$PayoutTransactionFilterInput({
    List<Input$PayoutTransactionFilterInput>? and,
    List<Input$PayoutTransactionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? royaltyReportId,
    Input$StringOperationFilterInput? stripeTransferId,
    Input$StringOperationFilterInput? stripePayoutId,
    Input$StringOperationFilterInput? destinationAccountId,
    Input$DecimalOperationFilterInput? amount,
    Input$StringOperationFilterInput? currency,
    Input$NullableOfAggregationLevelOperationFilterInput? level,
    Input$StringOperationFilterInput? description,
    Input$PayoutTransactionStatusOperationFilterInput? status,
    Input$StringOperationFilterInput? method,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$PayoutTransactionFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (royaltyReportId != null) r'royaltyReportId': royaltyReportId,
    if (stripeTransferId != null) r'stripeTransferId': stripeTransferId,
    if (stripePayoutId != null) r'stripePayoutId': stripePayoutId,
    if (destinationAccountId != null)
      r'destinationAccountId': destinationAccountId,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (level != null) r'level': level,
    if (description != null) r'description': description,
    if (status != null) r'status': status,
    if (method != null) r'method': method,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$PayoutTransactionFilterInput._(this._$data);

  factory Input$PayoutTransactionFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$PayoutTransactionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$PayoutTransactionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('royaltyReportId')) {
      final l$royaltyReportId = data['royaltyReportId'];
      result$data['royaltyReportId'] = l$royaltyReportId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$royaltyReportId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeTransferId')) {
      final l$stripeTransferId = data['stripeTransferId'];
      result$data['stripeTransferId'] = l$stripeTransferId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeTransferId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripePayoutId')) {
      final l$stripePayoutId = data['stripePayoutId'];
      result$data['stripePayoutId'] = l$stripePayoutId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripePayoutId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('destinationAccountId')) {
      final l$destinationAccountId = data['destinationAccountId'];
      result$data['destinationAccountId'] = l$destinationAccountId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$destinationAccountId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$amount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$currency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('level')) {
      final l$level = data['level'];
      result$data['level'] = l$level == null
          ? null
          : Input$NullableOfAggregationLevelOperationFilterInput.fromJson(
              (l$level as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$PayoutTransactionStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('method')) {
      final l$method = data['method'];
      result$data['method'] = l$method == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$method as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$PayoutTransactionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PayoutTransactionFilterInput>? get and =>
      (_$data['and'] as List<Input$PayoutTransactionFilterInput>?);

  List<Input$PayoutTransactionFilterInput>? get or =>
      (_$data['or'] as List<Input$PayoutTransactionFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get userId =>
      (_$data['userId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get royaltyReportId =>
      (_$data['royaltyReportId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeTransferId =>
      (_$data['stripeTransferId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripePayoutId =>
      (_$data['stripePayoutId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get destinationAccountId =>
      (_$data['destinationAccountId'] as Input$StringOperationFilterInput?);

  Input$DecimalOperationFilterInput? get amount =>
      (_$data['amount'] as Input$DecimalOperationFilterInput?);

  Input$StringOperationFilterInput? get currency =>
      (_$data['currency'] as Input$StringOperationFilterInput?);

  Input$NullableOfAggregationLevelOperationFilterInput? get level =>
      (_$data['level']
          as Input$NullableOfAggregationLevelOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$PayoutTransactionStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$PayoutTransactionStatusOperationFilterInput?);

  Input$StringOperationFilterInput? get method =>
      (_$data['method'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('royaltyReportId')) {
      final l$royaltyReportId = royaltyReportId;
      result$data['royaltyReportId'] = l$royaltyReportId?.toJson();
    }
    if (_$data.containsKey('stripeTransferId')) {
      final l$stripeTransferId = stripeTransferId;
      result$data['stripeTransferId'] = l$stripeTransferId?.toJson();
    }
    if (_$data.containsKey('stripePayoutId')) {
      final l$stripePayoutId = stripePayoutId;
      result$data['stripePayoutId'] = l$stripePayoutId?.toJson();
    }
    if (_$data.containsKey('destinationAccountId')) {
      final l$destinationAccountId = destinationAccountId;
      result$data['destinationAccountId'] = l$destinationAccountId?.toJson();
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount?.toJson();
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency?.toJson();
    }
    if (_$data.containsKey('level')) {
      final l$level = level;
      result$data['level'] = l$level?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('method')) {
      final l$method = method;
      result$data['method'] = l$method?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PayoutTransactionFilterInput<
    Input$PayoutTransactionFilterInput
  >
  get copyWith => CopyWith$Input$PayoutTransactionFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PayoutTransactionFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$royaltyReportId = royaltyReportId;
    final lOther$royaltyReportId = other.royaltyReportId;
    if (_$data.containsKey('royaltyReportId') !=
        other._$data.containsKey('royaltyReportId')) {
      return false;
    }
    if (l$royaltyReportId != lOther$royaltyReportId) {
      return false;
    }
    final l$stripeTransferId = stripeTransferId;
    final lOther$stripeTransferId = other.stripeTransferId;
    if (_$data.containsKey('stripeTransferId') !=
        other._$data.containsKey('stripeTransferId')) {
      return false;
    }
    if (l$stripeTransferId != lOther$stripeTransferId) {
      return false;
    }
    final l$stripePayoutId = stripePayoutId;
    final lOther$stripePayoutId = other.stripePayoutId;
    if (_$data.containsKey('stripePayoutId') !=
        other._$data.containsKey('stripePayoutId')) {
      return false;
    }
    if (l$stripePayoutId != lOther$stripePayoutId) {
      return false;
    }
    final l$destinationAccountId = destinationAccountId;
    final lOther$destinationAccountId = other.destinationAccountId;
    if (_$data.containsKey('destinationAccountId') !=
        other._$data.containsKey('destinationAccountId')) {
      return false;
    }
    if (l$destinationAccountId != lOther$destinationAccountId) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$level = level;
    final lOther$level = other.level;
    if (_$data.containsKey('level') != other._$data.containsKey('level')) {
      return false;
    }
    if (l$level != lOther$level) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$method = method;
    final lOther$method = other.method;
    if (_$data.containsKey('method') != other._$data.containsKey('method')) {
      return false;
    }
    if (l$method != lOther$method) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$userId = userId;
    final l$royaltyReportId = royaltyReportId;
    final l$stripeTransferId = stripeTransferId;
    final l$stripePayoutId = stripePayoutId;
    final l$destinationAccountId = destinationAccountId;
    final l$amount = amount;
    final l$currency = currency;
    final l$level = level;
    final l$description = description;
    final l$status = status;
    final l$method = method;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('royaltyReportId') ? l$royaltyReportId : const {},
      _$data.containsKey('stripeTransferId') ? l$stripeTransferId : const {},
      _$data.containsKey('stripePayoutId') ? l$stripePayoutId : const {},
      _$data.containsKey('destinationAccountId')
          ? l$destinationAccountId
          : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('level') ? l$level : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('method') ? l$method : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayoutTransactionFilterInput<TRes> {
  factory CopyWith$Input$PayoutTransactionFilterInput(
    Input$PayoutTransactionFilterInput instance,
    TRes Function(Input$PayoutTransactionFilterInput) then,
  ) = _CopyWithImpl$Input$PayoutTransactionFilterInput;

  factory CopyWith$Input$PayoutTransactionFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayoutTransactionFilterInput;

  TRes call({
    List<Input$PayoutTransactionFilterInput>? and,
    List<Input$PayoutTransactionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? royaltyReportId,
    Input$StringOperationFilterInput? stripeTransferId,
    Input$StringOperationFilterInput? stripePayoutId,
    Input$StringOperationFilterInput? destinationAccountId,
    Input$DecimalOperationFilterInput? amount,
    Input$StringOperationFilterInput? currency,
    Input$NullableOfAggregationLevelOperationFilterInput? level,
    Input$StringOperationFilterInput? description,
    Input$PayoutTransactionStatusOperationFilterInput? status,
    Input$StringOperationFilterInput? method,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$PayoutTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$PayoutTransactionFilterInput<
          Input$PayoutTransactionFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$PayoutTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$PayoutTransactionFilterInput<
          Input$PayoutTransactionFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get userId;
  CopyWith$Input$StringOperationFilterInput<TRes> get royaltyReportId;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeTransferId;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripePayoutId;
  CopyWith$Input$StringOperationFilterInput<TRes> get destinationAccountId;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount;
  CopyWith$Input$StringOperationFilterInput<TRes> get currency;
  CopyWith$Input$NullableOfAggregationLevelOperationFilterInput<TRes> get level;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$PayoutTransactionStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$StringOperationFilterInput<TRes> get method;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$PayoutTransactionFilterInput<TRes>
    implements CopyWith$Input$PayoutTransactionFilterInput<TRes> {
  _CopyWithImpl$Input$PayoutTransactionFilterInput(this._instance, this._then);

  final Input$PayoutTransactionFilterInput _instance;

  final TRes Function(Input$PayoutTransactionFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? royaltyReportId = _undefined,
    Object? stripeTransferId = _undefined,
    Object? stripePayoutId = _undefined,
    Object? destinationAccountId = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? level = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
    Object? method = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$PayoutTransactionFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$PayoutTransactionFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$PayoutTransactionFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (userId != _undefined)
        'userId': (userId as Input$StringOperationFilterInput?),
      if (royaltyReportId != _undefined)
        'royaltyReportId':
            (royaltyReportId as Input$StringOperationFilterInput?),
      if (stripeTransferId != _undefined)
        'stripeTransferId':
            (stripeTransferId as Input$StringOperationFilterInput?),
      if (stripePayoutId != _undefined)
        'stripePayoutId': (stripePayoutId as Input$StringOperationFilterInput?),
      if (destinationAccountId != _undefined)
        'destinationAccountId':
            (destinationAccountId as Input$StringOperationFilterInput?),
      if (amount != _undefined)
        'amount': (amount as Input$DecimalOperationFilterInput?),
      if (currency != _undefined)
        'currency': (currency as Input$StringOperationFilterInput?),
      if (level != _undefined)
        'level':
            (level as Input$NullableOfAggregationLevelOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (status != _undefined)
        'status':
            (status as Input$PayoutTransactionStatusOperationFilterInput?),
      if (method != _undefined)
        'method': (method as Input$StringOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$PayoutTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$PayoutTransactionFilterInput<
          Input$PayoutTransactionFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$PayoutTransactionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$PayoutTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$PayoutTransactionFilterInput<
          Input$PayoutTransactionFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$PayoutTransactionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userId,
            (e) => call(userId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get royaltyReportId {
    final local$royaltyReportId = _instance.royaltyReportId;
    return local$royaltyReportId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$royaltyReportId,
            (e) => call(royaltyReportId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeTransferId {
    final local$stripeTransferId = _instance.stripeTransferId;
    return local$stripeTransferId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeTransferId,
            (e) => call(stripeTransferId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePayoutId {
    final local$stripePayoutId = _instance.stripePayoutId;
    return local$stripePayoutId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripePayoutId,
            (e) => call(stripePayoutId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get destinationAccountId {
    final local$destinationAccountId = _instance.destinationAccountId;
    return local$destinationAccountId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$destinationAccountId,
            (e) => call(destinationAccountId: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount {
    final local$amount = _instance.amount;
    return local$amount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$amount,
            (e) => call(amount: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get currency {
    final local$currency = _instance.currency;
    return local$currency == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$currency,
            (e) => call(currency: e),
          );
  }

  CopyWith$Input$NullableOfAggregationLevelOperationFilterInput<TRes>
  get level {
    final local$level = _instance.level;
    return local$level == null
        ? CopyWith$Input$NullableOfAggregationLevelOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$NullableOfAggregationLevelOperationFilterInput(
            local$level,
            (e) => call(level: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$PayoutTransactionStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$PayoutTransactionStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$PayoutTransactionStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get method {
    final local$method = _instance.method;
    return local$method == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$method,
            (e) => call(method: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$PayoutTransactionFilterInput<TRes>
    implements CopyWith$Input$PayoutTransactionFilterInput<TRes> {
  _CopyWithStubImpl$Input$PayoutTransactionFilterInput(this._res);

  TRes _res;

  call({
    List<Input$PayoutTransactionFilterInput>? and,
    List<Input$PayoutTransactionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? royaltyReportId,
    Input$StringOperationFilterInput? stripeTransferId,
    Input$StringOperationFilterInput? stripePayoutId,
    Input$StringOperationFilterInput? destinationAccountId,
    Input$DecimalOperationFilterInput? amount,
    Input$StringOperationFilterInput? currency,
    Input$NullableOfAggregationLevelOperationFilterInput? level,
    Input$StringOperationFilterInput? description,
    Input$PayoutTransactionStatusOperationFilterInput? status,
    Input$StringOperationFilterInput? method,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get userId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get royaltyReportId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeTransferId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePayoutId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get destinationAccountId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get currency =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$NullableOfAggregationLevelOperationFilterInput<TRes>
  get level =>
      CopyWith$Input$NullableOfAggregationLevelOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$PayoutTransactionStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$PayoutTransactionStatusOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get method =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$PayoutTransactionSortInput {
  factory Input$PayoutTransactionSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? royaltyReportId,
    Enum$SortEnumType? stripeTransferId,
    Enum$SortEnumType? stripePayoutId,
    Enum$SortEnumType? destinationAccountId,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? level,
    Enum$SortEnumType? description,
    Enum$SortEnumType? status,
    Enum$SortEnumType? method,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$PayoutTransactionSortInput._({
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (royaltyReportId != null) r'royaltyReportId': royaltyReportId,
    if (stripeTransferId != null) r'stripeTransferId': stripeTransferId,
    if (stripePayoutId != null) r'stripePayoutId': stripePayoutId,
    if (destinationAccountId != null)
      r'destinationAccountId': destinationAccountId,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (level != null) r'level': level,
    if (description != null) r'description': description,
    if (status != null) r'status': status,
    if (method != null) r'method': method,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$PayoutTransactionSortInput._(this._$data);

  factory Input$PayoutTransactionSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$SortEnumType((l$userId as String));
    }
    if (data.containsKey('royaltyReportId')) {
      final l$royaltyReportId = data['royaltyReportId'];
      result$data['royaltyReportId'] = l$royaltyReportId == null
          ? null
          : fromJson$Enum$SortEnumType((l$royaltyReportId as String));
    }
    if (data.containsKey('stripeTransferId')) {
      final l$stripeTransferId = data['stripeTransferId'];
      result$data['stripeTransferId'] = l$stripeTransferId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeTransferId as String));
    }
    if (data.containsKey('stripePayoutId')) {
      final l$stripePayoutId = data['stripePayoutId'];
      result$data['stripePayoutId'] = l$stripePayoutId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripePayoutId as String));
    }
    if (data.containsKey('destinationAccountId')) {
      final l$destinationAccountId = data['destinationAccountId'];
      result$data['destinationAccountId'] = l$destinationAccountId == null
          ? null
          : fromJson$Enum$SortEnumType((l$destinationAccountId as String));
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : fromJson$Enum$SortEnumType((l$amount as String));
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$SortEnumType((l$currency as String));
    }
    if (data.containsKey('level')) {
      final l$level = data['level'];
      result$data['level'] = l$level == null
          ? null
          : fromJson$Enum$SortEnumType((l$level as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('method')) {
      final l$method = data['method'];
      result$data['method'] = l$method == null
          ? null
          : fromJson$Enum$SortEnumType((l$method as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$PayoutTransactionSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get userId => (_$data['userId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get royaltyReportId =>
      (_$data['royaltyReportId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeTransferId =>
      (_$data['stripeTransferId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripePayoutId =>
      (_$data['stripePayoutId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get destinationAccountId =>
      (_$data['destinationAccountId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get amount => (_$data['amount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get currency => (_$data['currency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get level => (_$data['level'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get method => (_$data['method'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId == null
          ? null
          : toJson$Enum$SortEnumType(l$userId);
    }
    if (_$data.containsKey('royaltyReportId')) {
      final l$royaltyReportId = royaltyReportId;
      result$data['royaltyReportId'] = l$royaltyReportId == null
          ? null
          : toJson$Enum$SortEnumType(l$royaltyReportId);
    }
    if (_$data.containsKey('stripeTransferId')) {
      final l$stripeTransferId = stripeTransferId;
      result$data['stripeTransferId'] = l$stripeTransferId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeTransferId);
    }
    if (_$data.containsKey('stripePayoutId')) {
      final l$stripePayoutId = stripePayoutId;
      result$data['stripePayoutId'] = l$stripePayoutId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripePayoutId);
    }
    if (_$data.containsKey('destinationAccountId')) {
      final l$destinationAccountId = destinationAccountId;
      result$data['destinationAccountId'] = l$destinationAccountId == null
          ? null
          : toJson$Enum$SortEnumType(l$destinationAccountId);
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount == null
          ? null
          : toJson$Enum$SortEnumType(l$amount);
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$SortEnumType(l$currency);
    }
    if (_$data.containsKey('level')) {
      final l$level = level;
      result$data['level'] = l$level == null
          ? null
          : toJson$Enum$SortEnumType(l$level);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('method')) {
      final l$method = method;
      result$data['method'] = l$method == null
          ? null
          : toJson$Enum$SortEnumType(l$method);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$PayoutTransactionSortInput<Input$PayoutTransactionSortInput>
  get copyWith => CopyWith$Input$PayoutTransactionSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PayoutTransactionSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$royaltyReportId = royaltyReportId;
    final lOther$royaltyReportId = other.royaltyReportId;
    if (_$data.containsKey('royaltyReportId') !=
        other._$data.containsKey('royaltyReportId')) {
      return false;
    }
    if (l$royaltyReportId != lOther$royaltyReportId) {
      return false;
    }
    final l$stripeTransferId = stripeTransferId;
    final lOther$stripeTransferId = other.stripeTransferId;
    if (_$data.containsKey('stripeTransferId') !=
        other._$data.containsKey('stripeTransferId')) {
      return false;
    }
    if (l$stripeTransferId != lOther$stripeTransferId) {
      return false;
    }
    final l$stripePayoutId = stripePayoutId;
    final lOther$stripePayoutId = other.stripePayoutId;
    if (_$data.containsKey('stripePayoutId') !=
        other._$data.containsKey('stripePayoutId')) {
      return false;
    }
    if (l$stripePayoutId != lOther$stripePayoutId) {
      return false;
    }
    final l$destinationAccountId = destinationAccountId;
    final lOther$destinationAccountId = other.destinationAccountId;
    if (_$data.containsKey('destinationAccountId') !=
        other._$data.containsKey('destinationAccountId')) {
      return false;
    }
    if (l$destinationAccountId != lOther$destinationAccountId) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$level = level;
    final lOther$level = other.level;
    if (_$data.containsKey('level') != other._$data.containsKey('level')) {
      return false;
    }
    if (l$level != lOther$level) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$method = method;
    final lOther$method = other.method;
    if (_$data.containsKey('method') != other._$data.containsKey('method')) {
      return false;
    }
    if (l$method != lOther$method) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$royaltyReportId = royaltyReportId;
    final l$stripeTransferId = stripeTransferId;
    final l$stripePayoutId = stripePayoutId;
    final l$destinationAccountId = destinationAccountId;
    final l$amount = amount;
    final l$currency = currency;
    final l$level = level;
    final l$description = description;
    final l$status = status;
    final l$method = method;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('royaltyReportId') ? l$royaltyReportId : const {},
      _$data.containsKey('stripeTransferId') ? l$stripeTransferId : const {},
      _$data.containsKey('stripePayoutId') ? l$stripePayoutId : const {},
      _$data.containsKey('destinationAccountId')
          ? l$destinationAccountId
          : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('level') ? l$level : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('method') ? l$method : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayoutTransactionSortInput<TRes> {
  factory CopyWith$Input$PayoutTransactionSortInput(
    Input$PayoutTransactionSortInput instance,
    TRes Function(Input$PayoutTransactionSortInput) then,
  ) = _CopyWithImpl$Input$PayoutTransactionSortInput;

  factory CopyWith$Input$PayoutTransactionSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayoutTransactionSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? royaltyReportId,
    Enum$SortEnumType? stripeTransferId,
    Enum$SortEnumType? stripePayoutId,
    Enum$SortEnumType? destinationAccountId,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? level,
    Enum$SortEnumType? description,
    Enum$SortEnumType? status,
    Enum$SortEnumType? method,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$PayoutTransactionSortInput<TRes>
    implements CopyWith$Input$PayoutTransactionSortInput<TRes> {
  _CopyWithImpl$Input$PayoutTransactionSortInput(this._instance, this._then);

  final Input$PayoutTransactionSortInput _instance;

  final TRes Function(Input$PayoutTransactionSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? royaltyReportId = _undefined,
    Object? stripeTransferId = _undefined,
    Object? stripePayoutId = _undefined,
    Object? destinationAccountId = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? level = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
    Object? method = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$PayoutTransactionSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (userId != _undefined) 'userId': (userId as Enum$SortEnumType?),
      if (royaltyReportId != _undefined)
        'royaltyReportId': (royaltyReportId as Enum$SortEnumType?),
      if (stripeTransferId != _undefined)
        'stripeTransferId': (stripeTransferId as Enum$SortEnumType?),
      if (stripePayoutId != _undefined)
        'stripePayoutId': (stripePayoutId as Enum$SortEnumType?),
      if (destinationAccountId != _undefined)
        'destinationAccountId': (destinationAccountId as Enum$SortEnumType?),
      if (amount != _undefined) 'amount': (amount as Enum$SortEnumType?),
      if (currency != _undefined) 'currency': (currency as Enum$SortEnumType?),
      if (level != _undefined) 'level': (level as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (method != _undefined) 'method': (method as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$PayoutTransactionSortInput<TRes>
    implements CopyWith$Input$PayoutTransactionSortInput<TRes> {
  _CopyWithStubImpl$Input$PayoutTransactionSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? royaltyReportId,
    Enum$SortEnumType? stripeTransferId,
    Enum$SortEnumType? stripePayoutId,
    Enum$SortEnumType? destinationAccountId,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? level,
    Enum$SortEnumType? description,
    Enum$SortEnumType? status,
    Enum$SortEnumType? method,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$PayoutTransactionStatusOperationFilterInput {
  factory Input$PayoutTransactionStatusOperationFilterInput({
    Enum$PayoutTransactionStatus? eq,
    Enum$PayoutTransactionStatus? neq,
    List<Enum$PayoutTransactionStatus>? $in,
    List<Enum$PayoutTransactionStatus>? nin,
  }) => Input$PayoutTransactionStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$PayoutTransactionStatusOperationFilterInput._(this._$data);

  factory Input$PayoutTransactionStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$PayoutTransactionStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$PayoutTransactionStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PayoutTransactionStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PayoutTransactionStatus((e as String)))
          .toList();
    }
    return Input$PayoutTransactionStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PayoutTransactionStatus? get eq =>
      (_$data['eq'] as Enum$PayoutTransactionStatus?);

  Enum$PayoutTransactionStatus? get neq =>
      (_$data['neq'] as Enum$PayoutTransactionStatus?);

  List<Enum$PayoutTransactionStatus>? get $in =>
      (_$data['in'] as List<Enum$PayoutTransactionStatus>?);

  List<Enum$PayoutTransactionStatus>? get nin =>
      (_$data['nin'] as List<Enum$PayoutTransactionStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$PayoutTransactionStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$PayoutTransactionStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$PayoutTransactionStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$PayoutTransactionStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$PayoutTransactionStatusOperationFilterInput<
    Input$PayoutTransactionStatusOperationFilterInput
  >
  get copyWith => CopyWith$Input$PayoutTransactionStatusOperationFilterInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PayoutTransactionStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayoutTransactionStatusOperationFilterInput<
  TRes
> {
  factory CopyWith$Input$PayoutTransactionStatusOperationFilterInput(
    Input$PayoutTransactionStatusOperationFilterInput instance,
    TRes Function(Input$PayoutTransactionStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$PayoutTransactionStatusOperationFilterInput;

  factory CopyWith$Input$PayoutTransactionStatusOperationFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$PayoutTransactionStatusOperationFilterInput;

  TRes call({
    Enum$PayoutTransactionStatus? eq,
    Enum$PayoutTransactionStatus? neq,
    List<Enum$PayoutTransactionStatus>? $in,
    List<Enum$PayoutTransactionStatus>? nin,
  });
}

class _CopyWithImpl$Input$PayoutTransactionStatusOperationFilterInput<TRes>
    implements
        CopyWith$Input$PayoutTransactionStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$PayoutTransactionStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$PayoutTransactionStatusOperationFilterInput _instance;

  final TRes Function(Input$PayoutTransactionStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$PayoutTransactionStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$PayoutTransactionStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$PayoutTransactionStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$PayoutTransactionStatus>?),
      if (nin != _undefined)
        'nin': (nin as List<Enum$PayoutTransactionStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$PayoutTransactionStatusOperationFilterInput<TRes>
    implements
        CopyWith$Input$PayoutTransactionStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$PayoutTransactionStatusOperationFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Enum$PayoutTransactionStatus? eq,
    Enum$PayoutTransactionStatus? neq,
    List<Enum$PayoutTransactionStatus>? $in,
    List<Enum$PayoutTransactionStatus>? nin,
  }) => _res;
}

class Input$PeriodTimeOperationFilterInput {
  factory Input$PeriodTimeOperationFilterInput({
    Enum$PeriodTime? eq,
    Enum$PeriodTime? neq,
    List<Enum$PeriodTime>? $in,
    List<Enum$PeriodTime>? nin,
  }) => Input$PeriodTimeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$PeriodTimeOperationFilterInput._(this._$data);

  factory Input$PeriodTimeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$PeriodTime((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$PeriodTime((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PeriodTime((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PeriodTime((e as String)))
          .toList();
    }
    return Input$PeriodTimeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PeriodTime? get eq => (_$data['eq'] as Enum$PeriodTime?);

  Enum$PeriodTime? get neq => (_$data['neq'] as Enum$PeriodTime?);

  List<Enum$PeriodTime>? get $in => (_$data['in'] as List<Enum$PeriodTime>?);

  List<Enum$PeriodTime>? get nin => (_$data['nin'] as List<Enum$PeriodTime>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$PeriodTime(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$PeriodTime(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$PeriodTime(e)).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$PeriodTime(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$PeriodTimeOperationFilterInput<
    Input$PeriodTimeOperationFilterInput
  >
  get copyWith => CopyWith$Input$PeriodTimeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PeriodTimeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PeriodTimeOperationFilterInput<TRes> {
  factory CopyWith$Input$PeriodTimeOperationFilterInput(
    Input$PeriodTimeOperationFilterInput instance,
    TRes Function(Input$PeriodTimeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$PeriodTimeOperationFilterInput;

  factory CopyWith$Input$PeriodTimeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PeriodTimeOperationFilterInput;

  TRes call({
    Enum$PeriodTime? eq,
    Enum$PeriodTime? neq,
    List<Enum$PeriodTime>? $in,
    List<Enum$PeriodTime>? nin,
  });
}

class _CopyWithImpl$Input$PeriodTimeOperationFilterInput<TRes>
    implements CopyWith$Input$PeriodTimeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$PeriodTimeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$PeriodTimeOperationFilterInput _instance;

  final TRes Function(Input$PeriodTimeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$PeriodTimeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$PeriodTime?),
      if (neq != _undefined) 'neq': (neq as Enum$PeriodTime?),
      if ($in != _undefined) 'in': ($in as List<Enum$PeriodTime>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$PeriodTime>?),
    }),
  );
}

class _CopyWithStubImpl$Input$PeriodTimeOperationFilterInput<TRes>
    implements CopyWith$Input$PeriodTimeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$PeriodTimeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$PeriodTime? eq,
    Enum$PeriodTime? neq,
    List<Enum$PeriodTime>? $in,
    List<Enum$PeriodTime>? nin,
  }) => _res;
}

class Input$PlatformRevenueFilterInput {
  factory Input$PlatformRevenueFilterInput({
    List<Input$PlatformRevenueFilterInput>? and,
    List<Input$PlatformRevenueFilterInput>? or,
    Input$DecimalOperationFilterInput? subscriptionRevenue,
    Input$DecimalOperationFilterInput? serviceRevenue,
    Input$DecimalOperationFilterInput? grossRevenue,
    Input$DecimalOperationFilterInput? royaltyPayoutAmount,
    Input$DecimalOperationFilterInput? servicePayoutAmount,
    Input$DecimalOperationFilterInput? refundAmount,
    Input$DecimalOperationFilterInput? totalPayoutAmount,
    Input$DecimalOperationFilterInput? grossDeductions,
    Input$DecimalOperationFilterInput? commissionProfit,
    Input$DecimalOperationFilterInput? netProfit,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$PlatformRevenueFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (subscriptionRevenue != null)
      r'subscriptionRevenue': subscriptionRevenue,
    if (serviceRevenue != null) r'serviceRevenue': serviceRevenue,
    if (grossRevenue != null) r'grossRevenue': grossRevenue,
    if (royaltyPayoutAmount != null)
      r'royaltyPayoutAmount': royaltyPayoutAmount,
    if (servicePayoutAmount != null)
      r'servicePayoutAmount': servicePayoutAmount,
    if (refundAmount != null) r'refundAmount': refundAmount,
    if (totalPayoutAmount != null) r'totalPayoutAmount': totalPayoutAmount,
    if (grossDeductions != null) r'grossDeductions': grossDeductions,
    if (commissionProfit != null) r'commissionProfit': commissionProfit,
    if (netProfit != null) r'netProfit': netProfit,
    if (currency != null) r'currency': currency,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$PlatformRevenueFilterInput._(this._$data);

  factory Input$PlatformRevenueFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$PlatformRevenueFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$PlatformRevenueFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('subscriptionRevenue')) {
      final l$subscriptionRevenue = data['subscriptionRevenue'];
      result$data['subscriptionRevenue'] = l$subscriptionRevenue == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$subscriptionRevenue as Map<String, dynamic>),
            );
    }
    if (data.containsKey('serviceRevenue')) {
      final l$serviceRevenue = data['serviceRevenue'];
      result$data['serviceRevenue'] = l$serviceRevenue == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$serviceRevenue as Map<String, dynamic>),
            );
    }
    if (data.containsKey('grossRevenue')) {
      final l$grossRevenue = data['grossRevenue'];
      result$data['grossRevenue'] = l$grossRevenue == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$grossRevenue as Map<String, dynamic>),
            );
    }
    if (data.containsKey('royaltyPayoutAmount')) {
      final l$royaltyPayoutAmount = data['royaltyPayoutAmount'];
      result$data['royaltyPayoutAmount'] = l$royaltyPayoutAmount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$royaltyPayoutAmount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('servicePayoutAmount')) {
      final l$servicePayoutAmount = data['servicePayoutAmount'];
      result$data['servicePayoutAmount'] = l$servicePayoutAmount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$servicePayoutAmount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('refundAmount')) {
      final l$refundAmount = data['refundAmount'];
      result$data['refundAmount'] = l$refundAmount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$refundAmount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('totalPayoutAmount')) {
      final l$totalPayoutAmount = data['totalPayoutAmount'];
      result$data['totalPayoutAmount'] = l$totalPayoutAmount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$totalPayoutAmount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('grossDeductions')) {
      final l$grossDeductions = data['grossDeductions'];
      result$data['grossDeductions'] = l$grossDeductions == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$grossDeductions as Map<String, dynamic>),
            );
    }
    if (data.containsKey('commissionProfit')) {
      final l$commissionProfit = data['commissionProfit'];
      result$data['commissionProfit'] = l$commissionProfit == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$commissionProfit as Map<String, dynamic>),
            );
    }
    if (data.containsKey('netProfit')) {
      final l$netProfit = data['netProfit'];
      result$data['netProfit'] = l$netProfit == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$netProfit as Map<String, dynamic>),
            );
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : Input$CurrencyTypeOperationFilterInput.fromJson(
              (l$currency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$PlatformRevenueFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PlatformRevenueFilterInput>? get and =>
      (_$data['and'] as List<Input$PlatformRevenueFilterInput>?);

  List<Input$PlatformRevenueFilterInput>? get or =>
      (_$data['or'] as List<Input$PlatformRevenueFilterInput>?);

  Input$DecimalOperationFilterInput? get subscriptionRevenue =>
      (_$data['subscriptionRevenue'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get serviceRevenue =>
      (_$data['serviceRevenue'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get grossRevenue =>
      (_$data['grossRevenue'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get royaltyPayoutAmount =>
      (_$data['royaltyPayoutAmount'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get servicePayoutAmount =>
      (_$data['servicePayoutAmount'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get refundAmount =>
      (_$data['refundAmount'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get totalPayoutAmount =>
      (_$data['totalPayoutAmount'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get grossDeductions =>
      (_$data['grossDeductions'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get commissionProfit =>
      (_$data['commissionProfit'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get netProfit =>
      (_$data['netProfit'] as Input$DecimalOperationFilterInput?);

  Input$CurrencyTypeOperationFilterInput? get currency =>
      (_$data['currency'] as Input$CurrencyTypeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('subscriptionRevenue')) {
      final l$subscriptionRevenue = subscriptionRevenue;
      result$data['subscriptionRevenue'] = l$subscriptionRevenue?.toJson();
    }
    if (_$data.containsKey('serviceRevenue')) {
      final l$serviceRevenue = serviceRevenue;
      result$data['serviceRevenue'] = l$serviceRevenue?.toJson();
    }
    if (_$data.containsKey('grossRevenue')) {
      final l$grossRevenue = grossRevenue;
      result$data['grossRevenue'] = l$grossRevenue?.toJson();
    }
    if (_$data.containsKey('royaltyPayoutAmount')) {
      final l$royaltyPayoutAmount = royaltyPayoutAmount;
      result$data['royaltyPayoutAmount'] = l$royaltyPayoutAmount?.toJson();
    }
    if (_$data.containsKey('servicePayoutAmount')) {
      final l$servicePayoutAmount = servicePayoutAmount;
      result$data['servicePayoutAmount'] = l$servicePayoutAmount?.toJson();
    }
    if (_$data.containsKey('refundAmount')) {
      final l$refundAmount = refundAmount;
      result$data['refundAmount'] = l$refundAmount?.toJson();
    }
    if (_$data.containsKey('totalPayoutAmount')) {
      final l$totalPayoutAmount = totalPayoutAmount;
      result$data['totalPayoutAmount'] = l$totalPayoutAmount?.toJson();
    }
    if (_$data.containsKey('grossDeductions')) {
      final l$grossDeductions = grossDeductions;
      result$data['grossDeductions'] = l$grossDeductions?.toJson();
    }
    if (_$data.containsKey('commissionProfit')) {
      final l$commissionProfit = commissionProfit;
      result$data['commissionProfit'] = l$commissionProfit?.toJson();
    }
    if (_$data.containsKey('netProfit')) {
      final l$netProfit = netProfit;
      result$data['netProfit'] = l$netProfit?.toJson();
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PlatformRevenueFilterInput<Input$PlatformRevenueFilterInput>
  get copyWith => CopyWith$Input$PlatformRevenueFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PlatformRevenueFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$subscriptionRevenue = subscriptionRevenue;
    final lOther$subscriptionRevenue = other.subscriptionRevenue;
    if (_$data.containsKey('subscriptionRevenue') !=
        other._$data.containsKey('subscriptionRevenue')) {
      return false;
    }
    if (l$subscriptionRevenue != lOther$subscriptionRevenue) {
      return false;
    }
    final l$serviceRevenue = serviceRevenue;
    final lOther$serviceRevenue = other.serviceRevenue;
    if (_$data.containsKey('serviceRevenue') !=
        other._$data.containsKey('serviceRevenue')) {
      return false;
    }
    if (l$serviceRevenue != lOther$serviceRevenue) {
      return false;
    }
    final l$grossRevenue = grossRevenue;
    final lOther$grossRevenue = other.grossRevenue;
    if (_$data.containsKey('grossRevenue') !=
        other._$data.containsKey('grossRevenue')) {
      return false;
    }
    if (l$grossRevenue != lOther$grossRevenue) {
      return false;
    }
    final l$royaltyPayoutAmount = royaltyPayoutAmount;
    final lOther$royaltyPayoutAmount = other.royaltyPayoutAmount;
    if (_$data.containsKey('royaltyPayoutAmount') !=
        other._$data.containsKey('royaltyPayoutAmount')) {
      return false;
    }
    if (l$royaltyPayoutAmount != lOther$royaltyPayoutAmount) {
      return false;
    }
    final l$servicePayoutAmount = servicePayoutAmount;
    final lOther$servicePayoutAmount = other.servicePayoutAmount;
    if (_$data.containsKey('servicePayoutAmount') !=
        other._$data.containsKey('servicePayoutAmount')) {
      return false;
    }
    if (l$servicePayoutAmount != lOther$servicePayoutAmount) {
      return false;
    }
    final l$refundAmount = refundAmount;
    final lOther$refundAmount = other.refundAmount;
    if (_$data.containsKey('refundAmount') !=
        other._$data.containsKey('refundAmount')) {
      return false;
    }
    if (l$refundAmount != lOther$refundAmount) {
      return false;
    }
    final l$totalPayoutAmount = totalPayoutAmount;
    final lOther$totalPayoutAmount = other.totalPayoutAmount;
    if (_$data.containsKey('totalPayoutAmount') !=
        other._$data.containsKey('totalPayoutAmount')) {
      return false;
    }
    if (l$totalPayoutAmount != lOther$totalPayoutAmount) {
      return false;
    }
    final l$grossDeductions = grossDeductions;
    final lOther$grossDeductions = other.grossDeductions;
    if (_$data.containsKey('grossDeductions') !=
        other._$data.containsKey('grossDeductions')) {
      return false;
    }
    if (l$grossDeductions != lOther$grossDeductions) {
      return false;
    }
    final l$commissionProfit = commissionProfit;
    final lOther$commissionProfit = other.commissionProfit;
    if (_$data.containsKey('commissionProfit') !=
        other._$data.containsKey('commissionProfit')) {
      return false;
    }
    if (l$commissionProfit != lOther$commissionProfit) {
      return false;
    }
    final l$netProfit = netProfit;
    final lOther$netProfit = other.netProfit;
    if (_$data.containsKey('netProfit') !=
        other._$data.containsKey('netProfit')) {
      return false;
    }
    if (l$netProfit != lOther$netProfit) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$subscriptionRevenue = subscriptionRevenue;
    final l$serviceRevenue = serviceRevenue;
    final l$grossRevenue = grossRevenue;
    final l$royaltyPayoutAmount = royaltyPayoutAmount;
    final l$servicePayoutAmount = servicePayoutAmount;
    final l$refundAmount = refundAmount;
    final l$totalPayoutAmount = totalPayoutAmount;
    final l$grossDeductions = grossDeductions;
    final l$commissionProfit = commissionProfit;
    final l$netProfit = netProfit;
    final l$currency = currency;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('subscriptionRevenue')
          ? l$subscriptionRevenue
          : const {},
      _$data.containsKey('serviceRevenue') ? l$serviceRevenue : const {},
      _$data.containsKey('grossRevenue') ? l$grossRevenue : const {},
      _$data.containsKey('royaltyPayoutAmount')
          ? l$royaltyPayoutAmount
          : const {},
      _$data.containsKey('servicePayoutAmount')
          ? l$servicePayoutAmount
          : const {},
      _$data.containsKey('refundAmount') ? l$refundAmount : const {},
      _$data.containsKey('totalPayoutAmount') ? l$totalPayoutAmount : const {},
      _$data.containsKey('grossDeductions') ? l$grossDeductions : const {},
      _$data.containsKey('commissionProfit') ? l$commissionProfit : const {},
      _$data.containsKey('netProfit') ? l$netProfit : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PlatformRevenueFilterInput<TRes> {
  factory CopyWith$Input$PlatformRevenueFilterInput(
    Input$PlatformRevenueFilterInput instance,
    TRes Function(Input$PlatformRevenueFilterInput) then,
  ) = _CopyWithImpl$Input$PlatformRevenueFilterInput;

  factory CopyWith$Input$PlatformRevenueFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlatformRevenueFilterInput;

  TRes call({
    List<Input$PlatformRevenueFilterInput>? and,
    List<Input$PlatformRevenueFilterInput>? or,
    Input$DecimalOperationFilterInput? subscriptionRevenue,
    Input$DecimalOperationFilterInput? serviceRevenue,
    Input$DecimalOperationFilterInput? grossRevenue,
    Input$DecimalOperationFilterInput? royaltyPayoutAmount,
    Input$DecimalOperationFilterInput? servicePayoutAmount,
    Input$DecimalOperationFilterInput? refundAmount,
    Input$DecimalOperationFilterInput? totalPayoutAmount,
    Input$DecimalOperationFilterInput? grossDeductions,
    Input$DecimalOperationFilterInput? commissionProfit,
    Input$DecimalOperationFilterInput? netProfit,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$PlatformRevenueFilterInput>? Function(
      Iterable<
        CopyWith$Input$PlatformRevenueFilterInput<
          Input$PlatformRevenueFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$PlatformRevenueFilterInput>? Function(
      Iterable<
        CopyWith$Input$PlatformRevenueFilterInput<
          Input$PlatformRevenueFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$DecimalOperationFilterInput<TRes> get subscriptionRevenue;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get serviceRevenue;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get grossRevenue;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get royaltyPayoutAmount;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get servicePayoutAmount;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get refundAmount;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get totalPayoutAmount;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get grossDeductions;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get commissionProfit;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get netProfit;
  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$PlatformRevenueFilterInput<TRes>
    implements CopyWith$Input$PlatformRevenueFilterInput<TRes> {
  _CopyWithImpl$Input$PlatformRevenueFilterInput(this._instance, this._then);

  final Input$PlatformRevenueFilterInput _instance;

  final TRes Function(Input$PlatformRevenueFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? subscriptionRevenue = _undefined,
    Object? serviceRevenue = _undefined,
    Object? grossRevenue = _undefined,
    Object? royaltyPayoutAmount = _undefined,
    Object? servicePayoutAmount = _undefined,
    Object? refundAmount = _undefined,
    Object? totalPayoutAmount = _undefined,
    Object? grossDeductions = _undefined,
    Object? commissionProfit = _undefined,
    Object? netProfit = _undefined,
    Object? currency = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$PlatformRevenueFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$PlatformRevenueFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$PlatformRevenueFilterInput>?),
      if (subscriptionRevenue != _undefined)
        'subscriptionRevenue':
            (subscriptionRevenue as Input$DecimalOperationFilterInput?),
      if (serviceRevenue != _undefined)
        'serviceRevenue':
            (serviceRevenue as Input$DecimalOperationFilterInput?),
      if (grossRevenue != _undefined)
        'grossRevenue': (grossRevenue as Input$DecimalOperationFilterInput?),
      if (royaltyPayoutAmount != _undefined)
        'royaltyPayoutAmount':
            (royaltyPayoutAmount as Input$DecimalOperationFilterInput?),
      if (servicePayoutAmount != _undefined)
        'servicePayoutAmount':
            (servicePayoutAmount as Input$DecimalOperationFilterInput?),
      if (refundAmount != _undefined)
        'refundAmount': (refundAmount as Input$DecimalOperationFilterInput?),
      if (totalPayoutAmount != _undefined)
        'totalPayoutAmount':
            (totalPayoutAmount as Input$DecimalOperationFilterInput?),
      if (grossDeductions != _undefined)
        'grossDeductions':
            (grossDeductions as Input$DecimalOperationFilterInput?),
      if (commissionProfit != _undefined)
        'commissionProfit':
            (commissionProfit as Input$DecimalOperationFilterInput?),
      if (netProfit != _undefined)
        'netProfit': (netProfit as Input$DecimalOperationFilterInput?),
      if (currency != _undefined)
        'currency': (currency as Input$CurrencyTypeOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$PlatformRevenueFilterInput>? Function(
      Iterable<
        CopyWith$Input$PlatformRevenueFilterInput<
          Input$PlatformRevenueFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$PlatformRevenueFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$PlatformRevenueFilterInput>? Function(
      Iterable<
        CopyWith$Input$PlatformRevenueFilterInput<
          Input$PlatformRevenueFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$PlatformRevenueFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$DecimalOperationFilterInput<TRes> get subscriptionRevenue {
    final local$subscriptionRevenue = _instance.subscriptionRevenue;
    return local$subscriptionRevenue == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$subscriptionRevenue,
            (e) => call(subscriptionRevenue: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get serviceRevenue {
    final local$serviceRevenue = _instance.serviceRevenue;
    return local$serviceRevenue == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$serviceRevenue,
            (e) => call(serviceRevenue: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get grossRevenue {
    final local$grossRevenue = _instance.grossRevenue;
    return local$grossRevenue == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$grossRevenue,
            (e) => call(grossRevenue: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get royaltyPayoutAmount {
    final local$royaltyPayoutAmount = _instance.royaltyPayoutAmount;
    return local$royaltyPayoutAmount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$royaltyPayoutAmount,
            (e) => call(royaltyPayoutAmount: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get servicePayoutAmount {
    final local$servicePayoutAmount = _instance.servicePayoutAmount;
    return local$servicePayoutAmount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$servicePayoutAmount,
            (e) => call(servicePayoutAmount: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get refundAmount {
    final local$refundAmount = _instance.refundAmount;
    return local$refundAmount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$refundAmount,
            (e) => call(refundAmount: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get totalPayoutAmount {
    final local$totalPayoutAmount = _instance.totalPayoutAmount;
    return local$totalPayoutAmount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$totalPayoutAmount,
            (e) => call(totalPayoutAmount: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get grossDeductions {
    final local$grossDeductions = _instance.grossDeductions;
    return local$grossDeductions == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$grossDeductions,
            (e) => call(grossDeductions: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get commissionProfit {
    final local$commissionProfit = _instance.commissionProfit;
    return local$commissionProfit == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$commissionProfit,
            (e) => call(commissionProfit: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get netProfit {
    final local$netProfit = _instance.netProfit;
    return local$netProfit == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$netProfit,
            (e) => call(netProfit: e),
          );
  }

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency {
    final local$currency = _instance.currency;
    return local$currency == null
        ? CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CurrencyTypeOperationFilterInput(
            local$currency,
            (e) => call(currency: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$PlatformRevenueFilterInput<TRes>
    implements CopyWith$Input$PlatformRevenueFilterInput<TRes> {
  _CopyWithStubImpl$Input$PlatformRevenueFilterInput(this._res);

  TRes _res;

  call({
    List<Input$PlatformRevenueFilterInput>? and,
    List<Input$PlatformRevenueFilterInput>? or,
    Input$DecimalOperationFilterInput? subscriptionRevenue,
    Input$DecimalOperationFilterInput? serviceRevenue,
    Input$DecimalOperationFilterInput? grossRevenue,
    Input$DecimalOperationFilterInput? royaltyPayoutAmount,
    Input$DecimalOperationFilterInput? servicePayoutAmount,
    Input$DecimalOperationFilterInput? refundAmount,
    Input$DecimalOperationFilterInput? totalPayoutAmount,
    Input$DecimalOperationFilterInput? grossDeductions,
    Input$DecimalOperationFilterInput? commissionProfit,
    Input$DecimalOperationFilterInput? netProfit,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$DecimalOperationFilterInput<TRes> get subscriptionRevenue =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get serviceRevenue =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get grossRevenue =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get royaltyPayoutAmount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get servicePayoutAmount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get refundAmount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get totalPayoutAmount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get grossDeductions =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get commissionProfit =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get netProfit =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency =>
      CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$PlatformRevenueSortInput {
  factory Input$PlatformRevenueSortInput({
    Enum$SortEnumType? subscriptionRevenue,
    Enum$SortEnumType? serviceRevenue,
    Enum$SortEnumType? grossRevenue,
    Enum$SortEnumType? royaltyPayoutAmount,
    Enum$SortEnumType? servicePayoutAmount,
    Enum$SortEnumType? refundAmount,
    Enum$SortEnumType? totalPayoutAmount,
    Enum$SortEnumType? grossDeductions,
    Enum$SortEnumType? commissionProfit,
    Enum$SortEnumType? netProfit,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$PlatformRevenueSortInput._({
    if (subscriptionRevenue != null)
      r'subscriptionRevenue': subscriptionRevenue,
    if (serviceRevenue != null) r'serviceRevenue': serviceRevenue,
    if (grossRevenue != null) r'grossRevenue': grossRevenue,
    if (royaltyPayoutAmount != null)
      r'royaltyPayoutAmount': royaltyPayoutAmount,
    if (servicePayoutAmount != null)
      r'servicePayoutAmount': servicePayoutAmount,
    if (refundAmount != null) r'refundAmount': refundAmount,
    if (totalPayoutAmount != null) r'totalPayoutAmount': totalPayoutAmount,
    if (grossDeductions != null) r'grossDeductions': grossDeductions,
    if (commissionProfit != null) r'commissionProfit': commissionProfit,
    if (netProfit != null) r'netProfit': netProfit,
    if (currency != null) r'currency': currency,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$PlatformRevenueSortInput._(this._$data);

  factory Input$PlatformRevenueSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('subscriptionRevenue')) {
      final l$subscriptionRevenue = data['subscriptionRevenue'];
      result$data['subscriptionRevenue'] = l$subscriptionRevenue == null
          ? null
          : fromJson$Enum$SortEnumType((l$subscriptionRevenue as String));
    }
    if (data.containsKey('serviceRevenue')) {
      final l$serviceRevenue = data['serviceRevenue'];
      result$data['serviceRevenue'] = l$serviceRevenue == null
          ? null
          : fromJson$Enum$SortEnumType((l$serviceRevenue as String));
    }
    if (data.containsKey('grossRevenue')) {
      final l$grossRevenue = data['grossRevenue'];
      result$data['grossRevenue'] = l$grossRevenue == null
          ? null
          : fromJson$Enum$SortEnumType((l$grossRevenue as String));
    }
    if (data.containsKey('royaltyPayoutAmount')) {
      final l$royaltyPayoutAmount = data['royaltyPayoutAmount'];
      result$data['royaltyPayoutAmount'] = l$royaltyPayoutAmount == null
          ? null
          : fromJson$Enum$SortEnumType((l$royaltyPayoutAmount as String));
    }
    if (data.containsKey('servicePayoutAmount')) {
      final l$servicePayoutAmount = data['servicePayoutAmount'];
      result$data['servicePayoutAmount'] = l$servicePayoutAmount == null
          ? null
          : fromJson$Enum$SortEnumType((l$servicePayoutAmount as String));
    }
    if (data.containsKey('refundAmount')) {
      final l$refundAmount = data['refundAmount'];
      result$data['refundAmount'] = l$refundAmount == null
          ? null
          : fromJson$Enum$SortEnumType((l$refundAmount as String));
    }
    if (data.containsKey('totalPayoutAmount')) {
      final l$totalPayoutAmount = data['totalPayoutAmount'];
      result$data['totalPayoutAmount'] = l$totalPayoutAmount == null
          ? null
          : fromJson$Enum$SortEnumType((l$totalPayoutAmount as String));
    }
    if (data.containsKey('grossDeductions')) {
      final l$grossDeductions = data['grossDeductions'];
      result$data['grossDeductions'] = l$grossDeductions == null
          ? null
          : fromJson$Enum$SortEnumType((l$grossDeductions as String));
    }
    if (data.containsKey('commissionProfit')) {
      final l$commissionProfit = data['commissionProfit'];
      result$data['commissionProfit'] = l$commissionProfit == null
          ? null
          : fromJson$Enum$SortEnumType((l$commissionProfit as String));
    }
    if (data.containsKey('netProfit')) {
      final l$netProfit = data['netProfit'];
      result$data['netProfit'] = l$netProfit == null
          ? null
          : fromJson$Enum$SortEnumType((l$netProfit as String));
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$SortEnumType((l$currency as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$PlatformRevenueSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get subscriptionRevenue =>
      (_$data['subscriptionRevenue'] as Enum$SortEnumType?);

  Enum$SortEnumType? get serviceRevenue =>
      (_$data['serviceRevenue'] as Enum$SortEnumType?);

  Enum$SortEnumType? get grossRevenue =>
      (_$data['grossRevenue'] as Enum$SortEnumType?);

  Enum$SortEnumType? get royaltyPayoutAmount =>
      (_$data['royaltyPayoutAmount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get servicePayoutAmount =>
      (_$data['servicePayoutAmount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get refundAmount =>
      (_$data['refundAmount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get totalPayoutAmount =>
      (_$data['totalPayoutAmount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get grossDeductions =>
      (_$data['grossDeductions'] as Enum$SortEnumType?);

  Enum$SortEnumType? get commissionProfit =>
      (_$data['commissionProfit'] as Enum$SortEnumType?);

  Enum$SortEnumType? get netProfit =>
      (_$data['netProfit'] as Enum$SortEnumType?);

  Enum$SortEnumType? get currency => (_$data['currency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('subscriptionRevenue')) {
      final l$subscriptionRevenue = subscriptionRevenue;
      result$data['subscriptionRevenue'] = l$subscriptionRevenue == null
          ? null
          : toJson$Enum$SortEnumType(l$subscriptionRevenue);
    }
    if (_$data.containsKey('serviceRevenue')) {
      final l$serviceRevenue = serviceRevenue;
      result$data['serviceRevenue'] = l$serviceRevenue == null
          ? null
          : toJson$Enum$SortEnumType(l$serviceRevenue);
    }
    if (_$data.containsKey('grossRevenue')) {
      final l$grossRevenue = grossRevenue;
      result$data['grossRevenue'] = l$grossRevenue == null
          ? null
          : toJson$Enum$SortEnumType(l$grossRevenue);
    }
    if (_$data.containsKey('royaltyPayoutAmount')) {
      final l$royaltyPayoutAmount = royaltyPayoutAmount;
      result$data['royaltyPayoutAmount'] = l$royaltyPayoutAmount == null
          ? null
          : toJson$Enum$SortEnumType(l$royaltyPayoutAmount);
    }
    if (_$data.containsKey('servicePayoutAmount')) {
      final l$servicePayoutAmount = servicePayoutAmount;
      result$data['servicePayoutAmount'] = l$servicePayoutAmount == null
          ? null
          : toJson$Enum$SortEnumType(l$servicePayoutAmount);
    }
    if (_$data.containsKey('refundAmount')) {
      final l$refundAmount = refundAmount;
      result$data['refundAmount'] = l$refundAmount == null
          ? null
          : toJson$Enum$SortEnumType(l$refundAmount);
    }
    if (_$data.containsKey('totalPayoutAmount')) {
      final l$totalPayoutAmount = totalPayoutAmount;
      result$data['totalPayoutAmount'] = l$totalPayoutAmount == null
          ? null
          : toJson$Enum$SortEnumType(l$totalPayoutAmount);
    }
    if (_$data.containsKey('grossDeductions')) {
      final l$grossDeductions = grossDeductions;
      result$data['grossDeductions'] = l$grossDeductions == null
          ? null
          : toJson$Enum$SortEnumType(l$grossDeductions);
    }
    if (_$data.containsKey('commissionProfit')) {
      final l$commissionProfit = commissionProfit;
      result$data['commissionProfit'] = l$commissionProfit == null
          ? null
          : toJson$Enum$SortEnumType(l$commissionProfit);
    }
    if (_$data.containsKey('netProfit')) {
      final l$netProfit = netProfit;
      result$data['netProfit'] = l$netProfit == null
          ? null
          : toJson$Enum$SortEnumType(l$netProfit);
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$SortEnumType(l$currency);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$PlatformRevenueSortInput<Input$PlatformRevenueSortInput>
  get copyWith => CopyWith$Input$PlatformRevenueSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PlatformRevenueSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$subscriptionRevenue = subscriptionRevenue;
    final lOther$subscriptionRevenue = other.subscriptionRevenue;
    if (_$data.containsKey('subscriptionRevenue') !=
        other._$data.containsKey('subscriptionRevenue')) {
      return false;
    }
    if (l$subscriptionRevenue != lOther$subscriptionRevenue) {
      return false;
    }
    final l$serviceRevenue = serviceRevenue;
    final lOther$serviceRevenue = other.serviceRevenue;
    if (_$data.containsKey('serviceRevenue') !=
        other._$data.containsKey('serviceRevenue')) {
      return false;
    }
    if (l$serviceRevenue != lOther$serviceRevenue) {
      return false;
    }
    final l$grossRevenue = grossRevenue;
    final lOther$grossRevenue = other.grossRevenue;
    if (_$data.containsKey('grossRevenue') !=
        other._$data.containsKey('grossRevenue')) {
      return false;
    }
    if (l$grossRevenue != lOther$grossRevenue) {
      return false;
    }
    final l$royaltyPayoutAmount = royaltyPayoutAmount;
    final lOther$royaltyPayoutAmount = other.royaltyPayoutAmount;
    if (_$data.containsKey('royaltyPayoutAmount') !=
        other._$data.containsKey('royaltyPayoutAmount')) {
      return false;
    }
    if (l$royaltyPayoutAmount != lOther$royaltyPayoutAmount) {
      return false;
    }
    final l$servicePayoutAmount = servicePayoutAmount;
    final lOther$servicePayoutAmount = other.servicePayoutAmount;
    if (_$data.containsKey('servicePayoutAmount') !=
        other._$data.containsKey('servicePayoutAmount')) {
      return false;
    }
    if (l$servicePayoutAmount != lOther$servicePayoutAmount) {
      return false;
    }
    final l$refundAmount = refundAmount;
    final lOther$refundAmount = other.refundAmount;
    if (_$data.containsKey('refundAmount') !=
        other._$data.containsKey('refundAmount')) {
      return false;
    }
    if (l$refundAmount != lOther$refundAmount) {
      return false;
    }
    final l$totalPayoutAmount = totalPayoutAmount;
    final lOther$totalPayoutAmount = other.totalPayoutAmount;
    if (_$data.containsKey('totalPayoutAmount') !=
        other._$data.containsKey('totalPayoutAmount')) {
      return false;
    }
    if (l$totalPayoutAmount != lOther$totalPayoutAmount) {
      return false;
    }
    final l$grossDeductions = grossDeductions;
    final lOther$grossDeductions = other.grossDeductions;
    if (_$data.containsKey('grossDeductions') !=
        other._$data.containsKey('grossDeductions')) {
      return false;
    }
    if (l$grossDeductions != lOther$grossDeductions) {
      return false;
    }
    final l$commissionProfit = commissionProfit;
    final lOther$commissionProfit = other.commissionProfit;
    if (_$data.containsKey('commissionProfit') !=
        other._$data.containsKey('commissionProfit')) {
      return false;
    }
    if (l$commissionProfit != lOther$commissionProfit) {
      return false;
    }
    final l$netProfit = netProfit;
    final lOther$netProfit = other.netProfit;
    if (_$data.containsKey('netProfit') !=
        other._$data.containsKey('netProfit')) {
      return false;
    }
    if (l$netProfit != lOther$netProfit) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subscriptionRevenue = subscriptionRevenue;
    final l$serviceRevenue = serviceRevenue;
    final l$grossRevenue = grossRevenue;
    final l$royaltyPayoutAmount = royaltyPayoutAmount;
    final l$servicePayoutAmount = servicePayoutAmount;
    final l$refundAmount = refundAmount;
    final l$totalPayoutAmount = totalPayoutAmount;
    final l$grossDeductions = grossDeductions;
    final l$commissionProfit = commissionProfit;
    final l$netProfit = netProfit;
    final l$currency = currency;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('subscriptionRevenue')
          ? l$subscriptionRevenue
          : const {},
      _$data.containsKey('serviceRevenue') ? l$serviceRevenue : const {},
      _$data.containsKey('grossRevenue') ? l$grossRevenue : const {},
      _$data.containsKey('royaltyPayoutAmount')
          ? l$royaltyPayoutAmount
          : const {},
      _$data.containsKey('servicePayoutAmount')
          ? l$servicePayoutAmount
          : const {},
      _$data.containsKey('refundAmount') ? l$refundAmount : const {},
      _$data.containsKey('totalPayoutAmount') ? l$totalPayoutAmount : const {},
      _$data.containsKey('grossDeductions') ? l$grossDeductions : const {},
      _$data.containsKey('commissionProfit') ? l$commissionProfit : const {},
      _$data.containsKey('netProfit') ? l$netProfit : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PlatformRevenueSortInput<TRes> {
  factory CopyWith$Input$PlatformRevenueSortInput(
    Input$PlatformRevenueSortInput instance,
    TRes Function(Input$PlatformRevenueSortInput) then,
  ) = _CopyWithImpl$Input$PlatformRevenueSortInput;

  factory CopyWith$Input$PlatformRevenueSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlatformRevenueSortInput;

  TRes call({
    Enum$SortEnumType? subscriptionRevenue,
    Enum$SortEnumType? serviceRevenue,
    Enum$SortEnumType? grossRevenue,
    Enum$SortEnumType? royaltyPayoutAmount,
    Enum$SortEnumType? servicePayoutAmount,
    Enum$SortEnumType? refundAmount,
    Enum$SortEnumType? totalPayoutAmount,
    Enum$SortEnumType? grossDeductions,
    Enum$SortEnumType? commissionProfit,
    Enum$SortEnumType? netProfit,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$PlatformRevenueSortInput<TRes>
    implements CopyWith$Input$PlatformRevenueSortInput<TRes> {
  _CopyWithImpl$Input$PlatformRevenueSortInput(this._instance, this._then);

  final Input$PlatformRevenueSortInput _instance;

  final TRes Function(Input$PlatformRevenueSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? subscriptionRevenue = _undefined,
    Object? serviceRevenue = _undefined,
    Object? grossRevenue = _undefined,
    Object? royaltyPayoutAmount = _undefined,
    Object? servicePayoutAmount = _undefined,
    Object? refundAmount = _undefined,
    Object? totalPayoutAmount = _undefined,
    Object? grossDeductions = _undefined,
    Object? commissionProfit = _undefined,
    Object? netProfit = _undefined,
    Object? currency = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$PlatformRevenueSortInput._({
      ..._instance._$data,
      if (subscriptionRevenue != _undefined)
        'subscriptionRevenue': (subscriptionRevenue as Enum$SortEnumType?),
      if (serviceRevenue != _undefined)
        'serviceRevenue': (serviceRevenue as Enum$SortEnumType?),
      if (grossRevenue != _undefined)
        'grossRevenue': (grossRevenue as Enum$SortEnumType?),
      if (royaltyPayoutAmount != _undefined)
        'royaltyPayoutAmount': (royaltyPayoutAmount as Enum$SortEnumType?),
      if (servicePayoutAmount != _undefined)
        'servicePayoutAmount': (servicePayoutAmount as Enum$SortEnumType?),
      if (refundAmount != _undefined)
        'refundAmount': (refundAmount as Enum$SortEnumType?),
      if (totalPayoutAmount != _undefined)
        'totalPayoutAmount': (totalPayoutAmount as Enum$SortEnumType?),
      if (grossDeductions != _undefined)
        'grossDeductions': (grossDeductions as Enum$SortEnumType?),
      if (commissionProfit != _undefined)
        'commissionProfit': (commissionProfit as Enum$SortEnumType?),
      if (netProfit != _undefined)
        'netProfit': (netProfit as Enum$SortEnumType?),
      if (currency != _undefined) 'currency': (currency as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$PlatformRevenueSortInput<TRes>
    implements CopyWith$Input$PlatformRevenueSortInput<TRes> {
  _CopyWithStubImpl$Input$PlatformRevenueSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? subscriptionRevenue,
    Enum$SortEnumType? serviceRevenue,
    Enum$SortEnumType? grossRevenue,
    Enum$SortEnumType? royaltyPayoutAmount,
    Enum$SortEnumType? servicePayoutAmount,
    Enum$SortEnumType? refundAmount,
    Enum$SortEnumType? totalPayoutAmount,
    Enum$SortEnumType? grossDeductions,
    Enum$SortEnumType? commissionProfit,
    Enum$SortEnumType? netProfit,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$PlaylistFilterInput {
  factory Input$PlaylistFilterInput({
    List<Input$PlaylistFilterInput>? and,
    List<Input$PlaylistFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? nameUnsigned,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? coverImage,
    Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput? tracksInfo,
    Input$BooleanOperationFilterInput? isPublic,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$PlaylistFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (name != null) r'name': name,
    if (nameUnsigned != null) r'nameUnsigned': nameUnsigned,
    if (description != null) r'description': description,
    if (coverImage != null) r'coverImage': coverImage,
    if (tracksInfo != null) r'tracksInfo': tracksInfo,
    if (isPublic != null) r'isPublic': isPublic,
    if (isVisible != null) r'isVisible': isVisible,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$PlaylistFilterInput._(this._$data);

  factory Input$PlaylistFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$PlaylistFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$PlaylistFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>),
            );
    }
    if (data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = data['nameUnsigned'];
      result$data['nameUnsigned'] = l$nameUnsigned == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$nameUnsigned as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = l$coverImage == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$coverImage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('tracksInfo')) {
      final l$tracksInfo = data['tracksInfo'];
      result$data['tracksInfo'] = l$tracksInfo == null
          ? null
          : Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput.fromJson(
              (l$tracksInfo as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isPublic')) {
      final l$isPublic = data['isPublic'];
      result$data['isPublic'] = l$isPublic == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isPublic as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isVisible as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$PlaylistFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PlaylistFilterInput>? get and =>
      (_$data['and'] as List<Input$PlaylistFilterInput>?);

  List<Input$PlaylistFilterInput>? get or =>
      (_$data['or'] as List<Input$PlaylistFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get userId =>
      (_$data['userId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get nameUnsigned =>
      (_$data['nameUnsigned'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get coverImage =>
      (_$data['coverImage'] as Input$StringOperationFilterInput?);

  Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput? get tracksInfo =>
      (_$data['tracksInfo']
          as Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput?);

  Input$BooleanOperationFilterInput? get isPublic =>
      (_$data['isPublic'] as Input$BooleanOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isVisible =>
      (_$data['isVisible'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = nameUnsigned;
      result$data['nameUnsigned'] = l$nameUnsigned?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage?.toJson();
    }
    if (_$data.containsKey('tracksInfo')) {
      final l$tracksInfo = tracksInfo;
      result$data['tracksInfo'] = l$tracksInfo?.toJson();
    }
    if (_$data.containsKey('isPublic')) {
      final l$isPublic = isPublic;
      result$data['isPublic'] = l$isPublic?.toJson();
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PlaylistFilterInput<Input$PlaylistFilterInput> get copyWith =>
      CopyWith$Input$PlaylistFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PlaylistFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$nameUnsigned = nameUnsigned;
    final lOther$nameUnsigned = other.nameUnsigned;
    if (_$data.containsKey('nameUnsigned') !=
        other._$data.containsKey('nameUnsigned')) {
      return false;
    }
    if (l$nameUnsigned != lOther$nameUnsigned) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$tracksInfo = tracksInfo;
    final lOther$tracksInfo = other.tracksInfo;
    if (_$data.containsKey('tracksInfo') !=
        other._$data.containsKey('tracksInfo')) {
      return false;
    }
    if (l$tracksInfo != lOther$tracksInfo) {
      return false;
    }
    final l$isPublic = isPublic;
    final lOther$isPublic = other.isPublic;
    if (_$data.containsKey('isPublic') !=
        other._$data.containsKey('isPublic')) {
      return false;
    }
    if (l$isPublic != lOther$isPublic) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$nameUnsigned = nameUnsigned;
    final l$description = description;
    final l$coverImage = coverImage;
    final l$tracksInfo = tracksInfo;
    final l$isPublic = isPublic;
    final l$isVisible = isVisible;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('nameUnsigned') ? l$nameUnsigned : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('tracksInfo') ? l$tracksInfo : const {},
      _$data.containsKey('isPublic') ? l$isPublic : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PlaylistFilterInput<TRes> {
  factory CopyWith$Input$PlaylistFilterInput(
    Input$PlaylistFilterInput instance,
    TRes Function(Input$PlaylistFilterInput) then,
  ) = _CopyWithImpl$Input$PlaylistFilterInput;

  factory CopyWith$Input$PlaylistFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlaylistFilterInput;

  TRes call({
    List<Input$PlaylistFilterInput>? and,
    List<Input$PlaylistFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? nameUnsigned,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? coverImage,
    Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput? tracksInfo,
    Input$BooleanOperationFilterInput? isPublic,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$PlaylistFilterInput>? Function(
      Iterable<CopyWith$Input$PlaylistFilterInput<Input$PlaylistFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$PlaylistFilterInput>? Function(
      Iterable<CopyWith$Input$PlaylistFilterInput<Input$PlaylistFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get userId;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  CopyWith$Input$StringOperationFilterInput<TRes> get nameUnsigned;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$StringOperationFilterInput<TRes> get coverImage;
  CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput<TRes>
  get tracksInfo;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isPublic;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$PlaylistFilterInput<TRes>
    implements CopyWith$Input$PlaylistFilterInput<TRes> {
  _CopyWithImpl$Input$PlaylistFilterInput(this._instance, this._then);

  final Input$PlaylistFilterInput _instance;

  final TRes Function(Input$PlaylistFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? name = _undefined,
    Object? nameUnsigned = _undefined,
    Object? description = _undefined,
    Object? coverImage = _undefined,
    Object? tracksInfo = _undefined,
    Object? isPublic = _undefined,
    Object? isVisible = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$PlaylistFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$PlaylistFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$PlaylistFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (userId != _undefined)
        'userId': (userId as Input$StringOperationFilterInput?),
      if (name != _undefined)
        'name': (name as Input$StringOperationFilterInput?),
      if (nameUnsigned != _undefined)
        'nameUnsigned': (nameUnsigned as Input$StringOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (coverImage != _undefined)
        'coverImage': (coverImage as Input$StringOperationFilterInput?),
      if (tracksInfo != _undefined)
        'tracksInfo':
            (tracksInfo
                as Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput?),
      if (isPublic != _undefined)
        'isPublic': (isPublic as Input$BooleanOperationFilterInput?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Input$BooleanOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$PlaylistFilterInput>? Function(
      Iterable<CopyWith$Input$PlaylistFilterInput<Input$PlaylistFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$PlaylistFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$PlaylistFilterInput>? Function(
      Iterable<CopyWith$Input$PlaylistFilterInput<Input$PlaylistFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$PlaylistFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userId,
            (e) => call(userId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name,
            (e) => call(name: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get nameUnsigned {
    final local$nameUnsigned = _instance.nameUnsigned;
    return local$nameUnsigned == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$nameUnsigned,
            (e) => call(nameUnsigned: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get coverImage {
    final local$coverImage = _instance.coverImage;
    return local$coverImage == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$coverImage,
            (e) => call(coverImage: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput<TRes>
  get tracksInfo {
    final local$tracksInfo = _instance.tracksInfo;
    return local$tracksInfo == null
        ? CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput(
            local$tracksInfo,
            (e) => call(tracksInfo: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isPublic {
    final local$isPublic = _instance.isPublic;
    return local$isPublic == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isPublic,
            (e) => call(isPublic: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible {
    final local$isVisible = _instance.isVisible;
    return local$isVisible == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isVisible,
            (e) => call(isVisible: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$PlaylistFilterInput<TRes>
    implements CopyWith$Input$PlaylistFilterInput<TRes> {
  _CopyWithStubImpl$Input$PlaylistFilterInput(this._res);

  TRes _res;

  call({
    List<Input$PlaylistFilterInput>? and,
    List<Input$PlaylistFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? nameUnsigned,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? coverImage,
    Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput? tracksInfo,
    Input$BooleanOperationFilterInput? isPublic,
    Input$BooleanOperationFilterInput? isVisible,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get userId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get nameUnsigned =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get coverImage =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput<TRes>
  get tracksInfo =>
      CopyWith$Input$ListFilterInputTypeOfPlaylistTracksInfoFilterInput.stub(
        _res,
      );

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isPublic =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isVisible =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$PlaylistSortInput {
  factory Input$PlaylistSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? name,
    Enum$SortEnumType? nameUnsigned,
    Enum$SortEnumType? description,
    Enum$SortEnumType? coverImage,
    Enum$SortEnumType? isPublic,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$PlaylistSortInput._({
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (name != null) r'name': name,
    if (nameUnsigned != null) r'nameUnsigned': nameUnsigned,
    if (description != null) r'description': description,
    if (coverImage != null) r'coverImage': coverImage,
    if (isPublic != null) r'isPublic': isPublic,
    if (isVisible != null) r'isVisible': isVisible,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$PlaylistSortInput._(this._$data);

  factory Input$PlaylistSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$SortEnumType((l$userId as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = data['nameUnsigned'];
      result$data['nameUnsigned'] = l$nameUnsigned == null
          ? null
          : fromJson$Enum$SortEnumType((l$nameUnsigned as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = l$coverImage == null
          ? null
          : fromJson$Enum$SortEnumType((l$coverImage as String));
    }
    if (data.containsKey('isPublic')) {
      final l$isPublic = data['isPublic'];
      result$data['isPublic'] = l$isPublic == null
          ? null
          : fromJson$Enum$SortEnumType((l$isPublic as String));
    }
    if (data.containsKey('isVisible')) {
      final l$isVisible = data['isVisible'];
      result$data['isVisible'] = l$isVisible == null
          ? null
          : fromJson$Enum$SortEnumType((l$isVisible as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$PlaylistSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get userId => (_$data['userId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);

  Enum$SortEnumType? get nameUnsigned =>
      (_$data['nameUnsigned'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get coverImage =>
      (_$data['coverImage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isPublic => (_$data['isPublic'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isVisible =>
      (_$data['isVisible'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId == null
          ? null
          : toJson$Enum$SortEnumType(l$userId);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null
          ? null
          : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = nameUnsigned;
      result$data['nameUnsigned'] = l$nameUnsigned == null
          ? null
          : toJson$Enum$SortEnumType(l$nameUnsigned);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage == null
          ? null
          : toJson$Enum$SortEnumType(l$coverImage);
    }
    if (_$data.containsKey('isPublic')) {
      final l$isPublic = isPublic;
      result$data['isPublic'] = l$isPublic == null
          ? null
          : toJson$Enum$SortEnumType(l$isPublic);
    }
    if (_$data.containsKey('isVisible')) {
      final l$isVisible = isVisible;
      result$data['isVisible'] = l$isVisible == null
          ? null
          : toJson$Enum$SortEnumType(l$isVisible);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$PlaylistSortInput<Input$PlaylistSortInput> get copyWith =>
      CopyWith$Input$PlaylistSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PlaylistSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$nameUnsigned = nameUnsigned;
    final lOther$nameUnsigned = other.nameUnsigned;
    if (_$data.containsKey('nameUnsigned') !=
        other._$data.containsKey('nameUnsigned')) {
      return false;
    }
    if (l$nameUnsigned != lOther$nameUnsigned) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$isPublic = isPublic;
    final lOther$isPublic = other.isPublic;
    if (_$data.containsKey('isPublic') !=
        other._$data.containsKey('isPublic')) {
      return false;
    }
    if (l$isPublic != lOther$isPublic) {
      return false;
    }
    final l$isVisible = isVisible;
    final lOther$isVisible = other.isVisible;
    if (_$data.containsKey('isVisible') !=
        other._$data.containsKey('isVisible')) {
      return false;
    }
    if (l$isVisible != lOther$isVisible) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$name = name;
    final l$nameUnsigned = nameUnsigned;
    final l$description = description;
    final l$coverImage = coverImage;
    final l$isPublic = isPublic;
    final l$isVisible = isVisible;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('nameUnsigned') ? l$nameUnsigned : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('isPublic') ? l$isPublic : const {},
      _$data.containsKey('isVisible') ? l$isVisible : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$PlaylistSortInput<TRes> {
  factory CopyWith$Input$PlaylistSortInput(
    Input$PlaylistSortInput instance,
    TRes Function(Input$PlaylistSortInput) then,
  ) = _CopyWithImpl$Input$PlaylistSortInput;

  factory CopyWith$Input$PlaylistSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlaylistSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? name,
    Enum$SortEnumType? nameUnsigned,
    Enum$SortEnumType? description,
    Enum$SortEnumType? coverImage,
    Enum$SortEnumType? isPublic,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$PlaylistSortInput<TRes>
    implements CopyWith$Input$PlaylistSortInput<TRes> {
  _CopyWithImpl$Input$PlaylistSortInput(this._instance, this._then);

  final Input$PlaylistSortInput _instance;

  final TRes Function(Input$PlaylistSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? name = _undefined,
    Object? nameUnsigned = _undefined,
    Object? description = _undefined,
    Object? coverImage = _undefined,
    Object? isPublic = _undefined,
    Object? isVisible = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$PlaylistSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (userId != _undefined) 'userId': (userId as Enum$SortEnumType?),
      if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      if (nameUnsigned != _undefined)
        'nameUnsigned': (nameUnsigned as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (coverImage != _undefined)
        'coverImage': (coverImage as Enum$SortEnumType?),
      if (isPublic != _undefined) 'isPublic': (isPublic as Enum$SortEnumType?),
      if (isVisible != _undefined)
        'isVisible': (isVisible as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$PlaylistSortInput<TRes>
    implements CopyWith$Input$PlaylistSortInput<TRes> {
  _CopyWithStubImpl$Input$PlaylistSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? name,
    Enum$SortEnumType? nameUnsigned,
    Enum$SortEnumType? description,
    Enum$SortEnumType? coverImage,
    Enum$SortEnumType? isPublic,
    Enum$SortEnumType? isVisible,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$PlaylistTracksInfoFilterInput {
  factory Input$PlaylistTracksInfoFilterInput({
    List<Input$PlaylistTracksInfoFilterInput>? and,
    List<Input$PlaylistTracksInfoFilterInput>? or,
    Input$StringOperationFilterInput? trackId,
    Input$DateTimeOperationFilterInput? addedTime,
  }) => Input$PlaylistTracksInfoFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (trackId != null) r'trackId': trackId,
    if (addedTime != null) r'addedTime': addedTime,
  });

  Input$PlaylistTracksInfoFilterInput._(this._$data);

  factory Input$PlaylistTracksInfoFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$PlaylistTracksInfoFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$PlaylistTracksInfoFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('trackId')) {
      final l$trackId = data['trackId'];
      result$data['trackId'] = l$trackId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$trackId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('addedTime')) {
      final l$addedTime = data['addedTime'];
      result$data['addedTime'] = l$addedTime == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$addedTime as Map<String, dynamic>),
            );
    }
    return Input$PlaylistTracksInfoFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PlaylistTracksInfoFilterInput>? get and =>
      (_$data['and'] as List<Input$PlaylistTracksInfoFilterInput>?);

  List<Input$PlaylistTracksInfoFilterInput>? get or =>
      (_$data['or'] as List<Input$PlaylistTracksInfoFilterInput>?);

  Input$StringOperationFilterInput? get trackId =>
      (_$data['trackId'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get addedTime =>
      (_$data['addedTime'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('trackId')) {
      final l$trackId = trackId;
      result$data['trackId'] = l$trackId?.toJson();
    }
    if (_$data.containsKey('addedTime')) {
      final l$addedTime = addedTime;
      result$data['addedTime'] = l$addedTime?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PlaylistTracksInfoFilterInput<
    Input$PlaylistTracksInfoFilterInput
  >
  get copyWith => CopyWith$Input$PlaylistTracksInfoFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PlaylistTracksInfoFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (_$data.containsKey('trackId') != other._$data.containsKey('trackId')) {
      return false;
    }
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$addedTime = addedTime;
    final lOther$addedTime = other.addedTime;
    if (_$data.containsKey('addedTime') !=
        other._$data.containsKey('addedTime')) {
      return false;
    }
    if (l$addedTime != lOther$addedTime) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$trackId = trackId;
    final l$addedTime = addedTime;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('trackId') ? l$trackId : const {},
      _$data.containsKey('addedTime') ? l$addedTime : const {},
    ]);
  }
}

abstract class CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> {
  factory CopyWith$Input$PlaylistTracksInfoFilterInput(
    Input$PlaylistTracksInfoFilterInput instance,
    TRes Function(Input$PlaylistTracksInfoFilterInput) then,
  ) = _CopyWithImpl$Input$PlaylistTracksInfoFilterInput;

  factory CopyWith$Input$PlaylistTracksInfoFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlaylistTracksInfoFilterInput;

  TRes call({
    List<Input$PlaylistTracksInfoFilterInput>? and,
    List<Input$PlaylistTracksInfoFilterInput>? or,
    Input$StringOperationFilterInput? trackId,
    Input$DateTimeOperationFilterInput? addedTime,
  });
  TRes and(
    Iterable<Input$PlaylistTracksInfoFilterInput>? Function(
      Iterable<
        CopyWith$Input$PlaylistTracksInfoFilterInput<
          Input$PlaylistTracksInfoFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$PlaylistTracksInfoFilterInput>? Function(
      Iterable<
        CopyWith$Input$PlaylistTracksInfoFilterInput<
          Input$PlaylistTracksInfoFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get trackId;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get addedTime;
}

class _CopyWithImpl$Input$PlaylistTracksInfoFilterInput<TRes>
    implements CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> {
  _CopyWithImpl$Input$PlaylistTracksInfoFilterInput(this._instance, this._then);

  final Input$PlaylistTracksInfoFilterInput _instance;

  final TRes Function(Input$PlaylistTracksInfoFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? trackId = _undefined,
    Object? addedTime = _undefined,
  }) => _then(
    Input$PlaylistTracksInfoFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$PlaylistTracksInfoFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$PlaylistTracksInfoFilterInput>?),
      if (trackId != _undefined)
        'trackId': (trackId as Input$StringOperationFilterInput?),
      if (addedTime != _undefined)
        'addedTime': (addedTime as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$PlaylistTracksInfoFilterInput>? Function(
      Iterable<
        CopyWith$Input$PlaylistTracksInfoFilterInput<
          Input$PlaylistTracksInfoFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$PlaylistTracksInfoFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$PlaylistTracksInfoFilterInput>? Function(
      Iterable<
        CopyWith$Input$PlaylistTracksInfoFilterInput<
          Input$PlaylistTracksInfoFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$PlaylistTracksInfoFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get trackId {
    final local$trackId = _instance.trackId;
    return local$trackId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$trackId,
            (e) => call(trackId: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get addedTime {
    final local$addedTime = _instance.addedTime;
    return local$addedTime == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$addedTime,
            (e) => call(addedTime: e),
          );
  }
}

class _CopyWithStubImpl$Input$PlaylistTracksInfoFilterInput<TRes>
    implements CopyWith$Input$PlaylistTracksInfoFilterInput<TRes> {
  _CopyWithStubImpl$Input$PlaylistTracksInfoFilterInput(this._res);

  TRes _res;

  call({
    List<Input$PlaylistTracksInfoFilterInput>? and,
    List<Input$PlaylistTracksInfoFilterInput>? or,
    Input$StringOperationFilterInput? trackId,
    Input$DateTimeOperationFilterInput? addedTime,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get trackId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get addedTime =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$PolicyStatusOperationFilterInput {
  factory Input$PolicyStatusOperationFilterInput({
    Enum$PolicyStatus? eq,
    Enum$PolicyStatus? neq,
    List<Enum$PolicyStatus>? $in,
    List<Enum$PolicyStatus>? nin,
  }) => Input$PolicyStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$PolicyStatusOperationFilterInput._(this._$data);

  factory Input$PolicyStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$PolicyStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$PolicyStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PolicyStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$PolicyStatus((e as String)))
          .toList();
    }
    return Input$PolicyStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PolicyStatus? get eq => (_$data['eq'] as Enum$PolicyStatus?);

  Enum$PolicyStatus? get neq => (_$data['neq'] as Enum$PolicyStatus?);

  List<Enum$PolicyStatus>? get $in =>
      (_$data['in'] as List<Enum$PolicyStatus>?);

  List<Enum$PolicyStatus>? get nin =>
      (_$data['nin'] as List<Enum$PolicyStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$PolicyStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$PolicyStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$PolicyStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$PolicyStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$PolicyStatusOperationFilterInput<
    Input$PolicyStatusOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$PolicyStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PolicyStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PolicyStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$PolicyStatusOperationFilterInput(
    Input$PolicyStatusOperationFilterInput instance,
    TRes Function(Input$PolicyStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$PolicyStatusOperationFilterInput;

  factory CopyWith$Input$PolicyStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PolicyStatusOperationFilterInput;

  TRes call({
    Enum$PolicyStatus? eq,
    Enum$PolicyStatus? neq,
    List<Enum$PolicyStatus>? $in,
    List<Enum$PolicyStatus>? nin,
  });
}

class _CopyWithImpl$Input$PolicyStatusOperationFilterInput<TRes>
    implements CopyWith$Input$PolicyStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$PolicyStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$PolicyStatusOperationFilterInput _instance;

  final TRes Function(Input$PolicyStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$PolicyStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$PolicyStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$PolicyStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$PolicyStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$PolicyStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$PolicyStatusOperationFilterInput<TRes>
    implements CopyWith$Input$PolicyStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$PolicyStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$PolicyStatus? eq,
    Enum$PolicyStatus? neq,
    List<Enum$PolicyStatus>? $in,
    List<Enum$PolicyStatus>? nin,
  }) => _res;
}

class Input$ProcessReportRequestInput {
  factory Input$ProcessReportRequestInput({
    required String reportId,
    required Enum$ReportStatus status,
    required Enum$ReportAction actionTaken,
    required List<Input$RestrictionActionDetailInput> restrictionActionDetails,
    int? suspensionDays,
    String? note,
  }) => Input$ProcessReportRequestInput._({
    r'reportId': reportId,
    r'status': status,
    r'actionTaken': actionTaken,
    r'restrictionActionDetails': restrictionActionDetails,
    if (suspensionDays != null) r'suspensionDays': suspensionDays,
    if (note != null) r'note': note,
  });

  Input$ProcessReportRequestInput._(this._$data);

  factory Input$ProcessReportRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$reportId = data['reportId'];
    result$data['reportId'] = (l$reportId as String);
    final l$status = data['status'];
    result$data['status'] = fromJson$Enum$ReportStatus((l$status as String));
    final l$actionTaken = data['actionTaken'];
    result$data['actionTaken'] = fromJson$Enum$ReportAction(
      (l$actionTaken as String),
    );
    final l$restrictionActionDetails = data['restrictionActionDetails'];
    result$data['restrictionActionDetails'] =
        (l$restrictionActionDetails as List<dynamic>)
            .map(
              (e) => Input$RestrictionActionDetailInput.fromJson(
                (e as Map<String, dynamic>),
              ),
            )
            .toList();
    if (data.containsKey('suspensionDays')) {
      final l$suspensionDays = data['suspensionDays'];
      result$data['suspensionDays'] = (l$suspensionDays as int?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    return Input$ProcessReportRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get reportId => (_$data['reportId'] as String);

  Enum$ReportStatus get status => (_$data['status'] as Enum$ReportStatus);

  Enum$ReportAction get actionTaken =>
      (_$data['actionTaken'] as Enum$ReportAction);

  List<Input$RestrictionActionDetailInput> get restrictionActionDetails =>
      (_$data['restrictionActionDetails']
          as List<Input$RestrictionActionDetailInput>);

  int? get suspensionDays => (_$data['suspensionDays'] as int?);

  String? get note => (_$data['note'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$reportId = reportId;
    result$data['reportId'] = l$reportId;
    final l$status = status;
    result$data['status'] = toJson$Enum$ReportStatus(l$status);
    final l$actionTaken = actionTaken;
    result$data['actionTaken'] = toJson$Enum$ReportAction(l$actionTaken);
    final l$restrictionActionDetails = restrictionActionDetails;
    result$data['restrictionActionDetails'] = l$restrictionActionDetails
        .map((e) => e.toJson())
        .toList();
    if (_$data.containsKey('suspensionDays')) {
      final l$suspensionDays = suspensionDays;
      result$data['suspensionDays'] = l$suspensionDays;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    return result$data;
  }

  CopyWith$Input$ProcessReportRequestInput<Input$ProcessReportRequestInput>
  get copyWith => CopyWith$Input$ProcessReportRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProcessReportRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reportId = reportId;
    final lOther$reportId = other.reportId;
    if (l$reportId != lOther$reportId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    final l$actionTaken = actionTaken;
    final lOther$actionTaken = other.actionTaken;
    if (l$actionTaken != lOther$actionTaken) {
      return false;
    }
    final l$restrictionActionDetails = restrictionActionDetails;
    final lOther$restrictionActionDetails = other.restrictionActionDetails;
    if (l$restrictionActionDetails.length !=
        lOther$restrictionActionDetails.length) {
      return false;
    }
    for (int i = 0; i < l$restrictionActionDetails.length; i++) {
      final l$restrictionActionDetails$entry = l$restrictionActionDetails[i];
      final lOther$restrictionActionDetails$entry =
          lOther$restrictionActionDetails[i];
      if (l$restrictionActionDetails$entry !=
          lOther$restrictionActionDetails$entry) {
        return false;
      }
    }
    final l$suspensionDays = suspensionDays;
    final lOther$suspensionDays = other.suspensionDays;
    if (_$data.containsKey('suspensionDays') !=
        other._$data.containsKey('suspensionDays')) {
      return false;
    }
    if (l$suspensionDays != lOther$suspensionDays) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reportId = reportId;
    final l$status = status;
    final l$actionTaken = actionTaken;
    final l$restrictionActionDetails = restrictionActionDetails;
    final l$suspensionDays = suspensionDays;
    final l$note = note;
    return Object.hashAll([
      l$reportId,
      l$status,
      l$actionTaken,
      Object.hashAll(l$restrictionActionDetails.map((v) => v)),
      _$data.containsKey('suspensionDays') ? l$suspensionDays : const {},
      _$data.containsKey('note') ? l$note : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProcessReportRequestInput<TRes> {
  factory CopyWith$Input$ProcessReportRequestInput(
    Input$ProcessReportRequestInput instance,
    TRes Function(Input$ProcessReportRequestInput) then,
  ) = _CopyWithImpl$Input$ProcessReportRequestInput;

  factory CopyWith$Input$ProcessReportRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProcessReportRequestInput;

  TRes call({
    String? reportId,
    Enum$ReportStatus? status,
    Enum$ReportAction? actionTaken,
    List<Input$RestrictionActionDetailInput>? restrictionActionDetails,
    int? suspensionDays,
    String? note,
  });
  TRes restrictionActionDetails(
    Iterable<Input$RestrictionActionDetailInput> Function(
      Iterable<
        CopyWith$Input$RestrictionActionDetailInput<
          Input$RestrictionActionDetailInput
        >
      >,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$ProcessReportRequestInput<TRes>
    implements CopyWith$Input$ProcessReportRequestInput<TRes> {
  _CopyWithImpl$Input$ProcessReportRequestInput(this._instance, this._then);

  final Input$ProcessReportRequestInput _instance;

  final TRes Function(Input$ProcessReportRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reportId = _undefined,
    Object? status = _undefined,
    Object? actionTaken = _undefined,
    Object? restrictionActionDetails = _undefined,
    Object? suspensionDays = _undefined,
    Object? note = _undefined,
  }) => _then(
    Input$ProcessReportRequestInput._({
      ..._instance._$data,
      if (reportId != _undefined && reportId != null)
        'reportId': (reportId as String),
      if (status != _undefined && status != null)
        'status': (status as Enum$ReportStatus),
      if (actionTaken != _undefined && actionTaken != null)
        'actionTaken': (actionTaken as Enum$ReportAction),
      if (restrictionActionDetails != _undefined &&
          restrictionActionDetails != null)
        'restrictionActionDetails':
            (restrictionActionDetails
                as List<Input$RestrictionActionDetailInput>),
      if (suspensionDays != _undefined)
        'suspensionDays': (suspensionDays as int?),
      if (note != _undefined) 'note': (note as String?),
    }),
  );

  TRes restrictionActionDetails(
    Iterable<Input$RestrictionActionDetailInput> Function(
      Iterable<
        CopyWith$Input$RestrictionActionDetailInput<
          Input$RestrictionActionDetailInput
        >
      >,
    )
    _fn,
  ) => call(
    restrictionActionDetails: _fn(
      _instance.restrictionActionDetails.map(
        (e) => CopyWith$Input$RestrictionActionDetailInput(e, (i) => i),
      ),
    ).toList(),
  );
}

class _CopyWithStubImpl$Input$ProcessReportRequestInput<TRes>
    implements CopyWith$Input$ProcessReportRequestInput<TRes> {
  _CopyWithStubImpl$Input$ProcessReportRequestInput(this._res);

  TRes _res;

  call({
    String? reportId,
    Enum$ReportStatus? status,
    Enum$ReportAction? actionTaken,
    List<Input$RestrictionActionDetailInput>? restrictionActionDetails,
    int? suspensionDays,
    String? note,
  }) => _res;

  restrictionActionDetails(_fn) => _res;
}

class Input$RecordingFilterInput {
  factory Input$RecordingFilterInput({
    List<Input$RecordingFilterInput>? and,
    List<Input$RecordingFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$StringOperationFilterInput? description,
    Input$ListFilterInputTypeOfRecordingSplitFilterInput? recordingSplits,
    Input$LongOperationFilterInput? version,
    Input$RecordingStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
  }) => Input$RecordingFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (trackId != null) r'trackId': trackId,
    if (description != null) r'description': description,
    if (recordingSplits != null) r'recordingSplits': recordingSplits,
    if (version != null) r'version': version,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
  });

  Input$RecordingFilterInput._(this._$data);

  factory Input$RecordingFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$RecordingFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$RecordingFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('trackId')) {
      final l$trackId = data['trackId'];
      result$data['trackId'] = l$trackId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$trackId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('recordingSplits')) {
      final l$recordingSplits = data['recordingSplits'];
      result$data['recordingSplits'] = l$recordingSplits == null
          ? null
          : Input$ListFilterInputTypeOfRecordingSplitFilterInput.fromJson(
              (l$recordingSplits as Map<String, dynamic>),
            );
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$version as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$RecordingStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    return Input$RecordingFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$RecordingFilterInput>? get and =>
      (_$data['and'] as List<Input$RecordingFilterInput>?);

  List<Input$RecordingFilterInput>? get or =>
      (_$data['or'] as List<Input$RecordingFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get trackId =>
      (_$data['trackId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$ListFilterInputTypeOfRecordingSplitFilterInput? get recordingSplits =>
      (_$data['recordingSplits']
          as Input$ListFilterInputTypeOfRecordingSplitFilterInput?);

  Input$LongOperationFilterInput? get version =>
      (_$data['version'] as Input$LongOperationFilterInput?);

  Input$RecordingStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$RecordingStatusOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('trackId')) {
      final l$trackId = trackId;
      result$data['trackId'] = l$trackId?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('recordingSplits')) {
      final l$recordingSplits = recordingSplits;
      result$data['recordingSplits'] = l$recordingSplits?.toJson();
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RecordingFilterInput<Input$RecordingFilterInput>
  get copyWith => CopyWith$Input$RecordingFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RecordingFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (_$data.containsKey('trackId') != other._$data.containsKey('trackId')) {
      return false;
    }
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$recordingSplits = recordingSplits;
    final lOther$recordingSplits = other.recordingSplits;
    if (_$data.containsKey('recordingSplits') !=
        other._$data.containsKey('recordingSplits')) {
      return false;
    }
    if (l$recordingSplits != lOther$recordingSplits) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$trackId = trackId;
    final l$description = description;
    final l$recordingSplits = recordingSplits;
    final l$version = version;
    final l$status = status;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('trackId') ? l$trackId : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('recordingSplits') ? l$recordingSplits : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$RecordingFilterInput<TRes> {
  factory CopyWith$Input$RecordingFilterInput(
    Input$RecordingFilterInput instance,
    TRes Function(Input$RecordingFilterInput) then,
  ) = _CopyWithImpl$Input$RecordingFilterInput;

  factory CopyWith$Input$RecordingFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RecordingFilterInput;

  TRes call({
    List<Input$RecordingFilterInput>? and,
    List<Input$RecordingFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$StringOperationFilterInput? description,
    Input$ListFilterInputTypeOfRecordingSplitFilterInput? recordingSplits,
    Input$LongOperationFilterInput? version,
    Input$RecordingStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
  });
  TRes and(
    Iterable<Input$RecordingFilterInput>? Function(
      Iterable<
        CopyWith$Input$RecordingFilterInput<Input$RecordingFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$RecordingFilterInput>? Function(
      Iterable<
        CopyWith$Input$RecordingFilterInput<Input$RecordingFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get trackId;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput<TRes>
  get recordingSplits;
  CopyWith$Input$LongOperationFilterInput<TRes> get version;
  CopyWith$Input$RecordingStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
}

class _CopyWithImpl$Input$RecordingFilterInput<TRes>
    implements CopyWith$Input$RecordingFilterInput<TRes> {
  _CopyWithImpl$Input$RecordingFilterInput(this._instance, this._then);

  final Input$RecordingFilterInput _instance;

  final TRes Function(Input$RecordingFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? trackId = _undefined,
    Object? description = _undefined,
    Object? recordingSplits = _undefined,
    Object? version = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
  }) => _then(
    Input$RecordingFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$RecordingFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$RecordingFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (trackId != _undefined)
        'trackId': (trackId as Input$StringOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (recordingSplits != _undefined)
        'recordingSplits':
            (recordingSplits
                as Input$ListFilterInputTypeOfRecordingSplitFilterInput?),
      if (version != _undefined)
        'version': (version as Input$LongOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$RecordingStatusOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$RecordingFilterInput>? Function(
      Iterable<
        CopyWith$Input$RecordingFilterInput<Input$RecordingFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$RecordingFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$RecordingFilterInput>? Function(
      Iterable<
        CopyWith$Input$RecordingFilterInput<Input$RecordingFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$RecordingFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get trackId {
    final local$trackId = _instance.trackId;
    return local$trackId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$trackId,
            (e) => call(trackId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput<TRes>
  get recordingSplits {
    final local$recordingSplits = _instance.recordingSplits;
    return local$recordingSplits == null
        ? CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput(
            local$recordingSplits,
            (e) => call(recordingSplits: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get version {
    final local$version = _instance.version;
    return local$version == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$version,
            (e) => call(version: e),
          );
  }

  CopyWith$Input$RecordingStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$RecordingStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$RecordingStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$RecordingFilterInput<TRes>
    implements CopyWith$Input$RecordingFilterInput<TRes> {
  _CopyWithStubImpl$Input$RecordingFilterInput(this._res);

  TRes _res;

  call({
    List<Input$RecordingFilterInput>? and,
    List<Input$RecordingFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$StringOperationFilterInput? description,
    Input$ListFilterInputTypeOfRecordingSplitFilterInput? recordingSplits,
    Input$LongOperationFilterInput? version,
    Input$RecordingStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get trackId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput<TRes>
  get recordingSplits =>
      CopyWith$Input$ListFilterInputTypeOfRecordingSplitFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get version =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$RecordingStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$RecordingStatusOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$RecordingSortInput {
  factory Input$RecordingSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? description,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
  }) => Input$RecordingSortInput._({
    if (id != null) r'id': id,
    if (trackId != null) r'trackId': trackId,
    if (description != null) r'description': description,
    if (version != null) r'version': version,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
  });

  Input$RecordingSortInput._(this._$data);

  factory Input$RecordingSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('trackId')) {
      final l$trackId = data['trackId'];
      result$data['trackId'] = l$trackId == null
          ? null
          : fromJson$Enum$SortEnumType((l$trackId as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$SortEnumType((l$version as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    return Input$RecordingSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get trackId => (_$data['trackId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get version => (_$data['version'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('trackId')) {
      final l$trackId = trackId;
      result$data['trackId'] = l$trackId == null
          ? null
          : toJson$Enum$SortEnumType(l$trackId);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version == null
          ? null
          : toJson$Enum$SortEnumType(l$version);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$RecordingSortInput<Input$RecordingSortInput> get copyWith =>
      CopyWith$Input$RecordingSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RecordingSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (_$data.containsKey('trackId') != other._$data.containsKey('trackId')) {
      return false;
    }
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$trackId = trackId;
    final l$description = description;
    final l$version = version;
    final l$status = status;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('trackId') ? l$trackId : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$RecordingSortInput<TRes> {
  factory CopyWith$Input$RecordingSortInput(
    Input$RecordingSortInput instance,
    TRes Function(Input$RecordingSortInput) then,
  ) = _CopyWithImpl$Input$RecordingSortInput;

  factory CopyWith$Input$RecordingSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RecordingSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? description,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
  });
}

class _CopyWithImpl$Input$RecordingSortInput<TRes>
    implements CopyWith$Input$RecordingSortInput<TRes> {
  _CopyWithImpl$Input$RecordingSortInput(this._instance, this._then);

  final Input$RecordingSortInput _instance;

  final TRes Function(Input$RecordingSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? trackId = _undefined,
    Object? description = _undefined,
    Object? version = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
  }) => _then(
    Input$RecordingSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (trackId != _undefined) 'trackId': (trackId as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (version != _undefined) 'version': (version as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$RecordingSortInput<TRes>
    implements CopyWith$Input$RecordingSortInput<TRes> {
  _CopyWithStubImpl$Input$RecordingSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? description,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
  }) => _res;
}

class Input$RecordingSplitFilterInput {
  factory Input$RecordingSplitFilterInput({
    List<Input$RecordingSplitFilterInput>? and,
    List<Input$RecordingSplitFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$ArtistRoleOperationFilterInput? artistRole,
    Input$DecimalOperationFilterInput? percentage,
  }) => Input$RecordingSplitFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (userId != null) r'userId': userId,
    if (artistRole != null) r'artistRole': artistRole,
    if (percentage != null) r'percentage': percentage,
  });

  Input$RecordingSplitFilterInput._(this._$data);

  factory Input$RecordingSplitFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$RecordingSplitFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$RecordingSplitFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('artistRole')) {
      final l$artistRole = data['artistRole'];
      result$data['artistRole'] = l$artistRole == null
          ? null
          : Input$ArtistRoleOperationFilterInput.fromJson(
              (l$artistRole as Map<String, dynamic>),
            );
    }
    if (data.containsKey('percentage')) {
      final l$percentage = data['percentage'];
      result$data['percentage'] = l$percentage == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$percentage as Map<String, dynamic>),
            );
    }
    return Input$RecordingSplitFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$RecordingSplitFilterInput>? get and =>
      (_$data['and'] as List<Input$RecordingSplitFilterInput>?);

  List<Input$RecordingSplitFilterInput>? get or =>
      (_$data['or'] as List<Input$RecordingSplitFilterInput>?);

  Input$StringOperationFilterInput? get userId =>
      (_$data['userId'] as Input$StringOperationFilterInput?);

  Input$ArtistRoleOperationFilterInput? get artistRole =>
      (_$data['artistRole'] as Input$ArtistRoleOperationFilterInput?);

  Input$DecimalOperationFilterInput? get percentage =>
      (_$data['percentage'] as Input$DecimalOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('artistRole')) {
      final l$artistRole = artistRole;
      result$data['artistRole'] = l$artistRole?.toJson();
    }
    if (_$data.containsKey('percentage')) {
      final l$percentage = percentage;
      result$data['percentage'] = l$percentage?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RecordingSplitFilterInput<Input$RecordingSplitFilterInput>
  get copyWith => CopyWith$Input$RecordingSplitFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RecordingSplitFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$artistRole = artistRole;
    final lOther$artistRole = other.artistRole;
    if (_$data.containsKey('artistRole') !=
        other._$data.containsKey('artistRole')) {
      return false;
    }
    if (l$artistRole != lOther$artistRole) {
      return false;
    }
    final l$percentage = percentage;
    final lOther$percentage = other.percentage;
    if (_$data.containsKey('percentage') !=
        other._$data.containsKey('percentage')) {
      return false;
    }
    if (l$percentage != lOther$percentage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$userId = userId;
    final l$artistRole = artistRole;
    final l$percentage = percentage;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('artistRole') ? l$artistRole : const {},
      _$data.containsKey('percentage') ? l$percentage : const {},
    ]);
  }
}

abstract class CopyWith$Input$RecordingSplitFilterInput<TRes> {
  factory CopyWith$Input$RecordingSplitFilterInput(
    Input$RecordingSplitFilterInput instance,
    TRes Function(Input$RecordingSplitFilterInput) then,
  ) = _CopyWithImpl$Input$RecordingSplitFilterInput;

  factory CopyWith$Input$RecordingSplitFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RecordingSplitFilterInput;

  TRes call({
    List<Input$RecordingSplitFilterInput>? and,
    List<Input$RecordingSplitFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$ArtistRoleOperationFilterInput? artistRole,
    Input$DecimalOperationFilterInput? percentage,
  });
  TRes and(
    Iterable<Input$RecordingSplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$RecordingSplitFilterInput<
          Input$RecordingSplitFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$RecordingSplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$RecordingSplitFilterInput<
          Input$RecordingSplitFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get userId;
  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get artistRole;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentage;
}

class _CopyWithImpl$Input$RecordingSplitFilterInput<TRes>
    implements CopyWith$Input$RecordingSplitFilterInput<TRes> {
  _CopyWithImpl$Input$RecordingSplitFilterInput(this._instance, this._then);

  final Input$RecordingSplitFilterInput _instance;

  final TRes Function(Input$RecordingSplitFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? userId = _undefined,
    Object? artistRole = _undefined,
    Object? percentage = _undefined,
  }) => _then(
    Input$RecordingSplitFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$RecordingSplitFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$RecordingSplitFilterInput>?),
      if (userId != _undefined)
        'userId': (userId as Input$StringOperationFilterInput?),
      if (artistRole != _undefined)
        'artistRole': (artistRole as Input$ArtistRoleOperationFilterInput?),
      if (percentage != _undefined)
        'percentage': (percentage as Input$DecimalOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$RecordingSplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$RecordingSplitFilterInput<
          Input$RecordingSplitFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$RecordingSplitFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$RecordingSplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$RecordingSplitFilterInput<
          Input$RecordingSplitFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$RecordingSplitFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userId,
            (e) => call(userId: e),
          );
  }

  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get artistRole {
    final local$artistRole = _instance.artistRole;
    return local$artistRole == null
        ? CopyWith$Input$ArtistRoleOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ArtistRoleOperationFilterInput(
            local$artistRole,
            (e) => call(artistRole: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentage {
    final local$percentage = _instance.percentage;
    return local$percentage == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$percentage,
            (e) => call(percentage: e),
          );
  }
}

class _CopyWithStubImpl$Input$RecordingSplitFilterInput<TRes>
    implements CopyWith$Input$RecordingSplitFilterInput<TRes> {
  _CopyWithStubImpl$Input$RecordingSplitFilterInput(this._res);

  TRes _res;

  call({
    List<Input$RecordingSplitFilterInput>? and,
    List<Input$RecordingSplitFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$ArtistRoleOperationFilterInput? artistRole,
    Input$DecimalOperationFilterInput? percentage,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get userId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get artistRole =>
      CopyWith$Input$ArtistRoleOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentage =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);
}

class Input$RecordingStatusOperationFilterInput {
  factory Input$RecordingStatusOperationFilterInput({
    Enum$RecordingStatus? eq,
    Enum$RecordingStatus? neq,
    List<Enum$RecordingStatus>? $in,
    List<Enum$RecordingStatus>? nin,
  }) => Input$RecordingStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$RecordingStatusOperationFilterInput._(this._$data);

  factory Input$RecordingStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$RecordingStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$RecordingStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RecordingStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RecordingStatus((e as String)))
          .toList();
    }
    return Input$RecordingStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RecordingStatus? get eq => (_$data['eq'] as Enum$RecordingStatus?);

  Enum$RecordingStatus? get neq => (_$data['neq'] as Enum$RecordingStatus?);

  List<Enum$RecordingStatus>? get $in =>
      (_$data['in'] as List<Enum$RecordingStatus>?);

  List<Enum$RecordingStatus>? get nin =>
      (_$data['nin'] as List<Enum$RecordingStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$RecordingStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$RecordingStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$RecordingStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$RecordingStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$RecordingStatusOperationFilterInput<
    Input$RecordingStatusOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$RecordingStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RecordingStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RecordingStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$RecordingStatusOperationFilterInput(
    Input$RecordingStatusOperationFilterInput instance,
    TRes Function(Input$RecordingStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$RecordingStatusOperationFilterInput;

  factory CopyWith$Input$RecordingStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RecordingStatusOperationFilterInput;

  TRes call({
    Enum$RecordingStatus? eq,
    Enum$RecordingStatus? neq,
    List<Enum$RecordingStatus>? $in,
    List<Enum$RecordingStatus>? nin,
  });
}

class _CopyWithImpl$Input$RecordingStatusOperationFilterInput<TRes>
    implements CopyWith$Input$RecordingStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$RecordingStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$RecordingStatusOperationFilterInput _instance;

  final TRes Function(Input$RecordingStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$RecordingStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$RecordingStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$RecordingStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$RecordingStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$RecordingStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$RecordingStatusOperationFilterInput<TRes>
    implements CopyWith$Input$RecordingStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$RecordingStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$RecordingStatus? eq,
    Enum$RecordingStatus? neq,
    List<Enum$RecordingStatus>? $in,
    List<Enum$RecordingStatus>? nin,
  }) => _res;
}

class Input$RedoRequestInput {
  factory Input$RedoRequestInput({
    required String packageOrderId,
    required int revisionNumber,
    required String clientFeedback,
  }) => Input$RedoRequestInput._({
    r'packageOrderId': packageOrderId,
    r'revisionNumber': revisionNumber,
    r'clientFeedback': clientFeedback,
  });

  Input$RedoRequestInput._(this._$data);

  factory Input$RedoRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$packageOrderId = data['packageOrderId'];
    result$data['packageOrderId'] = (l$packageOrderId as String);
    final l$revisionNumber = data['revisionNumber'];
    result$data['revisionNumber'] = (l$revisionNumber as int);
    final l$clientFeedback = data['clientFeedback'];
    result$data['clientFeedback'] = (l$clientFeedback as String);
    return Input$RedoRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get packageOrderId => (_$data['packageOrderId'] as String);

  int get revisionNumber => (_$data['revisionNumber'] as int);

  String get clientFeedback => (_$data['clientFeedback'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$packageOrderId = packageOrderId;
    result$data['packageOrderId'] = l$packageOrderId;
    final l$revisionNumber = revisionNumber;
    result$data['revisionNumber'] = l$revisionNumber;
    final l$clientFeedback = clientFeedback;
    result$data['clientFeedback'] = l$clientFeedback;
    return result$data;
  }

  CopyWith$Input$RedoRequestInput<Input$RedoRequestInput> get copyWith =>
      CopyWith$Input$RedoRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RedoRequestInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$packageOrderId = packageOrderId;
    final lOther$packageOrderId = other.packageOrderId;
    if (l$packageOrderId != lOther$packageOrderId) {
      return false;
    }
    final l$revisionNumber = revisionNumber;
    final lOther$revisionNumber = other.revisionNumber;
    if (l$revisionNumber != lOther$revisionNumber) {
      return false;
    }
    final l$clientFeedback = clientFeedback;
    final lOther$clientFeedback = other.clientFeedback;
    if (l$clientFeedback != lOther$clientFeedback) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$packageOrderId = packageOrderId;
    final l$revisionNumber = revisionNumber;
    final l$clientFeedback = clientFeedback;
    return Object.hashAll([
      l$packageOrderId,
      l$revisionNumber,
      l$clientFeedback,
    ]);
  }
}

abstract class CopyWith$Input$RedoRequestInput<TRes> {
  factory CopyWith$Input$RedoRequestInput(
    Input$RedoRequestInput instance,
    TRes Function(Input$RedoRequestInput) then,
  ) = _CopyWithImpl$Input$RedoRequestInput;

  factory CopyWith$Input$RedoRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RedoRequestInput;

  TRes call({
    String? packageOrderId,
    int? revisionNumber,
    String? clientFeedback,
  });
}

class _CopyWithImpl$Input$RedoRequestInput<TRes>
    implements CopyWith$Input$RedoRequestInput<TRes> {
  _CopyWithImpl$Input$RedoRequestInput(this._instance, this._then);

  final Input$RedoRequestInput _instance;

  final TRes Function(Input$RedoRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? packageOrderId = _undefined,
    Object? revisionNumber = _undefined,
    Object? clientFeedback = _undefined,
  }) => _then(
    Input$RedoRequestInput._({
      ..._instance._$data,
      if (packageOrderId != _undefined && packageOrderId != null)
        'packageOrderId': (packageOrderId as String),
      if (revisionNumber != _undefined && revisionNumber != null)
        'revisionNumber': (revisionNumber as int),
      if (clientFeedback != _undefined && clientFeedback != null)
        'clientFeedback': (clientFeedback as String),
    }),
  );
}

class _CopyWithStubImpl$Input$RedoRequestInput<TRes>
    implements CopyWith$Input$RedoRequestInput<TRes> {
  _CopyWithStubImpl$Input$RedoRequestInput(this._res);

  TRes _res;

  call({String? packageOrderId, int? revisionNumber, String? clientFeedback}) =>
      _res;
}

class Input$RefundReasonTypeOperationFilterInput {
  factory Input$RefundReasonTypeOperationFilterInput({
    Enum$RefundReasonType? eq,
    Enum$RefundReasonType? neq,
    List<Enum$RefundReasonType>? $in,
    List<Enum$RefundReasonType>? nin,
  }) => Input$RefundReasonTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$RefundReasonTypeOperationFilterInput._(this._$data);

  factory Input$RefundReasonTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$RefundReasonType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$RefundReasonType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RefundReasonType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RefundReasonType((e as String)))
          .toList();
    }
    return Input$RefundReasonTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RefundReasonType? get eq => (_$data['eq'] as Enum$RefundReasonType?);

  Enum$RefundReasonType? get neq => (_$data['neq'] as Enum$RefundReasonType?);

  List<Enum$RefundReasonType>? get $in =>
      (_$data['in'] as List<Enum$RefundReasonType>?);

  List<Enum$RefundReasonType>? get nin =>
      (_$data['nin'] as List<Enum$RefundReasonType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$RefundReasonType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$RefundReasonType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$RefundReasonType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$RefundReasonType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$RefundReasonTypeOperationFilterInput<
    Input$RefundReasonTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$RefundReasonTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RefundReasonTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RefundReasonTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$RefundReasonTypeOperationFilterInput(
    Input$RefundReasonTypeOperationFilterInput instance,
    TRes Function(Input$RefundReasonTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$RefundReasonTypeOperationFilterInput;

  factory CopyWith$Input$RefundReasonTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RefundReasonTypeOperationFilterInput;

  TRes call({
    Enum$RefundReasonType? eq,
    Enum$RefundReasonType? neq,
    List<Enum$RefundReasonType>? $in,
    List<Enum$RefundReasonType>? nin,
  });
}

class _CopyWithImpl$Input$RefundReasonTypeOperationFilterInput<TRes>
    implements CopyWith$Input$RefundReasonTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$RefundReasonTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$RefundReasonTypeOperationFilterInput _instance;

  final TRes Function(Input$RefundReasonTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$RefundReasonTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$RefundReasonType?),
      if (neq != _undefined) 'neq': (neq as Enum$RefundReasonType?),
      if ($in != _undefined) 'in': ($in as List<Enum$RefundReasonType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$RefundReasonType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$RefundReasonTypeOperationFilterInput<TRes>
    implements CopyWith$Input$RefundReasonTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$RefundReasonTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$RefundReasonType? eq,
    Enum$RefundReasonType? neq,
    List<Enum$RefundReasonType>? $in,
    List<Enum$RefundReasonType>? nin,
  }) => _res;
}

class Input$RefundTransactionFilterInput {
  factory Input$RefundTransactionFilterInput({
    List<Input$RefundTransactionFilterInput>? and,
    List<Input$RefundTransactionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? stripePaymentId,
    Input$DecimalOperationFilterInput? amount,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$RefundReasonTypeOperationFilterInput? reason,
    Input$RefundTransactionStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$RefundTransactionFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (stripePaymentId != null) r'stripePaymentId': stripePaymentId,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (reason != null) r'reason': reason,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$RefundTransactionFilterInput._(this._$data);

  factory Input$RefundTransactionFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$RefundTransactionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$RefundTransactionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripePaymentId')) {
      final l$stripePaymentId = data['stripePaymentId'];
      result$data['stripePaymentId'] = l$stripePaymentId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripePaymentId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$amount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : Input$CurrencyTypeOperationFilterInput.fromJson(
              (l$currency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = l$reason == null
          ? null
          : Input$RefundReasonTypeOperationFilterInput.fromJson(
              (l$reason as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$RefundTransactionStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$RefundTransactionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$RefundTransactionFilterInput>? get and =>
      (_$data['and'] as List<Input$RefundTransactionFilterInput>?);

  List<Input$RefundTransactionFilterInput>? get or =>
      (_$data['or'] as List<Input$RefundTransactionFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripePaymentId =>
      (_$data['stripePaymentId'] as Input$StringOperationFilterInput?);

  Input$DecimalOperationFilterInput? get amount =>
      (_$data['amount'] as Input$DecimalOperationFilterInput?);

  Input$CurrencyTypeOperationFilterInput? get currency =>
      (_$data['currency'] as Input$CurrencyTypeOperationFilterInput?);

  Input$RefundReasonTypeOperationFilterInput? get reason =>
      (_$data['reason'] as Input$RefundReasonTypeOperationFilterInput?);

  Input$RefundTransactionStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$RefundTransactionStatusOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('stripePaymentId')) {
      final l$stripePaymentId = stripePaymentId;
      result$data['stripePaymentId'] = l$stripePaymentId?.toJson();
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount?.toJson();
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency?.toJson();
    }
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RefundTransactionFilterInput<
    Input$RefundTransactionFilterInput
  >
  get copyWith => CopyWith$Input$RefundTransactionFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RefundTransactionFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$stripePaymentId = stripePaymentId;
    final lOther$stripePaymentId = other.stripePaymentId;
    if (_$data.containsKey('stripePaymentId') !=
        other._$data.containsKey('stripePaymentId')) {
      return false;
    }
    if (l$stripePaymentId != lOther$stripePaymentId) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$stripePaymentId = stripePaymentId;
    final l$amount = amount;
    final l$currency = currency;
    final l$reason = reason;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('stripePaymentId') ? l$stripePaymentId : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('reason') ? l$reason : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$RefundTransactionFilterInput<TRes> {
  factory CopyWith$Input$RefundTransactionFilterInput(
    Input$RefundTransactionFilterInput instance,
    TRes Function(Input$RefundTransactionFilterInput) then,
  ) = _CopyWithImpl$Input$RefundTransactionFilterInput;

  factory CopyWith$Input$RefundTransactionFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RefundTransactionFilterInput;

  TRes call({
    List<Input$RefundTransactionFilterInput>? and,
    List<Input$RefundTransactionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? stripePaymentId,
    Input$DecimalOperationFilterInput? amount,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$RefundReasonTypeOperationFilterInput? reason,
    Input$RefundTransactionStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$RefundTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$RefundTransactionFilterInput<
          Input$RefundTransactionFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$RefundTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$RefundTransactionFilterInput<
          Input$RefundTransactionFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripePaymentId;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount;
  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency;
  CopyWith$Input$RefundReasonTypeOperationFilterInput<TRes> get reason;
  CopyWith$Input$RefundTransactionStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$RefundTransactionFilterInput<TRes>
    implements CopyWith$Input$RefundTransactionFilterInput<TRes> {
  _CopyWithImpl$Input$RefundTransactionFilterInput(this._instance, this._then);

  final Input$RefundTransactionFilterInput _instance;

  final TRes Function(Input$RefundTransactionFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? stripePaymentId = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? reason = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$RefundTransactionFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$RefundTransactionFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$RefundTransactionFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (stripePaymentId != _undefined)
        'stripePaymentId':
            (stripePaymentId as Input$StringOperationFilterInput?),
      if (amount != _undefined)
        'amount': (amount as Input$DecimalOperationFilterInput?),
      if (currency != _undefined)
        'currency': (currency as Input$CurrencyTypeOperationFilterInput?),
      if (reason != _undefined)
        'reason': (reason as Input$RefundReasonTypeOperationFilterInput?),
      if (status != _undefined)
        'status':
            (status as Input$RefundTransactionStatusOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$RefundTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$RefundTransactionFilterInput<
          Input$RefundTransactionFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$RefundTransactionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$RefundTransactionFilterInput>? Function(
      Iterable<
        CopyWith$Input$RefundTransactionFilterInput<
          Input$RefundTransactionFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$RefundTransactionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePaymentId {
    final local$stripePaymentId = _instance.stripePaymentId;
    return local$stripePaymentId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripePaymentId,
            (e) => call(stripePaymentId: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount {
    final local$amount = _instance.amount;
    return local$amount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$amount,
            (e) => call(amount: e),
          );
  }

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency {
    final local$currency = _instance.currency;
    return local$currency == null
        ? CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CurrencyTypeOperationFilterInput(
            local$currency,
            (e) => call(currency: e),
          );
  }

  CopyWith$Input$RefundReasonTypeOperationFilterInput<TRes> get reason {
    final local$reason = _instance.reason;
    return local$reason == null
        ? CopyWith$Input$RefundReasonTypeOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$RefundReasonTypeOperationFilterInput(
            local$reason,
            (e) => call(reason: e),
          );
  }

  CopyWith$Input$RefundTransactionStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$RefundTransactionStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$RefundTransactionStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$RefundTransactionFilterInput<TRes>
    implements CopyWith$Input$RefundTransactionFilterInput<TRes> {
  _CopyWithStubImpl$Input$RefundTransactionFilterInput(this._res);

  TRes _res;

  call({
    List<Input$RefundTransactionFilterInput>? and,
    List<Input$RefundTransactionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? stripePaymentId,
    Input$DecimalOperationFilterInput? amount,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$RefundReasonTypeOperationFilterInput? reason,
    Input$RefundTransactionStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePaymentId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency =>
      CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_res);

  CopyWith$Input$RefundReasonTypeOperationFilterInput<TRes> get reason =>
      CopyWith$Input$RefundReasonTypeOperationFilterInput.stub(_res);

  CopyWith$Input$RefundTransactionStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$RefundTransactionStatusOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$RefundTransactionSortInput {
  factory Input$RefundTransactionSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? stripePaymentId,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? reason,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$RefundTransactionSortInput._({
    if (id != null) r'id': id,
    if (stripePaymentId != null) r'stripePaymentId': stripePaymentId,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (reason != null) r'reason': reason,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$RefundTransactionSortInput._(this._$data);

  factory Input$RefundTransactionSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('stripePaymentId')) {
      final l$stripePaymentId = data['stripePaymentId'];
      result$data['stripePaymentId'] = l$stripePaymentId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripePaymentId as String));
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : fromJson$Enum$SortEnumType((l$amount as String));
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$SortEnumType((l$currency as String));
    }
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = l$reason == null
          ? null
          : fromJson$Enum$SortEnumType((l$reason as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$RefundTransactionSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripePaymentId =>
      (_$data['stripePaymentId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get amount => (_$data['amount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get currency => (_$data['currency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get reason => (_$data['reason'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('stripePaymentId')) {
      final l$stripePaymentId = stripePaymentId;
      result$data['stripePaymentId'] = l$stripePaymentId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripePaymentId);
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount == null
          ? null
          : toJson$Enum$SortEnumType(l$amount);
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$SortEnumType(l$currency);
    }
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason == null
          ? null
          : toJson$Enum$SortEnumType(l$reason);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$RefundTransactionSortInput<Input$RefundTransactionSortInput>
  get copyWith => CopyWith$Input$RefundTransactionSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RefundTransactionSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$stripePaymentId = stripePaymentId;
    final lOther$stripePaymentId = other.stripePaymentId;
    if (_$data.containsKey('stripePaymentId') !=
        other._$data.containsKey('stripePaymentId')) {
      return false;
    }
    if (l$stripePaymentId != lOther$stripePaymentId) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$stripePaymentId = stripePaymentId;
    final l$amount = amount;
    final l$currency = currency;
    final l$reason = reason;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('stripePaymentId') ? l$stripePaymentId : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('reason') ? l$reason : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$RefundTransactionSortInput<TRes> {
  factory CopyWith$Input$RefundTransactionSortInput(
    Input$RefundTransactionSortInput instance,
    TRes Function(Input$RefundTransactionSortInput) then,
  ) = _CopyWithImpl$Input$RefundTransactionSortInput;

  factory CopyWith$Input$RefundTransactionSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RefundTransactionSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? stripePaymentId,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? reason,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$RefundTransactionSortInput<TRes>
    implements CopyWith$Input$RefundTransactionSortInput<TRes> {
  _CopyWithImpl$Input$RefundTransactionSortInput(this._instance, this._then);

  final Input$RefundTransactionSortInput _instance;

  final TRes Function(Input$RefundTransactionSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? stripePaymentId = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? reason = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$RefundTransactionSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (stripePaymentId != _undefined)
        'stripePaymentId': (stripePaymentId as Enum$SortEnumType?),
      if (amount != _undefined) 'amount': (amount as Enum$SortEnumType?),
      if (currency != _undefined) 'currency': (currency as Enum$SortEnumType?),
      if (reason != _undefined) 'reason': (reason as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$RefundTransactionSortInput<TRes>
    implements CopyWith$Input$RefundTransactionSortInput<TRes> {
  _CopyWithStubImpl$Input$RefundTransactionSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? stripePaymentId,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? reason,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$RefundTransactionStatusOperationFilterInput {
  factory Input$RefundTransactionStatusOperationFilterInput({
    Enum$RefundTransactionStatus? eq,
    Enum$RefundTransactionStatus? neq,
    List<Enum$RefundTransactionStatus>? $in,
    List<Enum$RefundTransactionStatus>? nin,
  }) => Input$RefundTransactionStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$RefundTransactionStatusOperationFilterInput._(this._$data);

  factory Input$RefundTransactionStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$RefundTransactionStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$RefundTransactionStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RefundTransactionStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RefundTransactionStatus((e as String)))
          .toList();
    }
    return Input$RefundTransactionStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RefundTransactionStatus? get eq =>
      (_$data['eq'] as Enum$RefundTransactionStatus?);

  Enum$RefundTransactionStatus? get neq =>
      (_$data['neq'] as Enum$RefundTransactionStatus?);

  List<Enum$RefundTransactionStatus>? get $in =>
      (_$data['in'] as List<Enum$RefundTransactionStatus>?);

  List<Enum$RefundTransactionStatus>? get nin =>
      (_$data['nin'] as List<Enum$RefundTransactionStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$RefundTransactionStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$RefundTransactionStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$RefundTransactionStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$RefundTransactionStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$RefundTransactionStatusOperationFilterInput<
    Input$RefundTransactionStatusOperationFilterInput
  >
  get copyWith => CopyWith$Input$RefundTransactionStatusOperationFilterInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RefundTransactionStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RefundTransactionStatusOperationFilterInput<
  TRes
> {
  factory CopyWith$Input$RefundTransactionStatusOperationFilterInput(
    Input$RefundTransactionStatusOperationFilterInput instance,
    TRes Function(Input$RefundTransactionStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$RefundTransactionStatusOperationFilterInput;

  factory CopyWith$Input$RefundTransactionStatusOperationFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$RefundTransactionStatusOperationFilterInput;

  TRes call({
    Enum$RefundTransactionStatus? eq,
    Enum$RefundTransactionStatus? neq,
    List<Enum$RefundTransactionStatus>? $in,
    List<Enum$RefundTransactionStatus>? nin,
  });
}

class _CopyWithImpl$Input$RefundTransactionStatusOperationFilterInput<TRes>
    implements
        CopyWith$Input$RefundTransactionStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$RefundTransactionStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$RefundTransactionStatusOperationFilterInput _instance;

  final TRes Function(Input$RefundTransactionStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$RefundTransactionStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$RefundTransactionStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$RefundTransactionStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$RefundTransactionStatus>?),
      if (nin != _undefined)
        'nin': (nin as List<Enum$RefundTransactionStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$RefundTransactionStatusOperationFilterInput<TRes>
    implements
        CopyWith$Input$RefundTransactionStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$RefundTransactionStatusOperationFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Enum$RefundTransactionStatus? eq,
    Enum$RefundTransactionStatus? neq,
    List<Enum$RefundTransactionStatus>? $in,
    List<Enum$RefundTransactionStatus>? nin,
  }) => _res;
}

class Input$ReleaseInfoFilterInput {
  factory Input$ReleaseInfoFilterInput({
    List<Input$ReleaseInfoFilterInput>? and,
    List<Input$ReleaseInfoFilterInput>? or,
    Input$BooleanOperationFilterInput? isRelease,
    Input$DateTimeOperationFilterInput? releaseDate,
    Input$DateTimeOperationFilterInput? releasedAt,
    Input$ReleaseStatusOperationFilterInput? releaseStatus,
  }) => Input$ReleaseInfoFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (isRelease != null) r'isRelease': isRelease,
    if (releaseDate != null) r'releaseDate': releaseDate,
    if (releasedAt != null) r'releasedAt': releasedAt,
    if (releaseStatus != null) r'releaseStatus': releaseStatus,
  });

  Input$ReleaseInfoFilterInput._(this._$data);

  factory Input$ReleaseInfoFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$ReleaseInfoFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$ReleaseInfoFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('isRelease')) {
      final l$isRelease = data['isRelease'];
      result$data['isRelease'] = l$isRelease == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isRelease as Map<String, dynamic>),
            );
    }
    if (data.containsKey('releaseDate')) {
      final l$releaseDate = data['releaseDate'];
      result$data['releaseDate'] = l$releaseDate == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$releaseDate as Map<String, dynamic>),
            );
    }
    if (data.containsKey('releasedAt')) {
      final l$releasedAt = data['releasedAt'];
      result$data['releasedAt'] = l$releasedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$releasedAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('releaseStatus')) {
      final l$releaseStatus = data['releaseStatus'];
      result$data['releaseStatus'] = l$releaseStatus == null
          ? null
          : Input$ReleaseStatusOperationFilterInput.fromJson(
              (l$releaseStatus as Map<String, dynamic>),
            );
    }
    return Input$ReleaseInfoFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ReleaseInfoFilterInput>? get and =>
      (_$data['and'] as List<Input$ReleaseInfoFilterInput>?);

  List<Input$ReleaseInfoFilterInput>? get or =>
      (_$data['or'] as List<Input$ReleaseInfoFilterInput>?);

  Input$BooleanOperationFilterInput? get isRelease =>
      (_$data['isRelease'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get releaseDate =>
      (_$data['releaseDate'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get releasedAt =>
      (_$data['releasedAt'] as Input$DateTimeOperationFilterInput?);

  Input$ReleaseStatusOperationFilterInput? get releaseStatus =>
      (_$data['releaseStatus'] as Input$ReleaseStatusOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('isRelease')) {
      final l$isRelease = isRelease;
      result$data['isRelease'] = l$isRelease?.toJson();
    }
    if (_$data.containsKey('releaseDate')) {
      final l$releaseDate = releaseDate;
      result$data['releaseDate'] = l$releaseDate?.toJson();
    }
    if (_$data.containsKey('releasedAt')) {
      final l$releasedAt = releasedAt;
      result$data['releasedAt'] = l$releasedAt?.toJson();
    }
    if (_$data.containsKey('releaseStatus')) {
      final l$releaseStatus = releaseStatus;
      result$data['releaseStatus'] = l$releaseStatus?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ReleaseInfoFilterInput<Input$ReleaseInfoFilterInput>
  get copyWith => CopyWith$Input$ReleaseInfoFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReleaseInfoFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$isRelease = isRelease;
    final lOther$isRelease = other.isRelease;
    if (_$data.containsKey('isRelease') !=
        other._$data.containsKey('isRelease')) {
      return false;
    }
    if (l$isRelease != lOther$isRelease) {
      return false;
    }
    final l$releaseDate = releaseDate;
    final lOther$releaseDate = other.releaseDate;
    if (_$data.containsKey('releaseDate') !=
        other._$data.containsKey('releaseDate')) {
      return false;
    }
    if (l$releaseDate != lOther$releaseDate) {
      return false;
    }
    final l$releasedAt = releasedAt;
    final lOther$releasedAt = other.releasedAt;
    if (_$data.containsKey('releasedAt') !=
        other._$data.containsKey('releasedAt')) {
      return false;
    }
    if (l$releasedAt != lOther$releasedAt) {
      return false;
    }
    final l$releaseStatus = releaseStatus;
    final lOther$releaseStatus = other.releaseStatus;
    if (_$data.containsKey('releaseStatus') !=
        other._$data.containsKey('releaseStatus')) {
      return false;
    }
    if (l$releaseStatus != lOther$releaseStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$isRelease = isRelease;
    final l$releaseDate = releaseDate;
    final l$releasedAt = releasedAt;
    final l$releaseStatus = releaseStatus;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('isRelease') ? l$isRelease : const {},
      _$data.containsKey('releaseDate') ? l$releaseDate : const {},
      _$data.containsKey('releasedAt') ? l$releasedAt : const {},
      _$data.containsKey('releaseStatus') ? l$releaseStatus : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReleaseInfoFilterInput<TRes> {
  factory CopyWith$Input$ReleaseInfoFilterInput(
    Input$ReleaseInfoFilterInput instance,
    TRes Function(Input$ReleaseInfoFilterInput) then,
  ) = _CopyWithImpl$Input$ReleaseInfoFilterInput;

  factory CopyWith$Input$ReleaseInfoFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseInfoFilterInput;

  TRes call({
    List<Input$ReleaseInfoFilterInput>? and,
    List<Input$ReleaseInfoFilterInput>? or,
    Input$BooleanOperationFilterInput? isRelease,
    Input$DateTimeOperationFilterInput? releaseDate,
    Input$DateTimeOperationFilterInput? releasedAt,
    Input$ReleaseStatusOperationFilterInput? releaseStatus,
  });
  TRes and(
    Iterable<Input$ReleaseInfoFilterInput>? Function(
      Iterable<
        CopyWith$Input$ReleaseInfoFilterInput<Input$ReleaseInfoFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$ReleaseInfoFilterInput>? Function(
      Iterable<
        CopyWith$Input$ReleaseInfoFilterInput<Input$ReleaseInfoFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isRelease;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get releaseDate;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get releasedAt;
  CopyWith$Input$ReleaseStatusOperationFilterInput<TRes> get releaseStatus;
}

class _CopyWithImpl$Input$ReleaseInfoFilterInput<TRes>
    implements CopyWith$Input$ReleaseInfoFilterInput<TRes> {
  _CopyWithImpl$Input$ReleaseInfoFilterInput(this._instance, this._then);

  final Input$ReleaseInfoFilterInput _instance;

  final TRes Function(Input$ReleaseInfoFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? isRelease = _undefined,
    Object? releaseDate = _undefined,
    Object? releasedAt = _undefined,
    Object? releaseStatus = _undefined,
  }) => _then(
    Input$ReleaseInfoFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$ReleaseInfoFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$ReleaseInfoFilterInput>?),
      if (isRelease != _undefined)
        'isRelease': (isRelease as Input$BooleanOperationFilterInput?),
      if (releaseDate != _undefined)
        'releaseDate': (releaseDate as Input$DateTimeOperationFilterInput?),
      if (releasedAt != _undefined)
        'releasedAt': (releasedAt as Input$DateTimeOperationFilterInput?),
      if (releaseStatus != _undefined)
        'releaseStatus':
            (releaseStatus as Input$ReleaseStatusOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$ReleaseInfoFilterInput>? Function(
      Iterable<
        CopyWith$Input$ReleaseInfoFilterInput<Input$ReleaseInfoFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$ReleaseInfoFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$ReleaseInfoFilterInput>? Function(
      Iterable<
        CopyWith$Input$ReleaseInfoFilterInput<Input$ReleaseInfoFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$ReleaseInfoFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isRelease {
    final local$isRelease = _instance.isRelease;
    return local$isRelease == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isRelease,
            (e) => call(isRelease: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get releaseDate {
    final local$releaseDate = _instance.releaseDate;
    return local$releaseDate == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$releaseDate,
            (e) => call(releaseDate: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get releasedAt {
    final local$releasedAt = _instance.releasedAt;
    return local$releasedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$releasedAt,
            (e) => call(releasedAt: e),
          );
  }

  CopyWith$Input$ReleaseStatusOperationFilterInput<TRes> get releaseStatus {
    final local$releaseStatus = _instance.releaseStatus;
    return local$releaseStatus == null
        ? CopyWith$Input$ReleaseStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ReleaseStatusOperationFilterInput(
            local$releaseStatus,
            (e) => call(releaseStatus: e),
          );
  }
}

class _CopyWithStubImpl$Input$ReleaseInfoFilterInput<TRes>
    implements CopyWith$Input$ReleaseInfoFilterInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseInfoFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ReleaseInfoFilterInput>? and,
    List<Input$ReleaseInfoFilterInput>? or,
    Input$BooleanOperationFilterInput? isRelease,
    Input$DateTimeOperationFilterInput? releaseDate,
    Input$DateTimeOperationFilterInput? releasedAt,
    Input$ReleaseStatusOperationFilterInput? releaseStatus,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isRelease =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get releaseDate =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get releasedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$ReleaseStatusOperationFilterInput<TRes> get releaseStatus =>
      CopyWith$Input$ReleaseStatusOperationFilterInput.stub(_res);
}

class Input$ReleaseInfoInput {
  factory Input$ReleaseInfoInput({
    required bool isRelease,
    DateTime? releaseDate,
    DateTime? releasedAt,
    required Enum$ReleaseStatus releaseStatus,
  }) => Input$ReleaseInfoInput._({
    r'isRelease': isRelease,
    if (releaseDate != null) r'releaseDate': releaseDate,
    if (releasedAt != null) r'releasedAt': releasedAt,
    r'releaseStatus': releaseStatus,
  });

  Input$ReleaseInfoInput._(this._$data);

  factory Input$ReleaseInfoInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$isRelease = data['isRelease'];
    result$data['isRelease'] = (l$isRelease as bool);
    if (data.containsKey('releaseDate')) {
      final l$releaseDate = data['releaseDate'];
      result$data['releaseDate'] = l$releaseDate == null
          ? null
          : DateTime.parse((l$releaseDate as String));
    }
    if (data.containsKey('releasedAt')) {
      final l$releasedAt = data['releasedAt'];
      result$data['releasedAt'] = l$releasedAt == null
          ? null
          : DateTime.parse((l$releasedAt as String));
    }
    final l$releaseStatus = data['releaseStatus'];
    result$data['releaseStatus'] = fromJson$Enum$ReleaseStatus(
      (l$releaseStatus as String),
    );
    return Input$ReleaseInfoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool get isRelease => (_$data['isRelease'] as bool);

  DateTime? get releaseDate => (_$data['releaseDate'] as DateTime?);

  DateTime? get releasedAt => (_$data['releasedAt'] as DateTime?);

  Enum$ReleaseStatus get releaseStatus =>
      (_$data['releaseStatus'] as Enum$ReleaseStatus);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$isRelease = isRelease;
    result$data['isRelease'] = l$isRelease;
    if (_$data.containsKey('releaseDate')) {
      final l$releaseDate = releaseDate;
      result$data['releaseDate'] = l$releaseDate?.toIso8601String();
    }
    if (_$data.containsKey('releasedAt')) {
      final l$releasedAt = releasedAt;
      result$data['releasedAt'] = l$releasedAt?.toIso8601String();
    }
    final l$releaseStatus = releaseStatus;
    result$data['releaseStatus'] = toJson$Enum$ReleaseStatus(l$releaseStatus);
    return result$data;
  }

  CopyWith$Input$ReleaseInfoInput<Input$ReleaseInfoInput> get copyWith =>
      CopyWith$Input$ReleaseInfoInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReleaseInfoInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$isRelease = isRelease;
    final lOther$isRelease = other.isRelease;
    if (l$isRelease != lOther$isRelease) {
      return false;
    }
    final l$releaseDate = releaseDate;
    final lOther$releaseDate = other.releaseDate;
    if (_$data.containsKey('releaseDate') !=
        other._$data.containsKey('releaseDate')) {
      return false;
    }
    if (l$releaseDate != lOther$releaseDate) {
      return false;
    }
    final l$releasedAt = releasedAt;
    final lOther$releasedAt = other.releasedAt;
    if (_$data.containsKey('releasedAt') !=
        other._$data.containsKey('releasedAt')) {
      return false;
    }
    if (l$releasedAt != lOther$releasedAt) {
      return false;
    }
    final l$releaseStatus = releaseStatus;
    final lOther$releaseStatus = other.releaseStatus;
    if (l$releaseStatus != lOther$releaseStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$isRelease = isRelease;
    final l$releaseDate = releaseDate;
    final l$releasedAt = releasedAt;
    final l$releaseStatus = releaseStatus;
    return Object.hashAll([
      l$isRelease,
      _$data.containsKey('releaseDate') ? l$releaseDate : const {},
      _$data.containsKey('releasedAt') ? l$releasedAt : const {},
      l$releaseStatus,
    ]);
  }
}

abstract class CopyWith$Input$ReleaseInfoInput<TRes> {
  factory CopyWith$Input$ReleaseInfoInput(
    Input$ReleaseInfoInput instance,
    TRes Function(Input$ReleaseInfoInput) then,
  ) = _CopyWithImpl$Input$ReleaseInfoInput;

  factory CopyWith$Input$ReleaseInfoInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseInfoInput;

  TRes call({
    bool? isRelease,
    DateTime? releaseDate,
    DateTime? releasedAt,
    Enum$ReleaseStatus? releaseStatus,
  });
}

class _CopyWithImpl$Input$ReleaseInfoInput<TRes>
    implements CopyWith$Input$ReleaseInfoInput<TRes> {
  _CopyWithImpl$Input$ReleaseInfoInput(this._instance, this._then);

  final Input$ReleaseInfoInput _instance;

  final TRes Function(Input$ReleaseInfoInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? isRelease = _undefined,
    Object? releaseDate = _undefined,
    Object? releasedAt = _undefined,
    Object? releaseStatus = _undefined,
  }) => _then(
    Input$ReleaseInfoInput._({
      ..._instance._$data,
      if (isRelease != _undefined && isRelease != null)
        'isRelease': (isRelease as bool),
      if (releaseDate != _undefined) 'releaseDate': (releaseDate as DateTime?),
      if (releasedAt != _undefined) 'releasedAt': (releasedAt as DateTime?),
      if (releaseStatus != _undefined && releaseStatus != null)
        'releaseStatus': (releaseStatus as Enum$ReleaseStatus),
    }),
  );
}

class _CopyWithStubImpl$Input$ReleaseInfoInput<TRes>
    implements CopyWith$Input$ReleaseInfoInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseInfoInput(this._res);

  TRes _res;

  call({
    bool? isRelease,
    DateTime? releaseDate,
    DateTime? releasedAt,
    Enum$ReleaseStatus? releaseStatus,
  }) => _res;
}

class Input$ReleaseInfoSortInput {
  factory Input$ReleaseInfoSortInput({
    Enum$SortEnumType? isRelease,
    Enum$SortEnumType? releaseDate,
    Enum$SortEnumType? releasedAt,
    Enum$SortEnumType? releaseStatus,
  }) => Input$ReleaseInfoSortInput._({
    if (isRelease != null) r'isRelease': isRelease,
    if (releaseDate != null) r'releaseDate': releaseDate,
    if (releasedAt != null) r'releasedAt': releasedAt,
    if (releaseStatus != null) r'releaseStatus': releaseStatus,
  });

  Input$ReleaseInfoSortInput._(this._$data);

  factory Input$ReleaseInfoSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('isRelease')) {
      final l$isRelease = data['isRelease'];
      result$data['isRelease'] = l$isRelease == null
          ? null
          : fromJson$Enum$SortEnumType((l$isRelease as String));
    }
    if (data.containsKey('releaseDate')) {
      final l$releaseDate = data['releaseDate'];
      result$data['releaseDate'] = l$releaseDate == null
          ? null
          : fromJson$Enum$SortEnumType((l$releaseDate as String));
    }
    if (data.containsKey('releasedAt')) {
      final l$releasedAt = data['releasedAt'];
      result$data['releasedAt'] = l$releasedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$releasedAt as String));
    }
    if (data.containsKey('releaseStatus')) {
      final l$releaseStatus = data['releaseStatus'];
      result$data['releaseStatus'] = l$releaseStatus == null
          ? null
          : fromJson$Enum$SortEnumType((l$releaseStatus as String));
    }
    return Input$ReleaseInfoSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get isRelease =>
      (_$data['isRelease'] as Enum$SortEnumType?);

  Enum$SortEnumType? get releaseDate =>
      (_$data['releaseDate'] as Enum$SortEnumType?);

  Enum$SortEnumType? get releasedAt =>
      (_$data['releasedAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get releaseStatus =>
      (_$data['releaseStatus'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('isRelease')) {
      final l$isRelease = isRelease;
      result$data['isRelease'] = l$isRelease == null
          ? null
          : toJson$Enum$SortEnumType(l$isRelease);
    }
    if (_$data.containsKey('releaseDate')) {
      final l$releaseDate = releaseDate;
      result$data['releaseDate'] = l$releaseDate == null
          ? null
          : toJson$Enum$SortEnumType(l$releaseDate);
    }
    if (_$data.containsKey('releasedAt')) {
      final l$releasedAt = releasedAt;
      result$data['releasedAt'] = l$releasedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$releasedAt);
    }
    if (_$data.containsKey('releaseStatus')) {
      final l$releaseStatus = releaseStatus;
      result$data['releaseStatus'] = l$releaseStatus == null
          ? null
          : toJson$Enum$SortEnumType(l$releaseStatus);
    }
    return result$data;
  }

  CopyWith$Input$ReleaseInfoSortInput<Input$ReleaseInfoSortInput>
  get copyWith => CopyWith$Input$ReleaseInfoSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReleaseInfoSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$isRelease = isRelease;
    final lOther$isRelease = other.isRelease;
    if (_$data.containsKey('isRelease') !=
        other._$data.containsKey('isRelease')) {
      return false;
    }
    if (l$isRelease != lOther$isRelease) {
      return false;
    }
    final l$releaseDate = releaseDate;
    final lOther$releaseDate = other.releaseDate;
    if (_$data.containsKey('releaseDate') !=
        other._$data.containsKey('releaseDate')) {
      return false;
    }
    if (l$releaseDate != lOther$releaseDate) {
      return false;
    }
    final l$releasedAt = releasedAt;
    final lOther$releasedAt = other.releasedAt;
    if (_$data.containsKey('releasedAt') !=
        other._$data.containsKey('releasedAt')) {
      return false;
    }
    if (l$releasedAt != lOther$releasedAt) {
      return false;
    }
    final l$releaseStatus = releaseStatus;
    final lOther$releaseStatus = other.releaseStatus;
    if (_$data.containsKey('releaseStatus') !=
        other._$data.containsKey('releaseStatus')) {
      return false;
    }
    if (l$releaseStatus != lOther$releaseStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$isRelease = isRelease;
    final l$releaseDate = releaseDate;
    final l$releasedAt = releasedAt;
    final l$releaseStatus = releaseStatus;
    return Object.hashAll([
      _$data.containsKey('isRelease') ? l$isRelease : const {},
      _$data.containsKey('releaseDate') ? l$releaseDate : const {},
      _$data.containsKey('releasedAt') ? l$releasedAt : const {},
      _$data.containsKey('releaseStatus') ? l$releaseStatus : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReleaseInfoSortInput<TRes> {
  factory CopyWith$Input$ReleaseInfoSortInput(
    Input$ReleaseInfoSortInput instance,
    TRes Function(Input$ReleaseInfoSortInput) then,
  ) = _CopyWithImpl$Input$ReleaseInfoSortInput;

  factory CopyWith$Input$ReleaseInfoSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseInfoSortInput;

  TRes call({
    Enum$SortEnumType? isRelease,
    Enum$SortEnumType? releaseDate,
    Enum$SortEnumType? releasedAt,
    Enum$SortEnumType? releaseStatus,
  });
}

class _CopyWithImpl$Input$ReleaseInfoSortInput<TRes>
    implements CopyWith$Input$ReleaseInfoSortInput<TRes> {
  _CopyWithImpl$Input$ReleaseInfoSortInput(this._instance, this._then);

  final Input$ReleaseInfoSortInput _instance;

  final TRes Function(Input$ReleaseInfoSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? isRelease = _undefined,
    Object? releaseDate = _undefined,
    Object? releasedAt = _undefined,
    Object? releaseStatus = _undefined,
  }) => _then(
    Input$ReleaseInfoSortInput._({
      ..._instance._$data,
      if (isRelease != _undefined)
        'isRelease': (isRelease as Enum$SortEnumType?),
      if (releaseDate != _undefined)
        'releaseDate': (releaseDate as Enum$SortEnumType?),
      if (releasedAt != _undefined)
        'releasedAt': (releasedAt as Enum$SortEnumType?),
      if (releaseStatus != _undefined)
        'releaseStatus': (releaseStatus as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$ReleaseInfoSortInput<TRes>
    implements CopyWith$Input$ReleaseInfoSortInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseInfoSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? isRelease,
    Enum$SortEnumType? releaseDate,
    Enum$SortEnumType? releasedAt,
    Enum$SortEnumType? releaseStatus,
  }) => _res;
}

class Input$ReleaseStatusOperationFilterInput {
  factory Input$ReleaseStatusOperationFilterInput({
    Enum$ReleaseStatus? eq,
    Enum$ReleaseStatus? neq,
    List<Enum$ReleaseStatus>? $in,
    List<Enum$ReleaseStatus>? nin,
  }) => Input$ReleaseStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$ReleaseStatusOperationFilterInput._(this._$data);

  factory Input$ReleaseStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$ReleaseStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$ReleaseStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ReleaseStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ReleaseStatus((e as String)))
          .toList();
    }
    return Input$ReleaseStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ReleaseStatus? get eq => (_$data['eq'] as Enum$ReleaseStatus?);

  Enum$ReleaseStatus? get neq => (_$data['neq'] as Enum$ReleaseStatus?);

  List<Enum$ReleaseStatus>? get $in =>
      (_$data['in'] as List<Enum$ReleaseStatus>?);

  List<Enum$ReleaseStatus>? get nin =>
      (_$data['nin'] as List<Enum$ReleaseStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$ReleaseStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$ReleaseStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$ReleaseStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$ReleaseStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$ReleaseStatusOperationFilterInput<
    Input$ReleaseStatusOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$ReleaseStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReleaseStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReleaseStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$ReleaseStatusOperationFilterInput(
    Input$ReleaseStatusOperationFilterInput instance,
    TRes Function(Input$ReleaseStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ReleaseStatusOperationFilterInput;

  factory CopyWith$Input$ReleaseStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseStatusOperationFilterInput;

  TRes call({
    Enum$ReleaseStatus? eq,
    Enum$ReleaseStatus? neq,
    List<Enum$ReleaseStatus>? $in,
    List<Enum$ReleaseStatus>? nin,
  });
}

class _CopyWithImpl$Input$ReleaseStatusOperationFilterInput<TRes>
    implements CopyWith$Input$ReleaseStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ReleaseStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ReleaseStatusOperationFilterInput _instance;

  final TRes Function(Input$ReleaseStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$ReleaseStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$ReleaseStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$ReleaseStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$ReleaseStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$ReleaseStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$ReleaseStatusOperationFilterInput<TRes>
    implements CopyWith$Input$ReleaseStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ReleaseStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$ReleaseStatus? eq,
    Enum$ReleaseStatus? neq,
    List<Enum$ReleaseStatus>? $in,
    List<Enum$ReleaseStatus>? nin,
  }) => _res;
}

class Input$RemoveFromPlaylistRequestInput {
  factory Input$RemoveFromPlaylistRequestInput({
    required String trackId,
    String? playlistId,
  }) => Input$RemoveFromPlaylistRequestInput._({
    r'trackId': trackId,
    if (playlistId != null) r'playlistId': playlistId,
  });

  Input$RemoveFromPlaylistRequestInput._(this._$data);

  factory Input$RemoveFromPlaylistRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$trackId = data['trackId'];
    result$data['trackId'] = (l$trackId as String);
    if (data.containsKey('playlistId')) {
      final l$playlistId = data['playlistId'];
      result$data['playlistId'] = (l$playlistId as String?);
    }
    return Input$RemoveFromPlaylistRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get trackId => (_$data['trackId'] as String);

  String? get playlistId => (_$data['playlistId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$trackId = trackId;
    result$data['trackId'] = l$trackId;
    if (_$data.containsKey('playlistId')) {
      final l$playlistId = playlistId;
      result$data['playlistId'] = l$playlistId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveFromPlaylistRequestInput<
    Input$RemoveFromPlaylistRequestInput
  >
  get copyWith => CopyWith$Input$RemoveFromPlaylistRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveFromPlaylistRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$playlistId = playlistId;
    final lOther$playlistId = other.playlistId;
    if (_$data.containsKey('playlistId') !=
        other._$data.containsKey('playlistId')) {
      return false;
    }
    if (l$playlistId != lOther$playlistId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$trackId = trackId;
    final l$playlistId = playlistId;
    return Object.hashAll([
      l$trackId,
      _$data.containsKey('playlistId') ? l$playlistId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveFromPlaylistRequestInput<TRes> {
  factory CopyWith$Input$RemoveFromPlaylistRequestInput(
    Input$RemoveFromPlaylistRequestInput instance,
    TRes Function(Input$RemoveFromPlaylistRequestInput) then,
  ) = _CopyWithImpl$Input$RemoveFromPlaylistRequestInput;

  factory CopyWith$Input$RemoveFromPlaylistRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveFromPlaylistRequestInput;

  TRes call({String? trackId, String? playlistId});
}

class _CopyWithImpl$Input$RemoveFromPlaylistRequestInput<TRes>
    implements CopyWith$Input$RemoveFromPlaylistRequestInput<TRes> {
  _CopyWithImpl$Input$RemoveFromPlaylistRequestInput(
    this._instance,
    this._then,
  );

  final Input$RemoveFromPlaylistRequestInput _instance;

  final TRes Function(Input$RemoveFromPlaylistRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? trackId = _undefined, Object? playlistId = _undefined}) =>
      _then(
        Input$RemoveFromPlaylistRequestInput._({
          ..._instance._$data,
          if (trackId != _undefined && trackId != null)
            'trackId': (trackId as String),
          if (playlistId != _undefined) 'playlistId': (playlistId as String?),
        }),
      );
}

class _CopyWithStubImpl$Input$RemoveFromPlaylistRequestInput<TRes>
    implements CopyWith$Input$RemoveFromPlaylistRequestInput<TRes> {
  _CopyWithStubImpl$Input$RemoveFromPlaylistRequestInput(this._res);

  TRes _res;

  call({String? trackId, String? playlistId}) => _res;
}

class Input$RemoveTrackFromAlbumRequestInput {
  factory Input$RemoveTrackFromAlbumRequestInput({
    required String trackId,
    required String albumId,
  }) => Input$RemoveTrackFromAlbumRequestInput._({
    r'trackId': trackId,
    r'albumId': albumId,
  });

  Input$RemoveTrackFromAlbumRequestInput._(this._$data);

  factory Input$RemoveTrackFromAlbumRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$trackId = data['trackId'];
    result$data['trackId'] = (l$trackId as String);
    final l$albumId = data['albumId'];
    result$data['albumId'] = (l$albumId as String);
    return Input$RemoveTrackFromAlbumRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get trackId => (_$data['trackId'] as String);

  String get albumId => (_$data['albumId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$trackId = trackId;
    result$data['trackId'] = l$trackId;
    final l$albumId = albumId;
    result$data['albumId'] = l$albumId;
    return result$data;
  }

  CopyWith$Input$RemoveTrackFromAlbumRequestInput<
    Input$RemoveTrackFromAlbumRequestInput
  >
  get copyWith =>
      CopyWith$Input$RemoveTrackFromAlbumRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveTrackFromAlbumRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$albumId = albumId;
    final lOther$albumId = other.albumId;
    if (l$albumId != lOther$albumId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$trackId = trackId;
    final l$albumId = albumId;
    return Object.hashAll([l$trackId, l$albumId]);
  }
}

abstract class CopyWith$Input$RemoveTrackFromAlbumRequestInput<TRes> {
  factory CopyWith$Input$RemoveTrackFromAlbumRequestInput(
    Input$RemoveTrackFromAlbumRequestInput instance,
    TRes Function(Input$RemoveTrackFromAlbumRequestInput) then,
  ) = _CopyWithImpl$Input$RemoveTrackFromAlbumRequestInput;

  factory CopyWith$Input$RemoveTrackFromAlbumRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveTrackFromAlbumRequestInput;

  TRes call({String? trackId, String? albumId});
}

class _CopyWithImpl$Input$RemoveTrackFromAlbumRequestInput<TRes>
    implements CopyWith$Input$RemoveTrackFromAlbumRequestInput<TRes> {
  _CopyWithImpl$Input$RemoveTrackFromAlbumRequestInput(
    this._instance,
    this._then,
  );

  final Input$RemoveTrackFromAlbumRequestInput _instance;

  final TRes Function(Input$RemoveTrackFromAlbumRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? trackId = _undefined, Object? albumId = _undefined}) =>
      _then(
        Input$RemoveTrackFromAlbumRequestInput._({
          ..._instance._$data,
          if (trackId != _undefined && trackId != null)
            'trackId': (trackId as String),
          if (albumId != _undefined && albumId != null)
            'albumId': (albumId as String),
        }),
      );
}

class _CopyWithStubImpl$Input$RemoveTrackFromAlbumRequestInput<TRes>
    implements CopyWith$Input$RemoveTrackFromAlbumRequestInput<TRes> {
  _CopyWithStubImpl$Input$RemoveTrackFromAlbumRequestInput(this._res);

  TRes _res;

  call({String? trackId, String? albumId}) => _res;
}

class Input$ReportFilterInput {
  factory Input$ReportFilterInput({
    List<Input$ReportFilterInput>? and,
    List<Input$ReportFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? reportedUserId,
    Input$StringOperationFilterInput? reporterId,
    Input$ReportTypeOperationFilterInput? reportType,
    Input$StringOperationFilterInput? description,
    Input$ReportStatusOperationFilterInput? status,
    Input$ReportPriorityOperationFilterInput? priority,
    Input$StringOperationFilterInput? relatedContentId,
    Input$NullableOfReportRelatedContentTypeOperationFilterInput?
    relatedContentType,
    Input$ListStringOperationFilterInput? evidences,
    Input$StringOperationFilterInput? assignedModeratorId,
    Input$NullableOfReportActionOperationFilterInput? actionTaken,
    Input$StringOperationFilterInput? note,
    Input$DateTimeOperationFilterInput? resolvedAt,
    Input$LongOperationFilterInput? totalReportsCount,
    Input$BooleanOperationFilterInput? isDeleted,
    Input$StringOperationFilterInput? backgroundJobId,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$ReportFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (reportedUserId != null) r'reportedUserId': reportedUserId,
    if (reporterId != null) r'reporterId': reporterId,
    if (reportType != null) r'reportType': reportType,
    if (description != null) r'description': description,
    if (status != null) r'status': status,
    if (priority != null) r'priority': priority,
    if (relatedContentId != null) r'relatedContentId': relatedContentId,
    if (relatedContentType != null) r'relatedContentType': relatedContentType,
    if (evidences != null) r'evidences': evidences,
    if (assignedModeratorId != null)
      r'assignedModeratorId': assignedModeratorId,
    if (actionTaken != null) r'actionTaken': actionTaken,
    if (note != null) r'note': note,
    if (resolvedAt != null) r'resolvedAt': resolvedAt,
    if (totalReportsCount != null) r'totalReportsCount': totalReportsCount,
    if (isDeleted != null) r'isDeleted': isDeleted,
    if (backgroundJobId != null) r'backgroundJobId': backgroundJobId,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ReportFilterInput._(this._$data);

  factory Input$ReportFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$ReportFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$ReportFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('reportedUserId')) {
      final l$reportedUserId = data['reportedUserId'];
      result$data['reportedUserId'] = l$reportedUserId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$reportedUserId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('reporterId')) {
      final l$reporterId = data['reporterId'];
      result$data['reporterId'] = l$reporterId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$reporterId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('reportType')) {
      final l$reportType = data['reportType'];
      result$data['reportType'] = l$reportType == null
          ? null
          : Input$ReportTypeOperationFilterInput.fromJson(
              (l$reportType as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$ReportStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('priority')) {
      final l$priority = data['priority'];
      result$data['priority'] = l$priority == null
          ? null
          : Input$ReportPriorityOperationFilterInput.fromJson(
              (l$priority as Map<String, dynamic>),
            );
    }
    if (data.containsKey('relatedContentId')) {
      final l$relatedContentId = data['relatedContentId'];
      result$data['relatedContentId'] = l$relatedContentId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$relatedContentId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('relatedContentType')) {
      final l$relatedContentType = data['relatedContentType'];
      result$data['relatedContentType'] = l$relatedContentType == null
          ? null
          : Input$NullableOfReportRelatedContentTypeOperationFilterInput.fromJson(
              (l$relatedContentType as Map<String, dynamic>),
            );
    }
    if (data.containsKey('evidences')) {
      final l$evidences = data['evidences'];
      result$data['evidences'] = l$evidences == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$evidences as Map<String, dynamic>),
            );
    }
    if (data.containsKey('assignedModeratorId')) {
      final l$assignedModeratorId = data['assignedModeratorId'];
      result$data['assignedModeratorId'] = l$assignedModeratorId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$assignedModeratorId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('actionTaken')) {
      final l$actionTaken = data['actionTaken'];
      result$data['actionTaken'] = l$actionTaken == null
          ? null
          : Input$NullableOfReportActionOperationFilterInput.fromJson(
              (l$actionTaken as Map<String, dynamic>),
            );
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = l$note == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$note as Map<String, dynamic>),
            );
    }
    if (data.containsKey('resolvedAt')) {
      final l$resolvedAt = data['resolvedAt'];
      result$data['resolvedAt'] = l$resolvedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$resolvedAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('totalReportsCount')) {
      final l$totalReportsCount = data['totalReportsCount'];
      result$data['totalReportsCount'] = l$totalReportsCount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$totalReportsCount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isDeleted')) {
      final l$isDeleted = data['isDeleted'];
      result$data['isDeleted'] = l$isDeleted == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isDeleted as Map<String, dynamic>),
            );
    }
    if (data.containsKey('backgroundJobId')) {
      final l$backgroundJobId = data['backgroundJobId'];
      result$data['backgroundJobId'] = l$backgroundJobId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$backgroundJobId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$ReportFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ReportFilterInput>? get and =>
      (_$data['and'] as List<Input$ReportFilterInput>?);

  List<Input$ReportFilterInput>? get or =>
      (_$data['or'] as List<Input$ReportFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get reportedUserId =>
      (_$data['reportedUserId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get reporterId =>
      (_$data['reporterId'] as Input$StringOperationFilterInput?);

  Input$ReportTypeOperationFilterInput? get reportType =>
      (_$data['reportType'] as Input$ReportTypeOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$ReportStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$ReportStatusOperationFilterInput?);

  Input$ReportPriorityOperationFilterInput? get priority =>
      (_$data['priority'] as Input$ReportPriorityOperationFilterInput?);

  Input$StringOperationFilterInput? get relatedContentId =>
      (_$data['relatedContentId'] as Input$StringOperationFilterInput?);

  Input$NullableOfReportRelatedContentTypeOperationFilterInput?
  get relatedContentType =>
      (_$data['relatedContentType']
          as Input$NullableOfReportRelatedContentTypeOperationFilterInput?);

  Input$ListStringOperationFilterInput? get evidences =>
      (_$data['evidences'] as Input$ListStringOperationFilterInput?);

  Input$StringOperationFilterInput? get assignedModeratorId =>
      (_$data['assignedModeratorId'] as Input$StringOperationFilterInput?);

  Input$NullableOfReportActionOperationFilterInput? get actionTaken =>
      (_$data['actionTaken']
          as Input$NullableOfReportActionOperationFilterInput?);

  Input$StringOperationFilterInput? get note =>
      (_$data['note'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get resolvedAt =>
      (_$data['resolvedAt'] as Input$DateTimeOperationFilterInput?);

  Input$LongOperationFilterInput? get totalReportsCount =>
      (_$data['totalReportsCount'] as Input$LongOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isDeleted =>
      (_$data['isDeleted'] as Input$BooleanOperationFilterInput?);

  Input$StringOperationFilterInput? get backgroundJobId =>
      (_$data['backgroundJobId'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('reportedUserId')) {
      final l$reportedUserId = reportedUserId;
      result$data['reportedUserId'] = l$reportedUserId?.toJson();
    }
    if (_$data.containsKey('reporterId')) {
      final l$reporterId = reporterId;
      result$data['reporterId'] = l$reporterId?.toJson();
    }
    if (_$data.containsKey('reportType')) {
      final l$reportType = reportType;
      result$data['reportType'] = l$reportType?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('priority')) {
      final l$priority = priority;
      result$data['priority'] = l$priority?.toJson();
    }
    if (_$data.containsKey('relatedContentId')) {
      final l$relatedContentId = relatedContentId;
      result$data['relatedContentId'] = l$relatedContentId?.toJson();
    }
    if (_$data.containsKey('relatedContentType')) {
      final l$relatedContentType = relatedContentType;
      result$data['relatedContentType'] = l$relatedContentType?.toJson();
    }
    if (_$data.containsKey('evidences')) {
      final l$evidences = evidences;
      result$data['evidences'] = l$evidences?.toJson();
    }
    if (_$data.containsKey('assignedModeratorId')) {
      final l$assignedModeratorId = assignedModeratorId;
      result$data['assignedModeratorId'] = l$assignedModeratorId?.toJson();
    }
    if (_$data.containsKey('actionTaken')) {
      final l$actionTaken = actionTaken;
      result$data['actionTaken'] = l$actionTaken?.toJson();
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note?.toJson();
    }
    if (_$data.containsKey('resolvedAt')) {
      final l$resolvedAt = resolvedAt;
      result$data['resolvedAt'] = l$resolvedAt?.toJson();
    }
    if (_$data.containsKey('totalReportsCount')) {
      final l$totalReportsCount = totalReportsCount;
      result$data['totalReportsCount'] = l$totalReportsCount?.toJson();
    }
    if (_$data.containsKey('isDeleted')) {
      final l$isDeleted = isDeleted;
      result$data['isDeleted'] = l$isDeleted?.toJson();
    }
    if (_$data.containsKey('backgroundJobId')) {
      final l$backgroundJobId = backgroundJobId;
      result$data['backgroundJobId'] = l$backgroundJobId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ReportFilterInput<Input$ReportFilterInput> get copyWith =>
      CopyWith$Input$ReportFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReportFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$reportedUserId = reportedUserId;
    final lOther$reportedUserId = other.reportedUserId;
    if (_$data.containsKey('reportedUserId') !=
        other._$data.containsKey('reportedUserId')) {
      return false;
    }
    if (l$reportedUserId != lOther$reportedUserId) {
      return false;
    }
    final l$reporterId = reporterId;
    final lOther$reporterId = other.reporterId;
    if (_$data.containsKey('reporterId') !=
        other._$data.containsKey('reporterId')) {
      return false;
    }
    if (l$reporterId != lOther$reporterId) {
      return false;
    }
    final l$reportType = reportType;
    final lOther$reportType = other.reportType;
    if (_$data.containsKey('reportType') !=
        other._$data.containsKey('reportType')) {
      return false;
    }
    if (l$reportType != lOther$reportType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$priority = priority;
    final lOther$priority = other.priority;
    if (_$data.containsKey('priority') !=
        other._$data.containsKey('priority')) {
      return false;
    }
    if (l$priority != lOther$priority) {
      return false;
    }
    final l$relatedContentId = relatedContentId;
    final lOther$relatedContentId = other.relatedContentId;
    if (_$data.containsKey('relatedContentId') !=
        other._$data.containsKey('relatedContentId')) {
      return false;
    }
    if (l$relatedContentId != lOther$relatedContentId) {
      return false;
    }
    final l$relatedContentType = relatedContentType;
    final lOther$relatedContentType = other.relatedContentType;
    if (_$data.containsKey('relatedContentType') !=
        other._$data.containsKey('relatedContentType')) {
      return false;
    }
    if (l$relatedContentType != lOther$relatedContentType) {
      return false;
    }
    final l$evidences = evidences;
    final lOther$evidences = other.evidences;
    if (_$data.containsKey('evidences') !=
        other._$data.containsKey('evidences')) {
      return false;
    }
    if (l$evidences != lOther$evidences) {
      return false;
    }
    final l$assignedModeratorId = assignedModeratorId;
    final lOther$assignedModeratorId = other.assignedModeratorId;
    if (_$data.containsKey('assignedModeratorId') !=
        other._$data.containsKey('assignedModeratorId')) {
      return false;
    }
    if (l$assignedModeratorId != lOther$assignedModeratorId) {
      return false;
    }
    final l$actionTaken = actionTaken;
    final lOther$actionTaken = other.actionTaken;
    if (_$data.containsKey('actionTaken') !=
        other._$data.containsKey('actionTaken')) {
      return false;
    }
    if (l$actionTaken != lOther$actionTaken) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$resolvedAt = resolvedAt;
    final lOther$resolvedAt = other.resolvedAt;
    if (_$data.containsKey('resolvedAt') !=
        other._$data.containsKey('resolvedAt')) {
      return false;
    }
    if (l$resolvedAt != lOther$resolvedAt) {
      return false;
    }
    final l$totalReportsCount = totalReportsCount;
    final lOther$totalReportsCount = other.totalReportsCount;
    if (_$data.containsKey('totalReportsCount') !=
        other._$data.containsKey('totalReportsCount')) {
      return false;
    }
    if (l$totalReportsCount != lOther$totalReportsCount) {
      return false;
    }
    final l$isDeleted = isDeleted;
    final lOther$isDeleted = other.isDeleted;
    if (_$data.containsKey('isDeleted') !=
        other._$data.containsKey('isDeleted')) {
      return false;
    }
    if (l$isDeleted != lOther$isDeleted) {
      return false;
    }
    final l$backgroundJobId = backgroundJobId;
    final lOther$backgroundJobId = other.backgroundJobId;
    if (_$data.containsKey('backgroundJobId') !=
        other._$data.containsKey('backgroundJobId')) {
      return false;
    }
    if (l$backgroundJobId != lOther$backgroundJobId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$reportedUserId = reportedUserId;
    final l$reporterId = reporterId;
    final l$reportType = reportType;
    final l$description = description;
    final l$status = status;
    final l$priority = priority;
    final l$relatedContentId = relatedContentId;
    final l$relatedContentType = relatedContentType;
    final l$evidences = evidences;
    final l$assignedModeratorId = assignedModeratorId;
    final l$actionTaken = actionTaken;
    final l$note = note;
    final l$resolvedAt = resolvedAt;
    final l$totalReportsCount = totalReportsCount;
    final l$isDeleted = isDeleted;
    final l$backgroundJobId = backgroundJobId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('reportedUserId') ? l$reportedUserId : const {},
      _$data.containsKey('reporterId') ? l$reporterId : const {},
      _$data.containsKey('reportType') ? l$reportType : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('priority') ? l$priority : const {},
      _$data.containsKey('relatedContentId') ? l$relatedContentId : const {},
      _$data.containsKey('relatedContentType')
          ? l$relatedContentType
          : const {},
      _$data.containsKey('evidences') ? l$evidences : const {},
      _$data.containsKey('assignedModeratorId')
          ? l$assignedModeratorId
          : const {},
      _$data.containsKey('actionTaken') ? l$actionTaken : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('resolvedAt') ? l$resolvedAt : const {},
      _$data.containsKey('totalReportsCount') ? l$totalReportsCount : const {},
      _$data.containsKey('isDeleted') ? l$isDeleted : const {},
      _$data.containsKey('backgroundJobId') ? l$backgroundJobId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReportFilterInput<TRes> {
  factory CopyWith$Input$ReportFilterInput(
    Input$ReportFilterInput instance,
    TRes Function(Input$ReportFilterInput) then,
  ) = _CopyWithImpl$Input$ReportFilterInput;

  factory CopyWith$Input$ReportFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReportFilterInput;

  TRes call({
    List<Input$ReportFilterInput>? and,
    List<Input$ReportFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? reportedUserId,
    Input$StringOperationFilterInput? reporterId,
    Input$ReportTypeOperationFilterInput? reportType,
    Input$StringOperationFilterInput? description,
    Input$ReportStatusOperationFilterInput? status,
    Input$ReportPriorityOperationFilterInput? priority,
    Input$StringOperationFilterInput? relatedContentId,
    Input$NullableOfReportRelatedContentTypeOperationFilterInput?
    relatedContentType,
    Input$ListStringOperationFilterInput? evidences,
    Input$StringOperationFilterInput? assignedModeratorId,
    Input$NullableOfReportActionOperationFilterInput? actionTaken,
    Input$StringOperationFilterInput? note,
    Input$DateTimeOperationFilterInput? resolvedAt,
    Input$LongOperationFilterInput? totalReportsCount,
    Input$BooleanOperationFilterInput? isDeleted,
    Input$StringOperationFilterInput? backgroundJobId,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$ReportFilterInput>? Function(
      Iterable<CopyWith$Input$ReportFilterInput<Input$ReportFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$ReportFilterInput>? Function(
      Iterable<CopyWith$Input$ReportFilterInput<Input$ReportFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get reportedUserId;
  CopyWith$Input$StringOperationFilterInput<TRes> get reporterId;
  CopyWith$Input$ReportTypeOperationFilterInput<TRes> get reportType;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$ReportStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$ReportPriorityOperationFilterInput<TRes> get priority;
  CopyWith$Input$StringOperationFilterInput<TRes> get relatedContentId;
  CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput<TRes>
  get relatedContentType;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get evidences;
  CopyWith$Input$StringOperationFilterInput<TRes> get assignedModeratorId;
  CopyWith$Input$NullableOfReportActionOperationFilterInput<TRes>
  get actionTaken;
  CopyWith$Input$StringOperationFilterInput<TRes> get note;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get resolvedAt;
  CopyWith$Input$LongOperationFilterInput<TRes> get totalReportsCount;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDeleted;
  CopyWith$Input$StringOperationFilterInput<TRes> get backgroundJobId;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$ReportFilterInput<TRes>
    implements CopyWith$Input$ReportFilterInput<TRes> {
  _CopyWithImpl$Input$ReportFilterInput(this._instance, this._then);

  final Input$ReportFilterInput _instance;

  final TRes Function(Input$ReportFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? reportedUserId = _undefined,
    Object? reporterId = _undefined,
    Object? reportType = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
    Object? priority = _undefined,
    Object? relatedContentId = _undefined,
    Object? relatedContentType = _undefined,
    Object? evidences = _undefined,
    Object? assignedModeratorId = _undefined,
    Object? actionTaken = _undefined,
    Object? note = _undefined,
    Object? resolvedAt = _undefined,
    Object? totalReportsCount = _undefined,
    Object? isDeleted = _undefined,
    Object? backgroundJobId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ReportFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$ReportFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$ReportFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (reportedUserId != _undefined)
        'reportedUserId': (reportedUserId as Input$StringOperationFilterInput?),
      if (reporterId != _undefined)
        'reporterId': (reporterId as Input$StringOperationFilterInput?),
      if (reportType != _undefined)
        'reportType': (reportType as Input$ReportTypeOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$ReportStatusOperationFilterInput?),
      if (priority != _undefined)
        'priority': (priority as Input$ReportPriorityOperationFilterInput?),
      if (relatedContentId != _undefined)
        'relatedContentId':
            (relatedContentId as Input$StringOperationFilterInput?),
      if (relatedContentType != _undefined)
        'relatedContentType':
            (relatedContentType
                as Input$NullableOfReportRelatedContentTypeOperationFilterInput?),
      if (evidences != _undefined)
        'evidences': (evidences as Input$ListStringOperationFilterInput?),
      if (assignedModeratorId != _undefined)
        'assignedModeratorId':
            (assignedModeratorId as Input$StringOperationFilterInput?),
      if (actionTaken != _undefined)
        'actionTaken':
            (actionTaken as Input$NullableOfReportActionOperationFilterInput?),
      if (note != _undefined)
        'note': (note as Input$StringOperationFilterInput?),
      if (resolvedAt != _undefined)
        'resolvedAt': (resolvedAt as Input$DateTimeOperationFilterInput?),
      if (totalReportsCount != _undefined)
        'totalReportsCount':
            (totalReportsCount as Input$LongOperationFilterInput?),
      if (isDeleted != _undefined)
        'isDeleted': (isDeleted as Input$BooleanOperationFilterInput?),
      if (backgroundJobId != _undefined)
        'backgroundJobId':
            (backgroundJobId as Input$StringOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$ReportFilterInput>? Function(
      Iterable<CopyWith$Input$ReportFilterInput<Input$ReportFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$ReportFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$ReportFilterInput>? Function(
      Iterable<CopyWith$Input$ReportFilterInput<Input$ReportFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$ReportFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get reportedUserId {
    final local$reportedUserId = _instance.reportedUserId;
    return local$reportedUserId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$reportedUserId,
            (e) => call(reportedUserId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get reporterId {
    final local$reporterId = _instance.reporterId;
    return local$reporterId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$reporterId,
            (e) => call(reporterId: e),
          );
  }

  CopyWith$Input$ReportTypeOperationFilterInput<TRes> get reportType {
    final local$reportType = _instance.reportType;
    return local$reportType == null
        ? CopyWith$Input$ReportTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ReportTypeOperationFilterInput(
            local$reportType,
            (e) => call(reportType: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$ReportStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$ReportStatusOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ReportStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$ReportPriorityOperationFilterInput<TRes> get priority {
    final local$priority = _instance.priority;
    return local$priority == null
        ? CopyWith$Input$ReportPriorityOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ReportPriorityOperationFilterInput(
            local$priority,
            (e) => call(priority: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get relatedContentId {
    final local$relatedContentId = _instance.relatedContentId;
    return local$relatedContentId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$relatedContentId,
            (e) => call(relatedContentId: e),
          );
  }

  CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput<TRes>
  get relatedContentType {
    final local$relatedContentType = _instance.relatedContentType;
    return local$relatedContentType == null
        ? CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput(
            local$relatedContentType,
            (e) => call(relatedContentType: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get evidences {
    final local$evidences = _instance.evidences;
    return local$evidences == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$evidences,
            (e) => call(evidences: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get assignedModeratorId {
    final local$assignedModeratorId = _instance.assignedModeratorId;
    return local$assignedModeratorId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$assignedModeratorId,
            (e) => call(assignedModeratorId: e),
          );
  }

  CopyWith$Input$NullableOfReportActionOperationFilterInput<TRes>
  get actionTaken {
    final local$actionTaken = _instance.actionTaken;
    return local$actionTaken == null
        ? CopyWith$Input$NullableOfReportActionOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$NullableOfReportActionOperationFilterInput(
            local$actionTaken,
            (e) => call(actionTaken: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get note {
    final local$note = _instance.note;
    return local$note == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$note,
            (e) => call(note: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get resolvedAt {
    final local$resolvedAt = _instance.resolvedAt;
    return local$resolvedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$resolvedAt,
            (e) => call(resolvedAt: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get totalReportsCount {
    final local$totalReportsCount = _instance.totalReportsCount;
    return local$totalReportsCount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$totalReportsCount,
            (e) => call(totalReportsCount: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDeleted {
    final local$isDeleted = _instance.isDeleted;
    return local$isDeleted == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isDeleted,
            (e) => call(isDeleted: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get backgroundJobId {
    final local$backgroundJobId = _instance.backgroundJobId;
    return local$backgroundJobId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$backgroundJobId,
            (e) => call(backgroundJobId: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$ReportFilterInput<TRes>
    implements CopyWith$Input$ReportFilterInput<TRes> {
  _CopyWithStubImpl$Input$ReportFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ReportFilterInput>? and,
    List<Input$ReportFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? reportedUserId,
    Input$StringOperationFilterInput? reporterId,
    Input$ReportTypeOperationFilterInput? reportType,
    Input$StringOperationFilterInput? description,
    Input$ReportStatusOperationFilterInput? status,
    Input$ReportPriorityOperationFilterInput? priority,
    Input$StringOperationFilterInput? relatedContentId,
    Input$NullableOfReportRelatedContentTypeOperationFilterInput?
    relatedContentType,
    Input$ListStringOperationFilterInput? evidences,
    Input$StringOperationFilterInput? assignedModeratorId,
    Input$NullableOfReportActionOperationFilterInput? actionTaken,
    Input$StringOperationFilterInput? note,
    Input$DateTimeOperationFilterInput? resolvedAt,
    Input$LongOperationFilterInput? totalReportsCount,
    Input$BooleanOperationFilterInput? isDeleted,
    Input$StringOperationFilterInput? backgroundJobId,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get reportedUserId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get reporterId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ReportTypeOperationFilterInput<TRes> get reportType =>
      CopyWith$Input$ReportTypeOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ReportStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$ReportStatusOperationFilterInput.stub(_res);

  CopyWith$Input$ReportPriorityOperationFilterInput<TRes> get priority =>
      CopyWith$Input$ReportPriorityOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get relatedContentId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput<TRes>
  get relatedContentType =>
      CopyWith$Input$NullableOfReportRelatedContentTypeOperationFilterInput.stub(
        _res,
      );

  CopyWith$Input$ListStringOperationFilterInput<TRes> get evidences =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get assignedModeratorId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$NullableOfReportActionOperationFilterInput<TRes>
  get actionTaken =>
      CopyWith$Input$NullableOfReportActionOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get note =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get resolvedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get totalReportsCount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isDeleted =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get backgroundJobId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$ReportPriorityOperationFilterInput {
  factory Input$ReportPriorityOperationFilterInput({
    Enum$ReportPriority? eq,
    Enum$ReportPriority? neq,
    List<Enum$ReportPriority>? $in,
    List<Enum$ReportPriority>? nin,
  }) => Input$ReportPriorityOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$ReportPriorityOperationFilterInput._(this._$data);

  factory Input$ReportPriorityOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$ReportPriority((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$ReportPriority((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ReportPriority((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ReportPriority((e as String)))
          .toList();
    }
    return Input$ReportPriorityOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ReportPriority? get eq => (_$data['eq'] as Enum$ReportPriority?);

  Enum$ReportPriority? get neq => (_$data['neq'] as Enum$ReportPriority?);

  List<Enum$ReportPriority>? get $in =>
      (_$data['in'] as List<Enum$ReportPriority>?);

  List<Enum$ReportPriority>? get nin =>
      (_$data['nin'] as List<Enum$ReportPriority>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$ReportPriority(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$ReportPriority(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$ReportPriority(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$ReportPriority(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$ReportPriorityOperationFilterInput<
    Input$ReportPriorityOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$ReportPriorityOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReportPriorityOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReportPriorityOperationFilterInput<TRes> {
  factory CopyWith$Input$ReportPriorityOperationFilterInput(
    Input$ReportPriorityOperationFilterInput instance,
    TRes Function(Input$ReportPriorityOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ReportPriorityOperationFilterInput;

  factory CopyWith$Input$ReportPriorityOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReportPriorityOperationFilterInput;

  TRes call({
    Enum$ReportPriority? eq,
    Enum$ReportPriority? neq,
    List<Enum$ReportPriority>? $in,
    List<Enum$ReportPriority>? nin,
  });
}

class _CopyWithImpl$Input$ReportPriorityOperationFilterInput<TRes>
    implements CopyWith$Input$ReportPriorityOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ReportPriorityOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ReportPriorityOperationFilterInput _instance;

  final TRes Function(Input$ReportPriorityOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$ReportPriorityOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$ReportPriority?),
      if (neq != _undefined) 'neq': (neq as Enum$ReportPriority?),
      if ($in != _undefined) 'in': ($in as List<Enum$ReportPriority>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$ReportPriority>?),
    }),
  );
}

class _CopyWithStubImpl$Input$ReportPriorityOperationFilterInput<TRes>
    implements CopyWith$Input$ReportPriorityOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ReportPriorityOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$ReportPriority? eq,
    Enum$ReportPriority? neq,
    List<Enum$ReportPriority>? $in,
    List<Enum$ReportPriority>? nin,
  }) => _res;
}

class Input$ReportSortInput {
  factory Input$ReportSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? reportedUserId,
    Enum$SortEnumType? reporterId,
    Enum$SortEnumType? reportType,
    Enum$SortEnumType? description,
    Enum$SortEnumType? status,
    Enum$SortEnumType? priority,
    Enum$SortEnumType? relatedContentId,
    Enum$SortEnumType? relatedContentType,
    Enum$SortEnumType? assignedModeratorId,
    Enum$SortEnumType? actionTaken,
    Enum$SortEnumType? note,
    Enum$SortEnumType? resolvedAt,
    Enum$SortEnumType? totalReportsCount,
    Enum$SortEnumType? isDeleted,
    Enum$SortEnumType? backgroundJobId,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$ReportSortInput._({
    if (id != null) r'id': id,
    if (reportedUserId != null) r'reportedUserId': reportedUserId,
    if (reporterId != null) r'reporterId': reporterId,
    if (reportType != null) r'reportType': reportType,
    if (description != null) r'description': description,
    if (status != null) r'status': status,
    if (priority != null) r'priority': priority,
    if (relatedContentId != null) r'relatedContentId': relatedContentId,
    if (relatedContentType != null) r'relatedContentType': relatedContentType,
    if (assignedModeratorId != null)
      r'assignedModeratorId': assignedModeratorId,
    if (actionTaken != null) r'actionTaken': actionTaken,
    if (note != null) r'note': note,
    if (resolvedAt != null) r'resolvedAt': resolvedAt,
    if (totalReportsCount != null) r'totalReportsCount': totalReportsCount,
    if (isDeleted != null) r'isDeleted': isDeleted,
    if (backgroundJobId != null) r'backgroundJobId': backgroundJobId,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ReportSortInput._(this._$data);

  factory Input$ReportSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('reportedUserId')) {
      final l$reportedUserId = data['reportedUserId'];
      result$data['reportedUserId'] = l$reportedUserId == null
          ? null
          : fromJson$Enum$SortEnumType((l$reportedUserId as String));
    }
    if (data.containsKey('reporterId')) {
      final l$reporterId = data['reporterId'];
      result$data['reporterId'] = l$reporterId == null
          ? null
          : fromJson$Enum$SortEnumType((l$reporterId as String));
    }
    if (data.containsKey('reportType')) {
      final l$reportType = data['reportType'];
      result$data['reportType'] = l$reportType == null
          ? null
          : fromJson$Enum$SortEnumType((l$reportType as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('priority')) {
      final l$priority = data['priority'];
      result$data['priority'] = l$priority == null
          ? null
          : fromJson$Enum$SortEnumType((l$priority as String));
    }
    if (data.containsKey('relatedContentId')) {
      final l$relatedContentId = data['relatedContentId'];
      result$data['relatedContentId'] = l$relatedContentId == null
          ? null
          : fromJson$Enum$SortEnumType((l$relatedContentId as String));
    }
    if (data.containsKey('relatedContentType')) {
      final l$relatedContentType = data['relatedContentType'];
      result$data['relatedContentType'] = l$relatedContentType == null
          ? null
          : fromJson$Enum$SortEnumType((l$relatedContentType as String));
    }
    if (data.containsKey('assignedModeratorId')) {
      final l$assignedModeratorId = data['assignedModeratorId'];
      result$data['assignedModeratorId'] = l$assignedModeratorId == null
          ? null
          : fromJson$Enum$SortEnumType((l$assignedModeratorId as String));
    }
    if (data.containsKey('actionTaken')) {
      final l$actionTaken = data['actionTaken'];
      result$data['actionTaken'] = l$actionTaken == null
          ? null
          : fromJson$Enum$SortEnumType((l$actionTaken as String));
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = l$note == null
          ? null
          : fromJson$Enum$SortEnumType((l$note as String));
    }
    if (data.containsKey('resolvedAt')) {
      final l$resolvedAt = data['resolvedAt'];
      result$data['resolvedAt'] = l$resolvedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$resolvedAt as String));
    }
    if (data.containsKey('totalReportsCount')) {
      final l$totalReportsCount = data['totalReportsCount'];
      result$data['totalReportsCount'] = l$totalReportsCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$totalReportsCount as String));
    }
    if (data.containsKey('isDeleted')) {
      final l$isDeleted = data['isDeleted'];
      result$data['isDeleted'] = l$isDeleted == null
          ? null
          : fromJson$Enum$SortEnumType((l$isDeleted as String));
    }
    if (data.containsKey('backgroundJobId')) {
      final l$backgroundJobId = data['backgroundJobId'];
      result$data['backgroundJobId'] = l$backgroundJobId == null
          ? null
          : fromJson$Enum$SortEnumType((l$backgroundJobId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$ReportSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get reportedUserId =>
      (_$data['reportedUserId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get reporterId =>
      (_$data['reporterId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get reportType =>
      (_$data['reportType'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get priority => (_$data['priority'] as Enum$SortEnumType?);

  Enum$SortEnumType? get relatedContentId =>
      (_$data['relatedContentId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get relatedContentType =>
      (_$data['relatedContentType'] as Enum$SortEnumType?);

  Enum$SortEnumType? get assignedModeratorId =>
      (_$data['assignedModeratorId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get actionTaken =>
      (_$data['actionTaken'] as Enum$SortEnumType?);

  Enum$SortEnumType? get note => (_$data['note'] as Enum$SortEnumType?);

  Enum$SortEnumType? get resolvedAt =>
      (_$data['resolvedAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get totalReportsCount =>
      (_$data['totalReportsCount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isDeleted =>
      (_$data['isDeleted'] as Enum$SortEnumType?);

  Enum$SortEnumType? get backgroundJobId =>
      (_$data['backgroundJobId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('reportedUserId')) {
      final l$reportedUserId = reportedUserId;
      result$data['reportedUserId'] = l$reportedUserId == null
          ? null
          : toJson$Enum$SortEnumType(l$reportedUserId);
    }
    if (_$data.containsKey('reporterId')) {
      final l$reporterId = reporterId;
      result$data['reporterId'] = l$reporterId == null
          ? null
          : toJson$Enum$SortEnumType(l$reporterId);
    }
    if (_$data.containsKey('reportType')) {
      final l$reportType = reportType;
      result$data['reportType'] = l$reportType == null
          ? null
          : toJson$Enum$SortEnumType(l$reportType);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('priority')) {
      final l$priority = priority;
      result$data['priority'] = l$priority == null
          ? null
          : toJson$Enum$SortEnumType(l$priority);
    }
    if (_$data.containsKey('relatedContentId')) {
      final l$relatedContentId = relatedContentId;
      result$data['relatedContentId'] = l$relatedContentId == null
          ? null
          : toJson$Enum$SortEnumType(l$relatedContentId);
    }
    if (_$data.containsKey('relatedContentType')) {
      final l$relatedContentType = relatedContentType;
      result$data['relatedContentType'] = l$relatedContentType == null
          ? null
          : toJson$Enum$SortEnumType(l$relatedContentType);
    }
    if (_$data.containsKey('assignedModeratorId')) {
      final l$assignedModeratorId = assignedModeratorId;
      result$data['assignedModeratorId'] = l$assignedModeratorId == null
          ? null
          : toJson$Enum$SortEnumType(l$assignedModeratorId);
    }
    if (_$data.containsKey('actionTaken')) {
      final l$actionTaken = actionTaken;
      result$data['actionTaken'] = l$actionTaken == null
          ? null
          : toJson$Enum$SortEnumType(l$actionTaken);
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note == null
          ? null
          : toJson$Enum$SortEnumType(l$note);
    }
    if (_$data.containsKey('resolvedAt')) {
      final l$resolvedAt = resolvedAt;
      result$data['resolvedAt'] = l$resolvedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$resolvedAt);
    }
    if (_$data.containsKey('totalReportsCount')) {
      final l$totalReportsCount = totalReportsCount;
      result$data['totalReportsCount'] = l$totalReportsCount == null
          ? null
          : toJson$Enum$SortEnumType(l$totalReportsCount);
    }
    if (_$data.containsKey('isDeleted')) {
      final l$isDeleted = isDeleted;
      result$data['isDeleted'] = l$isDeleted == null
          ? null
          : toJson$Enum$SortEnumType(l$isDeleted);
    }
    if (_$data.containsKey('backgroundJobId')) {
      final l$backgroundJobId = backgroundJobId;
      result$data['backgroundJobId'] = l$backgroundJobId == null
          ? null
          : toJson$Enum$SortEnumType(l$backgroundJobId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$ReportSortInput<Input$ReportSortInput> get copyWith =>
      CopyWith$Input$ReportSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReportSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$reportedUserId = reportedUserId;
    final lOther$reportedUserId = other.reportedUserId;
    if (_$data.containsKey('reportedUserId') !=
        other._$data.containsKey('reportedUserId')) {
      return false;
    }
    if (l$reportedUserId != lOther$reportedUserId) {
      return false;
    }
    final l$reporterId = reporterId;
    final lOther$reporterId = other.reporterId;
    if (_$data.containsKey('reporterId') !=
        other._$data.containsKey('reporterId')) {
      return false;
    }
    if (l$reporterId != lOther$reporterId) {
      return false;
    }
    final l$reportType = reportType;
    final lOther$reportType = other.reportType;
    if (_$data.containsKey('reportType') !=
        other._$data.containsKey('reportType')) {
      return false;
    }
    if (l$reportType != lOther$reportType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$priority = priority;
    final lOther$priority = other.priority;
    if (_$data.containsKey('priority') !=
        other._$data.containsKey('priority')) {
      return false;
    }
    if (l$priority != lOther$priority) {
      return false;
    }
    final l$relatedContentId = relatedContentId;
    final lOther$relatedContentId = other.relatedContentId;
    if (_$data.containsKey('relatedContentId') !=
        other._$data.containsKey('relatedContentId')) {
      return false;
    }
    if (l$relatedContentId != lOther$relatedContentId) {
      return false;
    }
    final l$relatedContentType = relatedContentType;
    final lOther$relatedContentType = other.relatedContentType;
    if (_$data.containsKey('relatedContentType') !=
        other._$data.containsKey('relatedContentType')) {
      return false;
    }
    if (l$relatedContentType != lOther$relatedContentType) {
      return false;
    }
    final l$assignedModeratorId = assignedModeratorId;
    final lOther$assignedModeratorId = other.assignedModeratorId;
    if (_$data.containsKey('assignedModeratorId') !=
        other._$data.containsKey('assignedModeratorId')) {
      return false;
    }
    if (l$assignedModeratorId != lOther$assignedModeratorId) {
      return false;
    }
    final l$actionTaken = actionTaken;
    final lOther$actionTaken = other.actionTaken;
    if (_$data.containsKey('actionTaken') !=
        other._$data.containsKey('actionTaken')) {
      return false;
    }
    if (l$actionTaken != lOther$actionTaken) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$resolvedAt = resolvedAt;
    final lOther$resolvedAt = other.resolvedAt;
    if (_$data.containsKey('resolvedAt') !=
        other._$data.containsKey('resolvedAt')) {
      return false;
    }
    if (l$resolvedAt != lOther$resolvedAt) {
      return false;
    }
    final l$totalReportsCount = totalReportsCount;
    final lOther$totalReportsCount = other.totalReportsCount;
    if (_$data.containsKey('totalReportsCount') !=
        other._$data.containsKey('totalReportsCount')) {
      return false;
    }
    if (l$totalReportsCount != lOther$totalReportsCount) {
      return false;
    }
    final l$isDeleted = isDeleted;
    final lOther$isDeleted = other.isDeleted;
    if (_$data.containsKey('isDeleted') !=
        other._$data.containsKey('isDeleted')) {
      return false;
    }
    if (l$isDeleted != lOther$isDeleted) {
      return false;
    }
    final l$backgroundJobId = backgroundJobId;
    final lOther$backgroundJobId = other.backgroundJobId;
    if (_$data.containsKey('backgroundJobId') !=
        other._$data.containsKey('backgroundJobId')) {
      return false;
    }
    if (l$backgroundJobId != lOther$backgroundJobId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$reportedUserId = reportedUserId;
    final l$reporterId = reporterId;
    final l$reportType = reportType;
    final l$description = description;
    final l$status = status;
    final l$priority = priority;
    final l$relatedContentId = relatedContentId;
    final l$relatedContentType = relatedContentType;
    final l$assignedModeratorId = assignedModeratorId;
    final l$actionTaken = actionTaken;
    final l$note = note;
    final l$resolvedAt = resolvedAt;
    final l$totalReportsCount = totalReportsCount;
    final l$isDeleted = isDeleted;
    final l$backgroundJobId = backgroundJobId;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('reportedUserId') ? l$reportedUserId : const {},
      _$data.containsKey('reporterId') ? l$reporterId : const {},
      _$data.containsKey('reportType') ? l$reportType : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('priority') ? l$priority : const {},
      _$data.containsKey('relatedContentId') ? l$relatedContentId : const {},
      _$data.containsKey('relatedContentType')
          ? l$relatedContentType
          : const {},
      _$data.containsKey('assignedModeratorId')
          ? l$assignedModeratorId
          : const {},
      _$data.containsKey('actionTaken') ? l$actionTaken : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('resolvedAt') ? l$resolvedAt : const {},
      _$data.containsKey('totalReportsCount') ? l$totalReportsCount : const {},
      _$data.containsKey('isDeleted') ? l$isDeleted : const {},
      _$data.containsKey('backgroundJobId') ? l$backgroundJobId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReportSortInput<TRes> {
  factory CopyWith$Input$ReportSortInput(
    Input$ReportSortInput instance,
    TRes Function(Input$ReportSortInput) then,
  ) = _CopyWithImpl$Input$ReportSortInput;

  factory CopyWith$Input$ReportSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReportSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? reportedUserId,
    Enum$SortEnumType? reporterId,
    Enum$SortEnumType? reportType,
    Enum$SortEnumType? description,
    Enum$SortEnumType? status,
    Enum$SortEnumType? priority,
    Enum$SortEnumType? relatedContentId,
    Enum$SortEnumType? relatedContentType,
    Enum$SortEnumType? assignedModeratorId,
    Enum$SortEnumType? actionTaken,
    Enum$SortEnumType? note,
    Enum$SortEnumType? resolvedAt,
    Enum$SortEnumType? totalReportsCount,
    Enum$SortEnumType? isDeleted,
    Enum$SortEnumType? backgroundJobId,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$ReportSortInput<TRes>
    implements CopyWith$Input$ReportSortInput<TRes> {
  _CopyWithImpl$Input$ReportSortInput(this._instance, this._then);

  final Input$ReportSortInput _instance;

  final TRes Function(Input$ReportSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? reportedUserId = _undefined,
    Object? reporterId = _undefined,
    Object? reportType = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
    Object? priority = _undefined,
    Object? relatedContentId = _undefined,
    Object? relatedContentType = _undefined,
    Object? assignedModeratorId = _undefined,
    Object? actionTaken = _undefined,
    Object? note = _undefined,
    Object? resolvedAt = _undefined,
    Object? totalReportsCount = _undefined,
    Object? isDeleted = _undefined,
    Object? backgroundJobId = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ReportSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (reportedUserId != _undefined)
        'reportedUserId': (reportedUserId as Enum$SortEnumType?),
      if (reporterId != _undefined)
        'reporterId': (reporterId as Enum$SortEnumType?),
      if (reportType != _undefined)
        'reportType': (reportType as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (priority != _undefined) 'priority': (priority as Enum$SortEnumType?),
      if (relatedContentId != _undefined)
        'relatedContentId': (relatedContentId as Enum$SortEnumType?),
      if (relatedContentType != _undefined)
        'relatedContentType': (relatedContentType as Enum$SortEnumType?),
      if (assignedModeratorId != _undefined)
        'assignedModeratorId': (assignedModeratorId as Enum$SortEnumType?),
      if (actionTaken != _undefined)
        'actionTaken': (actionTaken as Enum$SortEnumType?),
      if (note != _undefined) 'note': (note as Enum$SortEnumType?),
      if (resolvedAt != _undefined)
        'resolvedAt': (resolvedAt as Enum$SortEnumType?),
      if (totalReportsCount != _undefined)
        'totalReportsCount': (totalReportsCount as Enum$SortEnumType?),
      if (isDeleted != _undefined)
        'isDeleted': (isDeleted as Enum$SortEnumType?),
      if (backgroundJobId != _undefined)
        'backgroundJobId': (backgroundJobId as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$ReportSortInput<TRes>
    implements CopyWith$Input$ReportSortInput<TRes> {
  _CopyWithStubImpl$Input$ReportSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? reportedUserId,
    Enum$SortEnumType? reporterId,
    Enum$SortEnumType? reportType,
    Enum$SortEnumType? description,
    Enum$SortEnumType? status,
    Enum$SortEnumType? priority,
    Enum$SortEnumType? relatedContentId,
    Enum$SortEnumType? relatedContentType,
    Enum$SortEnumType? assignedModeratorId,
    Enum$SortEnumType? actionTaken,
    Enum$SortEnumType? note,
    Enum$SortEnumType? resolvedAt,
    Enum$SortEnumType? totalReportsCount,
    Enum$SortEnumType? isDeleted,
    Enum$SortEnumType? backgroundJobId,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$ReportStatusOperationFilterInput {
  factory Input$ReportStatusOperationFilterInput({
    Enum$ReportStatus? eq,
    Enum$ReportStatus? neq,
    List<Enum$ReportStatus>? $in,
    List<Enum$ReportStatus>? nin,
  }) => Input$ReportStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$ReportStatusOperationFilterInput._(this._$data);

  factory Input$ReportStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$ReportStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$ReportStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ReportStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ReportStatus((e as String)))
          .toList();
    }
    return Input$ReportStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ReportStatus? get eq => (_$data['eq'] as Enum$ReportStatus?);

  Enum$ReportStatus? get neq => (_$data['neq'] as Enum$ReportStatus?);

  List<Enum$ReportStatus>? get $in =>
      (_$data['in'] as List<Enum$ReportStatus>?);

  List<Enum$ReportStatus>? get nin =>
      (_$data['nin'] as List<Enum$ReportStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$ReportStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$ReportStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$ReportStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$ReportStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$ReportStatusOperationFilterInput<
    Input$ReportStatusOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$ReportStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReportStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReportStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$ReportStatusOperationFilterInput(
    Input$ReportStatusOperationFilterInput instance,
    TRes Function(Input$ReportStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ReportStatusOperationFilterInput;

  factory CopyWith$Input$ReportStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReportStatusOperationFilterInput;

  TRes call({
    Enum$ReportStatus? eq,
    Enum$ReportStatus? neq,
    List<Enum$ReportStatus>? $in,
    List<Enum$ReportStatus>? nin,
  });
}

class _CopyWithImpl$Input$ReportStatusOperationFilterInput<TRes>
    implements CopyWith$Input$ReportStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ReportStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ReportStatusOperationFilterInput _instance;

  final TRes Function(Input$ReportStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$ReportStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$ReportStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$ReportStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$ReportStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$ReportStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$ReportStatusOperationFilterInput<TRes>
    implements CopyWith$Input$ReportStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ReportStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$ReportStatus? eq,
    Enum$ReportStatus? neq,
    List<Enum$ReportStatus>? $in,
    List<Enum$ReportStatus>? nin,
  }) => _res;
}

class Input$ReportTypeOperationFilterInput {
  factory Input$ReportTypeOperationFilterInput({
    Enum$ReportType? eq,
    Enum$ReportType? neq,
    List<Enum$ReportType>? $in,
    List<Enum$ReportType>? nin,
  }) => Input$ReportTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$ReportTypeOperationFilterInput._(this._$data);

  factory Input$ReportTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$ReportType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$ReportType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ReportType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ReportType((e as String)))
          .toList();
    }
    return Input$ReportTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ReportType? get eq => (_$data['eq'] as Enum$ReportType?);

  Enum$ReportType? get neq => (_$data['neq'] as Enum$ReportType?);

  List<Enum$ReportType>? get $in => (_$data['in'] as List<Enum$ReportType>?);

  List<Enum$ReportType>? get nin => (_$data['nin'] as List<Enum$ReportType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$ReportType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$ReportType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$ReportType(e)).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$ReportType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$ReportTypeOperationFilterInput<
    Input$ReportTypeOperationFilterInput
  >
  get copyWith => CopyWith$Input$ReportTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReportTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReportTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$ReportTypeOperationFilterInput(
    Input$ReportTypeOperationFilterInput instance,
    TRes Function(Input$ReportTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$ReportTypeOperationFilterInput;

  factory CopyWith$Input$ReportTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReportTypeOperationFilterInput;

  TRes call({
    Enum$ReportType? eq,
    Enum$ReportType? neq,
    List<Enum$ReportType>? $in,
    List<Enum$ReportType>? nin,
  });
}

class _CopyWithImpl$Input$ReportTypeOperationFilterInput<TRes>
    implements CopyWith$Input$ReportTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$ReportTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$ReportTypeOperationFilterInput _instance;

  final TRes Function(Input$ReportTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$ReportTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$ReportType?),
      if (neq != _undefined) 'neq': (neq as Enum$ReportType?),
      if ($in != _undefined) 'in': ($in as List<Enum$ReportType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$ReportType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$ReportTypeOperationFilterInput<TRes>
    implements CopyWith$Input$ReportTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$ReportTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$ReportType? eq,
    Enum$ReportType? neq,
    List<Enum$ReportType>? $in,
    List<Enum$ReportType>? nin,
  }) => _res;
}

class Input$RequestBudgetFilterInput {
  factory Input$RequestBudgetFilterInput({
    List<Input$RequestBudgetFilterInput>? and,
    List<Input$RequestBudgetFilterInput>? or,
    Input$DecimalOperationFilterInput? min,
    Input$DecimalOperationFilterInput? max,
  }) => Input$RequestBudgetFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (min != null) r'min': min,
    if (max != null) r'max': max,
  });

  Input$RequestBudgetFilterInput._(this._$data);

  factory Input$RequestBudgetFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$RequestBudgetFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$RequestBudgetFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$min as Map<String, dynamic>),
            );
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$max as Map<String, dynamic>),
            );
    }
    return Input$RequestBudgetFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$RequestBudgetFilterInput>? get and =>
      (_$data['and'] as List<Input$RequestBudgetFilterInput>?);

  List<Input$RequestBudgetFilterInput>? get or =>
      (_$data['or'] as List<Input$RequestBudgetFilterInput>?);

  Input$DecimalOperationFilterInput? get min =>
      (_$data['min'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get max =>
      (_$data['max'] as Input$DecimalOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RequestBudgetFilterInput<Input$RequestBudgetFilterInput>
  get copyWith => CopyWith$Input$RequestBudgetFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequestBudgetFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$min = min;
    final l$max = max;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('max') ? l$max : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequestBudgetFilterInput<TRes> {
  factory CopyWith$Input$RequestBudgetFilterInput(
    Input$RequestBudgetFilterInput instance,
    TRes Function(Input$RequestBudgetFilterInput) then,
  ) = _CopyWithImpl$Input$RequestBudgetFilterInput;

  factory CopyWith$Input$RequestBudgetFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestBudgetFilterInput;

  TRes call({
    List<Input$RequestBudgetFilterInput>? and,
    List<Input$RequestBudgetFilterInput>? or,
    Input$DecimalOperationFilterInput? min,
    Input$DecimalOperationFilterInput? max,
  });
  TRes and(
    Iterable<Input$RequestBudgetFilterInput>? Function(
      Iterable<
        CopyWith$Input$RequestBudgetFilterInput<Input$RequestBudgetFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$RequestBudgetFilterInput>? Function(
      Iterable<
        CopyWith$Input$RequestBudgetFilterInput<Input$RequestBudgetFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$DecimalOperationFilterInput<TRes> get min;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get max;
}

class _CopyWithImpl$Input$RequestBudgetFilterInput<TRes>
    implements CopyWith$Input$RequestBudgetFilterInput<TRes> {
  _CopyWithImpl$Input$RequestBudgetFilterInput(this._instance, this._then);

  final Input$RequestBudgetFilterInput _instance;

  final TRes Function(Input$RequestBudgetFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? min = _undefined,
    Object? max = _undefined,
  }) => _then(
    Input$RequestBudgetFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$RequestBudgetFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$RequestBudgetFilterInput>?),
      if (min != _undefined) 'min': (min as Input$DecimalOperationFilterInput?),
      if (max != _undefined) 'max': (max as Input$DecimalOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$RequestBudgetFilterInput>? Function(
      Iterable<
        CopyWith$Input$RequestBudgetFilterInput<Input$RequestBudgetFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$RequestBudgetFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$RequestBudgetFilterInput>? Function(
      Iterable<
        CopyWith$Input$RequestBudgetFilterInput<Input$RequestBudgetFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$RequestBudgetFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$DecimalOperationFilterInput<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$min,
            (e) => call(min: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$max,
            (e) => call(max: e),
          );
  }
}

class _CopyWithStubImpl$Input$RequestBudgetFilterInput<TRes>
    implements CopyWith$Input$RequestBudgetFilterInput<TRes> {
  _CopyWithStubImpl$Input$RequestBudgetFilterInput(this._res);

  TRes _res;

  call({
    List<Input$RequestBudgetFilterInput>? and,
    List<Input$RequestBudgetFilterInput>? or,
    Input$DecimalOperationFilterInput? min,
    Input$DecimalOperationFilterInput? max,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$DecimalOperationFilterInput<TRes> get min =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get max =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);
}

class Input$RequestBudgetInput {
  factory Input$RequestBudgetInput({
    required double min,
    required double max,
  }) => Input$RequestBudgetInput._({r'min': min, r'max': max});

  Input$RequestBudgetInput._(this._$data);

  factory Input$RequestBudgetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$min = data['min'];
    result$data['min'] = (l$min as num).toDouble();
    final l$max = data['max'];
    result$data['max'] = (l$max as num).toDouble();
    return Input$RequestBudgetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double get min => (_$data['min'] as double);

  double get max => (_$data['max'] as double);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$min = min;
    result$data['min'] = l$min;
    final l$max = max;
    result$data['max'] = l$max;
    return result$data;
  }

  CopyWith$Input$RequestBudgetInput<Input$RequestBudgetInput> get copyWith =>
      CopyWith$Input$RequestBudgetInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequestBudgetInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (l$min != lOther$min) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (l$max != lOther$max) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$min = min;
    final l$max = max;
    return Object.hashAll([l$min, l$max]);
  }
}

abstract class CopyWith$Input$RequestBudgetInput<TRes> {
  factory CopyWith$Input$RequestBudgetInput(
    Input$RequestBudgetInput instance,
    TRes Function(Input$RequestBudgetInput) then,
  ) = _CopyWithImpl$Input$RequestBudgetInput;

  factory CopyWith$Input$RequestBudgetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestBudgetInput;

  TRes call({double? min, double? max});
}

class _CopyWithImpl$Input$RequestBudgetInput<TRes>
    implements CopyWith$Input$RequestBudgetInput<TRes> {
  _CopyWithImpl$Input$RequestBudgetInput(this._instance, this._then);

  final Input$RequestBudgetInput _instance;

  final TRes Function(Input$RequestBudgetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? min = _undefined, Object? max = _undefined}) => _then(
    Input$RequestBudgetInput._({
      ..._instance._$data,
      if (min != _undefined && min != null) 'min': (min as double),
      if (max != _undefined && max != null) 'max': (max as double),
    }),
  );
}

class _CopyWithStubImpl$Input$RequestBudgetInput<TRes>
    implements CopyWith$Input$RequestBudgetInput<TRes> {
  _CopyWithStubImpl$Input$RequestBudgetInput(this._res);

  TRes _res;

  call({double? min, double? max}) => _res;
}

class Input$RequestBudgetSortInput {
  factory Input$RequestBudgetSortInput({
    Enum$SortEnumType? min,
    Enum$SortEnumType? max,
  }) => Input$RequestBudgetSortInput._({
    if (min != null) r'min': min,
    if (max != null) r'max': max,
  });

  Input$RequestBudgetSortInput._(this._$data);

  factory Input$RequestBudgetSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : fromJson$Enum$SortEnumType((l$min as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : fromJson$Enum$SortEnumType((l$max as String));
    }
    return Input$RequestBudgetSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get min => (_$data['min'] as Enum$SortEnumType?);

  Enum$SortEnumType? get max => (_$data['max'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min == null
          ? null
          : toJson$Enum$SortEnumType(l$min);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max == null
          ? null
          : toJson$Enum$SortEnumType(l$max);
    }
    return result$data;
  }

  CopyWith$Input$RequestBudgetSortInput<Input$RequestBudgetSortInput>
  get copyWith => CopyWith$Input$RequestBudgetSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequestBudgetSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$min = min;
    final l$max = max;
    return Object.hashAll([
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('max') ? l$max : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequestBudgetSortInput<TRes> {
  factory CopyWith$Input$RequestBudgetSortInput(
    Input$RequestBudgetSortInput instance,
    TRes Function(Input$RequestBudgetSortInput) then,
  ) = _CopyWithImpl$Input$RequestBudgetSortInput;

  factory CopyWith$Input$RequestBudgetSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestBudgetSortInput;

  TRes call({Enum$SortEnumType? min, Enum$SortEnumType? max});
}

class _CopyWithImpl$Input$RequestBudgetSortInput<TRes>
    implements CopyWith$Input$RequestBudgetSortInput<TRes> {
  _CopyWithImpl$Input$RequestBudgetSortInput(this._instance, this._then);

  final Input$RequestBudgetSortInput _instance;

  final TRes Function(Input$RequestBudgetSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? min = _undefined, Object? max = _undefined}) => _then(
    Input$RequestBudgetSortInput._({
      ..._instance._$data,
      if (min != _undefined) 'min': (min as Enum$SortEnumType?),
      if (max != _undefined) 'max': (max as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$RequestBudgetSortInput<TRes>
    implements CopyWith$Input$RequestBudgetSortInput<TRes> {
  _CopyWithStubImpl$Input$RequestBudgetSortInput(this._res);

  TRes _res;

  call({Enum$SortEnumType? min, Enum$SortEnumType? max}) => _res;
}

class Input$RequestCreatingRequestInput {
  factory Input$RequestCreatingRequestInput({
    required String title,
    required String summary,
    required String detailDescription,
    required DateTime deadline,
    required Input$RequestBudgetInput budget,
  }) => Input$RequestCreatingRequestInput._({
    r'title': title,
    r'summary': summary,
    r'detailDescription': detailDescription,
    r'deadline': deadline,
    r'budget': budget,
  });

  Input$RequestCreatingRequestInput._(this._$data);

  factory Input$RequestCreatingRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    final l$summary = data['summary'];
    result$data['summary'] = (l$summary as String);
    final l$detailDescription = data['detailDescription'];
    result$data['detailDescription'] = (l$detailDescription as String);
    final l$deadline = data['deadline'];
    result$data['deadline'] = DateTime.parse((l$deadline as String));
    final l$budget = data['budget'];
    result$data['budget'] = Input$RequestBudgetInput.fromJson(
      (l$budget as Map<String, dynamic>),
    );
    return Input$RequestCreatingRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get title => (_$data['title'] as String);

  String get summary => (_$data['summary'] as String);

  String get detailDescription => (_$data['detailDescription'] as String);

  DateTime get deadline => (_$data['deadline'] as DateTime);

  Input$RequestBudgetInput get budget =>
      (_$data['budget'] as Input$RequestBudgetInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$title = title;
    result$data['title'] = l$title;
    final l$summary = summary;
    result$data['summary'] = l$summary;
    final l$detailDescription = detailDescription;
    result$data['detailDescription'] = l$detailDescription;
    final l$deadline = deadline;
    result$data['deadline'] = l$deadline.toIso8601String();
    final l$budget = budget;
    result$data['budget'] = l$budget.toJson();
    return result$data;
  }

  CopyWith$Input$RequestCreatingRequestInput<Input$RequestCreatingRequestInput>
  get copyWith => CopyWith$Input$RequestCreatingRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequestCreatingRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (l$summary != lOther$summary) {
      return false;
    }
    final l$detailDescription = detailDescription;
    final lOther$detailDescription = other.detailDescription;
    if (l$detailDescription != lOther$detailDescription) {
      return false;
    }
    final l$deadline = deadline;
    final lOther$deadline = other.deadline;
    if (l$deadline != lOther$deadline) {
      return false;
    }
    final l$budget = budget;
    final lOther$budget = other.budget;
    if (l$budget != lOther$budget) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$title = title;
    final l$summary = summary;
    final l$detailDescription = detailDescription;
    final l$deadline = deadline;
    final l$budget = budget;
    return Object.hashAll([
      l$title,
      l$summary,
      l$detailDescription,
      l$deadline,
      l$budget,
    ]);
  }
}

abstract class CopyWith$Input$RequestCreatingRequestInput<TRes> {
  factory CopyWith$Input$RequestCreatingRequestInput(
    Input$RequestCreatingRequestInput instance,
    TRes Function(Input$RequestCreatingRequestInput) then,
  ) = _CopyWithImpl$Input$RequestCreatingRequestInput;

  factory CopyWith$Input$RequestCreatingRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestCreatingRequestInput;

  TRes call({
    String? title,
    String? summary,
    String? detailDescription,
    DateTime? deadline,
    Input$RequestBudgetInput? budget,
  });
  CopyWith$Input$RequestBudgetInput<TRes> get budget;
}

class _CopyWithImpl$Input$RequestCreatingRequestInput<TRes>
    implements CopyWith$Input$RequestCreatingRequestInput<TRes> {
  _CopyWithImpl$Input$RequestCreatingRequestInput(this._instance, this._then);

  final Input$RequestCreatingRequestInput _instance;

  final TRes Function(Input$RequestCreatingRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? title = _undefined,
    Object? summary = _undefined,
    Object? detailDescription = _undefined,
    Object? deadline = _undefined,
    Object? budget = _undefined,
  }) => _then(
    Input$RequestCreatingRequestInput._({
      ..._instance._$data,
      if (title != _undefined && title != null) 'title': (title as String),
      if (summary != _undefined && summary != null)
        'summary': (summary as String),
      if (detailDescription != _undefined && detailDescription != null)
        'detailDescription': (detailDescription as String),
      if (deadline != _undefined && deadline != null)
        'deadline': (deadline as DateTime),
      if (budget != _undefined && budget != null)
        'budget': (budget as Input$RequestBudgetInput),
    }),
  );

  CopyWith$Input$RequestBudgetInput<TRes> get budget {
    final local$budget = _instance.budget;
    return CopyWith$Input$RequestBudgetInput(
      local$budget,
      (e) => call(budget: e),
    );
  }
}

class _CopyWithStubImpl$Input$RequestCreatingRequestInput<TRes>
    implements CopyWith$Input$RequestCreatingRequestInput<TRes> {
  _CopyWithStubImpl$Input$RequestCreatingRequestInput(this._res);

  TRes _res;

  call({
    String? title,
    String? summary,
    String? detailDescription,
    DateTime? deadline,
    Input$RequestBudgetInput? budget,
  }) => _res;

  CopyWith$Input$RequestBudgetInput<TRes> get budget =>
      CopyWith$Input$RequestBudgetInput.stub(_res);
}

class Input$RequestFilterInput {
  factory Input$RequestFilterInput({
    List<Input$RequestFilterInput>? and,
    List<Input$RequestFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? requestUserId,
    Input$StringOperationFilterInput? artistId,
    Input$StringOperationFilterInput? packageId,
    Input$StringOperationFilterInput? title,
    Input$StringOperationFilterInput? titleUnsigned,
    Input$StringOperationFilterInput? summary,
    Input$StringOperationFilterInput? summaryUnsigned,
    Input$StringOperationFilterInput? detailDescription,
    Input$StringOperationFilterInput? requirements,
    Input$RequestBudgetFilterInput? budget,
    Input$DateTimeOperationFilterInput? postCreatedTime,
    Input$DateTimeOperationFilterInput? updatedAt,
    Input$RequestTypeOperationFilterInput? type,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DateTimeOperationFilterInput? deadline,
    Input$RequestStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? requestCreatedTime,
    Input$StringOperationFilterInput? notes,
  }) => Input$RequestFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (requestUserId != null) r'requestUserId': requestUserId,
    if (artistId != null) r'artistId': artistId,
    if (packageId != null) r'packageId': packageId,
    if (title != null) r'title': title,
    if (titleUnsigned != null) r'titleUnsigned': titleUnsigned,
    if (summary != null) r'summary': summary,
    if (summaryUnsigned != null) r'summaryUnsigned': summaryUnsigned,
    if (detailDescription != null) r'detailDescription': detailDescription,
    if (requirements != null) r'requirements': requirements,
    if (budget != null) r'budget': budget,
    if (postCreatedTime != null) r'postCreatedTime': postCreatedTime,
    if (updatedAt != null) r'updatedAt': updatedAt,
    if (type != null) r'type': type,
    if (currency != null) r'currency': currency,
    if (deadline != null) r'deadline': deadline,
    if (status != null) r'status': status,
    if (requestCreatedTime != null) r'requestCreatedTime': requestCreatedTime,
    if (notes != null) r'notes': notes,
  });

  Input$RequestFilterInput._(this._$data);

  factory Input$RequestFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$RequestFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$RequestFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('requestUserId')) {
      final l$requestUserId = data['requestUserId'];
      result$data['requestUserId'] = l$requestUserId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$requestUserId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('artistId')) {
      final l$artistId = data['artistId'];
      result$data['artistId'] = l$artistId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$artistId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('packageId')) {
      final l$packageId = data['packageId'];
      result$data['packageId'] = l$packageId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$packageId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$title as Map<String, dynamic>),
            );
    }
    if (data.containsKey('titleUnsigned')) {
      final l$titleUnsigned = data['titleUnsigned'];
      result$data['titleUnsigned'] = l$titleUnsigned == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$titleUnsigned as Map<String, dynamic>),
            );
    }
    if (data.containsKey('summary')) {
      final l$summary = data['summary'];
      result$data['summary'] = l$summary == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$summary as Map<String, dynamic>),
            );
    }
    if (data.containsKey('summaryUnsigned')) {
      final l$summaryUnsigned = data['summaryUnsigned'];
      result$data['summaryUnsigned'] = l$summaryUnsigned == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$summaryUnsigned as Map<String, dynamic>),
            );
    }
    if (data.containsKey('detailDescription')) {
      final l$detailDescription = data['detailDescription'];
      result$data['detailDescription'] = l$detailDescription == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$detailDescription as Map<String, dynamic>),
            );
    }
    if (data.containsKey('requirements')) {
      final l$requirements = data['requirements'];
      result$data['requirements'] = l$requirements == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$requirements as Map<String, dynamic>),
            );
    }
    if (data.containsKey('budget')) {
      final l$budget = data['budget'];
      result$data['budget'] = l$budget == null
          ? null
          : Input$RequestBudgetFilterInput.fromJson(
              (l$budget as Map<String, dynamic>),
            );
    }
    if (data.containsKey('postCreatedTime')) {
      final l$postCreatedTime = data['postCreatedTime'];
      result$data['postCreatedTime'] = l$postCreatedTime == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$postCreatedTime as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : Input$RequestTypeOperationFilterInput.fromJson(
              (l$type as Map<String, dynamic>),
            );
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : Input$CurrencyTypeOperationFilterInput.fromJson(
              (l$currency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('deadline')) {
      final l$deadline = data['deadline'];
      result$data['deadline'] = l$deadline == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$deadline as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$RequestStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('requestCreatedTime')) {
      final l$requestCreatedTime = data['requestCreatedTime'];
      result$data['requestCreatedTime'] = l$requestCreatedTime == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$requestCreatedTime as Map<String, dynamic>),
            );
    }
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = l$notes == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$notes as Map<String, dynamic>),
            );
    }
    return Input$RequestFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$RequestFilterInput>? get and =>
      (_$data['and'] as List<Input$RequestFilterInput>?);

  List<Input$RequestFilterInput>? get or =>
      (_$data['or'] as List<Input$RequestFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get requestUserId =>
      (_$data['requestUserId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get artistId =>
      (_$data['artistId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get packageId =>
      (_$data['packageId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get title =>
      (_$data['title'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get titleUnsigned =>
      (_$data['titleUnsigned'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get summary =>
      (_$data['summary'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get summaryUnsigned =>
      (_$data['summaryUnsigned'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get detailDescription =>
      (_$data['detailDescription'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get requirements =>
      (_$data['requirements'] as Input$StringOperationFilterInput?);

  Input$RequestBudgetFilterInput? get budget =>
      (_$data['budget'] as Input$RequestBudgetFilterInput?);

  Input$DateTimeOperationFilterInput? get postCreatedTime =>
      (_$data['postCreatedTime'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Input$RequestTypeOperationFilterInput? get type =>
      (_$data['type'] as Input$RequestTypeOperationFilterInput?);

  Input$CurrencyTypeOperationFilterInput? get currency =>
      (_$data['currency'] as Input$CurrencyTypeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get deadline =>
      (_$data['deadline'] as Input$DateTimeOperationFilterInput?);

  Input$RequestStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$RequestStatusOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get requestCreatedTime =>
      (_$data['requestCreatedTime'] as Input$DateTimeOperationFilterInput?);

  Input$StringOperationFilterInput? get notes =>
      (_$data['notes'] as Input$StringOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('requestUserId')) {
      final l$requestUserId = requestUserId;
      result$data['requestUserId'] = l$requestUserId?.toJson();
    }
    if (_$data.containsKey('artistId')) {
      final l$artistId = artistId;
      result$data['artistId'] = l$artistId?.toJson();
    }
    if (_$data.containsKey('packageId')) {
      final l$packageId = packageId;
      result$data['packageId'] = l$packageId?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('titleUnsigned')) {
      final l$titleUnsigned = titleUnsigned;
      result$data['titleUnsigned'] = l$titleUnsigned?.toJson();
    }
    if (_$data.containsKey('summary')) {
      final l$summary = summary;
      result$data['summary'] = l$summary?.toJson();
    }
    if (_$data.containsKey('summaryUnsigned')) {
      final l$summaryUnsigned = summaryUnsigned;
      result$data['summaryUnsigned'] = l$summaryUnsigned?.toJson();
    }
    if (_$data.containsKey('detailDescription')) {
      final l$detailDescription = detailDescription;
      result$data['detailDescription'] = l$detailDescription?.toJson();
    }
    if (_$data.containsKey('requirements')) {
      final l$requirements = requirements;
      result$data['requirements'] = l$requirements?.toJson();
    }
    if (_$data.containsKey('budget')) {
      final l$budget = budget;
      result$data['budget'] = l$budget?.toJson();
    }
    if (_$data.containsKey('postCreatedTime')) {
      final l$postCreatedTime = postCreatedTime;
      result$data['postCreatedTime'] = l$postCreatedTime?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.toJson();
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency?.toJson();
    }
    if (_$data.containsKey('deadline')) {
      final l$deadline = deadline;
      result$data['deadline'] = l$deadline?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('requestCreatedTime')) {
      final l$requestCreatedTime = requestCreatedTime;
      result$data['requestCreatedTime'] = l$requestCreatedTime?.toJson();
    }
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] = l$notes?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RequestFilterInput<Input$RequestFilterInput> get copyWith =>
      CopyWith$Input$RequestFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequestFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$requestUserId = requestUserId;
    final lOther$requestUserId = other.requestUserId;
    if (_$data.containsKey('requestUserId') !=
        other._$data.containsKey('requestUserId')) {
      return false;
    }
    if (l$requestUserId != lOther$requestUserId) {
      return false;
    }
    final l$artistId = artistId;
    final lOther$artistId = other.artistId;
    if (_$data.containsKey('artistId') !=
        other._$data.containsKey('artistId')) {
      return false;
    }
    if (l$artistId != lOther$artistId) {
      return false;
    }
    final l$packageId = packageId;
    final lOther$packageId = other.packageId;
    if (_$data.containsKey('packageId') !=
        other._$data.containsKey('packageId')) {
      return false;
    }
    if (l$packageId != lOther$packageId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$titleUnsigned = titleUnsigned;
    final lOther$titleUnsigned = other.titleUnsigned;
    if (_$data.containsKey('titleUnsigned') !=
        other._$data.containsKey('titleUnsigned')) {
      return false;
    }
    if (l$titleUnsigned != lOther$titleUnsigned) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (_$data.containsKey('summary') != other._$data.containsKey('summary')) {
      return false;
    }
    if (l$summary != lOther$summary) {
      return false;
    }
    final l$summaryUnsigned = summaryUnsigned;
    final lOther$summaryUnsigned = other.summaryUnsigned;
    if (_$data.containsKey('summaryUnsigned') !=
        other._$data.containsKey('summaryUnsigned')) {
      return false;
    }
    if (l$summaryUnsigned != lOther$summaryUnsigned) {
      return false;
    }
    final l$detailDescription = detailDescription;
    final lOther$detailDescription = other.detailDescription;
    if (_$data.containsKey('detailDescription') !=
        other._$data.containsKey('detailDescription')) {
      return false;
    }
    if (l$detailDescription != lOther$detailDescription) {
      return false;
    }
    final l$requirements = requirements;
    final lOther$requirements = other.requirements;
    if (_$data.containsKey('requirements') !=
        other._$data.containsKey('requirements')) {
      return false;
    }
    if (l$requirements != lOther$requirements) {
      return false;
    }
    final l$budget = budget;
    final lOther$budget = other.budget;
    if (_$data.containsKey('budget') != other._$data.containsKey('budget')) {
      return false;
    }
    if (l$budget != lOther$budget) {
      return false;
    }
    final l$postCreatedTime = postCreatedTime;
    final lOther$postCreatedTime = other.postCreatedTime;
    if (_$data.containsKey('postCreatedTime') !=
        other._$data.containsKey('postCreatedTime')) {
      return false;
    }
    if (l$postCreatedTime != lOther$postCreatedTime) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$deadline = deadline;
    final lOther$deadline = other.deadline;
    if (_$data.containsKey('deadline') !=
        other._$data.containsKey('deadline')) {
      return false;
    }
    if (l$deadline != lOther$deadline) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$requestCreatedTime = requestCreatedTime;
    final lOther$requestCreatedTime = other.requestCreatedTime;
    if (_$data.containsKey('requestCreatedTime') !=
        other._$data.containsKey('requestCreatedTime')) {
      return false;
    }
    if (l$requestCreatedTime != lOther$requestCreatedTime) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != lOther$notes) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$requestUserId = requestUserId;
    final l$artistId = artistId;
    final l$packageId = packageId;
    final l$title = title;
    final l$titleUnsigned = titleUnsigned;
    final l$summary = summary;
    final l$summaryUnsigned = summaryUnsigned;
    final l$detailDescription = detailDescription;
    final l$requirements = requirements;
    final l$budget = budget;
    final l$postCreatedTime = postCreatedTime;
    final l$updatedAt = updatedAt;
    final l$type = type;
    final l$currency = currency;
    final l$deadline = deadline;
    final l$status = status;
    final l$requestCreatedTime = requestCreatedTime;
    final l$notes = notes;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('requestUserId') ? l$requestUserId : const {},
      _$data.containsKey('artistId') ? l$artistId : const {},
      _$data.containsKey('packageId') ? l$packageId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('titleUnsigned') ? l$titleUnsigned : const {},
      _$data.containsKey('summary') ? l$summary : const {},
      _$data.containsKey('summaryUnsigned') ? l$summaryUnsigned : const {},
      _$data.containsKey('detailDescription') ? l$detailDescription : const {},
      _$data.containsKey('requirements') ? l$requirements : const {},
      _$data.containsKey('budget') ? l$budget : const {},
      _$data.containsKey('postCreatedTime') ? l$postCreatedTime : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('deadline') ? l$deadline : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('requestCreatedTime')
          ? l$requestCreatedTime
          : const {},
      _$data.containsKey('notes') ? l$notes : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequestFilterInput<TRes> {
  factory CopyWith$Input$RequestFilterInput(
    Input$RequestFilterInput instance,
    TRes Function(Input$RequestFilterInput) then,
  ) = _CopyWithImpl$Input$RequestFilterInput;

  factory CopyWith$Input$RequestFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestFilterInput;

  TRes call({
    List<Input$RequestFilterInput>? and,
    List<Input$RequestFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? requestUserId,
    Input$StringOperationFilterInput? artistId,
    Input$StringOperationFilterInput? packageId,
    Input$StringOperationFilterInput? title,
    Input$StringOperationFilterInput? titleUnsigned,
    Input$StringOperationFilterInput? summary,
    Input$StringOperationFilterInput? summaryUnsigned,
    Input$StringOperationFilterInput? detailDescription,
    Input$StringOperationFilterInput? requirements,
    Input$RequestBudgetFilterInput? budget,
    Input$DateTimeOperationFilterInput? postCreatedTime,
    Input$DateTimeOperationFilterInput? updatedAt,
    Input$RequestTypeOperationFilterInput? type,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DateTimeOperationFilterInput? deadline,
    Input$RequestStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? requestCreatedTime,
    Input$StringOperationFilterInput? notes,
  });
  TRes and(
    Iterable<Input$RequestFilterInput>? Function(
      Iterable<CopyWith$Input$RequestFilterInput<Input$RequestFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$RequestFilterInput>? Function(
      Iterable<CopyWith$Input$RequestFilterInput<Input$RequestFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get requestUserId;
  CopyWith$Input$StringOperationFilterInput<TRes> get artistId;
  CopyWith$Input$StringOperationFilterInput<TRes> get packageId;
  CopyWith$Input$StringOperationFilterInput<TRes> get title;
  CopyWith$Input$StringOperationFilterInput<TRes> get titleUnsigned;
  CopyWith$Input$StringOperationFilterInput<TRes> get summary;
  CopyWith$Input$StringOperationFilterInput<TRes> get summaryUnsigned;
  CopyWith$Input$StringOperationFilterInput<TRes> get detailDescription;
  CopyWith$Input$StringOperationFilterInput<TRes> get requirements;
  CopyWith$Input$RequestBudgetFilterInput<TRes> get budget;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get postCreatedTime;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
  CopyWith$Input$RequestTypeOperationFilterInput<TRes> get type;
  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deadline;
  CopyWith$Input$RequestStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get requestCreatedTime;
  CopyWith$Input$StringOperationFilterInput<TRes> get notes;
}

class _CopyWithImpl$Input$RequestFilterInput<TRes>
    implements CopyWith$Input$RequestFilterInput<TRes> {
  _CopyWithImpl$Input$RequestFilterInput(this._instance, this._then);

  final Input$RequestFilterInput _instance;

  final TRes Function(Input$RequestFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? requestUserId = _undefined,
    Object? artistId = _undefined,
    Object? packageId = _undefined,
    Object? title = _undefined,
    Object? titleUnsigned = _undefined,
    Object? summary = _undefined,
    Object? summaryUnsigned = _undefined,
    Object? detailDescription = _undefined,
    Object? requirements = _undefined,
    Object? budget = _undefined,
    Object? postCreatedTime = _undefined,
    Object? updatedAt = _undefined,
    Object? type = _undefined,
    Object? currency = _undefined,
    Object? deadline = _undefined,
    Object? status = _undefined,
    Object? requestCreatedTime = _undefined,
    Object? notes = _undefined,
  }) => _then(
    Input$RequestFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$RequestFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$RequestFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (requestUserId != _undefined)
        'requestUserId': (requestUserId as Input$StringOperationFilterInput?),
      if (artistId != _undefined)
        'artistId': (artistId as Input$StringOperationFilterInput?),
      if (packageId != _undefined)
        'packageId': (packageId as Input$StringOperationFilterInput?),
      if (title != _undefined)
        'title': (title as Input$StringOperationFilterInput?),
      if (titleUnsigned != _undefined)
        'titleUnsigned': (titleUnsigned as Input$StringOperationFilterInput?),
      if (summary != _undefined)
        'summary': (summary as Input$StringOperationFilterInput?),
      if (summaryUnsigned != _undefined)
        'summaryUnsigned':
            (summaryUnsigned as Input$StringOperationFilterInput?),
      if (detailDescription != _undefined)
        'detailDescription':
            (detailDescription as Input$StringOperationFilterInput?),
      if (requirements != _undefined)
        'requirements': (requirements as Input$StringOperationFilterInput?),
      if (budget != _undefined)
        'budget': (budget as Input$RequestBudgetFilterInput?),
      if (postCreatedTime != _undefined)
        'postCreatedTime':
            (postCreatedTime as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
      if (type != _undefined)
        'type': (type as Input$RequestTypeOperationFilterInput?),
      if (currency != _undefined)
        'currency': (currency as Input$CurrencyTypeOperationFilterInput?),
      if (deadline != _undefined)
        'deadline': (deadline as Input$DateTimeOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$RequestStatusOperationFilterInput?),
      if (requestCreatedTime != _undefined)
        'requestCreatedTime':
            (requestCreatedTime as Input$DateTimeOperationFilterInput?),
      if (notes != _undefined)
        'notes': (notes as Input$StringOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$RequestFilterInput>? Function(
      Iterable<CopyWith$Input$RequestFilterInput<Input$RequestFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$RequestFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$RequestFilterInput>? Function(
      Iterable<CopyWith$Input$RequestFilterInput<Input$RequestFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$RequestFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get requestUserId {
    final local$requestUserId = _instance.requestUserId;
    return local$requestUserId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$requestUserId,
            (e) => call(requestUserId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get artistId {
    final local$artistId = _instance.artistId;
    return local$artistId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$artistId,
            (e) => call(artistId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get packageId {
    final local$packageId = _instance.packageId;
    return local$packageId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$packageId,
            (e) => call(packageId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$title,
            (e) => call(title: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get titleUnsigned {
    final local$titleUnsigned = _instance.titleUnsigned;
    return local$titleUnsigned == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$titleUnsigned,
            (e) => call(titleUnsigned: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get summary {
    final local$summary = _instance.summary;
    return local$summary == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$summary,
            (e) => call(summary: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get summaryUnsigned {
    final local$summaryUnsigned = _instance.summaryUnsigned;
    return local$summaryUnsigned == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$summaryUnsigned,
            (e) => call(summaryUnsigned: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get detailDescription {
    final local$detailDescription = _instance.detailDescription;
    return local$detailDescription == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$detailDescription,
            (e) => call(detailDescription: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get requirements {
    final local$requirements = _instance.requirements;
    return local$requirements == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$requirements,
            (e) => call(requirements: e),
          );
  }

  CopyWith$Input$RequestBudgetFilterInput<TRes> get budget {
    final local$budget = _instance.budget;
    return local$budget == null
        ? CopyWith$Input$RequestBudgetFilterInput.stub(_then(_instance))
        : CopyWith$Input$RequestBudgetFilterInput(
            local$budget,
            (e) => call(budget: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get postCreatedTime {
    final local$postCreatedTime = _instance.postCreatedTime;
    return local$postCreatedTime == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$postCreatedTime,
            (e) => call(postCreatedTime: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }

  CopyWith$Input$RequestTypeOperationFilterInput<TRes> get type {
    final local$type = _instance.type;
    return local$type == null
        ? CopyWith$Input$RequestTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$RequestTypeOperationFilterInput(
            local$type,
            (e) => call(type: e),
          );
  }

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency {
    final local$currency = _instance.currency;
    return local$currency == null
        ? CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CurrencyTypeOperationFilterInput(
            local$currency,
            (e) => call(currency: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deadline {
    final local$deadline = _instance.deadline;
    return local$deadline == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$deadline,
            (e) => call(deadline: e),
          );
  }

  CopyWith$Input$RequestStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$RequestStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$RequestStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get requestCreatedTime {
    final local$requestCreatedTime = _instance.requestCreatedTime;
    return local$requestCreatedTime == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$requestCreatedTime,
            (e) => call(requestCreatedTime: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get notes {
    final local$notes = _instance.notes;
    return local$notes == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$notes,
            (e) => call(notes: e),
          );
  }
}

class _CopyWithStubImpl$Input$RequestFilterInput<TRes>
    implements CopyWith$Input$RequestFilterInput<TRes> {
  _CopyWithStubImpl$Input$RequestFilterInput(this._res);

  TRes _res;

  call({
    List<Input$RequestFilterInput>? and,
    List<Input$RequestFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? requestUserId,
    Input$StringOperationFilterInput? artistId,
    Input$StringOperationFilterInput? packageId,
    Input$StringOperationFilterInput? title,
    Input$StringOperationFilterInput? titleUnsigned,
    Input$StringOperationFilterInput? summary,
    Input$StringOperationFilterInput? summaryUnsigned,
    Input$StringOperationFilterInput? detailDescription,
    Input$StringOperationFilterInput? requirements,
    Input$RequestBudgetFilterInput? budget,
    Input$DateTimeOperationFilterInput? postCreatedTime,
    Input$DateTimeOperationFilterInput? updatedAt,
    Input$RequestTypeOperationFilterInput? type,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DateTimeOperationFilterInput? deadline,
    Input$RequestStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? requestCreatedTime,
    Input$StringOperationFilterInput? notes,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get requestUserId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get artistId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get packageId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get title =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get titleUnsigned =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get summary =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get summaryUnsigned =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get detailDescription =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get requirements =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$RequestBudgetFilterInput<TRes> get budget =>
      CopyWith$Input$RequestBudgetFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get postCreatedTime =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$RequestTypeOperationFilterInput<TRes> get type =>
      CopyWith$Input$RequestTypeOperationFilterInput.stub(_res);

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency =>
      CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get deadline =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$RequestStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$RequestStatusOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get requestCreatedTime =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get notes =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);
}

class Input$RequestSortInput {
  factory Input$RequestSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? requestUserId,
    Enum$SortEnumType? artistId,
    Enum$SortEnumType? packageId,
    Enum$SortEnumType? title,
    Enum$SortEnumType? titleUnsigned,
    Enum$SortEnumType? summary,
    Enum$SortEnumType? summaryUnsigned,
    Enum$SortEnumType? detailDescription,
    Enum$SortEnumType? requirements,
    Input$RequestBudgetSortInput? budget,
    Enum$SortEnumType? postCreatedTime,
    Enum$SortEnumType? updatedAt,
    Enum$SortEnumType? type,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? deadline,
    Enum$SortEnumType? status,
    Enum$SortEnumType? requestCreatedTime,
    Enum$SortEnumType? notes,
  }) => Input$RequestSortInput._({
    if (id != null) r'id': id,
    if (requestUserId != null) r'requestUserId': requestUserId,
    if (artistId != null) r'artistId': artistId,
    if (packageId != null) r'packageId': packageId,
    if (title != null) r'title': title,
    if (titleUnsigned != null) r'titleUnsigned': titleUnsigned,
    if (summary != null) r'summary': summary,
    if (summaryUnsigned != null) r'summaryUnsigned': summaryUnsigned,
    if (detailDescription != null) r'detailDescription': detailDescription,
    if (requirements != null) r'requirements': requirements,
    if (budget != null) r'budget': budget,
    if (postCreatedTime != null) r'postCreatedTime': postCreatedTime,
    if (updatedAt != null) r'updatedAt': updatedAt,
    if (type != null) r'type': type,
    if (currency != null) r'currency': currency,
    if (deadline != null) r'deadline': deadline,
    if (status != null) r'status': status,
    if (requestCreatedTime != null) r'requestCreatedTime': requestCreatedTime,
    if (notes != null) r'notes': notes,
  });

  Input$RequestSortInput._(this._$data);

  factory Input$RequestSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('requestUserId')) {
      final l$requestUserId = data['requestUserId'];
      result$data['requestUserId'] = l$requestUserId == null
          ? null
          : fromJson$Enum$SortEnumType((l$requestUserId as String));
    }
    if (data.containsKey('artistId')) {
      final l$artistId = data['artistId'];
      result$data['artistId'] = l$artistId == null
          ? null
          : fromJson$Enum$SortEnumType((l$artistId as String));
    }
    if (data.containsKey('packageId')) {
      final l$packageId = data['packageId'];
      result$data['packageId'] = l$packageId == null
          ? null
          : fromJson$Enum$SortEnumType((l$packageId as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : fromJson$Enum$SortEnumType((l$title as String));
    }
    if (data.containsKey('titleUnsigned')) {
      final l$titleUnsigned = data['titleUnsigned'];
      result$data['titleUnsigned'] = l$titleUnsigned == null
          ? null
          : fromJson$Enum$SortEnumType((l$titleUnsigned as String));
    }
    if (data.containsKey('summary')) {
      final l$summary = data['summary'];
      result$data['summary'] = l$summary == null
          ? null
          : fromJson$Enum$SortEnumType((l$summary as String));
    }
    if (data.containsKey('summaryUnsigned')) {
      final l$summaryUnsigned = data['summaryUnsigned'];
      result$data['summaryUnsigned'] = l$summaryUnsigned == null
          ? null
          : fromJson$Enum$SortEnumType((l$summaryUnsigned as String));
    }
    if (data.containsKey('detailDescription')) {
      final l$detailDescription = data['detailDescription'];
      result$data['detailDescription'] = l$detailDescription == null
          ? null
          : fromJson$Enum$SortEnumType((l$detailDescription as String));
    }
    if (data.containsKey('requirements')) {
      final l$requirements = data['requirements'];
      result$data['requirements'] = l$requirements == null
          ? null
          : fromJson$Enum$SortEnumType((l$requirements as String));
    }
    if (data.containsKey('budget')) {
      final l$budget = data['budget'];
      result$data['budget'] = l$budget == null
          ? null
          : Input$RequestBudgetSortInput.fromJson(
              (l$budget as Map<String, dynamic>),
            );
    }
    if (data.containsKey('postCreatedTime')) {
      final l$postCreatedTime = data['postCreatedTime'];
      result$data['postCreatedTime'] = l$postCreatedTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$postCreatedTime as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : fromJson$Enum$SortEnumType((l$type as String));
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$SortEnumType((l$currency as String));
    }
    if (data.containsKey('deadline')) {
      final l$deadline = data['deadline'];
      result$data['deadline'] = l$deadline == null
          ? null
          : fromJson$Enum$SortEnumType((l$deadline as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('requestCreatedTime')) {
      final l$requestCreatedTime = data['requestCreatedTime'];
      result$data['requestCreatedTime'] = l$requestCreatedTime == null
          ? null
          : fromJson$Enum$SortEnumType((l$requestCreatedTime as String));
    }
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = l$notes == null
          ? null
          : fromJson$Enum$SortEnumType((l$notes as String));
    }
    return Input$RequestSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get requestUserId =>
      (_$data['requestUserId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get artistId => (_$data['artistId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get packageId =>
      (_$data['packageId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get title => (_$data['title'] as Enum$SortEnumType?);

  Enum$SortEnumType? get titleUnsigned =>
      (_$data['titleUnsigned'] as Enum$SortEnumType?);

  Enum$SortEnumType? get summary => (_$data['summary'] as Enum$SortEnumType?);

  Enum$SortEnumType? get summaryUnsigned =>
      (_$data['summaryUnsigned'] as Enum$SortEnumType?);

  Enum$SortEnumType? get detailDescription =>
      (_$data['detailDescription'] as Enum$SortEnumType?);

  Enum$SortEnumType? get requirements =>
      (_$data['requirements'] as Enum$SortEnumType?);

  Input$RequestBudgetSortInput? get budget =>
      (_$data['budget'] as Input$RequestBudgetSortInput?);

  Enum$SortEnumType? get postCreatedTime =>
      (_$data['postCreatedTime'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get type => (_$data['type'] as Enum$SortEnumType?);

  Enum$SortEnumType? get currency => (_$data['currency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get deadline => (_$data['deadline'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get requestCreatedTime =>
      (_$data['requestCreatedTime'] as Enum$SortEnumType?);

  Enum$SortEnumType? get notes => (_$data['notes'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('requestUserId')) {
      final l$requestUserId = requestUserId;
      result$data['requestUserId'] = l$requestUserId == null
          ? null
          : toJson$Enum$SortEnumType(l$requestUserId);
    }
    if (_$data.containsKey('artistId')) {
      final l$artistId = artistId;
      result$data['artistId'] = l$artistId == null
          ? null
          : toJson$Enum$SortEnumType(l$artistId);
    }
    if (_$data.containsKey('packageId')) {
      final l$packageId = packageId;
      result$data['packageId'] = l$packageId == null
          ? null
          : toJson$Enum$SortEnumType(l$packageId);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title == null
          ? null
          : toJson$Enum$SortEnumType(l$title);
    }
    if (_$data.containsKey('titleUnsigned')) {
      final l$titleUnsigned = titleUnsigned;
      result$data['titleUnsigned'] = l$titleUnsigned == null
          ? null
          : toJson$Enum$SortEnumType(l$titleUnsigned);
    }
    if (_$data.containsKey('summary')) {
      final l$summary = summary;
      result$data['summary'] = l$summary == null
          ? null
          : toJson$Enum$SortEnumType(l$summary);
    }
    if (_$data.containsKey('summaryUnsigned')) {
      final l$summaryUnsigned = summaryUnsigned;
      result$data['summaryUnsigned'] = l$summaryUnsigned == null
          ? null
          : toJson$Enum$SortEnumType(l$summaryUnsigned);
    }
    if (_$data.containsKey('detailDescription')) {
      final l$detailDescription = detailDescription;
      result$data['detailDescription'] = l$detailDescription == null
          ? null
          : toJson$Enum$SortEnumType(l$detailDescription);
    }
    if (_$data.containsKey('requirements')) {
      final l$requirements = requirements;
      result$data['requirements'] = l$requirements == null
          ? null
          : toJson$Enum$SortEnumType(l$requirements);
    }
    if (_$data.containsKey('budget')) {
      final l$budget = budget;
      result$data['budget'] = l$budget?.toJson();
    }
    if (_$data.containsKey('postCreatedTime')) {
      final l$postCreatedTime = postCreatedTime;
      result$data['postCreatedTime'] = l$postCreatedTime == null
          ? null
          : toJson$Enum$SortEnumType(l$postCreatedTime);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type == null
          ? null
          : toJson$Enum$SortEnumType(l$type);
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$SortEnumType(l$currency);
    }
    if (_$data.containsKey('deadline')) {
      final l$deadline = deadline;
      result$data['deadline'] = l$deadline == null
          ? null
          : toJson$Enum$SortEnumType(l$deadline);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('requestCreatedTime')) {
      final l$requestCreatedTime = requestCreatedTime;
      result$data['requestCreatedTime'] = l$requestCreatedTime == null
          ? null
          : toJson$Enum$SortEnumType(l$requestCreatedTime);
    }
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] = l$notes == null
          ? null
          : toJson$Enum$SortEnumType(l$notes);
    }
    return result$data;
  }

  CopyWith$Input$RequestSortInput<Input$RequestSortInput> get copyWith =>
      CopyWith$Input$RequestSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequestSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$requestUserId = requestUserId;
    final lOther$requestUserId = other.requestUserId;
    if (_$data.containsKey('requestUserId') !=
        other._$data.containsKey('requestUserId')) {
      return false;
    }
    if (l$requestUserId != lOther$requestUserId) {
      return false;
    }
    final l$artistId = artistId;
    final lOther$artistId = other.artistId;
    if (_$data.containsKey('artistId') !=
        other._$data.containsKey('artistId')) {
      return false;
    }
    if (l$artistId != lOther$artistId) {
      return false;
    }
    final l$packageId = packageId;
    final lOther$packageId = other.packageId;
    if (_$data.containsKey('packageId') !=
        other._$data.containsKey('packageId')) {
      return false;
    }
    if (l$packageId != lOther$packageId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$titleUnsigned = titleUnsigned;
    final lOther$titleUnsigned = other.titleUnsigned;
    if (_$data.containsKey('titleUnsigned') !=
        other._$data.containsKey('titleUnsigned')) {
      return false;
    }
    if (l$titleUnsigned != lOther$titleUnsigned) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (_$data.containsKey('summary') != other._$data.containsKey('summary')) {
      return false;
    }
    if (l$summary != lOther$summary) {
      return false;
    }
    final l$summaryUnsigned = summaryUnsigned;
    final lOther$summaryUnsigned = other.summaryUnsigned;
    if (_$data.containsKey('summaryUnsigned') !=
        other._$data.containsKey('summaryUnsigned')) {
      return false;
    }
    if (l$summaryUnsigned != lOther$summaryUnsigned) {
      return false;
    }
    final l$detailDescription = detailDescription;
    final lOther$detailDescription = other.detailDescription;
    if (_$data.containsKey('detailDescription') !=
        other._$data.containsKey('detailDescription')) {
      return false;
    }
    if (l$detailDescription != lOther$detailDescription) {
      return false;
    }
    final l$requirements = requirements;
    final lOther$requirements = other.requirements;
    if (_$data.containsKey('requirements') !=
        other._$data.containsKey('requirements')) {
      return false;
    }
    if (l$requirements != lOther$requirements) {
      return false;
    }
    final l$budget = budget;
    final lOther$budget = other.budget;
    if (_$data.containsKey('budget') != other._$data.containsKey('budget')) {
      return false;
    }
    if (l$budget != lOther$budget) {
      return false;
    }
    final l$postCreatedTime = postCreatedTime;
    final lOther$postCreatedTime = other.postCreatedTime;
    if (_$data.containsKey('postCreatedTime') !=
        other._$data.containsKey('postCreatedTime')) {
      return false;
    }
    if (l$postCreatedTime != lOther$postCreatedTime) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$deadline = deadline;
    final lOther$deadline = other.deadline;
    if (_$data.containsKey('deadline') !=
        other._$data.containsKey('deadline')) {
      return false;
    }
    if (l$deadline != lOther$deadline) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$requestCreatedTime = requestCreatedTime;
    final lOther$requestCreatedTime = other.requestCreatedTime;
    if (_$data.containsKey('requestCreatedTime') !=
        other._$data.containsKey('requestCreatedTime')) {
      return false;
    }
    if (l$requestCreatedTime != lOther$requestCreatedTime) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != lOther$notes) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$requestUserId = requestUserId;
    final l$artistId = artistId;
    final l$packageId = packageId;
    final l$title = title;
    final l$titleUnsigned = titleUnsigned;
    final l$summary = summary;
    final l$summaryUnsigned = summaryUnsigned;
    final l$detailDescription = detailDescription;
    final l$requirements = requirements;
    final l$budget = budget;
    final l$postCreatedTime = postCreatedTime;
    final l$updatedAt = updatedAt;
    final l$type = type;
    final l$currency = currency;
    final l$deadline = deadline;
    final l$status = status;
    final l$requestCreatedTime = requestCreatedTime;
    final l$notes = notes;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('requestUserId') ? l$requestUserId : const {},
      _$data.containsKey('artistId') ? l$artistId : const {},
      _$data.containsKey('packageId') ? l$packageId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('titleUnsigned') ? l$titleUnsigned : const {},
      _$data.containsKey('summary') ? l$summary : const {},
      _$data.containsKey('summaryUnsigned') ? l$summaryUnsigned : const {},
      _$data.containsKey('detailDescription') ? l$detailDescription : const {},
      _$data.containsKey('requirements') ? l$requirements : const {},
      _$data.containsKey('budget') ? l$budget : const {},
      _$data.containsKey('postCreatedTime') ? l$postCreatedTime : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('deadline') ? l$deadline : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('requestCreatedTime')
          ? l$requestCreatedTime
          : const {},
      _$data.containsKey('notes') ? l$notes : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequestSortInput<TRes> {
  factory CopyWith$Input$RequestSortInput(
    Input$RequestSortInput instance,
    TRes Function(Input$RequestSortInput) then,
  ) = _CopyWithImpl$Input$RequestSortInput;

  factory CopyWith$Input$RequestSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? requestUserId,
    Enum$SortEnumType? artistId,
    Enum$SortEnumType? packageId,
    Enum$SortEnumType? title,
    Enum$SortEnumType? titleUnsigned,
    Enum$SortEnumType? summary,
    Enum$SortEnumType? summaryUnsigned,
    Enum$SortEnumType? detailDescription,
    Enum$SortEnumType? requirements,
    Input$RequestBudgetSortInput? budget,
    Enum$SortEnumType? postCreatedTime,
    Enum$SortEnumType? updatedAt,
    Enum$SortEnumType? type,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? deadline,
    Enum$SortEnumType? status,
    Enum$SortEnumType? requestCreatedTime,
    Enum$SortEnumType? notes,
  });
  CopyWith$Input$RequestBudgetSortInput<TRes> get budget;
}

class _CopyWithImpl$Input$RequestSortInput<TRes>
    implements CopyWith$Input$RequestSortInput<TRes> {
  _CopyWithImpl$Input$RequestSortInput(this._instance, this._then);

  final Input$RequestSortInput _instance;

  final TRes Function(Input$RequestSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? requestUserId = _undefined,
    Object? artistId = _undefined,
    Object? packageId = _undefined,
    Object? title = _undefined,
    Object? titleUnsigned = _undefined,
    Object? summary = _undefined,
    Object? summaryUnsigned = _undefined,
    Object? detailDescription = _undefined,
    Object? requirements = _undefined,
    Object? budget = _undefined,
    Object? postCreatedTime = _undefined,
    Object? updatedAt = _undefined,
    Object? type = _undefined,
    Object? currency = _undefined,
    Object? deadline = _undefined,
    Object? status = _undefined,
    Object? requestCreatedTime = _undefined,
    Object? notes = _undefined,
  }) => _then(
    Input$RequestSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (requestUserId != _undefined)
        'requestUserId': (requestUserId as Enum$SortEnumType?),
      if (artistId != _undefined) 'artistId': (artistId as Enum$SortEnumType?),
      if (packageId != _undefined)
        'packageId': (packageId as Enum$SortEnumType?),
      if (title != _undefined) 'title': (title as Enum$SortEnumType?),
      if (titleUnsigned != _undefined)
        'titleUnsigned': (titleUnsigned as Enum$SortEnumType?),
      if (summary != _undefined) 'summary': (summary as Enum$SortEnumType?),
      if (summaryUnsigned != _undefined)
        'summaryUnsigned': (summaryUnsigned as Enum$SortEnumType?),
      if (detailDescription != _undefined)
        'detailDescription': (detailDescription as Enum$SortEnumType?),
      if (requirements != _undefined)
        'requirements': (requirements as Enum$SortEnumType?),
      if (budget != _undefined)
        'budget': (budget as Input$RequestBudgetSortInput?),
      if (postCreatedTime != _undefined)
        'postCreatedTime': (postCreatedTime as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
      if (type != _undefined) 'type': (type as Enum$SortEnumType?),
      if (currency != _undefined) 'currency': (currency as Enum$SortEnumType?),
      if (deadline != _undefined) 'deadline': (deadline as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (requestCreatedTime != _undefined)
        'requestCreatedTime': (requestCreatedTime as Enum$SortEnumType?),
      if (notes != _undefined) 'notes': (notes as Enum$SortEnumType?),
    }),
  );

  CopyWith$Input$RequestBudgetSortInput<TRes> get budget {
    final local$budget = _instance.budget;
    return local$budget == null
        ? CopyWith$Input$RequestBudgetSortInput.stub(_then(_instance))
        : CopyWith$Input$RequestBudgetSortInput(
            local$budget,
            (e) => call(budget: e),
          );
  }
}

class _CopyWithStubImpl$Input$RequestSortInput<TRes>
    implements CopyWith$Input$RequestSortInput<TRes> {
  _CopyWithStubImpl$Input$RequestSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? requestUserId,
    Enum$SortEnumType? artistId,
    Enum$SortEnumType? packageId,
    Enum$SortEnumType? title,
    Enum$SortEnumType? titleUnsigned,
    Enum$SortEnumType? summary,
    Enum$SortEnumType? summaryUnsigned,
    Enum$SortEnumType? detailDescription,
    Enum$SortEnumType? requirements,
    Input$RequestBudgetSortInput? budget,
    Enum$SortEnumType? postCreatedTime,
    Enum$SortEnumType? updatedAt,
    Enum$SortEnumType? type,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? deadline,
    Enum$SortEnumType? status,
    Enum$SortEnumType? requestCreatedTime,
    Enum$SortEnumType? notes,
  }) => _res;

  CopyWith$Input$RequestBudgetSortInput<TRes> get budget =>
      CopyWith$Input$RequestBudgetSortInput.stub(_res);
}

class Input$RequestStatusOperationFilterInput {
  factory Input$RequestStatusOperationFilterInput({
    Enum$RequestStatus? eq,
    Enum$RequestStatus? neq,
    List<Enum$RequestStatus>? $in,
    List<Enum$RequestStatus>? nin,
  }) => Input$RequestStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$RequestStatusOperationFilterInput._(this._$data);

  factory Input$RequestStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$RequestStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$RequestStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RequestStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RequestStatus((e as String)))
          .toList();
    }
    return Input$RequestStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RequestStatus? get eq => (_$data['eq'] as Enum$RequestStatus?);

  Enum$RequestStatus? get neq => (_$data['neq'] as Enum$RequestStatus?);

  List<Enum$RequestStatus>? get $in =>
      (_$data['in'] as List<Enum$RequestStatus>?);

  List<Enum$RequestStatus>? get nin =>
      (_$data['nin'] as List<Enum$RequestStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$RequestStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$RequestStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$RequestStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$RequestStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$RequestStatusOperationFilterInput<
    Input$RequestStatusOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$RequestStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequestStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequestStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$RequestStatusOperationFilterInput(
    Input$RequestStatusOperationFilterInput instance,
    TRes Function(Input$RequestStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$RequestStatusOperationFilterInput;

  factory CopyWith$Input$RequestStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestStatusOperationFilterInput;

  TRes call({
    Enum$RequestStatus? eq,
    Enum$RequestStatus? neq,
    List<Enum$RequestStatus>? $in,
    List<Enum$RequestStatus>? nin,
  });
}

class _CopyWithImpl$Input$RequestStatusOperationFilterInput<TRes>
    implements CopyWith$Input$RequestStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$RequestStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$RequestStatusOperationFilterInput _instance;

  final TRes Function(Input$RequestStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$RequestStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$RequestStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$RequestStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$RequestStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$RequestStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$RequestStatusOperationFilterInput<TRes>
    implements CopyWith$Input$RequestStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$RequestStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$RequestStatus? eq,
    Enum$RequestStatus? neq,
    List<Enum$RequestStatus>? $in,
    List<Enum$RequestStatus>? nin,
  }) => _res;
}

class Input$RequestTypeOperationFilterInput {
  factory Input$RequestTypeOperationFilterInput({
    Enum$RequestType? eq,
    Enum$RequestType? neq,
    List<Enum$RequestType>? $in,
    List<Enum$RequestType>? nin,
  }) => Input$RequestTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$RequestTypeOperationFilterInput._(this._$data);

  factory Input$RequestTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$RequestType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$RequestType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RequestType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RequestType((e as String)))
          .toList();
    }
    return Input$RequestTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RequestType? get eq => (_$data['eq'] as Enum$RequestType?);

  Enum$RequestType? get neq => (_$data['neq'] as Enum$RequestType?);

  List<Enum$RequestType>? get $in => (_$data['in'] as List<Enum$RequestType>?);

  List<Enum$RequestType>? get nin => (_$data['nin'] as List<Enum$RequestType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$RequestType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$RequestType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$RequestType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$RequestType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$RequestTypeOperationFilterInput<
    Input$RequestTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$RequestTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequestTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequestTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$RequestTypeOperationFilterInput(
    Input$RequestTypeOperationFilterInput instance,
    TRes Function(Input$RequestTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$RequestTypeOperationFilterInput;

  factory CopyWith$Input$RequestTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestTypeOperationFilterInput;

  TRes call({
    Enum$RequestType? eq,
    Enum$RequestType? neq,
    List<Enum$RequestType>? $in,
    List<Enum$RequestType>? nin,
  });
}

class _CopyWithImpl$Input$RequestTypeOperationFilterInput<TRes>
    implements CopyWith$Input$RequestTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$RequestTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$RequestTypeOperationFilterInput _instance;

  final TRes Function(Input$RequestTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$RequestTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$RequestType?),
      if (neq != _undefined) 'neq': (neq as Enum$RequestType?),
      if ($in != _undefined) 'in': ($in as List<Enum$RequestType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$RequestType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$RequestTypeOperationFilterInput<TRes>
    implements CopyWith$Input$RequestTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$RequestTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$RequestType? eq,
    Enum$RequestType? neq,
    List<Enum$RequestType>? $in,
    List<Enum$RequestType>? nin,
  }) => _res;
}

class Input$RequestUpdatingRequestInput {
  factory Input$RequestUpdatingRequestInput({
    required String id,
    String? title,
    String? summary,
    String? detailDescription,
    DateTime? deadline,
    Input$RequestBudgetInput? budget,
    Enum$RequestStatus? status,
  }) => Input$RequestUpdatingRequestInput._({
    r'id': id,
    if (title != null) r'title': title,
    if (summary != null) r'summary': summary,
    if (detailDescription != null) r'detailDescription': detailDescription,
    if (deadline != null) r'deadline': deadline,
    if (budget != null) r'budget': budget,
    if (status != null) r'status': status,
  });

  Input$RequestUpdatingRequestInput._(this._$data);

  factory Input$RequestUpdatingRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('summary')) {
      final l$summary = data['summary'];
      result$data['summary'] = (l$summary as String?);
    }
    if (data.containsKey('detailDescription')) {
      final l$detailDescription = data['detailDescription'];
      result$data['detailDescription'] = (l$detailDescription as String?);
    }
    if (data.containsKey('deadline')) {
      final l$deadline = data['deadline'];
      result$data['deadline'] = l$deadline == null
          ? null
          : DateTime.parse((l$deadline as String));
    }
    if (data.containsKey('budget')) {
      final l$budget = data['budget'];
      result$data['budget'] = l$budget == null
          ? null
          : Input$RequestBudgetInput.fromJson(
              (l$budget as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$RequestStatus((l$status as String));
    }
    return Input$RequestUpdatingRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  String? get title => (_$data['title'] as String?);

  String? get summary => (_$data['summary'] as String?);

  String? get detailDescription => (_$data['detailDescription'] as String?);

  DateTime? get deadline => (_$data['deadline'] as DateTime?);

  Input$RequestBudgetInput? get budget =>
      (_$data['budget'] as Input$RequestBudgetInput?);

  Enum$RequestStatus? get status => (_$data['status'] as Enum$RequestStatus?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('summary')) {
      final l$summary = summary;
      result$data['summary'] = l$summary;
    }
    if (_$data.containsKey('detailDescription')) {
      final l$detailDescription = detailDescription;
      result$data['detailDescription'] = l$detailDescription;
    }
    if (_$data.containsKey('deadline')) {
      final l$deadline = deadline;
      result$data['deadline'] = l$deadline?.toIso8601String();
    }
    if (_$data.containsKey('budget')) {
      final l$budget = budget;
      result$data['budget'] = l$budget?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$RequestStatus(l$status);
    }
    return result$data;
  }

  CopyWith$Input$RequestUpdatingRequestInput<Input$RequestUpdatingRequestInput>
  get copyWith => CopyWith$Input$RequestUpdatingRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequestUpdatingRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (_$data.containsKey('summary') != other._$data.containsKey('summary')) {
      return false;
    }
    if (l$summary != lOther$summary) {
      return false;
    }
    final l$detailDescription = detailDescription;
    final lOther$detailDescription = other.detailDescription;
    if (_$data.containsKey('detailDescription') !=
        other._$data.containsKey('detailDescription')) {
      return false;
    }
    if (l$detailDescription != lOther$detailDescription) {
      return false;
    }
    final l$deadline = deadline;
    final lOther$deadline = other.deadline;
    if (_$data.containsKey('deadline') !=
        other._$data.containsKey('deadline')) {
      return false;
    }
    if (l$deadline != lOther$deadline) {
      return false;
    }
    final l$budget = budget;
    final lOther$budget = other.budget;
    if (_$data.containsKey('budget') != other._$data.containsKey('budget')) {
      return false;
    }
    if (l$budget != lOther$budget) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$title = title;
    final l$summary = summary;
    final l$detailDescription = detailDescription;
    final l$deadline = deadline;
    final l$budget = budget;
    final l$status = status;
    return Object.hashAll([
      l$id,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('summary') ? l$summary : const {},
      _$data.containsKey('detailDescription') ? l$detailDescription : const {},
      _$data.containsKey('deadline') ? l$deadline : const {},
      _$data.containsKey('budget') ? l$budget : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequestUpdatingRequestInput<TRes> {
  factory CopyWith$Input$RequestUpdatingRequestInput(
    Input$RequestUpdatingRequestInput instance,
    TRes Function(Input$RequestUpdatingRequestInput) then,
  ) = _CopyWithImpl$Input$RequestUpdatingRequestInput;

  factory CopyWith$Input$RequestUpdatingRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestUpdatingRequestInput;

  TRes call({
    String? id,
    String? title,
    String? summary,
    String? detailDescription,
    DateTime? deadline,
    Input$RequestBudgetInput? budget,
    Enum$RequestStatus? status,
  });
  CopyWith$Input$RequestBudgetInput<TRes> get budget;
}

class _CopyWithImpl$Input$RequestUpdatingRequestInput<TRes>
    implements CopyWith$Input$RequestUpdatingRequestInput<TRes> {
  _CopyWithImpl$Input$RequestUpdatingRequestInput(this._instance, this._then);

  final Input$RequestUpdatingRequestInput _instance;

  final TRes Function(Input$RequestUpdatingRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? title = _undefined,
    Object? summary = _undefined,
    Object? detailDescription = _undefined,
    Object? deadline = _undefined,
    Object? budget = _undefined,
    Object? status = _undefined,
  }) => _then(
    Input$RequestUpdatingRequestInput._({
      ..._instance._$data,
      if (id != _undefined && id != null) 'id': (id as String),
      if (title != _undefined) 'title': (title as String?),
      if (summary != _undefined) 'summary': (summary as String?),
      if (detailDescription != _undefined)
        'detailDescription': (detailDescription as String?),
      if (deadline != _undefined) 'deadline': (deadline as DateTime?),
      if (budget != _undefined) 'budget': (budget as Input$RequestBudgetInput?),
      if (status != _undefined) 'status': (status as Enum$RequestStatus?),
    }),
  );

  CopyWith$Input$RequestBudgetInput<TRes> get budget {
    final local$budget = _instance.budget;
    return local$budget == null
        ? CopyWith$Input$RequestBudgetInput.stub(_then(_instance))
        : CopyWith$Input$RequestBudgetInput(
            local$budget,
            (e) => call(budget: e),
          );
  }
}

class _CopyWithStubImpl$Input$RequestUpdatingRequestInput<TRes>
    implements CopyWith$Input$RequestUpdatingRequestInput<TRes> {
  _CopyWithStubImpl$Input$RequestUpdatingRequestInput(this._res);

  TRes _res;

  call({
    String? id,
    String? title,
    String? summary,
    String? detailDescription,
    DateTime? deadline,
    Input$RequestBudgetInput? budget,
    Enum$RequestStatus? status,
  }) => _res;

  CopyWith$Input$RequestBudgetInput<TRes> get budget =>
      CopyWith$Input$RequestBudgetInput.stub(_res);
}

class Input$RestrictionActionDetailInput {
  factory Input$RestrictionActionDetailInput({
    required Enum$RestrictionAction restrictionAction,
    String? note,
  }) => Input$RestrictionActionDetailInput._({
    r'restrictionAction': restrictionAction,
    if (note != null) r'note': note,
  });

  Input$RestrictionActionDetailInput._(this._$data);

  factory Input$RestrictionActionDetailInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$restrictionAction = data['restrictionAction'];
    result$data['restrictionAction'] = fromJson$Enum$RestrictionAction(
      (l$restrictionAction as String),
    );
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    return Input$RestrictionActionDetailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RestrictionAction get restrictionAction =>
      (_$data['restrictionAction'] as Enum$RestrictionAction);

  String? get note => (_$data['note'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$restrictionAction = restrictionAction;
    result$data['restrictionAction'] = toJson$Enum$RestrictionAction(
      l$restrictionAction,
    );
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    return result$data;
  }

  CopyWith$Input$RestrictionActionDetailInput<
    Input$RestrictionActionDetailInput
  >
  get copyWith => CopyWith$Input$RestrictionActionDetailInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RestrictionActionDetailInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$restrictionAction = restrictionAction;
    final lOther$restrictionAction = other.restrictionAction;
    if (l$restrictionAction != lOther$restrictionAction) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$restrictionAction = restrictionAction;
    final l$note = note;
    return Object.hashAll([
      l$restrictionAction,
      _$data.containsKey('note') ? l$note : const {},
    ]);
  }
}

abstract class CopyWith$Input$RestrictionActionDetailInput<TRes> {
  factory CopyWith$Input$RestrictionActionDetailInput(
    Input$RestrictionActionDetailInput instance,
    TRes Function(Input$RestrictionActionDetailInput) then,
  ) = _CopyWithImpl$Input$RestrictionActionDetailInput;

  factory CopyWith$Input$RestrictionActionDetailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RestrictionActionDetailInput;

  TRes call({Enum$RestrictionAction? restrictionAction, String? note});
}

class _CopyWithImpl$Input$RestrictionActionDetailInput<TRes>
    implements CopyWith$Input$RestrictionActionDetailInput<TRes> {
  _CopyWithImpl$Input$RestrictionActionDetailInput(this._instance, this._then);

  final Input$RestrictionActionDetailInput _instance;

  final TRes Function(Input$RestrictionActionDetailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? restrictionAction = _undefined,
    Object? note = _undefined,
  }) => _then(
    Input$RestrictionActionDetailInput._({
      ..._instance._$data,
      if (restrictionAction != _undefined && restrictionAction != null)
        'restrictionAction': (restrictionAction as Enum$RestrictionAction),
      if (note != _undefined) 'note': (note as String?),
    }),
  );
}

class _CopyWithStubImpl$Input$RestrictionActionDetailInput<TRes>
    implements CopyWith$Input$RestrictionActionDetailInput<TRes> {
  _CopyWithStubImpl$Input$RestrictionActionDetailInput(this._res);

  TRes _res;

  call({Enum$RestrictionAction? restrictionAction, String? note}) => _res;
}

class Input$RestrictionFilterInput {
  factory Input$RestrictionFilterInput({
    List<Input$RestrictionFilterInput>? and,
    List<Input$RestrictionFilterInput>? or,
    Input$RestrictionTypeOperationFilterInput? type,
    Input$NullableOfRestrictionActionOperationFilterInput? action,
    Input$StringOperationFilterInput? reason,
    Input$DateTimeOperationFilterInput? restrictedAt,
    Input$DateTimeOperationFilterInput? expired,
  }) => Input$RestrictionFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (type != null) r'type': type,
    if (action != null) r'action': action,
    if (reason != null) r'reason': reason,
    if (restrictedAt != null) r'restrictedAt': restrictedAt,
    if (expired != null) r'expired': expired,
  });

  Input$RestrictionFilterInput._(this._$data);

  factory Input$RestrictionFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$RestrictionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$RestrictionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : Input$RestrictionTypeOperationFilterInput.fromJson(
              (l$type as Map<String, dynamic>),
            );
    }
    if (data.containsKey('action')) {
      final l$action = data['action'];
      result$data['action'] = l$action == null
          ? null
          : Input$NullableOfRestrictionActionOperationFilterInput.fromJson(
              (l$action as Map<String, dynamic>),
            );
    }
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = l$reason == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$reason as Map<String, dynamic>),
            );
    }
    if (data.containsKey('restrictedAt')) {
      final l$restrictedAt = data['restrictedAt'];
      result$data['restrictedAt'] = l$restrictedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$restrictedAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('expired')) {
      final l$expired = data['expired'];
      result$data['expired'] = l$expired == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$expired as Map<String, dynamic>),
            );
    }
    return Input$RestrictionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$RestrictionFilterInput>? get and =>
      (_$data['and'] as List<Input$RestrictionFilterInput>?);

  List<Input$RestrictionFilterInput>? get or =>
      (_$data['or'] as List<Input$RestrictionFilterInput>?);

  Input$RestrictionTypeOperationFilterInput? get type =>
      (_$data['type'] as Input$RestrictionTypeOperationFilterInput?);

  Input$NullableOfRestrictionActionOperationFilterInput? get action =>
      (_$data['action']
          as Input$NullableOfRestrictionActionOperationFilterInput?);

  Input$StringOperationFilterInput? get reason =>
      (_$data['reason'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get restrictedAt =>
      (_$data['restrictedAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get expired =>
      (_$data['expired'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.toJson();
    }
    if (_$data.containsKey('action')) {
      final l$action = action;
      result$data['action'] = l$action?.toJson();
    }
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason?.toJson();
    }
    if (_$data.containsKey('restrictedAt')) {
      final l$restrictedAt = restrictedAt;
      result$data['restrictedAt'] = l$restrictedAt?.toJson();
    }
    if (_$data.containsKey('expired')) {
      final l$expired = expired;
      result$data['expired'] = l$expired?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RestrictionFilterInput<Input$RestrictionFilterInput>
  get copyWith => CopyWith$Input$RestrictionFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RestrictionFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$action = action;
    final lOther$action = other.action;
    if (_$data.containsKey('action') != other._$data.containsKey('action')) {
      return false;
    }
    if (l$action != lOther$action) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    final l$restrictedAt = restrictedAt;
    final lOther$restrictedAt = other.restrictedAt;
    if (_$data.containsKey('restrictedAt') !=
        other._$data.containsKey('restrictedAt')) {
      return false;
    }
    if (l$restrictedAt != lOther$restrictedAt) {
      return false;
    }
    final l$expired = expired;
    final lOther$expired = other.expired;
    if (_$data.containsKey('expired') != other._$data.containsKey('expired')) {
      return false;
    }
    if (l$expired != lOther$expired) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$type = type;
    final l$action = action;
    final l$reason = reason;
    final l$restrictedAt = restrictedAt;
    final l$expired = expired;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('action') ? l$action : const {},
      _$data.containsKey('reason') ? l$reason : const {},
      _$data.containsKey('restrictedAt') ? l$restrictedAt : const {},
      _$data.containsKey('expired') ? l$expired : const {},
    ]);
  }
}

abstract class CopyWith$Input$RestrictionFilterInput<TRes> {
  factory CopyWith$Input$RestrictionFilterInput(
    Input$RestrictionFilterInput instance,
    TRes Function(Input$RestrictionFilterInput) then,
  ) = _CopyWithImpl$Input$RestrictionFilterInput;

  factory CopyWith$Input$RestrictionFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RestrictionFilterInput;

  TRes call({
    List<Input$RestrictionFilterInput>? and,
    List<Input$RestrictionFilterInput>? or,
    Input$RestrictionTypeOperationFilterInput? type,
    Input$NullableOfRestrictionActionOperationFilterInput? action,
    Input$StringOperationFilterInput? reason,
    Input$DateTimeOperationFilterInput? restrictedAt,
    Input$DateTimeOperationFilterInput? expired,
  });
  TRes and(
    Iterable<Input$RestrictionFilterInput>? Function(
      Iterable<
        CopyWith$Input$RestrictionFilterInput<Input$RestrictionFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$RestrictionFilterInput>? Function(
      Iterable<
        CopyWith$Input$RestrictionFilterInput<Input$RestrictionFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$RestrictionTypeOperationFilterInput<TRes> get type;
  CopyWith$Input$NullableOfRestrictionActionOperationFilterInput<TRes>
  get action;
  CopyWith$Input$StringOperationFilterInput<TRes> get reason;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get restrictedAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get expired;
}

class _CopyWithImpl$Input$RestrictionFilterInput<TRes>
    implements CopyWith$Input$RestrictionFilterInput<TRes> {
  _CopyWithImpl$Input$RestrictionFilterInput(this._instance, this._then);

  final Input$RestrictionFilterInput _instance;

  final TRes Function(Input$RestrictionFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? type = _undefined,
    Object? action = _undefined,
    Object? reason = _undefined,
    Object? restrictedAt = _undefined,
    Object? expired = _undefined,
  }) => _then(
    Input$RestrictionFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$RestrictionFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$RestrictionFilterInput>?),
      if (type != _undefined)
        'type': (type as Input$RestrictionTypeOperationFilterInput?),
      if (action != _undefined)
        'action':
            (action as Input$NullableOfRestrictionActionOperationFilterInput?),
      if (reason != _undefined)
        'reason': (reason as Input$StringOperationFilterInput?),
      if (restrictedAt != _undefined)
        'restrictedAt': (restrictedAt as Input$DateTimeOperationFilterInput?),
      if (expired != _undefined)
        'expired': (expired as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$RestrictionFilterInput>? Function(
      Iterable<
        CopyWith$Input$RestrictionFilterInput<Input$RestrictionFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$RestrictionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$RestrictionFilterInput>? Function(
      Iterable<
        CopyWith$Input$RestrictionFilterInput<Input$RestrictionFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$RestrictionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$RestrictionTypeOperationFilterInput<TRes> get type {
    final local$type = _instance.type;
    return local$type == null
        ? CopyWith$Input$RestrictionTypeOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$RestrictionTypeOperationFilterInput(
            local$type,
            (e) => call(type: e),
          );
  }

  CopyWith$Input$NullableOfRestrictionActionOperationFilterInput<TRes>
  get action {
    final local$action = _instance.action;
    return local$action == null
        ? CopyWith$Input$NullableOfRestrictionActionOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$NullableOfRestrictionActionOperationFilterInput(
            local$action,
            (e) => call(action: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get reason {
    final local$reason = _instance.reason;
    return local$reason == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$reason,
            (e) => call(reason: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get restrictedAt {
    final local$restrictedAt = _instance.restrictedAt;
    return local$restrictedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$restrictedAt,
            (e) => call(restrictedAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get expired {
    final local$expired = _instance.expired;
    return local$expired == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$expired,
            (e) => call(expired: e),
          );
  }
}

class _CopyWithStubImpl$Input$RestrictionFilterInput<TRes>
    implements CopyWith$Input$RestrictionFilterInput<TRes> {
  _CopyWithStubImpl$Input$RestrictionFilterInput(this._res);

  TRes _res;

  call({
    List<Input$RestrictionFilterInput>? and,
    List<Input$RestrictionFilterInput>? or,
    Input$RestrictionTypeOperationFilterInput? type,
    Input$NullableOfRestrictionActionOperationFilterInput? action,
    Input$StringOperationFilterInput? reason,
    Input$DateTimeOperationFilterInput? restrictedAt,
    Input$DateTimeOperationFilterInput? expired,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$RestrictionTypeOperationFilterInput<TRes> get type =>
      CopyWith$Input$RestrictionTypeOperationFilterInput.stub(_res);

  CopyWith$Input$NullableOfRestrictionActionOperationFilterInput<TRes>
  get action =>
      CopyWith$Input$NullableOfRestrictionActionOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get reason =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get restrictedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get expired =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$RestrictionSortInput {
  factory Input$RestrictionSortInput({
    Enum$SortEnumType? type,
    Enum$SortEnumType? action,
    Enum$SortEnumType? reason,
    Enum$SortEnumType? restrictedAt,
    Enum$SortEnumType? expired,
  }) => Input$RestrictionSortInput._({
    if (type != null) r'type': type,
    if (action != null) r'action': action,
    if (reason != null) r'reason': reason,
    if (restrictedAt != null) r'restrictedAt': restrictedAt,
    if (expired != null) r'expired': expired,
  });

  Input$RestrictionSortInput._(this._$data);

  factory Input$RestrictionSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : fromJson$Enum$SortEnumType((l$type as String));
    }
    if (data.containsKey('action')) {
      final l$action = data['action'];
      result$data['action'] = l$action == null
          ? null
          : fromJson$Enum$SortEnumType((l$action as String));
    }
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = l$reason == null
          ? null
          : fromJson$Enum$SortEnumType((l$reason as String));
    }
    if (data.containsKey('restrictedAt')) {
      final l$restrictedAt = data['restrictedAt'];
      result$data['restrictedAt'] = l$restrictedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$restrictedAt as String));
    }
    if (data.containsKey('expired')) {
      final l$expired = data['expired'];
      result$data['expired'] = l$expired == null
          ? null
          : fromJson$Enum$SortEnumType((l$expired as String));
    }
    return Input$RestrictionSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get type => (_$data['type'] as Enum$SortEnumType?);

  Enum$SortEnumType? get action => (_$data['action'] as Enum$SortEnumType?);

  Enum$SortEnumType? get reason => (_$data['reason'] as Enum$SortEnumType?);

  Enum$SortEnumType? get restrictedAt =>
      (_$data['restrictedAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get expired => (_$data['expired'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type == null
          ? null
          : toJson$Enum$SortEnumType(l$type);
    }
    if (_$data.containsKey('action')) {
      final l$action = action;
      result$data['action'] = l$action == null
          ? null
          : toJson$Enum$SortEnumType(l$action);
    }
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason == null
          ? null
          : toJson$Enum$SortEnumType(l$reason);
    }
    if (_$data.containsKey('restrictedAt')) {
      final l$restrictedAt = restrictedAt;
      result$data['restrictedAt'] = l$restrictedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$restrictedAt);
    }
    if (_$data.containsKey('expired')) {
      final l$expired = expired;
      result$data['expired'] = l$expired == null
          ? null
          : toJson$Enum$SortEnumType(l$expired);
    }
    return result$data;
  }

  CopyWith$Input$RestrictionSortInput<Input$RestrictionSortInput>
  get copyWith => CopyWith$Input$RestrictionSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RestrictionSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$action = action;
    final lOther$action = other.action;
    if (_$data.containsKey('action') != other._$data.containsKey('action')) {
      return false;
    }
    if (l$action != lOther$action) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    final l$restrictedAt = restrictedAt;
    final lOther$restrictedAt = other.restrictedAt;
    if (_$data.containsKey('restrictedAt') !=
        other._$data.containsKey('restrictedAt')) {
      return false;
    }
    if (l$restrictedAt != lOther$restrictedAt) {
      return false;
    }
    final l$expired = expired;
    final lOther$expired = other.expired;
    if (_$data.containsKey('expired') != other._$data.containsKey('expired')) {
      return false;
    }
    if (l$expired != lOther$expired) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type = type;
    final l$action = action;
    final l$reason = reason;
    final l$restrictedAt = restrictedAt;
    final l$expired = expired;
    return Object.hashAll([
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('action') ? l$action : const {},
      _$data.containsKey('reason') ? l$reason : const {},
      _$data.containsKey('restrictedAt') ? l$restrictedAt : const {},
      _$data.containsKey('expired') ? l$expired : const {},
    ]);
  }
}

abstract class CopyWith$Input$RestrictionSortInput<TRes> {
  factory CopyWith$Input$RestrictionSortInput(
    Input$RestrictionSortInput instance,
    TRes Function(Input$RestrictionSortInput) then,
  ) = _CopyWithImpl$Input$RestrictionSortInput;

  factory CopyWith$Input$RestrictionSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RestrictionSortInput;

  TRes call({
    Enum$SortEnumType? type,
    Enum$SortEnumType? action,
    Enum$SortEnumType? reason,
    Enum$SortEnumType? restrictedAt,
    Enum$SortEnumType? expired,
  });
}

class _CopyWithImpl$Input$RestrictionSortInput<TRes>
    implements CopyWith$Input$RestrictionSortInput<TRes> {
  _CopyWithImpl$Input$RestrictionSortInput(this._instance, this._then);

  final Input$RestrictionSortInput _instance;

  final TRes Function(Input$RestrictionSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type = _undefined,
    Object? action = _undefined,
    Object? reason = _undefined,
    Object? restrictedAt = _undefined,
    Object? expired = _undefined,
  }) => _then(
    Input$RestrictionSortInput._({
      ..._instance._$data,
      if (type != _undefined) 'type': (type as Enum$SortEnumType?),
      if (action != _undefined) 'action': (action as Enum$SortEnumType?),
      if (reason != _undefined) 'reason': (reason as Enum$SortEnumType?),
      if (restrictedAt != _undefined)
        'restrictedAt': (restrictedAt as Enum$SortEnumType?),
      if (expired != _undefined) 'expired': (expired as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$RestrictionSortInput<TRes>
    implements CopyWith$Input$RestrictionSortInput<TRes> {
  _CopyWithStubImpl$Input$RestrictionSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? type,
    Enum$SortEnumType? action,
    Enum$SortEnumType? reason,
    Enum$SortEnumType? restrictedAt,
    Enum$SortEnumType? expired,
  }) => _res;
}

class Input$RestrictionTypeOperationFilterInput {
  factory Input$RestrictionTypeOperationFilterInput({
    Enum$RestrictionType? eq,
    Enum$RestrictionType? neq,
    List<Enum$RestrictionType>? $in,
    List<Enum$RestrictionType>? nin,
  }) => Input$RestrictionTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$RestrictionTypeOperationFilterInput._(this._$data);

  factory Input$RestrictionTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$RestrictionType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$RestrictionType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RestrictionType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$RestrictionType((e as String)))
          .toList();
    }
    return Input$RestrictionTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RestrictionType? get eq => (_$data['eq'] as Enum$RestrictionType?);

  Enum$RestrictionType? get neq => (_$data['neq'] as Enum$RestrictionType?);

  List<Enum$RestrictionType>? get $in =>
      (_$data['in'] as List<Enum$RestrictionType>?);

  List<Enum$RestrictionType>? get nin =>
      (_$data['nin'] as List<Enum$RestrictionType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$RestrictionType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$RestrictionType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$RestrictionType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$RestrictionType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$RestrictionTypeOperationFilterInput<
    Input$RestrictionTypeOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$RestrictionTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RestrictionTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RestrictionTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$RestrictionTypeOperationFilterInput(
    Input$RestrictionTypeOperationFilterInput instance,
    TRes Function(Input$RestrictionTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$RestrictionTypeOperationFilterInput;

  factory CopyWith$Input$RestrictionTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RestrictionTypeOperationFilterInput;

  TRes call({
    Enum$RestrictionType? eq,
    Enum$RestrictionType? neq,
    List<Enum$RestrictionType>? $in,
    List<Enum$RestrictionType>? nin,
  });
}

class _CopyWithImpl$Input$RestrictionTypeOperationFilterInput<TRes>
    implements CopyWith$Input$RestrictionTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$RestrictionTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$RestrictionTypeOperationFilterInput _instance;

  final TRes Function(Input$RestrictionTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$RestrictionTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$RestrictionType?),
      if (neq != _undefined) 'neq': (neq as Enum$RestrictionType?),
      if ($in != _undefined) 'in': ($in as List<Enum$RestrictionType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$RestrictionType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$RestrictionTypeOperationFilterInput<TRes>
    implements CopyWith$Input$RestrictionTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$RestrictionTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$RestrictionType? eq,
    Enum$RestrictionType? neq,
    List<Enum$RestrictionType>? $in,
    List<Enum$RestrictionType>? nin,
  }) => _res;
}

class Input$ReviewFilterInput {
  factory Input$ReviewFilterInput({
    List<Input$ReviewFilterInput>? and,
    List<Input$ReviewFilterInput>? or,
    Input$IntOperationFilterInput? rating,
    Input$StringOperationFilterInput? content,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$ReviewFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (rating != null) r'rating': rating,
    if (content != null) r'content': content,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ReviewFilterInput._(this._$data);

  factory Input$ReviewFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) =>
                Input$ReviewFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) =>
                Input$ReviewFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = l$rating == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$rating as Map<String, dynamic>),
            );
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$content as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$ReviewFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ReviewFilterInput>? get and =>
      (_$data['and'] as List<Input$ReviewFilterInput>?);

  List<Input$ReviewFilterInput>? get or =>
      (_$data['or'] as List<Input$ReviewFilterInput>?);

  Input$IntOperationFilterInput? get rating =>
      (_$data['rating'] as Input$IntOperationFilterInput?);

  Input$StringOperationFilterInput? get content =>
      (_$data['content'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ReviewFilterInput<Input$ReviewFilterInput> get copyWith =>
      CopyWith$Input$ReviewFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReviewFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$rating = rating;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReviewFilterInput<TRes> {
  factory CopyWith$Input$ReviewFilterInput(
    Input$ReviewFilterInput instance,
    TRes Function(Input$ReviewFilterInput) then,
  ) = _CopyWithImpl$Input$ReviewFilterInput;

  factory CopyWith$Input$ReviewFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReviewFilterInput;

  TRes call({
    List<Input$ReviewFilterInput>? and,
    List<Input$ReviewFilterInput>? or,
    Input$IntOperationFilterInput? rating,
    Input$StringOperationFilterInput? content,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$ReviewFilterInput>? Function(
      Iterable<CopyWith$Input$ReviewFilterInput<Input$ReviewFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$ReviewFilterInput>? Function(
      Iterable<CopyWith$Input$ReviewFilterInput<Input$ReviewFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$IntOperationFilterInput<TRes> get rating;
  CopyWith$Input$StringOperationFilterInput<TRes> get content;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$ReviewFilterInput<TRes>
    implements CopyWith$Input$ReviewFilterInput<TRes> {
  _CopyWithImpl$Input$ReviewFilterInput(this._instance, this._then);

  final Input$ReviewFilterInput _instance;

  final TRes Function(Input$ReviewFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? rating = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ReviewFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$ReviewFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$ReviewFilterInput>?),
      if (rating != _undefined)
        'rating': (rating as Input$IntOperationFilterInput?),
      if (content != _undefined)
        'content': (content as Input$StringOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$ReviewFilterInput>? Function(
      Iterable<CopyWith$Input$ReviewFilterInput<Input$ReviewFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$ReviewFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$ReviewFilterInput>? Function(
      Iterable<CopyWith$Input$ReviewFilterInput<Input$ReviewFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$ReviewFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$IntOperationFilterInput<TRes> get rating {
    final local$rating = _instance.rating;
    return local$rating == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$rating,
            (e) => call(rating: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$content,
            (e) => call(content: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$ReviewFilterInput<TRes>
    implements CopyWith$Input$ReviewFilterInput<TRes> {
  _CopyWithStubImpl$Input$ReviewFilterInput(this._res);

  TRes _res;

  call({
    List<Input$ReviewFilterInput>? and,
    List<Input$ReviewFilterInput>? or,
    Input$IntOperationFilterInput? rating,
    Input$StringOperationFilterInput? content,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$IntOperationFilterInput<TRes> get rating =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get content =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$ReviewSortInput {
  factory Input$ReviewSortInput({
    Enum$SortEnumType? rating,
    Enum$SortEnumType? content,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$ReviewSortInput._({
    if (rating != null) r'rating': rating,
    if (content != null) r'content': content,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$ReviewSortInput._(this._$data);

  factory Input$ReviewSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = l$rating == null
          ? null
          : fromJson$Enum$SortEnumType((l$rating as String));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : fromJson$Enum$SortEnumType((l$content as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$ReviewSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get rating => (_$data['rating'] as Enum$SortEnumType?);

  Enum$SortEnumType? get content => (_$data['content'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating == null
          ? null
          : toJson$Enum$SortEnumType(l$rating);
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content == null
          ? null
          : toJson$Enum$SortEnumType(l$content);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$ReviewSortInput<Input$ReviewSortInput> get copyWith =>
      CopyWith$Input$ReviewSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReviewSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$rating = rating;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReviewSortInput<TRes> {
  factory CopyWith$Input$ReviewSortInput(
    Input$ReviewSortInput instance,
    TRes Function(Input$ReviewSortInput) then,
  ) = _CopyWithImpl$Input$ReviewSortInput;

  factory CopyWith$Input$ReviewSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReviewSortInput;

  TRes call({
    Enum$SortEnumType? rating,
    Enum$SortEnumType? content,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$ReviewSortInput<TRes>
    implements CopyWith$Input$ReviewSortInput<TRes> {
  _CopyWithImpl$Input$ReviewSortInput(this._instance, this._then);

  final Input$ReviewSortInput _instance;

  final TRes Function(Input$ReviewSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? rating = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$ReviewSortInput._({
      ..._instance._$data,
      if (rating != _undefined) 'rating': (rating as Enum$SortEnumType?),
      if (content != _undefined) 'content': (content as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$ReviewSortInput<TRes>
    implements CopyWith$Input$ReviewSortInput<TRes> {
  _CopyWithStubImpl$Input$ReviewSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? rating,
    Enum$SortEnumType? content,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$RoyaltyPolicyFilterInput {
  factory Input$RoyaltyPolicyFilterInput({
    List<Input$RoyaltyPolicyFilterInput>? and,
    List<Input$RoyaltyPolicyFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$DecimalOperationFilterInput? ratePerStream,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DecimalOperationFilterInput? recordingPercentage,
    Input$DecimalOperationFilterInput? workPercentage,
    Input$LongOperationFilterInput? version,
    Input$PolicyStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$RoyaltyPolicyFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (ratePerStream != null) r'ratePerStream': ratePerStream,
    if (currency != null) r'currency': currency,
    if (recordingPercentage != null)
      r'recordingPercentage': recordingPercentage,
    if (workPercentage != null) r'workPercentage': workPercentage,
    if (version != null) r'version': version,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$RoyaltyPolicyFilterInput._(this._$data);

  factory Input$RoyaltyPolicyFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$RoyaltyPolicyFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$RoyaltyPolicyFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('ratePerStream')) {
      final l$ratePerStream = data['ratePerStream'];
      result$data['ratePerStream'] = l$ratePerStream == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$ratePerStream as Map<String, dynamic>),
            );
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : Input$CurrencyTypeOperationFilterInput.fromJson(
              (l$currency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('recordingPercentage')) {
      final l$recordingPercentage = data['recordingPercentage'];
      result$data['recordingPercentage'] = l$recordingPercentage == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$recordingPercentage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('workPercentage')) {
      final l$workPercentage = data['workPercentage'];
      result$data['workPercentage'] = l$workPercentage == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$workPercentage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$version as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$PolicyStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$RoyaltyPolicyFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$RoyaltyPolicyFilterInput>? get and =>
      (_$data['and'] as List<Input$RoyaltyPolicyFilterInput>?);

  List<Input$RoyaltyPolicyFilterInput>? get or =>
      (_$data['or'] as List<Input$RoyaltyPolicyFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$DecimalOperationFilterInput? get ratePerStream =>
      (_$data['ratePerStream'] as Input$DecimalOperationFilterInput?);

  Input$CurrencyTypeOperationFilterInput? get currency =>
      (_$data['currency'] as Input$CurrencyTypeOperationFilterInput?);

  Input$DecimalOperationFilterInput? get recordingPercentage =>
      (_$data['recordingPercentage'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get workPercentage =>
      (_$data['workPercentage'] as Input$DecimalOperationFilterInput?);

  Input$LongOperationFilterInput? get version =>
      (_$data['version'] as Input$LongOperationFilterInput?);

  Input$PolicyStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$PolicyStatusOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('ratePerStream')) {
      final l$ratePerStream = ratePerStream;
      result$data['ratePerStream'] = l$ratePerStream?.toJson();
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency?.toJson();
    }
    if (_$data.containsKey('recordingPercentage')) {
      final l$recordingPercentage = recordingPercentage;
      result$data['recordingPercentage'] = l$recordingPercentage?.toJson();
    }
    if (_$data.containsKey('workPercentage')) {
      final l$workPercentage = workPercentage;
      result$data['workPercentage'] = l$workPercentage?.toJson();
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RoyaltyPolicyFilterInput<Input$RoyaltyPolicyFilterInput>
  get copyWith => CopyWith$Input$RoyaltyPolicyFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RoyaltyPolicyFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$ratePerStream = ratePerStream;
    final lOther$ratePerStream = other.ratePerStream;
    if (_$data.containsKey('ratePerStream') !=
        other._$data.containsKey('ratePerStream')) {
      return false;
    }
    if (l$ratePerStream != lOther$ratePerStream) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$recordingPercentage = recordingPercentage;
    final lOther$recordingPercentage = other.recordingPercentage;
    if (_$data.containsKey('recordingPercentage') !=
        other._$data.containsKey('recordingPercentage')) {
      return false;
    }
    if (l$recordingPercentage != lOther$recordingPercentage) {
      return false;
    }
    final l$workPercentage = workPercentage;
    final lOther$workPercentage = other.workPercentage;
    if (_$data.containsKey('workPercentage') !=
        other._$data.containsKey('workPercentage')) {
      return false;
    }
    if (l$workPercentage != lOther$workPercentage) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$ratePerStream = ratePerStream;
    final l$currency = currency;
    final l$recordingPercentage = recordingPercentage;
    final l$workPercentage = workPercentage;
    final l$version = version;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('ratePerStream') ? l$ratePerStream : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('recordingPercentage')
          ? l$recordingPercentage
          : const {},
      _$data.containsKey('workPercentage') ? l$workPercentage : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$RoyaltyPolicyFilterInput<TRes> {
  factory CopyWith$Input$RoyaltyPolicyFilterInput(
    Input$RoyaltyPolicyFilterInput instance,
    TRes Function(Input$RoyaltyPolicyFilterInput) then,
  ) = _CopyWithImpl$Input$RoyaltyPolicyFilterInput;

  factory CopyWith$Input$RoyaltyPolicyFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RoyaltyPolicyFilterInput;

  TRes call({
    List<Input$RoyaltyPolicyFilterInput>? and,
    List<Input$RoyaltyPolicyFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$DecimalOperationFilterInput? ratePerStream,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DecimalOperationFilterInput? recordingPercentage,
    Input$DecimalOperationFilterInput? workPercentage,
    Input$LongOperationFilterInput? version,
    Input$PolicyStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$RoyaltyPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltyPolicyFilterInput<Input$RoyaltyPolicyFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$RoyaltyPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltyPolicyFilterInput<Input$RoyaltyPolicyFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get ratePerStream;
  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get recordingPercentage;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get workPercentage;
  CopyWith$Input$LongOperationFilterInput<TRes> get version;
  CopyWith$Input$PolicyStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$RoyaltyPolicyFilterInput<TRes>
    implements CopyWith$Input$RoyaltyPolicyFilterInput<TRes> {
  _CopyWithImpl$Input$RoyaltyPolicyFilterInput(this._instance, this._then);

  final Input$RoyaltyPolicyFilterInput _instance;

  final TRes Function(Input$RoyaltyPolicyFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? ratePerStream = _undefined,
    Object? currency = _undefined,
    Object? recordingPercentage = _undefined,
    Object? workPercentage = _undefined,
    Object? version = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$RoyaltyPolicyFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$RoyaltyPolicyFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$RoyaltyPolicyFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (ratePerStream != _undefined)
        'ratePerStream': (ratePerStream as Input$DecimalOperationFilterInput?),
      if (currency != _undefined)
        'currency': (currency as Input$CurrencyTypeOperationFilterInput?),
      if (recordingPercentage != _undefined)
        'recordingPercentage':
            (recordingPercentage as Input$DecimalOperationFilterInput?),
      if (workPercentage != _undefined)
        'workPercentage':
            (workPercentage as Input$DecimalOperationFilterInput?),
      if (version != _undefined)
        'version': (version as Input$LongOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$PolicyStatusOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$RoyaltyPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltyPolicyFilterInput<Input$RoyaltyPolicyFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$RoyaltyPolicyFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$RoyaltyPolicyFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltyPolicyFilterInput<Input$RoyaltyPolicyFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$RoyaltyPolicyFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get ratePerStream {
    final local$ratePerStream = _instance.ratePerStream;
    return local$ratePerStream == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$ratePerStream,
            (e) => call(ratePerStream: e),
          );
  }

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency {
    final local$currency = _instance.currency;
    return local$currency == null
        ? CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CurrencyTypeOperationFilterInput(
            local$currency,
            (e) => call(currency: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get recordingPercentage {
    final local$recordingPercentage = _instance.recordingPercentage;
    return local$recordingPercentage == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$recordingPercentage,
            (e) => call(recordingPercentage: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get workPercentage {
    final local$workPercentage = _instance.workPercentage;
    return local$workPercentage == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$workPercentage,
            (e) => call(workPercentage: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get version {
    final local$version = _instance.version;
    return local$version == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$version,
            (e) => call(version: e),
          );
  }

  CopyWith$Input$PolicyStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$PolicyStatusOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$PolicyStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$RoyaltyPolicyFilterInput<TRes>
    implements CopyWith$Input$RoyaltyPolicyFilterInput<TRes> {
  _CopyWithStubImpl$Input$RoyaltyPolicyFilterInput(this._res);

  TRes _res;

  call({
    List<Input$RoyaltyPolicyFilterInput>? and,
    List<Input$RoyaltyPolicyFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$DecimalOperationFilterInput? ratePerStream,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$DecimalOperationFilterInput? recordingPercentage,
    Input$DecimalOperationFilterInput? workPercentage,
    Input$LongOperationFilterInput? version,
    Input$PolicyStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get ratePerStream =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency =>
      CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get recordingPercentage =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get workPercentage =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get version =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$PolicyStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$PolicyStatusOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$RoyaltyPolicySortInput {
  factory Input$RoyaltyPolicySortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? ratePerStream,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? recordingPercentage,
    Enum$SortEnumType? workPercentage,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$RoyaltyPolicySortInput._({
    if (id != null) r'id': id,
    if (ratePerStream != null) r'ratePerStream': ratePerStream,
    if (currency != null) r'currency': currency,
    if (recordingPercentage != null)
      r'recordingPercentage': recordingPercentage,
    if (workPercentage != null) r'workPercentage': workPercentage,
    if (version != null) r'version': version,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$RoyaltyPolicySortInput._(this._$data);

  factory Input$RoyaltyPolicySortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('ratePerStream')) {
      final l$ratePerStream = data['ratePerStream'];
      result$data['ratePerStream'] = l$ratePerStream == null
          ? null
          : fromJson$Enum$SortEnumType((l$ratePerStream as String));
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$SortEnumType((l$currency as String));
    }
    if (data.containsKey('recordingPercentage')) {
      final l$recordingPercentage = data['recordingPercentage'];
      result$data['recordingPercentage'] = l$recordingPercentage == null
          ? null
          : fromJson$Enum$SortEnumType((l$recordingPercentage as String));
    }
    if (data.containsKey('workPercentage')) {
      final l$workPercentage = data['workPercentage'];
      result$data['workPercentage'] = l$workPercentage == null
          ? null
          : fromJson$Enum$SortEnumType((l$workPercentage as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$SortEnumType((l$version as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$RoyaltyPolicySortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get ratePerStream =>
      (_$data['ratePerStream'] as Enum$SortEnumType?);

  Enum$SortEnumType? get currency => (_$data['currency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get recordingPercentage =>
      (_$data['recordingPercentage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get workPercentage =>
      (_$data['workPercentage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get version => (_$data['version'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('ratePerStream')) {
      final l$ratePerStream = ratePerStream;
      result$data['ratePerStream'] = l$ratePerStream == null
          ? null
          : toJson$Enum$SortEnumType(l$ratePerStream);
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$SortEnumType(l$currency);
    }
    if (_$data.containsKey('recordingPercentage')) {
      final l$recordingPercentage = recordingPercentage;
      result$data['recordingPercentage'] = l$recordingPercentage == null
          ? null
          : toJson$Enum$SortEnumType(l$recordingPercentage);
    }
    if (_$data.containsKey('workPercentage')) {
      final l$workPercentage = workPercentage;
      result$data['workPercentage'] = l$workPercentage == null
          ? null
          : toJson$Enum$SortEnumType(l$workPercentage);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version == null
          ? null
          : toJson$Enum$SortEnumType(l$version);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$RoyaltyPolicySortInput<Input$RoyaltyPolicySortInput>
  get copyWith => CopyWith$Input$RoyaltyPolicySortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RoyaltyPolicySortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$ratePerStream = ratePerStream;
    final lOther$ratePerStream = other.ratePerStream;
    if (_$data.containsKey('ratePerStream') !=
        other._$data.containsKey('ratePerStream')) {
      return false;
    }
    if (l$ratePerStream != lOther$ratePerStream) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$recordingPercentage = recordingPercentage;
    final lOther$recordingPercentage = other.recordingPercentage;
    if (_$data.containsKey('recordingPercentage') !=
        other._$data.containsKey('recordingPercentage')) {
      return false;
    }
    if (l$recordingPercentage != lOther$recordingPercentage) {
      return false;
    }
    final l$workPercentage = workPercentage;
    final lOther$workPercentage = other.workPercentage;
    if (_$data.containsKey('workPercentage') !=
        other._$data.containsKey('workPercentage')) {
      return false;
    }
    if (l$workPercentage != lOther$workPercentage) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$ratePerStream = ratePerStream;
    final l$currency = currency;
    final l$recordingPercentage = recordingPercentage;
    final l$workPercentage = workPercentage;
    final l$version = version;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('ratePerStream') ? l$ratePerStream : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('recordingPercentage')
          ? l$recordingPercentage
          : const {},
      _$data.containsKey('workPercentage') ? l$workPercentage : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$RoyaltyPolicySortInput<TRes> {
  factory CopyWith$Input$RoyaltyPolicySortInput(
    Input$RoyaltyPolicySortInput instance,
    TRes Function(Input$RoyaltyPolicySortInput) then,
  ) = _CopyWithImpl$Input$RoyaltyPolicySortInput;

  factory CopyWith$Input$RoyaltyPolicySortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RoyaltyPolicySortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? ratePerStream,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? recordingPercentage,
    Enum$SortEnumType? workPercentage,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$RoyaltyPolicySortInput<TRes>
    implements CopyWith$Input$RoyaltyPolicySortInput<TRes> {
  _CopyWithImpl$Input$RoyaltyPolicySortInput(this._instance, this._then);

  final Input$RoyaltyPolicySortInput _instance;

  final TRes Function(Input$RoyaltyPolicySortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? ratePerStream = _undefined,
    Object? currency = _undefined,
    Object? recordingPercentage = _undefined,
    Object? workPercentage = _undefined,
    Object? version = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$RoyaltyPolicySortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (ratePerStream != _undefined)
        'ratePerStream': (ratePerStream as Enum$SortEnumType?),
      if (currency != _undefined) 'currency': (currency as Enum$SortEnumType?),
      if (recordingPercentage != _undefined)
        'recordingPercentage': (recordingPercentage as Enum$SortEnumType?),
      if (workPercentage != _undefined)
        'workPercentage': (workPercentage as Enum$SortEnumType?),
      if (version != _undefined) 'version': (version as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$RoyaltyPolicySortInput<TRes>
    implements CopyWith$Input$RoyaltyPolicySortInput<TRes> {
  _CopyWithStubImpl$Input$RoyaltyPolicySortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? ratePerStream,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? recordingPercentage,
    Enum$SortEnumType? workPercentage,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$RoyaltyReportFilterInput {
  factory Input$RoyaltyReportFilterInput({
    List<Input$RoyaltyReportFilterInput>? and,
    List<Input$RoyaltyReportFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$IntOperationFilterInput? month,
    Input$IntOperationFilterInput? year,
    Input$LongOperationFilterInput? streamCount,
    Input$DecimalOperationFilterInput? totalRoyaltyAmount,
    Input$ListFilterInputTypeOfRoyaltySplitFilterInput? royaltySplits,
    Input$DateTimeOperationFilterInput? createdAt,
  }) => Input$RoyaltyReportFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (trackId != null) r'trackId': trackId,
    if (month != null) r'month': month,
    if (year != null) r'year': year,
    if (streamCount != null) r'streamCount': streamCount,
    if (totalRoyaltyAmount != null) r'totalRoyaltyAmount': totalRoyaltyAmount,
    if (royaltySplits != null) r'royaltySplits': royaltySplits,
    if (createdAt != null) r'createdAt': createdAt,
  });

  Input$RoyaltyReportFilterInput._(this._$data);

  factory Input$RoyaltyReportFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$RoyaltyReportFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$RoyaltyReportFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('trackId')) {
      final l$trackId = data['trackId'];
      result$data['trackId'] = l$trackId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$trackId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('month')) {
      final l$month = data['month'];
      result$data['month'] = l$month == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$month as Map<String, dynamic>),
            );
    }
    if (data.containsKey('year')) {
      final l$year = data['year'];
      result$data['year'] = l$year == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$year as Map<String, dynamic>),
            );
    }
    if (data.containsKey('streamCount')) {
      final l$streamCount = data['streamCount'];
      result$data['streamCount'] = l$streamCount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$streamCount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('totalRoyaltyAmount')) {
      final l$totalRoyaltyAmount = data['totalRoyaltyAmount'];
      result$data['totalRoyaltyAmount'] = l$totalRoyaltyAmount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$totalRoyaltyAmount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('royaltySplits')) {
      final l$royaltySplits = data['royaltySplits'];
      result$data['royaltySplits'] = l$royaltySplits == null
          ? null
          : Input$ListFilterInputTypeOfRoyaltySplitFilterInput.fromJson(
              (l$royaltySplits as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    return Input$RoyaltyReportFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$RoyaltyReportFilterInput>? get and =>
      (_$data['and'] as List<Input$RoyaltyReportFilterInput>?);

  List<Input$RoyaltyReportFilterInput>? get or =>
      (_$data['or'] as List<Input$RoyaltyReportFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get trackId =>
      (_$data['trackId'] as Input$StringOperationFilterInput?);

  Input$IntOperationFilterInput? get month =>
      (_$data['month'] as Input$IntOperationFilterInput?);

  Input$IntOperationFilterInput? get year =>
      (_$data['year'] as Input$IntOperationFilterInput?);

  Input$LongOperationFilterInput? get streamCount =>
      (_$data['streamCount'] as Input$LongOperationFilterInput?);

  Input$DecimalOperationFilterInput? get totalRoyaltyAmount =>
      (_$data['totalRoyaltyAmount'] as Input$DecimalOperationFilterInput?);

  Input$ListFilterInputTypeOfRoyaltySplitFilterInput? get royaltySplits =>
      (_$data['royaltySplits']
          as Input$ListFilterInputTypeOfRoyaltySplitFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('trackId')) {
      final l$trackId = trackId;
      result$data['trackId'] = l$trackId?.toJson();
    }
    if (_$data.containsKey('month')) {
      final l$month = month;
      result$data['month'] = l$month?.toJson();
    }
    if (_$data.containsKey('year')) {
      final l$year = year;
      result$data['year'] = l$year?.toJson();
    }
    if (_$data.containsKey('streamCount')) {
      final l$streamCount = streamCount;
      result$data['streamCount'] = l$streamCount?.toJson();
    }
    if (_$data.containsKey('totalRoyaltyAmount')) {
      final l$totalRoyaltyAmount = totalRoyaltyAmount;
      result$data['totalRoyaltyAmount'] = l$totalRoyaltyAmount?.toJson();
    }
    if (_$data.containsKey('royaltySplits')) {
      final l$royaltySplits = royaltySplits;
      result$data['royaltySplits'] = l$royaltySplits?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RoyaltyReportFilterInput<Input$RoyaltyReportFilterInput>
  get copyWith => CopyWith$Input$RoyaltyReportFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RoyaltyReportFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (_$data.containsKey('trackId') != other._$data.containsKey('trackId')) {
      return false;
    }
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$month = month;
    final lOther$month = other.month;
    if (_$data.containsKey('month') != other._$data.containsKey('month')) {
      return false;
    }
    if (l$month != lOther$month) {
      return false;
    }
    final l$year = year;
    final lOther$year = other.year;
    if (_$data.containsKey('year') != other._$data.containsKey('year')) {
      return false;
    }
    if (l$year != lOther$year) {
      return false;
    }
    final l$streamCount = streamCount;
    final lOther$streamCount = other.streamCount;
    if (_$data.containsKey('streamCount') !=
        other._$data.containsKey('streamCount')) {
      return false;
    }
    if (l$streamCount != lOther$streamCount) {
      return false;
    }
    final l$totalRoyaltyAmount = totalRoyaltyAmount;
    final lOther$totalRoyaltyAmount = other.totalRoyaltyAmount;
    if (_$data.containsKey('totalRoyaltyAmount') !=
        other._$data.containsKey('totalRoyaltyAmount')) {
      return false;
    }
    if (l$totalRoyaltyAmount != lOther$totalRoyaltyAmount) {
      return false;
    }
    final l$royaltySplits = royaltySplits;
    final lOther$royaltySplits = other.royaltySplits;
    if (_$data.containsKey('royaltySplits') !=
        other._$data.containsKey('royaltySplits')) {
      return false;
    }
    if (l$royaltySplits != lOther$royaltySplits) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$trackId = trackId;
    final l$month = month;
    final l$year = year;
    final l$streamCount = streamCount;
    final l$totalRoyaltyAmount = totalRoyaltyAmount;
    final l$royaltySplits = royaltySplits;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('trackId') ? l$trackId : const {},
      _$data.containsKey('month') ? l$month : const {},
      _$data.containsKey('year') ? l$year : const {},
      _$data.containsKey('streamCount') ? l$streamCount : const {},
      _$data.containsKey('totalRoyaltyAmount')
          ? l$totalRoyaltyAmount
          : const {},
      _$data.containsKey('royaltySplits') ? l$royaltySplits : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$RoyaltyReportFilterInput<TRes> {
  factory CopyWith$Input$RoyaltyReportFilterInput(
    Input$RoyaltyReportFilterInput instance,
    TRes Function(Input$RoyaltyReportFilterInput) then,
  ) = _CopyWithImpl$Input$RoyaltyReportFilterInput;

  factory CopyWith$Input$RoyaltyReportFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RoyaltyReportFilterInput;

  TRes call({
    List<Input$RoyaltyReportFilterInput>? and,
    List<Input$RoyaltyReportFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$IntOperationFilterInput? month,
    Input$IntOperationFilterInput? year,
    Input$LongOperationFilterInput? streamCount,
    Input$DecimalOperationFilterInput? totalRoyaltyAmount,
    Input$ListFilterInputTypeOfRoyaltySplitFilterInput? royaltySplits,
    Input$DateTimeOperationFilterInput? createdAt,
  });
  TRes and(
    Iterable<Input$RoyaltyReportFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltyReportFilterInput<Input$RoyaltyReportFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$RoyaltyReportFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltyReportFilterInput<Input$RoyaltyReportFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get trackId;
  CopyWith$Input$IntOperationFilterInput<TRes> get month;
  CopyWith$Input$IntOperationFilterInput<TRes> get year;
  CopyWith$Input$LongOperationFilterInput<TRes> get streamCount;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get totalRoyaltyAmount;
  CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput<TRes>
  get royaltySplits;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
}

class _CopyWithImpl$Input$RoyaltyReportFilterInput<TRes>
    implements CopyWith$Input$RoyaltyReportFilterInput<TRes> {
  _CopyWithImpl$Input$RoyaltyReportFilterInput(this._instance, this._then);

  final Input$RoyaltyReportFilterInput _instance;

  final TRes Function(Input$RoyaltyReportFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? trackId = _undefined,
    Object? month = _undefined,
    Object? year = _undefined,
    Object? streamCount = _undefined,
    Object? totalRoyaltyAmount = _undefined,
    Object? royaltySplits = _undefined,
    Object? createdAt = _undefined,
  }) => _then(
    Input$RoyaltyReportFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$RoyaltyReportFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$RoyaltyReportFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (trackId != _undefined)
        'trackId': (trackId as Input$StringOperationFilterInput?),
      if (month != _undefined)
        'month': (month as Input$IntOperationFilterInput?),
      if (year != _undefined) 'year': (year as Input$IntOperationFilterInput?),
      if (streamCount != _undefined)
        'streamCount': (streamCount as Input$LongOperationFilterInput?),
      if (totalRoyaltyAmount != _undefined)
        'totalRoyaltyAmount':
            (totalRoyaltyAmount as Input$DecimalOperationFilterInput?),
      if (royaltySplits != _undefined)
        'royaltySplits':
            (royaltySplits
                as Input$ListFilterInputTypeOfRoyaltySplitFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$RoyaltyReportFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltyReportFilterInput<Input$RoyaltyReportFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$RoyaltyReportFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$RoyaltyReportFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltyReportFilterInput<Input$RoyaltyReportFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$RoyaltyReportFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get trackId {
    final local$trackId = _instance.trackId;
    return local$trackId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$trackId,
            (e) => call(trackId: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get month {
    final local$month = _instance.month;
    return local$month == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$month,
            (e) => call(month: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get year {
    final local$year = _instance.year;
    return local$year == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$year,
            (e) => call(year: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get streamCount {
    final local$streamCount = _instance.streamCount;
    return local$streamCount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$streamCount,
            (e) => call(streamCount: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get totalRoyaltyAmount {
    final local$totalRoyaltyAmount = _instance.totalRoyaltyAmount;
    return local$totalRoyaltyAmount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$totalRoyaltyAmount,
            (e) => call(totalRoyaltyAmount: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput<TRes>
  get royaltySplits {
    final local$royaltySplits = _instance.royaltySplits;
    return local$royaltySplits == null
        ? CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput(
            local$royaltySplits,
            (e) => call(royaltySplits: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$RoyaltyReportFilterInput<TRes>
    implements CopyWith$Input$RoyaltyReportFilterInput<TRes> {
  _CopyWithStubImpl$Input$RoyaltyReportFilterInput(this._res);

  TRes _res;

  call({
    List<Input$RoyaltyReportFilterInput>? and,
    List<Input$RoyaltyReportFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$IntOperationFilterInput? month,
    Input$IntOperationFilterInput? year,
    Input$LongOperationFilterInput? streamCount,
    Input$DecimalOperationFilterInput? totalRoyaltyAmount,
    Input$ListFilterInputTypeOfRoyaltySplitFilterInput? royaltySplits,
    Input$DateTimeOperationFilterInput? createdAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get trackId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get month =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get year =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get streamCount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get totalRoyaltyAmount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput<TRes>
  get royaltySplits =>
      CopyWith$Input$ListFilterInputTypeOfRoyaltySplitFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$RoyaltyReportSortInput {
  factory Input$RoyaltyReportSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? month,
    Enum$SortEnumType? year,
    Enum$SortEnumType? streamCount,
    Enum$SortEnumType? totalRoyaltyAmount,
    Enum$SortEnumType? createdAt,
  }) => Input$RoyaltyReportSortInput._({
    if (id != null) r'id': id,
    if (trackId != null) r'trackId': trackId,
    if (month != null) r'month': month,
    if (year != null) r'year': year,
    if (streamCount != null) r'streamCount': streamCount,
    if (totalRoyaltyAmount != null) r'totalRoyaltyAmount': totalRoyaltyAmount,
    if (createdAt != null) r'createdAt': createdAt,
  });

  Input$RoyaltyReportSortInput._(this._$data);

  factory Input$RoyaltyReportSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('trackId')) {
      final l$trackId = data['trackId'];
      result$data['trackId'] = l$trackId == null
          ? null
          : fromJson$Enum$SortEnumType((l$trackId as String));
    }
    if (data.containsKey('month')) {
      final l$month = data['month'];
      result$data['month'] = l$month == null
          ? null
          : fromJson$Enum$SortEnumType((l$month as String));
    }
    if (data.containsKey('year')) {
      final l$year = data['year'];
      result$data['year'] = l$year == null
          ? null
          : fromJson$Enum$SortEnumType((l$year as String));
    }
    if (data.containsKey('streamCount')) {
      final l$streamCount = data['streamCount'];
      result$data['streamCount'] = l$streamCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$streamCount as String));
    }
    if (data.containsKey('totalRoyaltyAmount')) {
      final l$totalRoyaltyAmount = data['totalRoyaltyAmount'];
      result$data['totalRoyaltyAmount'] = l$totalRoyaltyAmount == null
          ? null
          : fromJson$Enum$SortEnumType((l$totalRoyaltyAmount as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    return Input$RoyaltyReportSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get trackId => (_$data['trackId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get month => (_$data['month'] as Enum$SortEnumType?);

  Enum$SortEnumType? get year => (_$data['year'] as Enum$SortEnumType?);

  Enum$SortEnumType? get streamCount =>
      (_$data['streamCount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get totalRoyaltyAmount =>
      (_$data['totalRoyaltyAmount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('trackId')) {
      final l$trackId = trackId;
      result$data['trackId'] = l$trackId == null
          ? null
          : toJson$Enum$SortEnumType(l$trackId);
    }
    if (_$data.containsKey('month')) {
      final l$month = month;
      result$data['month'] = l$month == null
          ? null
          : toJson$Enum$SortEnumType(l$month);
    }
    if (_$data.containsKey('year')) {
      final l$year = year;
      result$data['year'] = l$year == null
          ? null
          : toJson$Enum$SortEnumType(l$year);
    }
    if (_$data.containsKey('streamCount')) {
      final l$streamCount = streamCount;
      result$data['streamCount'] = l$streamCount == null
          ? null
          : toJson$Enum$SortEnumType(l$streamCount);
    }
    if (_$data.containsKey('totalRoyaltyAmount')) {
      final l$totalRoyaltyAmount = totalRoyaltyAmount;
      result$data['totalRoyaltyAmount'] = l$totalRoyaltyAmount == null
          ? null
          : toJson$Enum$SortEnumType(l$totalRoyaltyAmount);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$RoyaltyReportSortInput<Input$RoyaltyReportSortInput>
  get copyWith => CopyWith$Input$RoyaltyReportSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RoyaltyReportSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (_$data.containsKey('trackId') != other._$data.containsKey('trackId')) {
      return false;
    }
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$month = month;
    final lOther$month = other.month;
    if (_$data.containsKey('month') != other._$data.containsKey('month')) {
      return false;
    }
    if (l$month != lOther$month) {
      return false;
    }
    final l$year = year;
    final lOther$year = other.year;
    if (_$data.containsKey('year') != other._$data.containsKey('year')) {
      return false;
    }
    if (l$year != lOther$year) {
      return false;
    }
    final l$streamCount = streamCount;
    final lOther$streamCount = other.streamCount;
    if (_$data.containsKey('streamCount') !=
        other._$data.containsKey('streamCount')) {
      return false;
    }
    if (l$streamCount != lOther$streamCount) {
      return false;
    }
    final l$totalRoyaltyAmount = totalRoyaltyAmount;
    final lOther$totalRoyaltyAmount = other.totalRoyaltyAmount;
    if (_$data.containsKey('totalRoyaltyAmount') !=
        other._$data.containsKey('totalRoyaltyAmount')) {
      return false;
    }
    if (l$totalRoyaltyAmount != lOther$totalRoyaltyAmount) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$trackId = trackId;
    final l$month = month;
    final l$year = year;
    final l$streamCount = streamCount;
    final l$totalRoyaltyAmount = totalRoyaltyAmount;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('trackId') ? l$trackId : const {},
      _$data.containsKey('month') ? l$month : const {},
      _$data.containsKey('year') ? l$year : const {},
      _$data.containsKey('streamCount') ? l$streamCount : const {},
      _$data.containsKey('totalRoyaltyAmount')
          ? l$totalRoyaltyAmount
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$RoyaltyReportSortInput<TRes> {
  factory CopyWith$Input$RoyaltyReportSortInput(
    Input$RoyaltyReportSortInput instance,
    TRes Function(Input$RoyaltyReportSortInput) then,
  ) = _CopyWithImpl$Input$RoyaltyReportSortInput;

  factory CopyWith$Input$RoyaltyReportSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RoyaltyReportSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? month,
    Enum$SortEnumType? year,
    Enum$SortEnumType? streamCount,
    Enum$SortEnumType? totalRoyaltyAmount,
    Enum$SortEnumType? createdAt,
  });
}

class _CopyWithImpl$Input$RoyaltyReportSortInput<TRes>
    implements CopyWith$Input$RoyaltyReportSortInput<TRes> {
  _CopyWithImpl$Input$RoyaltyReportSortInput(this._instance, this._then);

  final Input$RoyaltyReportSortInput _instance;

  final TRes Function(Input$RoyaltyReportSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? trackId = _undefined,
    Object? month = _undefined,
    Object? year = _undefined,
    Object? streamCount = _undefined,
    Object? totalRoyaltyAmount = _undefined,
    Object? createdAt = _undefined,
  }) => _then(
    Input$RoyaltyReportSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (trackId != _undefined) 'trackId': (trackId as Enum$SortEnumType?),
      if (month != _undefined) 'month': (month as Enum$SortEnumType?),
      if (year != _undefined) 'year': (year as Enum$SortEnumType?),
      if (streamCount != _undefined)
        'streamCount': (streamCount as Enum$SortEnumType?),
      if (totalRoyaltyAmount != _undefined)
        'totalRoyaltyAmount': (totalRoyaltyAmount as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$RoyaltyReportSortInput<TRes>
    implements CopyWith$Input$RoyaltyReportSortInput<TRes> {
  _CopyWithStubImpl$Input$RoyaltyReportSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? month,
    Enum$SortEnumType? year,
    Enum$SortEnumType? streamCount,
    Enum$SortEnumType? totalRoyaltyAmount,
    Enum$SortEnumType? createdAt,
  }) => _res;
}

class Input$RoyaltySplitFilterInput {
  factory Input$RoyaltySplitFilterInput({
    List<Input$RoyaltySplitFilterInput>? and,
    List<Input$RoyaltySplitFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$ArtistRoleOperationFilterInput? artistRole,
    Input$DecimalOperationFilterInput? percentage,
    Input$DecimalOperationFilterInput? amount,
    Input$AggregationLevelOperationFilterInput? level,
    Input$BooleanOperationFilterInput? isTransferred,
  }) => Input$RoyaltySplitFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (userId != null) r'userId': userId,
    if (artistRole != null) r'artistRole': artistRole,
    if (percentage != null) r'percentage': percentage,
    if (amount != null) r'amount': amount,
    if (level != null) r'level': level,
    if (isTransferred != null) r'isTransferred': isTransferred,
  });

  Input$RoyaltySplitFilterInput._(this._$data);

  factory Input$RoyaltySplitFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$RoyaltySplitFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$RoyaltySplitFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('artistRole')) {
      final l$artistRole = data['artistRole'];
      result$data['artistRole'] = l$artistRole == null
          ? null
          : Input$ArtistRoleOperationFilterInput.fromJson(
              (l$artistRole as Map<String, dynamic>),
            );
    }
    if (data.containsKey('percentage')) {
      final l$percentage = data['percentage'];
      result$data['percentage'] = l$percentage == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$percentage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$amount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('level')) {
      final l$level = data['level'];
      result$data['level'] = l$level == null
          ? null
          : Input$AggregationLevelOperationFilterInput.fromJson(
              (l$level as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isTransferred')) {
      final l$isTransferred = data['isTransferred'];
      result$data['isTransferred'] = l$isTransferred == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isTransferred as Map<String, dynamic>),
            );
    }
    return Input$RoyaltySplitFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$RoyaltySplitFilterInput>? get and =>
      (_$data['and'] as List<Input$RoyaltySplitFilterInput>?);

  List<Input$RoyaltySplitFilterInput>? get or =>
      (_$data['or'] as List<Input$RoyaltySplitFilterInput>?);

  Input$StringOperationFilterInput? get userId =>
      (_$data['userId'] as Input$StringOperationFilterInput?);

  Input$ArtistRoleOperationFilterInput? get artistRole =>
      (_$data['artistRole'] as Input$ArtistRoleOperationFilterInput?);

  Input$DecimalOperationFilterInput? get percentage =>
      (_$data['percentage'] as Input$DecimalOperationFilterInput?);

  Input$DecimalOperationFilterInput? get amount =>
      (_$data['amount'] as Input$DecimalOperationFilterInput?);

  Input$AggregationLevelOperationFilterInput? get level =>
      (_$data['level'] as Input$AggregationLevelOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isTransferred =>
      (_$data['isTransferred'] as Input$BooleanOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('artistRole')) {
      final l$artistRole = artistRole;
      result$data['artistRole'] = l$artistRole?.toJson();
    }
    if (_$data.containsKey('percentage')) {
      final l$percentage = percentage;
      result$data['percentage'] = l$percentage?.toJson();
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount?.toJson();
    }
    if (_$data.containsKey('level')) {
      final l$level = level;
      result$data['level'] = l$level?.toJson();
    }
    if (_$data.containsKey('isTransferred')) {
      final l$isTransferred = isTransferred;
      result$data['isTransferred'] = l$isTransferred?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RoyaltySplitFilterInput<Input$RoyaltySplitFilterInput>
  get copyWith => CopyWith$Input$RoyaltySplitFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RoyaltySplitFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$artistRole = artistRole;
    final lOther$artistRole = other.artistRole;
    if (_$data.containsKey('artistRole') !=
        other._$data.containsKey('artistRole')) {
      return false;
    }
    if (l$artistRole != lOther$artistRole) {
      return false;
    }
    final l$percentage = percentage;
    final lOther$percentage = other.percentage;
    if (_$data.containsKey('percentage') !=
        other._$data.containsKey('percentage')) {
      return false;
    }
    if (l$percentage != lOther$percentage) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$level = level;
    final lOther$level = other.level;
    if (_$data.containsKey('level') != other._$data.containsKey('level')) {
      return false;
    }
    if (l$level != lOther$level) {
      return false;
    }
    final l$isTransferred = isTransferred;
    final lOther$isTransferred = other.isTransferred;
    if (_$data.containsKey('isTransferred') !=
        other._$data.containsKey('isTransferred')) {
      return false;
    }
    if (l$isTransferred != lOther$isTransferred) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$userId = userId;
    final l$artistRole = artistRole;
    final l$percentage = percentage;
    final l$amount = amount;
    final l$level = level;
    final l$isTransferred = isTransferred;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('artistRole') ? l$artistRole : const {},
      _$data.containsKey('percentage') ? l$percentage : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('level') ? l$level : const {},
      _$data.containsKey('isTransferred') ? l$isTransferred : const {},
    ]);
  }
}

abstract class CopyWith$Input$RoyaltySplitFilterInput<TRes> {
  factory CopyWith$Input$RoyaltySplitFilterInput(
    Input$RoyaltySplitFilterInput instance,
    TRes Function(Input$RoyaltySplitFilterInput) then,
  ) = _CopyWithImpl$Input$RoyaltySplitFilterInput;

  factory CopyWith$Input$RoyaltySplitFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RoyaltySplitFilterInput;

  TRes call({
    List<Input$RoyaltySplitFilterInput>? and,
    List<Input$RoyaltySplitFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$ArtistRoleOperationFilterInput? artistRole,
    Input$DecimalOperationFilterInput? percentage,
    Input$DecimalOperationFilterInput? amount,
    Input$AggregationLevelOperationFilterInput? level,
    Input$BooleanOperationFilterInput? isTransferred,
  });
  TRes and(
    Iterable<Input$RoyaltySplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltySplitFilterInput<Input$RoyaltySplitFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$RoyaltySplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltySplitFilterInput<Input$RoyaltySplitFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get userId;
  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get artistRole;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentage;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount;
  CopyWith$Input$AggregationLevelOperationFilterInput<TRes> get level;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isTransferred;
}

class _CopyWithImpl$Input$RoyaltySplitFilterInput<TRes>
    implements CopyWith$Input$RoyaltySplitFilterInput<TRes> {
  _CopyWithImpl$Input$RoyaltySplitFilterInput(this._instance, this._then);

  final Input$RoyaltySplitFilterInput _instance;

  final TRes Function(Input$RoyaltySplitFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? userId = _undefined,
    Object? artistRole = _undefined,
    Object? percentage = _undefined,
    Object? amount = _undefined,
    Object? level = _undefined,
    Object? isTransferred = _undefined,
  }) => _then(
    Input$RoyaltySplitFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$RoyaltySplitFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$RoyaltySplitFilterInput>?),
      if (userId != _undefined)
        'userId': (userId as Input$StringOperationFilterInput?),
      if (artistRole != _undefined)
        'artistRole': (artistRole as Input$ArtistRoleOperationFilterInput?),
      if (percentage != _undefined)
        'percentage': (percentage as Input$DecimalOperationFilterInput?),
      if (amount != _undefined)
        'amount': (amount as Input$DecimalOperationFilterInput?),
      if (level != _undefined)
        'level': (level as Input$AggregationLevelOperationFilterInput?),
      if (isTransferred != _undefined)
        'isTransferred': (isTransferred as Input$BooleanOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$RoyaltySplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltySplitFilterInput<Input$RoyaltySplitFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$RoyaltySplitFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$RoyaltySplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$RoyaltySplitFilterInput<Input$RoyaltySplitFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$RoyaltySplitFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userId,
            (e) => call(userId: e),
          );
  }

  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get artistRole {
    final local$artistRole = _instance.artistRole;
    return local$artistRole == null
        ? CopyWith$Input$ArtistRoleOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ArtistRoleOperationFilterInput(
            local$artistRole,
            (e) => call(artistRole: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentage {
    final local$percentage = _instance.percentage;
    return local$percentage == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$percentage,
            (e) => call(percentage: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount {
    final local$amount = _instance.amount;
    return local$amount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$amount,
            (e) => call(amount: e),
          );
  }

  CopyWith$Input$AggregationLevelOperationFilterInput<TRes> get level {
    final local$level = _instance.level;
    return local$level == null
        ? CopyWith$Input$AggregationLevelOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$AggregationLevelOperationFilterInput(
            local$level,
            (e) => call(level: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isTransferred {
    final local$isTransferred = _instance.isTransferred;
    return local$isTransferred == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isTransferred,
            (e) => call(isTransferred: e),
          );
  }
}

class _CopyWithStubImpl$Input$RoyaltySplitFilterInput<TRes>
    implements CopyWith$Input$RoyaltySplitFilterInput<TRes> {
  _CopyWithStubImpl$Input$RoyaltySplitFilterInput(this._res);

  TRes _res;

  call({
    List<Input$RoyaltySplitFilterInput>? and,
    List<Input$RoyaltySplitFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$ArtistRoleOperationFilterInput? artistRole,
    Input$DecimalOperationFilterInput? percentage,
    Input$DecimalOperationFilterInput? amount,
    Input$AggregationLevelOperationFilterInput? level,
    Input$BooleanOperationFilterInput? isTransferred,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get userId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get artistRole =>
      CopyWith$Input$ArtistRoleOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentage =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$AggregationLevelOperationFilterInput<TRes> get level =>
      CopyWith$Input$AggregationLevelOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isTransferred =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);
}

class Input$StringOperationFilterInput {
  factory Input$StringOperationFilterInput({
    List<Input$StringOperationFilterInput>? and,
    List<Input$StringOperationFilterInput>? or,
    String? eq,
    String? neq,
    String? contains,
    String? ncontains,
    List<String?>? $in,
    List<String?>? nin,
    String? startsWith,
    String? nstartsWith,
    String? endsWith,
    String? nendsWith,
  }) => Input$StringOperationFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if (contains != null) r'contains': contains,
    if (ncontains != null) r'ncontains': ncontains,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
    if (startsWith != null) r'startsWith': startsWith,
    if (nstartsWith != null) r'nstartsWith': nstartsWith,
    if (endsWith != null) r'endsWith': endsWith,
    if (nendsWith != null) r'nendsWith': nendsWith,
  });

  Input$StringOperationFilterInput._(this._$data);

  factory Input$StringOperationFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$StringOperationFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$StringOperationFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = (l$eq as String?);
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = (l$neq as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('ncontains')) {
      final l$ncontains = data['ncontains'];
      result$data['ncontains'] = (l$ncontains as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('nstartsWith')) {
      final l$nstartsWith = data['nstartsWith'];
      result$data['nstartsWith'] = (l$nstartsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('nendsWith')) {
      final l$nendsWith = data['nendsWith'];
      result$data['nendsWith'] = (l$nendsWith as String?);
    }
    return Input$StringOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$StringOperationFilterInput>? get and =>
      (_$data['and'] as List<Input$StringOperationFilterInput>?);

  List<Input$StringOperationFilterInput>? get or =>
      (_$data['or'] as List<Input$StringOperationFilterInput>?);

  String? get eq => (_$data['eq'] as String?);

  String? get neq => (_$data['neq'] as String?);

  String? get contains => (_$data['contains'] as String?);

  String? get ncontains => (_$data['ncontains'] as String?);

  List<String?>? get $in => (_$data['in'] as List<String?>?);

  List<String?>? get nin => (_$data['nin'] as List<String?>?);

  String? get startsWith => (_$data['startsWith'] as String?);

  String? get nstartsWith => (_$data['nstartsWith'] as String?);

  String? get endsWith => (_$data['endsWith'] as String?);

  String? get nendsWith => (_$data['nendsWith'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq;
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('ncontains')) {
      final l$ncontains = ncontains;
      result$data['ncontains'] = l$ncontains;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('nstartsWith')) {
      final l$nstartsWith = nstartsWith;
      result$data['nstartsWith'] = l$nstartsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('nendsWith')) {
      final l$nendsWith = nendsWith;
      result$data['nendsWith'] = l$nendsWith;
    }
    return result$data;
  }

  CopyWith$Input$StringOperationFilterInput<Input$StringOperationFilterInput>
  get copyWith => CopyWith$Input$StringOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StringOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$ncontains = ncontains;
    final lOther$ncontains = other.ncontains;
    if (_$data.containsKey('ncontains') !=
        other._$data.containsKey('ncontains')) {
      return false;
    }
    if (l$ncontains != lOther$ncontains) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$nstartsWith = nstartsWith;
    final lOther$nstartsWith = other.nstartsWith;
    if (_$data.containsKey('nstartsWith') !=
        other._$data.containsKey('nstartsWith')) {
      return false;
    }
    if (l$nstartsWith != lOther$nstartsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$nendsWith = nendsWith;
    final lOther$nendsWith = other.nendsWith;
    if (_$data.containsKey('nendsWith') !=
        other._$data.containsKey('nendsWith')) {
      return false;
    }
    if (l$nendsWith != lOther$nendsWith) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$eq = eq;
    final l$neq = neq;
    final l$contains = contains;
    final l$ncontains = ncontains;
    final l$$in = $in;
    final l$nin = nin;
    final l$startsWith = startsWith;
    final l$nstartsWith = nstartsWith;
    final l$endsWith = endsWith;
    final l$nendsWith = nendsWith;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('ncontains') ? l$ncontains : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('nstartsWith') ? l$nstartsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('nendsWith') ? l$nendsWith : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringOperationFilterInput<TRes> {
  factory CopyWith$Input$StringOperationFilterInput(
    Input$StringOperationFilterInput instance,
    TRes Function(Input$StringOperationFilterInput) then,
  ) = _CopyWithImpl$Input$StringOperationFilterInput;

  factory CopyWith$Input$StringOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StringOperationFilterInput;

  TRes call({
    List<Input$StringOperationFilterInput>? and,
    List<Input$StringOperationFilterInput>? or,
    String? eq,
    String? neq,
    String? contains,
    String? ncontains,
    List<String?>? $in,
    List<String?>? nin,
    String? startsWith,
    String? nstartsWith,
    String? endsWith,
    String? nendsWith,
  });
  TRes and(
    Iterable<Input$StringOperationFilterInput>? Function(
      Iterable<
        CopyWith$Input$StringOperationFilterInput<
          Input$StringOperationFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$StringOperationFilterInput>? Function(
      Iterable<
        CopyWith$Input$StringOperationFilterInput<
          Input$StringOperationFilterInput
        >
      >?,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$StringOperationFilterInput<TRes>
    implements CopyWith$Input$StringOperationFilterInput<TRes> {
  _CopyWithImpl$Input$StringOperationFilterInput(this._instance, this._then);

  final Input$StringOperationFilterInput _instance;

  final TRes Function(Input$StringOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? contains = _undefined,
    Object? ncontains = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
    Object? startsWith = _undefined,
    Object? nstartsWith = _undefined,
    Object? endsWith = _undefined,
    Object? nendsWith = _undefined,
  }) => _then(
    Input$StringOperationFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$StringOperationFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$StringOperationFilterInput>?),
      if (eq != _undefined) 'eq': (eq as String?),
      if (neq != _undefined) 'neq': (neq as String?),
      if (contains != _undefined) 'contains': (contains as String?),
      if (ncontains != _undefined) 'ncontains': (ncontains as String?),
      if ($in != _undefined) 'in': ($in as List<String?>?),
      if (nin != _undefined) 'nin': (nin as List<String?>?),
      if (startsWith != _undefined) 'startsWith': (startsWith as String?),
      if (nstartsWith != _undefined) 'nstartsWith': (nstartsWith as String?),
      if (endsWith != _undefined) 'endsWith': (endsWith as String?),
      if (nendsWith != _undefined) 'nendsWith': (nendsWith as String?),
    }),
  );

  TRes and(
    Iterable<Input$StringOperationFilterInput>? Function(
      Iterable<
        CopyWith$Input$StringOperationFilterInput<
          Input$StringOperationFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$StringOperationFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$StringOperationFilterInput>? Function(
      Iterable<
        CopyWith$Input$StringOperationFilterInput<
          Input$StringOperationFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$StringOperationFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );
}

class _CopyWithStubImpl$Input$StringOperationFilterInput<TRes>
    implements CopyWith$Input$StringOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$StringOperationFilterInput(this._res);

  TRes _res;

  call({
    List<Input$StringOperationFilterInput>? and,
    List<Input$StringOperationFilterInput>? or,
    String? eq,
    String? neq,
    String? contains,
    String? ncontains,
    List<String?>? $in,
    List<String?>? nin,
    String? startsWith,
    String? nstartsWith,
    String? endsWith,
    String? nendsWith,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;
}

class Input$StripeProductRequestInput {
  factory Input$StripeProductRequestInput({
    required String id,
    required List<String> stripePriceIds,
  }) => Input$StripeProductRequestInput._({
    r'id': id,
    r'stripePriceIds': stripePriceIds,
  });

  Input$StripeProductRequestInput._(this._$data);

  factory Input$StripeProductRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$stripePriceIds = data['stripePriceIds'];
    result$data['stripePriceIds'] = (l$stripePriceIds as List<dynamic>)
        .map((e) => (e as String))
        .toList();
    return Input$StripeProductRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  List<String> get stripePriceIds => (_$data['stripePriceIds'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$stripePriceIds = stripePriceIds;
    result$data['stripePriceIds'] = l$stripePriceIds.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$StripeProductRequestInput<Input$StripeProductRequestInput>
  get copyWith => CopyWith$Input$StripeProductRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StripeProductRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$stripePriceIds = stripePriceIds;
    final lOther$stripePriceIds = other.stripePriceIds;
    if (l$stripePriceIds.length != lOther$stripePriceIds.length) {
      return false;
    }
    for (int i = 0; i < l$stripePriceIds.length; i++) {
      final l$stripePriceIds$entry = l$stripePriceIds[i];
      final lOther$stripePriceIds$entry = lOther$stripePriceIds[i];
      if (l$stripePriceIds$entry != lOther$stripePriceIds$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$stripePriceIds = stripePriceIds;
    return Object.hashAll([
      l$id,
      Object.hashAll(l$stripePriceIds.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$StripeProductRequestInput<TRes> {
  factory CopyWith$Input$StripeProductRequestInput(
    Input$StripeProductRequestInput instance,
    TRes Function(Input$StripeProductRequestInput) then,
  ) = _CopyWithImpl$Input$StripeProductRequestInput;

  factory CopyWith$Input$StripeProductRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StripeProductRequestInput;

  TRes call({String? id, List<String>? stripePriceIds});
}

class _CopyWithImpl$Input$StripeProductRequestInput<TRes>
    implements CopyWith$Input$StripeProductRequestInput<TRes> {
  _CopyWithImpl$Input$StripeProductRequestInput(this._instance, this._then);

  final Input$StripeProductRequestInput _instance;

  final TRes Function(Input$StripeProductRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined, Object? stripePriceIds = _undefined}) =>
      _then(
        Input$StripeProductRequestInput._({
          ..._instance._$data,
          if (id != _undefined && id != null) 'id': (id as String),
          if (stripePriceIds != _undefined && stripePriceIds != null)
            'stripePriceIds': (stripePriceIds as List<String>),
        }),
      );
}

class _CopyWithStubImpl$Input$StripeProductRequestInput<TRes>
    implements CopyWith$Input$StripeProductRequestInput<TRes> {
  _CopyWithStubImpl$Input$StripeProductRequestInput(this._res);

  TRes _res;

  call({String? id, List<String>? stripePriceIds}) => _res;
}

class Input$SubmitDeliveryRequestInput {
  factory Input$SubmitDeliveryRequestInput({
    required String packageOrderId,
    required String deliveryFileUrl,
    String? notes,
  }) => Input$SubmitDeliveryRequestInput._({
    r'packageOrderId': packageOrderId,
    r'deliveryFileUrl': deliveryFileUrl,
    if (notes != null) r'notes': notes,
  });

  Input$SubmitDeliveryRequestInput._(this._$data);

  factory Input$SubmitDeliveryRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$packageOrderId = data['packageOrderId'];
    result$data['packageOrderId'] = (l$packageOrderId as String);
    final l$deliveryFileUrl = data['deliveryFileUrl'];
    result$data['deliveryFileUrl'] = (l$deliveryFileUrl as String);
    if (data.containsKey('notes')) {
      final l$notes = data['notes'];
      result$data['notes'] = (l$notes as String?);
    }
    return Input$SubmitDeliveryRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get packageOrderId => (_$data['packageOrderId'] as String);

  String get deliveryFileUrl => (_$data['deliveryFileUrl'] as String);

  String? get notes => (_$data['notes'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$packageOrderId = packageOrderId;
    result$data['packageOrderId'] = l$packageOrderId;
    final l$deliveryFileUrl = deliveryFileUrl;
    result$data['deliveryFileUrl'] = l$deliveryFileUrl;
    if (_$data.containsKey('notes')) {
      final l$notes = notes;
      result$data['notes'] = l$notes;
    }
    return result$data;
  }

  CopyWith$Input$SubmitDeliveryRequestInput<Input$SubmitDeliveryRequestInput>
  get copyWith => CopyWith$Input$SubmitDeliveryRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SubmitDeliveryRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$packageOrderId = packageOrderId;
    final lOther$packageOrderId = other.packageOrderId;
    if (l$packageOrderId != lOther$packageOrderId) {
      return false;
    }
    final l$deliveryFileUrl = deliveryFileUrl;
    final lOther$deliveryFileUrl = other.deliveryFileUrl;
    if (l$deliveryFileUrl != lOther$deliveryFileUrl) {
      return false;
    }
    final l$notes = notes;
    final lOther$notes = other.notes;
    if (_$data.containsKey('notes') != other._$data.containsKey('notes')) {
      return false;
    }
    if (l$notes != lOther$notes) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$packageOrderId = packageOrderId;
    final l$deliveryFileUrl = deliveryFileUrl;
    final l$notes = notes;
    return Object.hashAll([
      l$packageOrderId,
      l$deliveryFileUrl,
      _$data.containsKey('notes') ? l$notes : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubmitDeliveryRequestInput<TRes> {
  factory CopyWith$Input$SubmitDeliveryRequestInput(
    Input$SubmitDeliveryRequestInput instance,
    TRes Function(Input$SubmitDeliveryRequestInput) then,
  ) = _CopyWithImpl$Input$SubmitDeliveryRequestInput;

  factory CopyWith$Input$SubmitDeliveryRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubmitDeliveryRequestInput;

  TRes call({String? packageOrderId, String? deliveryFileUrl, String? notes});
}

class _CopyWithImpl$Input$SubmitDeliveryRequestInput<TRes>
    implements CopyWith$Input$SubmitDeliveryRequestInput<TRes> {
  _CopyWithImpl$Input$SubmitDeliveryRequestInput(this._instance, this._then);

  final Input$SubmitDeliveryRequestInput _instance;

  final TRes Function(Input$SubmitDeliveryRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? packageOrderId = _undefined,
    Object? deliveryFileUrl = _undefined,
    Object? notes = _undefined,
  }) => _then(
    Input$SubmitDeliveryRequestInput._({
      ..._instance._$data,
      if (packageOrderId != _undefined && packageOrderId != null)
        'packageOrderId': (packageOrderId as String),
      if (deliveryFileUrl != _undefined && deliveryFileUrl != null)
        'deliveryFileUrl': (deliveryFileUrl as String),
      if (notes != _undefined) 'notes': (notes as String?),
    }),
  );
}

class _CopyWithStubImpl$Input$SubmitDeliveryRequestInput<TRes>
    implements CopyWith$Input$SubmitDeliveryRequestInput<TRes> {
  _CopyWithStubImpl$Input$SubmitDeliveryRequestInput(this._res);

  TRes _res;

  call({String? packageOrderId, String? deliveryFileUrl, String? notes}) =>
      _res;
}

class Input$SubscriptionFilterInput {
  factory Input$SubscriptionFilterInput({
    List<Input$SubscriptionFilterInput>? and,
    List<Input$SubscriptionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? code,
    Input$IntOperationFilterInput? version,
    Input$DecimalOperationFilterInput? amount,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$SubscriptionTierOperationFilterInput? tier,
    Input$SubscriptionStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$SubscriptionFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (description != null) r'description': description,
    if (code != null) r'code': code,
    if (version != null) r'version': version,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (tier != null) r'tier': tier,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$SubscriptionFilterInput._(this._$data);

  factory Input$SubscriptionFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$SubscriptionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$SubscriptionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('code')) {
      final l$code = data['code'];
      result$data['code'] = l$code == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$code as Map<String, dynamic>),
            );
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$version as Map<String, dynamic>),
            );
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$amount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : Input$CurrencyTypeOperationFilterInput.fromJson(
              (l$currency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('tier')) {
      final l$tier = data['tier'];
      result$data['tier'] = l$tier == null
          ? null
          : Input$SubscriptionTierOperationFilterInput.fromJson(
              (l$tier as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$SubscriptionStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$SubscriptionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SubscriptionFilterInput>? get and =>
      (_$data['and'] as List<Input$SubscriptionFilterInput>?);

  List<Input$SubscriptionFilterInput>? get or =>
      (_$data['or'] as List<Input$SubscriptionFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get code =>
      (_$data['code'] as Input$StringOperationFilterInput?);

  Input$IntOperationFilterInput? get version =>
      (_$data['version'] as Input$IntOperationFilterInput?);

  Input$DecimalOperationFilterInput? get amount =>
      (_$data['amount'] as Input$DecimalOperationFilterInput?);

  Input$CurrencyTypeOperationFilterInput? get currency =>
      (_$data['currency'] as Input$CurrencyTypeOperationFilterInput?);

  Input$SubscriptionTierOperationFilterInput? get tier =>
      (_$data['tier'] as Input$SubscriptionTierOperationFilterInput?);

  Input$SubscriptionStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$SubscriptionStatusOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('code')) {
      final l$code = code;
      result$data['code'] = l$code?.toJson();
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version?.toJson();
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount?.toJson();
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency?.toJson();
    }
    if (_$data.containsKey('tier')) {
      final l$tier = tier;
      result$data['tier'] = l$tier?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SubscriptionFilterInput<Input$SubscriptionFilterInput>
  get copyWith => CopyWith$Input$SubscriptionFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SubscriptionFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (_$data.containsKey('code') != other._$data.containsKey('code')) {
      return false;
    }
    if (l$code != lOther$code) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$tier = tier;
    final lOther$tier = other.tier;
    if (_$data.containsKey('tier') != other._$data.containsKey('tier')) {
      return false;
    }
    if (l$tier != lOther$tier) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$name = name;
    final l$description = description;
    final l$code = code;
    final l$version = version;
    final l$amount = amount;
    final l$currency = currency;
    final l$tier = tier;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('code') ? l$code : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('tier') ? l$tier : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubscriptionFilterInput<TRes> {
  factory CopyWith$Input$SubscriptionFilterInput(
    Input$SubscriptionFilterInput instance,
    TRes Function(Input$SubscriptionFilterInput) then,
  ) = _CopyWithImpl$Input$SubscriptionFilterInput;

  factory CopyWith$Input$SubscriptionFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubscriptionFilterInput;

  TRes call({
    List<Input$SubscriptionFilterInput>? and,
    List<Input$SubscriptionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? code,
    Input$IntOperationFilterInput? version,
    Input$DecimalOperationFilterInput? amount,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$SubscriptionTierOperationFilterInput? tier,
    Input$SubscriptionStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$SubscriptionFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionFilterInput<Input$SubscriptionFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$SubscriptionFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionFilterInput<Input$SubscriptionFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$StringOperationFilterInput<TRes> get code;
  CopyWith$Input$IntOperationFilterInput<TRes> get version;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount;
  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency;
  CopyWith$Input$SubscriptionTierOperationFilterInput<TRes> get tier;
  CopyWith$Input$SubscriptionStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$SubscriptionFilterInput<TRes>
    implements CopyWith$Input$SubscriptionFilterInput<TRes> {
  _CopyWithImpl$Input$SubscriptionFilterInput(this._instance, this._then);

  final Input$SubscriptionFilterInput _instance;

  final TRes Function(Input$SubscriptionFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? code = _undefined,
    Object? version = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? tier = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$SubscriptionFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$SubscriptionFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$SubscriptionFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (name != _undefined)
        'name': (name as Input$StringOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (code != _undefined)
        'code': (code as Input$StringOperationFilterInput?),
      if (version != _undefined)
        'version': (version as Input$IntOperationFilterInput?),
      if (amount != _undefined)
        'amount': (amount as Input$DecimalOperationFilterInput?),
      if (currency != _undefined)
        'currency': (currency as Input$CurrencyTypeOperationFilterInput?),
      if (tier != _undefined)
        'tier': (tier as Input$SubscriptionTierOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$SubscriptionStatusOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$SubscriptionFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionFilterInput<Input$SubscriptionFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$SubscriptionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$SubscriptionFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionFilterInput<Input$SubscriptionFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$SubscriptionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name,
            (e) => call(name: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get code {
    final local$code = _instance.code;
    return local$code == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$code,
            (e) => call(code: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get version {
    final local$version = _instance.version;
    return local$version == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$version,
            (e) => call(version: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount {
    final local$amount = _instance.amount;
    return local$amount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$amount,
            (e) => call(amount: e),
          );
  }

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency {
    final local$currency = _instance.currency;
    return local$currency == null
        ? CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CurrencyTypeOperationFilterInput(
            local$currency,
            (e) => call(currency: e),
          );
  }

  CopyWith$Input$SubscriptionTierOperationFilterInput<TRes> get tier {
    final local$tier = _instance.tier;
    return local$tier == null
        ? CopyWith$Input$SubscriptionTierOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$SubscriptionTierOperationFilterInput(
            local$tier,
            (e) => call(tier: e),
          );
  }

  CopyWith$Input$SubscriptionStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$SubscriptionStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$SubscriptionStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$SubscriptionFilterInput<TRes>
    implements CopyWith$Input$SubscriptionFilterInput<TRes> {
  _CopyWithStubImpl$Input$SubscriptionFilterInput(this._res);

  TRes _res;

  call({
    List<Input$SubscriptionFilterInput>? and,
    List<Input$SubscriptionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? description,
    Input$StringOperationFilterInput? code,
    Input$IntOperationFilterInput? version,
    Input$DecimalOperationFilterInput? amount,
    Input$CurrencyTypeOperationFilterInput? currency,
    Input$SubscriptionTierOperationFilterInput? tier,
    Input$SubscriptionStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get code =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get version =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get amount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes> get currency =>
      CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_res);

  CopyWith$Input$SubscriptionTierOperationFilterInput<TRes> get tier =>
      CopyWith$Input$SubscriptionTierOperationFilterInput.stub(_res);

  CopyWith$Input$SubscriptionStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$SubscriptionStatusOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$SubscriptionPlanFilterInput {
  factory Input$SubscriptionPlanFilterInput({
    List<Input$SubscriptionPlanFilterInput>? and,
    List<Input$SubscriptionPlanFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? subscriptionId,
    Input$StringOperationFilterInput? stripeProductId,
    Input$BooleanOperationFilterInput? stripeProductActive,
    Input$StringOperationFilterInput? stripeProductName,
    Input$ListStringOperationFilterInput? stripeProductImages,
    Input$StringOperationFilterInput? stripeProductType,
    Input$ListFilterInputTypeOfMetadataFilterInput? stripeProductMetadata,
    Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?
    subscriptionPlanPrices,
  }) => Input$SubscriptionPlanFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (subscriptionId != null) r'subscriptionId': subscriptionId,
    if (stripeProductId != null) r'stripeProductId': stripeProductId,
    if (stripeProductActive != null)
      r'stripeProductActive': stripeProductActive,
    if (stripeProductName != null) r'stripeProductName': stripeProductName,
    if (stripeProductImages != null)
      r'stripeProductImages': stripeProductImages,
    if (stripeProductType != null) r'stripeProductType': stripeProductType,
    if (stripeProductMetadata != null)
      r'stripeProductMetadata': stripeProductMetadata,
    if (subscriptionPlanPrices != null)
      r'subscriptionPlanPrices': subscriptionPlanPrices,
  });

  Input$SubscriptionPlanFilterInput._(this._$data);

  factory Input$SubscriptionPlanFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$SubscriptionPlanFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$SubscriptionPlanFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionId')) {
      final l$subscriptionId = data['subscriptionId'];
      result$data['subscriptionId'] = l$subscriptionId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$subscriptionId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductId')) {
      final l$stripeProductId = data['stripeProductId'];
      result$data['stripeProductId'] = l$stripeProductId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeProductId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductActive')) {
      final l$stripeProductActive = data['stripeProductActive'];
      result$data['stripeProductActive'] = l$stripeProductActive == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$stripeProductActive as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductName')) {
      final l$stripeProductName = data['stripeProductName'];
      result$data['stripeProductName'] = l$stripeProductName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeProductName as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductImages')) {
      final l$stripeProductImages = data['stripeProductImages'];
      result$data['stripeProductImages'] = l$stripeProductImages == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$stripeProductImages as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductType')) {
      final l$stripeProductType = data['stripeProductType'];
      result$data['stripeProductType'] = l$stripeProductType == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeProductType as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductMetadata')) {
      final l$stripeProductMetadata = data['stripeProductMetadata'];
      result$data['stripeProductMetadata'] = l$stripeProductMetadata == null
          ? null
          : Input$ListFilterInputTypeOfMetadataFilterInput.fromJson(
              (l$stripeProductMetadata as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionPlanPrices')) {
      final l$subscriptionPlanPrices = data['subscriptionPlanPrices'];
      result$data['subscriptionPlanPrices'] = l$subscriptionPlanPrices == null
          ? null
          : Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput.fromJson(
              (l$subscriptionPlanPrices as Map<String, dynamic>),
            );
    }
    return Input$SubscriptionPlanFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SubscriptionPlanFilterInput>? get and =>
      (_$data['and'] as List<Input$SubscriptionPlanFilterInput>?);

  List<Input$SubscriptionPlanFilterInput>? get or =>
      (_$data['or'] as List<Input$SubscriptionPlanFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get subscriptionId =>
      (_$data['subscriptionId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeProductId =>
      (_$data['stripeProductId'] as Input$StringOperationFilterInput?);

  Input$BooleanOperationFilterInput? get stripeProductActive =>
      (_$data['stripeProductActive'] as Input$BooleanOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeProductName =>
      (_$data['stripeProductName'] as Input$StringOperationFilterInput?);

  Input$ListStringOperationFilterInput? get stripeProductImages =>
      (_$data['stripeProductImages'] as Input$ListStringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeProductType =>
      (_$data['stripeProductType'] as Input$StringOperationFilterInput?);

  Input$ListFilterInputTypeOfMetadataFilterInput? get stripeProductMetadata =>
      (_$data['stripeProductMetadata']
          as Input$ListFilterInputTypeOfMetadataFilterInput?);

  Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?
  get subscriptionPlanPrices =>
      (_$data['subscriptionPlanPrices']
          as Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('subscriptionId')) {
      final l$subscriptionId = subscriptionId;
      result$data['subscriptionId'] = l$subscriptionId?.toJson();
    }
    if (_$data.containsKey('stripeProductId')) {
      final l$stripeProductId = stripeProductId;
      result$data['stripeProductId'] = l$stripeProductId?.toJson();
    }
    if (_$data.containsKey('stripeProductActive')) {
      final l$stripeProductActive = stripeProductActive;
      result$data['stripeProductActive'] = l$stripeProductActive?.toJson();
    }
    if (_$data.containsKey('stripeProductName')) {
      final l$stripeProductName = stripeProductName;
      result$data['stripeProductName'] = l$stripeProductName?.toJson();
    }
    if (_$data.containsKey('stripeProductImages')) {
      final l$stripeProductImages = stripeProductImages;
      result$data['stripeProductImages'] = l$stripeProductImages?.toJson();
    }
    if (_$data.containsKey('stripeProductType')) {
      final l$stripeProductType = stripeProductType;
      result$data['stripeProductType'] = l$stripeProductType?.toJson();
    }
    if (_$data.containsKey('stripeProductMetadata')) {
      final l$stripeProductMetadata = stripeProductMetadata;
      result$data['stripeProductMetadata'] = l$stripeProductMetadata?.toJson();
    }
    if (_$data.containsKey('subscriptionPlanPrices')) {
      final l$subscriptionPlanPrices = subscriptionPlanPrices;
      result$data['subscriptionPlanPrices'] = l$subscriptionPlanPrices
          ?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SubscriptionPlanFilterInput<Input$SubscriptionPlanFilterInput>
  get copyWith => CopyWith$Input$SubscriptionPlanFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SubscriptionPlanFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$subscriptionId = subscriptionId;
    final lOther$subscriptionId = other.subscriptionId;
    if (_$data.containsKey('subscriptionId') !=
        other._$data.containsKey('subscriptionId')) {
      return false;
    }
    if (l$subscriptionId != lOther$subscriptionId) {
      return false;
    }
    final l$stripeProductId = stripeProductId;
    final lOther$stripeProductId = other.stripeProductId;
    if (_$data.containsKey('stripeProductId') !=
        other._$data.containsKey('stripeProductId')) {
      return false;
    }
    if (l$stripeProductId != lOther$stripeProductId) {
      return false;
    }
    final l$stripeProductActive = stripeProductActive;
    final lOther$stripeProductActive = other.stripeProductActive;
    if (_$data.containsKey('stripeProductActive') !=
        other._$data.containsKey('stripeProductActive')) {
      return false;
    }
    if (l$stripeProductActive != lOther$stripeProductActive) {
      return false;
    }
    final l$stripeProductName = stripeProductName;
    final lOther$stripeProductName = other.stripeProductName;
    if (_$data.containsKey('stripeProductName') !=
        other._$data.containsKey('stripeProductName')) {
      return false;
    }
    if (l$stripeProductName != lOther$stripeProductName) {
      return false;
    }
    final l$stripeProductImages = stripeProductImages;
    final lOther$stripeProductImages = other.stripeProductImages;
    if (_$data.containsKey('stripeProductImages') !=
        other._$data.containsKey('stripeProductImages')) {
      return false;
    }
    if (l$stripeProductImages != lOther$stripeProductImages) {
      return false;
    }
    final l$stripeProductType = stripeProductType;
    final lOther$stripeProductType = other.stripeProductType;
    if (_$data.containsKey('stripeProductType') !=
        other._$data.containsKey('stripeProductType')) {
      return false;
    }
    if (l$stripeProductType != lOther$stripeProductType) {
      return false;
    }
    final l$stripeProductMetadata = stripeProductMetadata;
    final lOther$stripeProductMetadata = other.stripeProductMetadata;
    if (_$data.containsKey('stripeProductMetadata') !=
        other._$data.containsKey('stripeProductMetadata')) {
      return false;
    }
    if (l$stripeProductMetadata != lOther$stripeProductMetadata) {
      return false;
    }
    final l$subscriptionPlanPrices = subscriptionPlanPrices;
    final lOther$subscriptionPlanPrices = other.subscriptionPlanPrices;
    if (_$data.containsKey('subscriptionPlanPrices') !=
        other._$data.containsKey('subscriptionPlanPrices')) {
      return false;
    }
    if (l$subscriptionPlanPrices != lOther$subscriptionPlanPrices) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$subscriptionId = subscriptionId;
    final l$stripeProductId = stripeProductId;
    final l$stripeProductActive = stripeProductActive;
    final l$stripeProductName = stripeProductName;
    final l$stripeProductImages = stripeProductImages;
    final l$stripeProductType = stripeProductType;
    final l$stripeProductMetadata = stripeProductMetadata;
    final l$subscriptionPlanPrices = subscriptionPlanPrices;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('subscriptionId') ? l$subscriptionId : const {},
      _$data.containsKey('stripeProductId') ? l$stripeProductId : const {},
      _$data.containsKey('stripeProductActive')
          ? l$stripeProductActive
          : const {},
      _$data.containsKey('stripeProductName') ? l$stripeProductName : const {},
      _$data.containsKey('stripeProductImages')
          ? l$stripeProductImages
          : const {},
      _$data.containsKey('stripeProductType') ? l$stripeProductType : const {},
      _$data.containsKey('stripeProductMetadata')
          ? l$stripeProductMetadata
          : const {},
      _$data.containsKey('subscriptionPlanPrices')
          ? l$subscriptionPlanPrices
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubscriptionPlanFilterInput<TRes> {
  factory CopyWith$Input$SubscriptionPlanFilterInput(
    Input$SubscriptionPlanFilterInput instance,
    TRes Function(Input$SubscriptionPlanFilterInput) then,
  ) = _CopyWithImpl$Input$SubscriptionPlanFilterInput;

  factory CopyWith$Input$SubscriptionPlanFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubscriptionPlanFilterInput;

  TRes call({
    List<Input$SubscriptionPlanFilterInput>? and,
    List<Input$SubscriptionPlanFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? subscriptionId,
    Input$StringOperationFilterInput? stripeProductId,
    Input$BooleanOperationFilterInput? stripeProductActive,
    Input$StringOperationFilterInput? stripeProductName,
    Input$ListStringOperationFilterInput? stripeProductImages,
    Input$StringOperationFilterInput? stripeProductType,
    Input$ListFilterInputTypeOfMetadataFilterInput? stripeProductMetadata,
    Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?
    subscriptionPlanPrices,
  });
  TRes and(
    Iterable<Input$SubscriptionPlanFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionPlanFilterInput<
          Input$SubscriptionPlanFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$SubscriptionPlanFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionPlanFilterInput<
          Input$SubscriptionPlanFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionId;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductId;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get stripeProductActive;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductName;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get stripeProductImages;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductType;
  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get stripeProductMetadata;
  CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<TRes>
  get subscriptionPlanPrices;
}

class _CopyWithImpl$Input$SubscriptionPlanFilterInput<TRes>
    implements CopyWith$Input$SubscriptionPlanFilterInput<TRes> {
  _CopyWithImpl$Input$SubscriptionPlanFilterInput(this._instance, this._then);

  final Input$SubscriptionPlanFilterInput _instance;

  final TRes Function(Input$SubscriptionPlanFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? subscriptionId = _undefined,
    Object? stripeProductId = _undefined,
    Object? stripeProductActive = _undefined,
    Object? stripeProductName = _undefined,
    Object? stripeProductImages = _undefined,
    Object? stripeProductType = _undefined,
    Object? stripeProductMetadata = _undefined,
    Object? subscriptionPlanPrices = _undefined,
  }) => _then(
    Input$SubscriptionPlanFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$SubscriptionPlanFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$SubscriptionPlanFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (subscriptionId != _undefined)
        'subscriptionId': (subscriptionId as Input$StringOperationFilterInput?),
      if (stripeProductId != _undefined)
        'stripeProductId':
            (stripeProductId as Input$StringOperationFilterInput?),
      if (stripeProductActive != _undefined)
        'stripeProductActive':
            (stripeProductActive as Input$BooleanOperationFilterInput?),
      if (stripeProductName != _undefined)
        'stripeProductName':
            (stripeProductName as Input$StringOperationFilterInput?),
      if (stripeProductImages != _undefined)
        'stripeProductImages':
            (stripeProductImages as Input$ListStringOperationFilterInput?),
      if (stripeProductType != _undefined)
        'stripeProductType':
            (stripeProductType as Input$StringOperationFilterInput?),
      if (stripeProductMetadata != _undefined)
        'stripeProductMetadata':
            (stripeProductMetadata
                as Input$ListFilterInputTypeOfMetadataFilterInput?),
      if (subscriptionPlanPrices != _undefined)
        'subscriptionPlanPrices':
            (subscriptionPlanPrices
                as Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$SubscriptionPlanFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionPlanFilterInput<
          Input$SubscriptionPlanFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$SubscriptionPlanFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$SubscriptionPlanFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionPlanFilterInput<
          Input$SubscriptionPlanFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$SubscriptionPlanFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionId {
    final local$subscriptionId = _instance.subscriptionId;
    return local$subscriptionId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$subscriptionId,
            (e) => call(subscriptionId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductId {
    final local$stripeProductId = _instance.stripeProductId;
    return local$stripeProductId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeProductId,
            (e) => call(stripeProductId: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get stripeProductActive {
    final local$stripeProductActive = _instance.stripeProductActive;
    return local$stripeProductActive == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$stripeProductActive,
            (e) => call(stripeProductActive: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductName {
    final local$stripeProductName = _instance.stripeProductName;
    return local$stripeProductName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeProductName,
            (e) => call(stripeProductName: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get stripeProductImages {
    final local$stripeProductImages = _instance.stripeProductImages;
    return local$stripeProductImages == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$stripeProductImages,
            (e) => call(stripeProductImages: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductType {
    final local$stripeProductType = _instance.stripeProductType;
    return local$stripeProductType == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeProductType,
            (e) => call(stripeProductType: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get stripeProductMetadata {
    final local$stripeProductMetadata = _instance.stripeProductMetadata;
    return local$stripeProductMetadata == null
        ? CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput(
            local$stripeProductMetadata,
            (e) => call(stripeProductMetadata: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<TRes>
  get subscriptionPlanPrices {
    final local$subscriptionPlanPrices = _instance.subscriptionPlanPrices;
    return local$subscriptionPlanPrices == null
        ? CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput(
            local$subscriptionPlanPrices,
            (e) => call(subscriptionPlanPrices: e),
          );
  }
}

class _CopyWithStubImpl$Input$SubscriptionPlanFilterInput<TRes>
    implements CopyWith$Input$SubscriptionPlanFilterInput<TRes> {
  _CopyWithStubImpl$Input$SubscriptionPlanFilterInput(this._res);

  TRes _res;

  call({
    List<Input$SubscriptionPlanFilterInput>? and,
    List<Input$SubscriptionPlanFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? subscriptionId,
    Input$StringOperationFilterInput? stripeProductId,
    Input$BooleanOperationFilterInput? stripeProductActive,
    Input$StringOperationFilterInput? stripeProductName,
    Input$ListStringOperationFilterInput? stripeProductImages,
    Input$StringOperationFilterInput? stripeProductType,
    Input$ListFilterInputTypeOfMetadataFilterInput? stripeProductMetadata,
    Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?
    subscriptionPlanPrices,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get stripeProductActive =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get stripeProductImages =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductType =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get stripeProductMetadata =>
      CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<TRes>
  get subscriptionPlanPrices =>
      CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput.stub(
        _res,
      );
}

class Input$SubscriptionPlanPriceFilterInput {
  factory Input$SubscriptionPlanPriceFilterInput({
    List<Input$SubscriptionPlanPriceFilterInput>? and,
    List<Input$SubscriptionPlanPriceFilterInput>? or,
    Input$StringOperationFilterInput? stripePriceId,
    Input$BooleanOperationFilterInput? stripePriceActive,
    Input$LongOperationFilterInput? stripePriceUnitAmount,
    Input$StringOperationFilterInput? stripePriceCurrency,
    Input$StringOperationFilterInput? stripePriceLookupKey,
    Input$ListFilterInputTypeOfMetadataFilterInput? stripePriceMetadata,
    Input$PeriodTimeOperationFilterInput? interval,
    Input$LongOperationFilterInput? intervalCount,
  }) => Input$SubscriptionPlanPriceFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (stripePriceId != null) r'stripePriceId': stripePriceId,
    if (stripePriceActive != null) r'stripePriceActive': stripePriceActive,
    if (stripePriceUnitAmount != null)
      r'stripePriceUnitAmount': stripePriceUnitAmount,
    if (stripePriceCurrency != null)
      r'stripePriceCurrency': stripePriceCurrency,
    if (stripePriceLookupKey != null)
      r'stripePriceLookupKey': stripePriceLookupKey,
    if (stripePriceMetadata != null)
      r'stripePriceMetadata': stripePriceMetadata,
    if (interval != null) r'interval': interval,
    if (intervalCount != null) r'intervalCount': intervalCount,
  });

  Input$SubscriptionPlanPriceFilterInput._(this._$data);

  factory Input$SubscriptionPlanPriceFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$SubscriptionPlanPriceFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$SubscriptionPlanPriceFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('stripePriceId')) {
      final l$stripePriceId = data['stripePriceId'];
      result$data['stripePriceId'] = l$stripePriceId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripePriceId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripePriceActive')) {
      final l$stripePriceActive = data['stripePriceActive'];
      result$data['stripePriceActive'] = l$stripePriceActive == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$stripePriceActive as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripePriceUnitAmount')) {
      final l$stripePriceUnitAmount = data['stripePriceUnitAmount'];
      result$data['stripePriceUnitAmount'] = l$stripePriceUnitAmount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$stripePriceUnitAmount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripePriceCurrency')) {
      final l$stripePriceCurrency = data['stripePriceCurrency'];
      result$data['stripePriceCurrency'] = l$stripePriceCurrency == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripePriceCurrency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripePriceLookupKey')) {
      final l$stripePriceLookupKey = data['stripePriceLookupKey'];
      result$data['stripePriceLookupKey'] = l$stripePriceLookupKey == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripePriceLookupKey as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripePriceMetadata')) {
      final l$stripePriceMetadata = data['stripePriceMetadata'];
      result$data['stripePriceMetadata'] = l$stripePriceMetadata == null
          ? null
          : Input$ListFilterInputTypeOfMetadataFilterInput.fromJson(
              (l$stripePriceMetadata as Map<String, dynamic>),
            );
    }
    if (data.containsKey('interval')) {
      final l$interval = data['interval'];
      result$data['interval'] = l$interval == null
          ? null
          : Input$PeriodTimeOperationFilterInput.fromJson(
              (l$interval as Map<String, dynamic>),
            );
    }
    if (data.containsKey('intervalCount')) {
      final l$intervalCount = data['intervalCount'];
      result$data['intervalCount'] = l$intervalCount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$intervalCount as Map<String, dynamic>),
            );
    }
    return Input$SubscriptionPlanPriceFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SubscriptionPlanPriceFilterInput>? get and =>
      (_$data['and'] as List<Input$SubscriptionPlanPriceFilterInput>?);

  List<Input$SubscriptionPlanPriceFilterInput>? get or =>
      (_$data['or'] as List<Input$SubscriptionPlanPriceFilterInput>?);

  Input$StringOperationFilterInput? get stripePriceId =>
      (_$data['stripePriceId'] as Input$StringOperationFilterInput?);

  Input$BooleanOperationFilterInput? get stripePriceActive =>
      (_$data['stripePriceActive'] as Input$BooleanOperationFilterInput?);

  Input$LongOperationFilterInput? get stripePriceUnitAmount =>
      (_$data['stripePriceUnitAmount'] as Input$LongOperationFilterInput?);

  Input$StringOperationFilterInput? get stripePriceCurrency =>
      (_$data['stripePriceCurrency'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripePriceLookupKey =>
      (_$data['stripePriceLookupKey'] as Input$StringOperationFilterInput?);

  Input$ListFilterInputTypeOfMetadataFilterInput? get stripePriceMetadata =>
      (_$data['stripePriceMetadata']
          as Input$ListFilterInputTypeOfMetadataFilterInput?);

  Input$PeriodTimeOperationFilterInput? get interval =>
      (_$data['interval'] as Input$PeriodTimeOperationFilterInput?);

  Input$LongOperationFilterInput? get intervalCount =>
      (_$data['intervalCount'] as Input$LongOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('stripePriceId')) {
      final l$stripePriceId = stripePriceId;
      result$data['stripePriceId'] = l$stripePriceId?.toJson();
    }
    if (_$data.containsKey('stripePriceActive')) {
      final l$stripePriceActive = stripePriceActive;
      result$data['stripePriceActive'] = l$stripePriceActive?.toJson();
    }
    if (_$data.containsKey('stripePriceUnitAmount')) {
      final l$stripePriceUnitAmount = stripePriceUnitAmount;
      result$data['stripePriceUnitAmount'] = l$stripePriceUnitAmount?.toJson();
    }
    if (_$data.containsKey('stripePriceCurrency')) {
      final l$stripePriceCurrency = stripePriceCurrency;
      result$data['stripePriceCurrency'] = l$stripePriceCurrency?.toJson();
    }
    if (_$data.containsKey('stripePriceLookupKey')) {
      final l$stripePriceLookupKey = stripePriceLookupKey;
      result$data['stripePriceLookupKey'] = l$stripePriceLookupKey?.toJson();
    }
    if (_$data.containsKey('stripePriceMetadata')) {
      final l$stripePriceMetadata = stripePriceMetadata;
      result$data['stripePriceMetadata'] = l$stripePriceMetadata?.toJson();
    }
    if (_$data.containsKey('interval')) {
      final l$interval = interval;
      result$data['interval'] = l$interval?.toJson();
    }
    if (_$data.containsKey('intervalCount')) {
      final l$intervalCount = intervalCount;
      result$data['intervalCount'] = l$intervalCount?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SubscriptionPlanPriceFilterInput<
    Input$SubscriptionPlanPriceFilterInput
  >
  get copyWith =>
      CopyWith$Input$SubscriptionPlanPriceFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SubscriptionPlanPriceFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$stripePriceId = stripePriceId;
    final lOther$stripePriceId = other.stripePriceId;
    if (_$data.containsKey('stripePriceId') !=
        other._$data.containsKey('stripePriceId')) {
      return false;
    }
    if (l$stripePriceId != lOther$stripePriceId) {
      return false;
    }
    final l$stripePriceActive = stripePriceActive;
    final lOther$stripePriceActive = other.stripePriceActive;
    if (_$data.containsKey('stripePriceActive') !=
        other._$data.containsKey('stripePriceActive')) {
      return false;
    }
    if (l$stripePriceActive != lOther$stripePriceActive) {
      return false;
    }
    final l$stripePriceUnitAmount = stripePriceUnitAmount;
    final lOther$stripePriceUnitAmount = other.stripePriceUnitAmount;
    if (_$data.containsKey('stripePriceUnitAmount') !=
        other._$data.containsKey('stripePriceUnitAmount')) {
      return false;
    }
    if (l$stripePriceUnitAmount != lOther$stripePriceUnitAmount) {
      return false;
    }
    final l$stripePriceCurrency = stripePriceCurrency;
    final lOther$stripePriceCurrency = other.stripePriceCurrency;
    if (_$data.containsKey('stripePriceCurrency') !=
        other._$data.containsKey('stripePriceCurrency')) {
      return false;
    }
    if (l$stripePriceCurrency != lOther$stripePriceCurrency) {
      return false;
    }
    final l$stripePriceLookupKey = stripePriceLookupKey;
    final lOther$stripePriceLookupKey = other.stripePriceLookupKey;
    if (_$data.containsKey('stripePriceLookupKey') !=
        other._$data.containsKey('stripePriceLookupKey')) {
      return false;
    }
    if (l$stripePriceLookupKey != lOther$stripePriceLookupKey) {
      return false;
    }
    final l$stripePriceMetadata = stripePriceMetadata;
    final lOther$stripePriceMetadata = other.stripePriceMetadata;
    if (_$data.containsKey('stripePriceMetadata') !=
        other._$data.containsKey('stripePriceMetadata')) {
      return false;
    }
    if (l$stripePriceMetadata != lOther$stripePriceMetadata) {
      return false;
    }
    final l$interval = interval;
    final lOther$interval = other.interval;
    if (_$data.containsKey('interval') !=
        other._$data.containsKey('interval')) {
      return false;
    }
    if (l$interval != lOther$interval) {
      return false;
    }
    final l$intervalCount = intervalCount;
    final lOther$intervalCount = other.intervalCount;
    if (_$data.containsKey('intervalCount') !=
        other._$data.containsKey('intervalCount')) {
      return false;
    }
    if (l$intervalCount != lOther$intervalCount) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$stripePriceId = stripePriceId;
    final l$stripePriceActive = stripePriceActive;
    final l$stripePriceUnitAmount = stripePriceUnitAmount;
    final l$stripePriceCurrency = stripePriceCurrency;
    final l$stripePriceLookupKey = stripePriceLookupKey;
    final l$stripePriceMetadata = stripePriceMetadata;
    final l$interval = interval;
    final l$intervalCount = intervalCount;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('stripePriceId') ? l$stripePriceId : const {},
      _$data.containsKey('stripePriceActive') ? l$stripePriceActive : const {},
      _$data.containsKey('stripePriceUnitAmount')
          ? l$stripePriceUnitAmount
          : const {},
      _$data.containsKey('stripePriceCurrency')
          ? l$stripePriceCurrency
          : const {},
      _$data.containsKey('stripePriceLookupKey')
          ? l$stripePriceLookupKey
          : const {},
      _$data.containsKey('stripePriceMetadata')
          ? l$stripePriceMetadata
          : const {},
      _$data.containsKey('interval') ? l$interval : const {},
      _$data.containsKey('intervalCount') ? l$intervalCount : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> {
  factory CopyWith$Input$SubscriptionPlanPriceFilterInput(
    Input$SubscriptionPlanPriceFilterInput instance,
    TRes Function(Input$SubscriptionPlanPriceFilterInput) then,
  ) = _CopyWithImpl$Input$SubscriptionPlanPriceFilterInput;

  factory CopyWith$Input$SubscriptionPlanPriceFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubscriptionPlanPriceFilterInput;

  TRes call({
    List<Input$SubscriptionPlanPriceFilterInput>? and,
    List<Input$SubscriptionPlanPriceFilterInput>? or,
    Input$StringOperationFilterInput? stripePriceId,
    Input$BooleanOperationFilterInput? stripePriceActive,
    Input$LongOperationFilterInput? stripePriceUnitAmount,
    Input$StringOperationFilterInput? stripePriceCurrency,
    Input$StringOperationFilterInput? stripePriceLookupKey,
    Input$ListFilterInputTypeOfMetadataFilterInput? stripePriceMetadata,
    Input$PeriodTimeOperationFilterInput? interval,
    Input$LongOperationFilterInput? intervalCount,
  });
  TRes and(
    Iterable<Input$SubscriptionPlanPriceFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionPlanPriceFilterInput<
          Input$SubscriptionPlanPriceFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$SubscriptionPlanPriceFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionPlanPriceFilterInput<
          Input$SubscriptionPlanPriceFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get stripePriceId;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get stripePriceActive;
  CopyWith$Input$LongOperationFilterInput<TRes> get stripePriceUnitAmount;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripePriceCurrency;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripePriceLookupKey;
  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get stripePriceMetadata;
  CopyWith$Input$PeriodTimeOperationFilterInput<TRes> get interval;
  CopyWith$Input$LongOperationFilterInput<TRes> get intervalCount;
}

class _CopyWithImpl$Input$SubscriptionPlanPriceFilterInput<TRes>
    implements CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> {
  _CopyWithImpl$Input$SubscriptionPlanPriceFilterInput(
    this._instance,
    this._then,
  );

  final Input$SubscriptionPlanPriceFilterInput _instance;

  final TRes Function(Input$SubscriptionPlanPriceFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? stripePriceId = _undefined,
    Object? stripePriceActive = _undefined,
    Object? stripePriceUnitAmount = _undefined,
    Object? stripePriceCurrency = _undefined,
    Object? stripePriceLookupKey = _undefined,
    Object? stripePriceMetadata = _undefined,
    Object? interval = _undefined,
    Object? intervalCount = _undefined,
  }) => _then(
    Input$SubscriptionPlanPriceFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$SubscriptionPlanPriceFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$SubscriptionPlanPriceFilterInput>?),
      if (stripePriceId != _undefined)
        'stripePriceId': (stripePriceId as Input$StringOperationFilterInput?),
      if (stripePriceActive != _undefined)
        'stripePriceActive':
            (stripePriceActive as Input$BooleanOperationFilterInput?),
      if (stripePriceUnitAmount != _undefined)
        'stripePriceUnitAmount':
            (stripePriceUnitAmount as Input$LongOperationFilterInput?),
      if (stripePriceCurrency != _undefined)
        'stripePriceCurrency':
            (stripePriceCurrency as Input$StringOperationFilterInput?),
      if (stripePriceLookupKey != _undefined)
        'stripePriceLookupKey':
            (stripePriceLookupKey as Input$StringOperationFilterInput?),
      if (stripePriceMetadata != _undefined)
        'stripePriceMetadata':
            (stripePriceMetadata
                as Input$ListFilterInputTypeOfMetadataFilterInput?),
      if (interval != _undefined)
        'interval': (interval as Input$PeriodTimeOperationFilterInput?),
      if (intervalCount != _undefined)
        'intervalCount': (intervalCount as Input$LongOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$SubscriptionPlanPriceFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionPlanPriceFilterInput<
          Input$SubscriptionPlanPriceFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$SubscriptionPlanPriceFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$SubscriptionPlanPriceFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionPlanPriceFilterInput<
          Input$SubscriptionPlanPriceFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$SubscriptionPlanPriceFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePriceId {
    final local$stripePriceId = _instance.stripePriceId;
    return local$stripePriceId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripePriceId,
            (e) => call(stripePriceId: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get stripePriceActive {
    final local$stripePriceActive = _instance.stripePriceActive;
    return local$stripePriceActive == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$stripePriceActive,
            (e) => call(stripePriceActive: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get stripePriceUnitAmount {
    final local$stripePriceUnitAmount = _instance.stripePriceUnitAmount;
    return local$stripePriceUnitAmount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$stripePriceUnitAmount,
            (e) => call(stripePriceUnitAmount: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePriceCurrency {
    final local$stripePriceCurrency = _instance.stripePriceCurrency;
    return local$stripePriceCurrency == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripePriceCurrency,
            (e) => call(stripePriceCurrency: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePriceLookupKey {
    final local$stripePriceLookupKey = _instance.stripePriceLookupKey;
    return local$stripePriceLookupKey == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripePriceLookupKey,
            (e) => call(stripePriceLookupKey: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get stripePriceMetadata {
    final local$stripePriceMetadata = _instance.stripePriceMetadata;
    return local$stripePriceMetadata == null
        ? CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput(
            local$stripePriceMetadata,
            (e) => call(stripePriceMetadata: e),
          );
  }

  CopyWith$Input$PeriodTimeOperationFilterInput<TRes> get interval {
    final local$interval = _instance.interval;
    return local$interval == null
        ? CopyWith$Input$PeriodTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$PeriodTimeOperationFilterInput(
            local$interval,
            (e) => call(interval: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get intervalCount {
    final local$intervalCount = _instance.intervalCount;
    return local$intervalCount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$intervalCount,
            (e) => call(intervalCount: e),
          );
  }
}

class _CopyWithStubImpl$Input$SubscriptionPlanPriceFilterInput<TRes>
    implements CopyWith$Input$SubscriptionPlanPriceFilterInput<TRes> {
  _CopyWithStubImpl$Input$SubscriptionPlanPriceFilterInput(this._res);

  TRes _res;

  call({
    List<Input$SubscriptionPlanPriceFilterInput>? and,
    List<Input$SubscriptionPlanPriceFilterInput>? or,
    Input$StringOperationFilterInput? stripePriceId,
    Input$BooleanOperationFilterInput? stripePriceActive,
    Input$LongOperationFilterInput? stripePriceUnitAmount,
    Input$StringOperationFilterInput? stripePriceCurrency,
    Input$StringOperationFilterInput? stripePriceLookupKey,
    Input$ListFilterInputTypeOfMetadataFilterInput? stripePriceMetadata,
    Input$PeriodTimeOperationFilterInput? interval,
    Input$LongOperationFilterInput? intervalCount,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePriceId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get stripePriceActive =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get stripePriceUnitAmount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePriceCurrency =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripePriceLookupKey =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get stripePriceMetadata =>
      CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput.stub(_res);

  CopyWith$Input$PeriodTimeOperationFilterInput<TRes> get interval =>
      CopyWith$Input$PeriodTimeOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get intervalCount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);
}

class Input$SubscriptionPlanSortInput {
  factory Input$SubscriptionPlanSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? subscriptionId,
    Enum$SortEnumType? stripeProductId,
    Enum$SortEnumType? stripeProductActive,
    Enum$SortEnumType? stripeProductName,
    Enum$SortEnumType? stripeProductType,
  }) => Input$SubscriptionPlanSortInput._({
    if (id != null) r'id': id,
    if (subscriptionId != null) r'subscriptionId': subscriptionId,
    if (stripeProductId != null) r'stripeProductId': stripeProductId,
    if (stripeProductActive != null)
      r'stripeProductActive': stripeProductActive,
    if (stripeProductName != null) r'stripeProductName': stripeProductName,
    if (stripeProductType != null) r'stripeProductType': stripeProductType,
  });

  Input$SubscriptionPlanSortInput._(this._$data);

  factory Input$SubscriptionPlanSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('subscriptionId')) {
      final l$subscriptionId = data['subscriptionId'];
      result$data['subscriptionId'] = l$subscriptionId == null
          ? null
          : fromJson$Enum$SortEnumType((l$subscriptionId as String));
    }
    if (data.containsKey('stripeProductId')) {
      final l$stripeProductId = data['stripeProductId'];
      result$data['stripeProductId'] = l$stripeProductId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeProductId as String));
    }
    if (data.containsKey('stripeProductActive')) {
      final l$stripeProductActive = data['stripeProductActive'];
      result$data['stripeProductActive'] = l$stripeProductActive == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeProductActive as String));
    }
    if (data.containsKey('stripeProductName')) {
      final l$stripeProductName = data['stripeProductName'];
      result$data['stripeProductName'] = l$stripeProductName == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeProductName as String));
    }
    if (data.containsKey('stripeProductType')) {
      final l$stripeProductType = data['stripeProductType'];
      result$data['stripeProductType'] = l$stripeProductType == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeProductType as String));
    }
    return Input$SubscriptionPlanSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get subscriptionId =>
      (_$data['subscriptionId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeProductId =>
      (_$data['stripeProductId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeProductActive =>
      (_$data['stripeProductActive'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeProductName =>
      (_$data['stripeProductName'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeProductType =>
      (_$data['stripeProductType'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('subscriptionId')) {
      final l$subscriptionId = subscriptionId;
      result$data['subscriptionId'] = l$subscriptionId == null
          ? null
          : toJson$Enum$SortEnumType(l$subscriptionId);
    }
    if (_$data.containsKey('stripeProductId')) {
      final l$stripeProductId = stripeProductId;
      result$data['stripeProductId'] = l$stripeProductId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeProductId);
    }
    if (_$data.containsKey('stripeProductActive')) {
      final l$stripeProductActive = stripeProductActive;
      result$data['stripeProductActive'] = l$stripeProductActive == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeProductActive);
    }
    if (_$data.containsKey('stripeProductName')) {
      final l$stripeProductName = stripeProductName;
      result$data['stripeProductName'] = l$stripeProductName == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeProductName);
    }
    if (_$data.containsKey('stripeProductType')) {
      final l$stripeProductType = stripeProductType;
      result$data['stripeProductType'] = l$stripeProductType == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeProductType);
    }
    return result$data;
  }

  CopyWith$Input$SubscriptionPlanSortInput<Input$SubscriptionPlanSortInput>
  get copyWith => CopyWith$Input$SubscriptionPlanSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SubscriptionPlanSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$subscriptionId = subscriptionId;
    final lOther$subscriptionId = other.subscriptionId;
    if (_$data.containsKey('subscriptionId') !=
        other._$data.containsKey('subscriptionId')) {
      return false;
    }
    if (l$subscriptionId != lOther$subscriptionId) {
      return false;
    }
    final l$stripeProductId = stripeProductId;
    final lOther$stripeProductId = other.stripeProductId;
    if (_$data.containsKey('stripeProductId') !=
        other._$data.containsKey('stripeProductId')) {
      return false;
    }
    if (l$stripeProductId != lOther$stripeProductId) {
      return false;
    }
    final l$stripeProductActive = stripeProductActive;
    final lOther$stripeProductActive = other.stripeProductActive;
    if (_$data.containsKey('stripeProductActive') !=
        other._$data.containsKey('stripeProductActive')) {
      return false;
    }
    if (l$stripeProductActive != lOther$stripeProductActive) {
      return false;
    }
    final l$stripeProductName = stripeProductName;
    final lOther$stripeProductName = other.stripeProductName;
    if (_$data.containsKey('stripeProductName') !=
        other._$data.containsKey('stripeProductName')) {
      return false;
    }
    if (l$stripeProductName != lOther$stripeProductName) {
      return false;
    }
    final l$stripeProductType = stripeProductType;
    final lOther$stripeProductType = other.stripeProductType;
    if (_$data.containsKey('stripeProductType') !=
        other._$data.containsKey('stripeProductType')) {
      return false;
    }
    if (l$stripeProductType != lOther$stripeProductType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$subscriptionId = subscriptionId;
    final l$stripeProductId = stripeProductId;
    final l$stripeProductActive = stripeProductActive;
    final l$stripeProductName = stripeProductName;
    final l$stripeProductType = stripeProductType;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('subscriptionId') ? l$subscriptionId : const {},
      _$data.containsKey('stripeProductId') ? l$stripeProductId : const {},
      _$data.containsKey('stripeProductActive')
          ? l$stripeProductActive
          : const {},
      _$data.containsKey('stripeProductName') ? l$stripeProductName : const {},
      _$data.containsKey('stripeProductType') ? l$stripeProductType : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubscriptionPlanSortInput<TRes> {
  factory CopyWith$Input$SubscriptionPlanSortInput(
    Input$SubscriptionPlanSortInput instance,
    TRes Function(Input$SubscriptionPlanSortInput) then,
  ) = _CopyWithImpl$Input$SubscriptionPlanSortInput;

  factory CopyWith$Input$SubscriptionPlanSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubscriptionPlanSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? subscriptionId,
    Enum$SortEnumType? stripeProductId,
    Enum$SortEnumType? stripeProductActive,
    Enum$SortEnumType? stripeProductName,
    Enum$SortEnumType? stripeProductType,
  });
}

class _CopyWithImpl$Input$SubscriptionPlanSortInput<TRes>
    implements CopyWith$Input$SubscriptionPlanSortInput<TRes> {
  _CopyWithImpl$Input$SubscriptionPlanSortInput(this._instance, this._then);

  final Input$SubscriptionPlanSortInput _instance;

  final TRes Function(Input$SubscriptionPlanSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? subscriptionId = _undefined,
    Object? stripeProductId = _undefined,
    Object? stripeProductActive = _undefined,
    Object? stripeProductName = _undefined,
    Object? stripeProductType = _undefined,
  }) => _then(
    Input$SubscriptionPlanSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (subscriptionId != _undefined)
        'subscriptionId': (subscriptionId as Enum$SortEnumType?),
      if (stripeProductId != _undefined)
        'stripeProductId': (stripeProductId as Enum$SortEnumType?),
      if (stripeProductActive != _undefined)
        'stripeProductActive': (stripeProductActive as Enum$SortEnumType?),
      if (stripeProductName != _undefined)
        'stripeProductName': (stripeProductName as Enum$SortEnumType?),
      if (stripeProductType != _undefined)
        'stripeProductType': (stripeProductType as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$SubscriptionPlanSortInput<TRes>
    implements CopyWith$Input$SubscriptionPlanSortInput<TRes> {
  _CopyWithStubImpl$Input$SubscriptionPlanSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? subscriptionId,
    Enum$SortEnumType? stripeProductId,
    Enum$SortEnumType? stripeProductActive,
    Enum$SortEnumType? stripeProductName,
    Enum$SortEnumType? stripeProductType,
  }) => _res;
}

class Input$SubscriptionSnapshotFilterInput {
  factory Input$SubscriptionSnapshotFilterInput({
    List<Input$SubscriptionSnapshotFilterInput>? and,
    List<Input$SubscriptionSnapshotFilterInput>? or,
    Input$StringOperationFilterInput? subscriptionName,
    Input$StringOperationFilterInput? subscriptionDescription,
    Input$StringOperationFilterInput? subscriptionCode,
    Input$IntOperationFilterInput? subscriptionVersion,
    Input$DecimalOperationFilterInput? subscriptionAmount,
    Input$CurrencyTypeOperationFilterInput? subscriptionCurrency,
    Input$SubscriptionTierOperationFilterInput? subscriptionTier,
    Input$SubscriptionStatusOperationFilterInput? subscriptionStatus,
    Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?
    subscriptionPlanPrices,
    Input$StringOperationFilterInput? stripeProductId,
    Input$BooleanOperationFilterInput? stripeProductActive,
    Input$StringOperationFilterInput? stripeProductName,
    Input$ListStringOperationFilterInput? stripeProductImages,
    Input$StringOperationFilterInput? stripeProductType,
    Input$ListFilterInputTypeOfMetadataFilterInput? stripeProductMetadata,
  }) => Input$SubscriptionSnapshotFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (subscriptionName != null) r'subscriptionName': subscriptionName,
    if (subscriptionDescription != null)
      r'subscriptionDescription': subscriptionDescription,
    if (subscriptionCode != null) r'subscriptionCode': subscriptionCode,
    if (subscriptionVersion != null)
      r'subscriptionVersion': subscriptionVersion,
    if (subscriptionAmount != null) r'subscriptionAmount': subscriptionAmount,
    if (subscriptionCurrency != null)
      r'subscriptionCurrency': subscriptionCurrency,
    if (subscriptionTier != null) r'subscriptionTier': subscriptionTier,
    if (subscriptionStatus != null) r'subscriptionStatus': subscriptionStatus,
    if (subscriptionPlanPrices != null)
      r'subscriptionPlanPrices': subscriptionPlanPrices,
    if (stripeProductId != null) r'stripeProductId': stripeProductId,
    if (stripeProductActive != null)
      r'stripeProductActive': stripeProductActive,
    if (stripeProductName != null) r'stripeProductName': stripeProductName,
    if (stripeProductImages != null)
      r'stripeProductImages': stripeProductImages,
    if (stripeProductType != null) r'stripeProductType': stripeProductType,
    if (stripeProductMetadata != null)
      r'stripeProductMetadata': stripeProductMetadata,
  });

  Input$SubscriptionSnapshotFilterInput._(this._$data);

  factory Input$SubscriptionSnapshotFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$SubscriptionSnapshotFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$SubscriptionSnapshotFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('subscriptionName')) {
      final l$subscriptionName = data['subscriptionName'];
      result$data['subscriptionName'] = l$subscriptionName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$subscriptionName as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionDescription')) {
      final l$subscriptionDescription = data['subscriptionDescription'];
      result$data['subscriptionDescription'] = l$subscriptionDescription == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$subscriptionDescription as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionCode')) {
      final l$subscriptionCode = data['subscriptionCode'];
      result$data['subscriptionCode'] = l$subscriptionCode == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$subscriptionCode as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionVersion')) {
      final l$subscriptionVersion = data['subscriptionVersion'];
      result$data['subscriptionVersion'] = l$subscriptionVersion == null
          ? null
          : Input$IntOperationFilterInput.fromJson(
              (l$subscriptionVersion as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionAmount')) {
      final l$subscriptionAmount = data['subscriptionAmount'];
      result$data['subscriptionAmount'] = l$subscriptionAmount == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$subscriptionAmount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionCurrency')) {
      final l$subscriptionCurrency = data['subscriptionCurrency'];
      result$data['subscriptionCurrency'] = l$subscriptionCurrency == null
          ? null
          : Input$CurrencyTypeOperationFilterInput.fromJson(
              (l$subscriptionCurrency as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionTier')) {
      final l$subscriptionTier = data['subscriptionTier'];
      result$data['subscriptionTier'] = l$subscriptionTier == null
          ? null
          : Input$SubscriptionTierOperationFilterInput.fromJson(
              (l$subscriptionTier as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionStatus')) {
      final l$subscriptionStatus = data['subscriptionStatus'];
      result$data['subscriptionStatus'] = l$subscriptionStatus == null
          ? null
          : Input$SubscriptionStatusOperationFilterInput.fromJson(
              (l$subscriptionStatus as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionPlanPrices')) {
      final l$subscriptionPlanPrices = data['subscriptionPlanPrices'];
      result$data['subscriptionPlanPrices'] = l$subscriptionPlanPrices == null
          ? null
          : Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput.fromJson(
              (l$subscriptionPlanPrices as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductId')) {
      final l$stripeProductId = data['stripeProductId'];
      result$data['stripeProductId'] = l$stripeProductId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeProductId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductActive')) {
      final l$stripeProductActive = data['stripeProductActive'];
      result$data['stripeProductActive'] = l$stripeProductActive == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$stripeProductActive as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductName')) {
      final l$stripeProductName = data['stripeProductName'];
      result$data['stripeProductName'] = l$stripeProductName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeProductName as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductImages')) {
      final l$stripeProductImages = data['stripeProductImages'];
      result$data['stripeProductImages'] = l$stripeProductImages == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$stripeProductImages as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductType')) {
      final l$stripeProductType = data['stripeProductType'];
      result$data['stripeProductType'] = l$stripeProductType == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeProductType as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeProductMetadata')) {
      final l$stripeProductMetadata = data['stripeProductMetadata'];
      result$data['stripeProductMetadata'] = l$stripeProductMetadata == null
          ? null
          : Input$ListFilterInputTypeOfMetadataFilterInput.fromJson(
              (l$stripeProductMetadata as Map<String, dynamic>),
            );
    }
    return Input$SubscriptionSnapshotFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SubscriptionSnapshotFilterInput>? get and =>
      (_$data['and'] as List<Input$SubscriptionSnapshotFilterInput>?);

  List<Input$SubscriptionSnapshotFilterInput>? get or =>
      (_$data['or'] as List<Input$SubscriptionSnapshotFilterInput>?);

  Input$StringOperationFilterInput? get subscriptionName =>
      (_$data['subscriptionName'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get subscriptionDescription =>
      (_$data['subscriptionDescription'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get subscriptionCode =>
      (_$data['subscriptionCode'] as Input$StringOperationFilterInput?);

  Input$IntOperationFilterInput? get subscriptionVersion =>
      (_$data['subscriptionVersion'] as Input$IntOperationFilterInput?);

  Input$DecimalOperationFilterInput? get subscriptionAmount =>
      (_$data['subscriptionAmount'] as Input$DecimalOperationFilterInput?);

  Input$CurrencyTypeOperationFilterInput? get subscriptionCurrency =>
      (_$data['subscriptionCurrency']
          as Input$CurrencyTypeOperationFilterInput?);

  Input$SubscriptionTierOperationFilterInput? get subscriptionTier =>
      (_$data['subscriptionTier']
          as Input$SubscriptionTierOperationFilterInput?);

  Input$SubscriptionStatusOperationFilterInput? get subscriptionStatus =>
      (_$data['subscriptionStatus']
          as Input$SubscriptionStatusOperationFilterInput?);

  Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?
  get subscriptionPlanPrices =>
      (_$data['subscriptionPlanPrices']
          as Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?);

  Input$StringOperationFilterInput? get stripeProductId =>
      (_$data['stripeProductId'] as Input$StringOperationFilterInput?);

  Input$BooleanOperationFilterInput? get stripeProductActive =>
      (_$data['stripeProductActive'] as Input$BooleanOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeProductName =>
      (_$data['stripeProductName'] as Input$StringOperationFilterInput?);

  Input$ListStringOperationFilterInput? get stripeProductImages =>
      (_$data['stripeProductImages'] as Input$ListStringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeProductType =>
      (_$data['stripeProductType'] as Input$StringOperationFilterInput?);

  Input$ListFilterInputTypeOfMetadataFilterInput? get stripeProductMetadata =>
      (_$data['stripeProductMetadata']
          as Input$ListFilterInputTypeOfMetadataFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('subscriptionName')) {
      final l$subscriptionName = subscriptionName;
      result$data['subscriptionName'] = l$subscriptionName?.toJson();
    }
    if (_$data.containsKey('subscriptionDescription')) {
      final l$subscriptionDescription = subscriptionDescription;
      result$data['subscriptionDescription'] = l$subscriptionDescription
          ?.toJson();
    }
    if (_$data.containsKey('subscriptionCode')) {
      final l$subscriptionCode = subscriptionCode;
      result$data['subscriptionCode'] = l$subscriptionCode?.toJson();
    }
    if (_$data.containsKey('subscriptionVersion')) {
      final l$subscriptionVersion = subscriptionVersion;
      result$data['subscriptionVersion'] = l$subscriptionVersion?.toJson();
    }
    if (_$data.containsKey('subscriptionAmount')) {
      final l$subscriptionAmount = subscriptionAmount;
      result$data['subscriptionAmount'] = l$subscriptionAmount?.toJson();
    }
    if (_$data.containsKey('subscriptionCurrency')) {
      final l$subscriptionCurrency = subscriptionCurrency;
      result$data['subscriptionCurrency'] = l$subscriptionCurrency?.toJson();
    }
    if (_$data.containsKey('subscriptionTier')) {
      final l$subscriptionTier = subscriptionTier;
      result$data['subscriptionTier'] = l$subscriptionTier?.toJson();
    }
    if (_$data.containsKey('subscriptionStatus')) {
      final l$subscriptionStatus = subscriptionStatus;
      result$data['subscriptionStatus'] = l$subscriptionStatus?.toJson();
    }
    if (_$data.containsKey('subscriptionPlanPrices')) {
      final l$subscriptionPlanPrices = subscriptionPlanPrices;
      result$data['subscriptionPlanPrices'] = l$subscriptionPlanPrices
          ?.toJson();
    }
    if (_$data.containsKey('stripeProductId')) {
      final l$stripeProductId = stripeProductId;
      result$data['stripeProductId'] = l$stripeProductId?.toJson();
    }
    if (_$data.containsKey('stripeProductActive')) {
      final l$stripeProductActive = stripeProductActive;
      result$data['stripeProductActive'] = l$stripeProductActive?.toJson();
    }
    if (_$data.containsKey('stripeProductName')) {
      final l$stripeProductName = stripeProductName;
      result$data['stripeProductName'] = l$stripeProductName?.toJson();
    }
    if (_$data.containsKey('stripeProductImages')) {
      final l$stripeProductImages = stripeProductImages;
      result$data['stripeProductImages'] = l$stripeProductImages?.toJson();
    }
    if (_$data.containsKey('stripeProductType')) {
      final l$stripeProductType = stripeProductType;
      result$data['stripeProductType'] = l$stripeProductType?.toJson();
    }
    if (_$data.containsKey('stripeProductMetadata')) {
      final l$stripeProductMetadata = stripeProductMetadata;
      result$data['stripeProductMetadata'] = l$stripeProductMetadata?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SubscriptionSnapshotFilterInput<
    Input$SubscriptionSnapshotFilterInput
  >
  get copyWith =>
      CopyWith$Input$SubscriptionSnapshotFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SubscriptionSnapshotFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$subscriptionName = subscriptionName;
    final lOther$subscriptionName = other.subscriptionName;
    if (_$data.containsKey('subscriptionName') !=
        other._$data.containsKey('subscriptionName')) {
      return false;
    }
    if (l$subscriptionName != lOther$subscriptionName) {
      return false;
    }
    final l$subscriptionDescription = subscriptionDescription;
    final lOther$subscriptionDescription = other.subscriptionDescription;
    if (_$data.containsKey('subscriptionDescription') !=
        other._$data.containsKey('subscriptionDescription')) {
      return false;
    }
    if (l$subscriptionDescription != lOther$subscriptionDescription) {
      return false;
    }
    final l$subscriptionCode = subscriptionCode;
    final lOther$subscriptionCode = other.subscriptionCode;
    if (_$data.containsKey('subscriptionCode') !=
        other._$data.containsKey('subscriptionCode')) {
      return false;
    }
    if (l$subscriptionCode != lOther$subscriptionCode) {
      return false;
    }
    final l$subscriptionVersion = subscriptionVersion;
    final lOther$subscriptionVersion = other.subscriptionVersion;
    if (_$data.containsKey('subscriptionVersion') !=
        other._$data.containsKey('subscriptionVersion')) {
      return false;
    }
    if (l$subscriptionVersion != lOther$subscriptionVersion) {
      return false;
    }
    final l$subscriptionAmount = subscriptionAmount;
    final lOther$subscriptionAmount = other.subscriptionAmount;
    if (_$data.containsKey('subscriptionAmount') !=
        other._$data.containsKey('subscriptionAmount')) {
      return false;
    }
    if (l$subscriptionAmount != lOther$subscriptionAmount) {
      return false;
    }
    final l$subscriptionCurrency = subscriptionCurrency;
    final lOther$subscriptionCurrency = other.subscriptionCurrency;
    if (_$data.containsKey('subscriptionCurrency') !=
        other._$data.containsKey('subscriptionCurrency')) {
      return false;
    }
    if (l$subscriptionCurrency != lOther$subscriptionCurrency) {
      return false;
    }
    final l$subscriptionTier = subscriptionTier;
    final lOther$subscriptionTier = other.subscriptionTier;
    if (_$data.containsKey('subscriptionTier') !=
        other._$data.containsKey('subscriptionTier')) {
      return false;
    }
    if (l$subscriptionTier != lOther$subscriptionTier) {
      return false;
    }
    final l$subscriptionStatus = subscriptionStatus;
    final lOther$subscriptionStatus = other.subscriptionStatus;
    if (_$data.containsKey('subscriptionStatus') !=
        other._$data.containsKey('subscriptionStatus')) {
      return false;
    }
    if (l$subscriptionStatus != lOther$subscriptionStatus) {
      return false;
    }
    final l$subscriptionPlanPrices = subscriptionPlanPrices;
    final lOther$subscriptionPlanPrices = other.subscriptionPlanPrices;
    if (_$data.containsKey('subscriptionPlanPrices') !=
        other._$data.containsKey('subscriptionPlanPrices')) {
      return false;
    }
    if (l$subscriptionPlanPrices != lOther$subscriptionPlanPrices) {
      return false;
    }
    final l$stripeProductId = stripeProductId;
    final lOther$stripeProductId = other.stripeProductId;
    if (_$data.containsKey('stripeProductId') !=
        other._$data.containsKey('stripeProductId')) {
      return false;
    }
    if (l$stripeProductId != lOther$stripeProductId) {
      return false;
    }
    final l$stripeProductActive = stripeProductActive;
    final lOther$stripeProductActive = other.stripeProductActive;
    if (_$data.containsKey('stripeProductActive') !=
        other._$data.containsKey('stripeProductActive')) {
      return false;
    }
    if (l$stripeProductActive != lOther$stripeProductActive) {
      return false;
    }
    final l$stripeProductName = stripeProductName;
    final lOther$stripeProductName = other.stripeProductName;
    if (_$data.containsKey('stripeProductName') !=
        other._$data.containsKey('stripeProductName')) {
      return false;
    }
    if (l$stripeProductName != lOther$stripeProductName) {
      return false;
    }
    final l$stripeProductImages = stripeProductImages;
    final lOther$stripeProductImages = other.stripeProductImages;
    if (_$data.containsKey('stripeProductImages') !=
        other._$data.containsKey('stripeProductImages')) {
      return false;
    }
    if (l$stripeProductImages != lOther$stripeProductImages) {
      return false;
    }
    final l$stripeProductType = stripeProductType;
    final lOther$stripeProductType = other.stripeProductType;
    if (_$data.containsKey('stripeProductType') !=
        other._$data.containsKey('stripeProductType')) {
      return false;
    }
    if (l$stripeProductType != lOther$stripeProductType) {
      return false;
    }
    final l$stripeProductMetadata = stripeProductMetadata;
    final lOther$stripeProductMetadata = other.stripeProductMetadata;
    if (_$data.containsKey('stripeProductMetadata') !=
        other._$data.containsKey('stripeProductMetadata')) {
      return false;
    }
    if (l$stripeProductMetadata != lOther$stripeProductMetadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$subscriptionName = subscriptionName;
    final l$subscriptionDescription = subscriptionDescription;
    final l$subscriptionCode = subscriptionCode;
    final l$subscriptionVersion = subscriptionVersion;
    final l$subscriptionAmount = subscriptionAmount;
    final l$subscriptionCurrency = subscriptionCurrency;
    final l$subscriptionTier = subscriptionTier;
    final l$subscriptionStatus = subscriptionStatus;
    final l$subscriptionPlanPrices = subscriptionPlanPrices;
    final l$stripeProductId = stripeProductId;
    final l$stripeProductActive = stripeProductActive;
    final l$stripeProductName = stripeProductName;
    final l$stripeProductImages = stripeProductImages;
    final l$stripeProductType = stripeProductType;
    final l$stripeProductMetadata = stripeProductMetadata;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('subscriptionName') ? l$subscriptionName : const {},
      _$data.containsKey('subscriptionDescription')
          ? l$subscriptionDescription
          : const {},
      _$data.containsKey('subscriptionCode') ? l$subscriptionCode : const {},
      _$data.containsKey('subscriptionVersion')
          ? l$subscriptionVersion
          : const {},
      _$data.containsKey('subscriptionAmount')
          ? l$subscriptionAmount
          : const {},
      _$data.containsKey('subscriptionCurrency')
          ? l$subscriptionCurrency
          : const {},
      _$data.containsKey('subscriptionTier') ? l$subscriptionTier : const {},
      _$data.containsKey('subscriptionStatus')
          ? l$subscriptionStatus
          : const {},
      _$data.containsKey('subscriptionPlanPrices')
          ? l$subscriptionPlanPrices
          : const {},
      _$data.containsKey('stripeProductId') ? l$stripeProductId : const {},
      _$data.containsKey('stripeProductActive')
          ? l$stripeProductActive
          : const {},
      _$data.containsKey('stripeProductName') ? l$stripeProductName : const {},
      _$data.containsKey('stripeProductImages')
          ? l$stripeProductImages
          : const {},
      _$data.containsKey('stripeProductType') ? l$stripeProductType : const {},
      _$data.containsKey('stripeProductMetadata')
          ? l$stripeProductMetadata
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubscriptionSnapshotFilterInput<TRes> {
  factory CopyWith$Input$SubscriptionSnapshotFilterInput(
    Input$SubscriptionSnapshotFilterInput instance,
    TRes Function(Input$SubscriptionSnapshotFilterInput) then,
  ) = _CopyWithImpl$Input$SubscriptionSnapshotFilterInput;

  factory CopyWith$Input$SubscriptionSnapshotFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubscriptionSnapshotFilterInput;

  TRes call({
    List<Input$SubscriptionSnapshotFilterInput>? and,
    List<Input$SubscriptionSnapshotFilterInput>? or,
    Input$StringOperationFilterInput? subscriptionName,
    Input$StringOperationFilterInput? subscriptionDescription,
    Input$StringOperationFilterInput? subscriptionCode,
    Input$IntOperationFilterInput? subscriptionVersion,
    Input$DecimalOperationFilterInput? subscriptionAmount,
    Input$CurrencyTypeOperationFilterInput? subscriptionCurrency,
    Input$SubscriptionTierOperationFilterInput? subscriptionTier,
    Input$SubscriptionStatusOperationFilterInput? subscriptionStatus,
    Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?
    subscriptionPlanPrices,
    Input$StringOperationFilterInput? stripeProductId,
    Input$BooleanOperationFilterInput? stripeProductActive,
    Input$StringOperationFilterInput? stripeProductName,
    Input$ListStringOperationFilterInput? stripeProductImages,
    Input$StringOperationFilterInput? stripeProductType,
    Input$ListFilterInputTypeOfMetadataFilterInput? stripeProductMetadata,
  });
  TRes and(
    Iterable<Input$SubscriptionSnapshotFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionSnapshotFilterInput<
          Input$SubscriptionSnapshotFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$SubscriptionSnapshotFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionSnapshotFilterInput<
          Input$SubscriptionSnapshotFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionName;
  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionDescription;
  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionCode;
  CopyWith$Input$IntOperationFilterInput<TRes> get subscriptionVersion;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get subscriptionAmount;
  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes>
  get subscriptionCurrency;
  CopyWith$Input$SubscriptionTierOperationFilterInput<TRes>
  get subscriptionTier;
  CopyWith$Input$SubscriptionStatusOperationFilterInput<TRes>
  get subscriptionStatus;
  CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<TRes>
  get subscriptionPlanPrices;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductId;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get stripeProductActive;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductName;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get stripeProductImages;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductType;
  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get stripeProductMetadata;
}

class _CopyWithImpl$Input$SubscriptionSnapshotFilterInput<TRes>
    implements CopyWith$Input$SubscriptionSnapshotFilterInput<TRes> {
  _CopyWithImpl$Input$SubscriptionSnapshotFilterInput(
    this._instance,
    this._then,
  );

  final Input$SubscriptionSnapshotFilterInput _instance;

  final TRes Function(Input$SubscriptionSnapshotFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? subscriptionName = _undefined,
    Object? subscriptionDescription = _undefined,
    Object? subscriptionCode = _undefined,
    Object? subscriptionVersion = _undefined,
    Object? subscriptionAmount = _undefined,
    Object? subscriptionCurrency = _undefined,
    Object? subscriptionTier = _undefined,
    Object? subscriptionStatus = _undefined,
    Object? subscriptionPlanPrices = _undefined,
    Object? stripeProductId = _undefined,
    Object? stripeProductActive = _undefined,
    Object? stripeProductName = _undefined,
    Object? stripeProductImages = _undefined,
    Object? stripeProductType = _undefined,
    Object? stripeProductMetadata = _undefined,
  }) => _then(
    Input$SubscriptionSnapshotFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$SubscriptionSnapshotFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$SubscriptionSnapshotFilterInput>?),
      if (subscriptionName != _undefined)
        'subscriptionName':
            (subscriptionName as Input$StringOperationFilterInput?),
      if (subscriptionDescription != _undefined)
        'subscriptionDescription':
            (subscriptionDescription as Input$StringOperationFilterInput?),
      if (subscriptionCode != _undefined)
        'subscriptionCode':
            (subscriptionCode as Input$StringOperationFilterInput?),
      if (subscriptionVersion != _undefined)
        'subscriptionVersion':
            (subscriptionVersion as Input$IntOperationFilterInput?),
      if (subscriptionAmount != _undefined)
        'subscriptionAmount':
            (subscriptionAmount as Input$DecimalOperationFilterInput?),
      if (subscriptionCurrency != _undefined)
        'subscriptionCurrency':
            (subscriptionCurrency as Input$CurrencyTypeOperationFilterInput?),
      if (subscriptionTier != _undefined)
        'subscriptionTier':
            (subscriptionTier as Input$SubscriptionTierOperationFilterInput?),
      if (subscriptionStatus != _undefined)
        'subscriptionStatus':
            (subscriptionStatus
                as Input$SubscriptionStatusOperationFilterInput?),
      if (subscriptionPlanPrices != _undefined)
        'subscriptionPlanPrices':
            (subscriptionPlanPrices
                as Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?),
      if (stripeProductId != _undefined)
        'stripeProductId':
            (stripeProductId as Input$StringOperationFilterInput?),
      if (stripeProductActive != _undefined)
        'stripeProductActive':
            (stripeProductActive as Input$BooleanOperationFilterInput?),
      if (stripeProductName != _undefined)
        'stripeProductName':
            (stripeProductName as Input$StringOperationFilterInput?),
      if (stripeProductImages != _undefined)
        'stripeProductImages':
            (stripeProductImages as Input$ListStringOperationFilterInput?),
      if (stripeProductType != _undefined)
        'stripeProductType':
            (stripeProductType as Input$StringOperationFilterInput?),
      if (stripeProductMetadata != _undefined)
        'stripeProductMetadata':
            (stripeProductMetadata
                as Input$ListFilterInputTypeOfMetadataFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$SubscriptionSnapshotFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionSnapshotFilterInput<
          Input$SubscriptionSnapshotFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$SubscriptionSnapshotFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$SubscriptionSnapshotFilterInput>? Function(
      Iterable<
        CopyWith$Input$SubscriptionSnapshotFilterInput<
          Input$SubscriptionSnapshotFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$SubscriptionSnapshotFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionName {
    final local$subscriptionName = _instance.subscriptionName;
    return local$subscriptionName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$subscriptionName,
            (e) => call(subscriptionName: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionDescription {
    final local$subscriptionDescription = _instance.subscriptionDescription;
    return local$subscriptionDescription == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$subscriptionDescription,
            (e) => call(subscriptionDescription: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionCode {
    final local$subscriptionCode = _instance.subscriptionCode;
    return local$subscriptionCode == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$subscriptionCode,
            (e) => call(subscriptionCode: e),
          );
  }

  CopyWith$Input$IntOperationFilterInput<TRes> get subscriptionVersion {
    final local$subscriptionVersion = _instance.subscriptionVersion;
    return local$subscriptionVersion == null
        ? CopyWith$Input$IntOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$IntOperationFilterInput(
            local$subscriptionVersion,
            (e) => call(subscriptionVersion: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get subscriptionAmount {
    final local$subscriptionAmount = _instance.subscriptionAmount;
    return local$subscriptionAmount == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$subscriptionAmount,
            (e) => call(subscriptionAmount: e),
          );
  }

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes>
  get subscriptionCurrency {
    final local$subscriptionCurrency = _instance.subscriptionCurrency;
    return local$subscriptionCurrency == null
        ? CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$CurrencyTypeOperationFilterInput(
            local$subscriptionCurrency,
            (e) => call(subscriptionCurrency: e),
          );
  }

  CopyWith$Input$SubscriptionTierOperationFilterInput<TRes>
  get subscriptionTier {
    final local$subscriptionTier = _instance.subscriptionTier;
    return local$subscriptionTier == null
        ? CopyWith$Input$SubscriptionTierOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$SubscriptionTierOperationFilterInput(
            local$subscriptionTier,
            (e) => call(subscriptionTier: e),
          );
  }

  CopyWith$Input$SubscriptionStatusOperationFilterInput<TRes>
  get subscriptionStatus {
    final local$subscriptionStatus = _instance.subscriptionStatus;
    return local$subscriptionStatus == null
        ? CopyWith$Input$SubscriptionStatusOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$SubscriptionStatusOperationFilterInput(
            local$subscriptionStatus,
            (e) => call(subscriptionStatus: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<TRes>
  get subscriptionPlanPrices {
    final local$subscriptionPlanPrices = _instance.subscriptionPlanPrices;
    return local$subscriptionPlanPrices == null
        ? CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput(
            local$subscriptionPlanPrices,
            (e) => call(subscriptionPlanPrices: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductId {
    final local$stripeProductId = _instance.stripeProductId;
    return local$stripeProductId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeProductId,
            (e) => call(stripeProductId: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get stripeProductActive {
    final local$stripeProductActive = _instance.stripeProductActive;
    return local$stripeProductActive == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$stripeProductActive,
            (e) => call(stripeProductActive: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductName {
    final local$stripeProductName = _instance.stripeProductName;
    return local$stripeProductName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeProductName,
            (e) => call(stripeProductName: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get stripeProductImages {
    final local$stripeProductImages = _instance.stripeProductImages;
    return local$stripeProductImages == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$stripeProductImages,
            (e) => call(stripeProductImages: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductType {
    final local$stripeProductType = _instance.stripeProductType;
    return local$stripeProductType == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeProductType,
            (e) => call(stripeProductType: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get stripeProductMetadata {
    final local$stripeProductMetadata = _instance.stripeProductMetadata;
    return local$stripeProductMetadata == null
        ? CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput(
            local$stripeProductMetadata,
            (e) => call(stripeProductMetadata: e),
          );
  }
}

class _CopyWithStubImpl$Input$SubscriptionSnapshotFilterInput<TRes>
    implements CopyWith$Input$SubscriptionSnapshotFilterInput<TRes> {
  _CopyWithStubImpl$Input$SubscriptionSnapshotFilterInput(this._res);

  TRes _res;

  call({
    List<Input$SubscriptionSnapshotFilterInput>? and,
    List<Input$SubscriptionSnapshotFilterInput>? or,
    Input$StringOperationFilterInput? subscriptionName,
    Input$StringOperationFilterInput? subscriptionDescription,
    Input$StringOperationFilterInput? subscriptionCode,
    Input$IntOperationFilterInput? subscriptionVersion,
    Input$DecimalOperationFilterInput? subscriptionAmount,
    Input$CurrencyTypeOperationFilterInput? subscriptionCurrency,
    Input$SubscriptionTierOperationFilterInput? subscriptionTier,
    Input$SubscriptionStatusOperationFilterInput? subscriptionStatus,
    Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput?
    subscriptionPlanPrices,
    Input$StringOperationFilterInput? stripeProductId,
    Input$BooleanOperationFilterInput? stripeProductActive,
    Input$StringOperationFilterInput? stripeProductName,
    Input$ListStringOperationFilterInput? stripeProductImages,
    Input$StringOperationFilterInput? stripeProductType,
    Input$ListFilterInputTypeOfMetadataFilterInput? stripeProductMetadata,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionDescription =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionCode =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$IntOperationFilterInput<TRes> get subscriptionVersion =>
      CopyWith$Input$IntOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get subscriptionAmount =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$CurrencyTypeOperationFilterInput<TRes>
  get subscriptionCurrency =>
      CopyWith$Input$CurrencyTypeOperationFilterInput.stub(_res);

  CopyWith$Input$SubscriptionTierOperationFilterInput<TRes>
  get subscriptionTier =>
      CopyWith$Input$SubscriptionTierOperationFilterInput.stub(_res);

  CopyWith$Input$SubscriptionStatusOperationFilterInput<TRes>
  get subscriptionStatus =>
      CopyWith$Input$SubscriptionStatusOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput<TRes>
  get subscriptionPlanPrices =>
      CopyWith$Input$ListFilterInputTypeOfSubscriptionPlanPriceFilterInput.stub(
        _res,
      );

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get stripeProductActive =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get stripeProductImages =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeProductType =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput<TRes>
  get stripeProductMetadata =>
      CopyWith$Input$ListFilterInputTypeOfMetadataFilterInput.stub(_res);
}

class Input$SubscriptionSnapshotSortInput {
  factory Input$SubscriptionSnapshotSortInput({
    Enum$SortEnumType? subscriptionName,
    Enum$SortEnumType? subscriptionDescription,
    Enum$SortEnumType? subscriptionCode,
    Enum$SortEnumType? subscriptionVersion,
    Enum$SortEnumType? subscriptionAmount,
    Enum$SortEnumType? subscriptionCurrency,
    Enum$SortEnumType? subscriptionTier,
    Enum$SortEnumType? subscriptionStatus,
    Enum$SortEnumType? stripeProductId,
    Enum$SortEnumType? stripeProductActive,
    Enum$SortEnumType? stripeProductName,
    Enum$SortEnumType? stripeProductType,
  }) => Input$SubscriptionSnapshotSortInput._({
    if (subscriptionName != null) r'subscriptionName': subscriptionName,
    if (subscriptionDescription != null)
      r'subscriptionDescription': subscriptionDescription,
    if (subscriptionCode != null) r'subscriptionCode': subscriptionCode,
    if (subscriptionVersion != null)
      r'subscriptionVersion': subscriptionVersion,
    if (subscriptionAmount != null) r'subscriptionAmount': subscriptionAmount,
    if (subscriptionCurrency != null)
      r'subscriptionCurrency': subscriptionCurrency,
    if (subscriptionTier != null) r'subscriptionTier': subscriptionTier,
    if (subscriptionStatus != null) r'subscriptionStatus': subscriptionStatus,
    if (stripeProductId != null) r'stripeProductId': stripeProductId,
    if (stripeProductActive != null)
      r'stripeProductActive': stripeProductActive,
    if (stripeProductName != null) r'stripeProductName': stripeProductName,
    if (stripeProductType != null) r'stripeProductType': stripeProductType,
  });

  Input$SubscriptionSnapshotSortInput._(this._$data);

  factory Input$SubscriptionSnapshotSortInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('subscriptionName')) {
      final l$subscriptionName = data['subscriptionName'];
      result$data['subscriptionName'] = l$subscriptionName == null
          ? null
          : fromJson$Enum$SortEnumType((l$subscriptionName as String));
    }
    if (data.containsKey('subscriptionDescription')) {
      final l$subscriptionDescription = data['subscriptionDescription'];
      result$data['subscriptionDescription'] = l$subscriptionDescription == null
          ? null
          : fromJson$Enum$SortEnumType((l$subscriptionDescription as String));
    }
    if (data.containsKey('subscriptionCode')) {
      final l$subscriptionCode = data['subscriptionCode'];
      result$data['subscriptionCode'] = l$subscriptionCode == null
          ? null
          : fromJson$Enum$SortEnumType((l$subscriptionCode as String));
    }
    if (data.containsKey('subscriptionVersion')) {
      final l$subscriptionVersion = data['subscriptionVersion'];
      result$data['subscriptionVersion'] = l$subscriptionVersion == null
          ? null
          : fromJson$Enum$SortEnumType((l$subscriptionVersion as String));
    }
    if (data.containsKey('subscriptionAmount')) {
      final l$subscriptionAmount = data['subscriptionAmount'];
      result$data['subscriptionAmount'] = l$subscriptionAmount == null
          ? null
          : fromJson$Enum$SortEnumType((l$subscriptionAmount as String));
    }
    if (data.containsKey('subscriptionCurrency')) {
      final l$subscriptionCurrency = data['subscriptionCurrency'];
      result$data['subscriptionCurrency'] = l$subscriptionCurrency == null
          ? null
          : fromJson$Enum$SortEnumType((l$subscriptionCurrency as String));
    }
    if (data.containsKey('subscriptionTier')) {
      final l$subscriptionTier = data['subscriptionTier'];
      result$data['subscriptionTier'] = l$subscriptionTier == null
          ? null
          : fromJson$Enum$SortEnumType((l$subscriptionTier as String));
    }
    if (data.containsKey('subscriptionStatus')) {
      final l$subscriptionStatus = data['subscriptionStatus'];
      result$data['subscriptionStatus'] = l$subscriptionStatus == null
          ? null
          : fromJson$Enum$SortEnumType((l$subscriptionStatus as String));
    }
    if (data.containsKey('stripeProductId')) {
      final l$stripeProductId = data['stripeProductId'];
      result$data['stripeProductId'] = l$stripeProductId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeProductId as String));
    }
    if (data.containsKey('stripeProductActive')) {
      final l$stripeProductActive = data['stripeProductActive'];
      result$data['stripeProductActive'] = l$stripeProductActive == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeProductActive as String));
    }
    if (data.containsKey('stripeProductName')) {
      final l$stripeProductName = data['stripeProductName'];
      result$data['stripeProductName'] = l$stripeProductName == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeProductName as String));
    }
    if (data.containsKey('stripeProductType')) {
      final l$stripeProductType = data['stripeProductType'];
      result$data['stripeProductType'] = l$stripeProductType == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeProductType as String));
    }
    return Input$SubscriptionSnapshotSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get subscriptionName =>
      (_$data['subscriptionName'] as Enum$SortEnumType?);

  Enum$SortEnumType? get subscriptionDescription =>
      (_$data['subscriptionDescription'] as Enum$SortEnumType?);

  Enum$SortEnumType? get subscriptionCode =>
      (_$data['subscriptionCode'] as Enum$SortEnumType?);

  Enum$SortEnumType? get subscriptionVersion =>
      (_$data['subscriptionVersion'] as Enum$SortEnumType?);

  Enum$SortEnumType? get subscriptionAmount =>
      (_$data['subscriptionAmount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get subscriptionCurrency =>
      (_$data['subscriptionCurrency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get subscriptionTier =>
      (_$data['subscriptionTier'] as Enum$SortEnumType?);

  Enum$SortEnumType? get subscriptionStatus =>
      (_$data['subscriptionStatus'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeProductId =>
      (_$data['stripeProductId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeProductActive =>
      (_$data['stripeProductActive'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeProductName =>
      (_$data['stripeProductName'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeProductType =>
      (_$data['stripeProductType'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('subscriptionName')) {
      final l$subscriptionName = subscriptionName;
      result$data['subscriptionName'] = l$subscriptionName == null
          ? null
          : toJson$Enum$SortEnumType(l$subscriptionName);
    }
    if (_$data.containsKey('subscriptionDescription')) {
      final l$subscriptionDescription = subscriptionDescription;
      result$data['subscriptionDescription'] = l$subscriptionDescription == null
          ? null
          : toJson$Enum$SortEnumType(l$subscriptionDescription);
    }
    if (_$data.containsKey('subscriptionCode')) {
      final l$subscriptionCode = subscriptionCode;
      result$data['subscriptionCode'] = l$subscriptionCode == null
          ? null
          : toJson$Enum$SortEnumType(l$subscriptionCode);
    }
    if (_$data.containsKey('subscriptionVersion')) {
      final l$subscriptionVersion = subscriptionVersion;
      result$data['subscriptionVersion'] = l$subscriptionVersion == null
          ? null
          : toJson$Enum$SortEnumType(l$subscriptionVersion);
    }
    if (_$data.containsKey('subscriptionAmount')) {
      final l$subscriptionAmount = subscriptionAmount;
      result$data['subscriptionAmount'] = l$subscriptionAmount == null
          ? null
          : toJson$Enum$SortEnumType(l$subscriptionAmount);
    }
    if (_$data.containsKey('subscriptionCurrency')) {
      final l$subscriptionCurrency = subscriptionCurrency;
      result$data['subscriptionCurrency'] = l$subscriptionCurrency == null
          ? null
          : toJson$Enum$SortEnumType(l$subscriptionCurrency);
    }
    if (_$data.containsKey('subscriptionTier')) {
      final l$subscriptionTier = subscriptionTier;
      result$data['subscriptionTier'] = l$subscriptionTier == null
          ? null
          : toJson$Enum$SortEnumType(l$subscriptionTier);
    }
    if (_$data.containsKey('subscriptionStatus')) {
      final l$subscriptionStatus = subscriptionStatus;
      result$data['subscriptionStatus'] = l$subscriptionStatus == null
          ? null
          : toJson$Enum$SortEnumType(l$subscriptionStatus);
    }
    if (_$data.containsKey('stripeProductId')) {
      final l$stripeProductId = stripeProductId;
      result$data['stripeProductId'] = l$stripeProductId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeProductId);
    }
    if (_$data.containsKey('stripeProductActive')) {
      final l$stripeProductActive = stripeProductActive;
      result$data['stripeProductActive'] = l$stripeProductActive == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeProductActive);
    }
    if (_$data.containsKey('stripeProductName')) {
      final l$stripeProductName = stripeProductName;
      result$data['stripeProductName'] = l$stripeProductName == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeProductName);
    }
    if (_$data.containsKey('stripeProductType')) {
      final l$stripeProductType = stripeProductType;
      result$data['stripeProductType'] = l$stripeProductType == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeProductType);
    }
    return result$data;
  }

  CopyWith$Input$SubscriptionSnapshotSortInput<
    Input$SubscriptionSnapshotSortInput
  >
  get copyWith => CopyWith$Input$SubscriptionSnapshotSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SubscriptionSnapshotSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$subscriptionName = subscriptionName;
    final lOther$subscriptionName = other.subscriptionName;
    if (_$data.containsKey('subscriptionName') !=
        other._$data.containsKey('subscriptionName')) {
      return false;
    }
    if (l$subscriptionName != lOther$subscriptionName) {
      return false;
    }
    final l$subscriptionDescription = subscriptionDescription;
    final lOther$subscriptionDescription = other.subscriptionDescription;
    if (_$data.containsKey('subscriptionDescription') !=
        other._$data.containsKey('subscriptionDescription')) {
      return false;
    }
    if (l$subscriptionDescription != lOther$subscriptionDescription) {
      return false;
    }
    final l$subscriptionCode = subscriptionCode;
    final lOther$subscriptionCode = other.subscriptionCode;
    if (_$data.containsKey('subscriptionCode') !=
        other._$data.containsKey('subscriptionCode')) {
      return false;
    }
    if (l$subscriptionCode != lOther$subscriptionCode) {
      return false;
    }
    final l$subscriptionVersion = subscriptionVersion;
    final lOther$subscriptionVersion = other.subscriptionVersion;
    if (_$data.containsKey('subscriptionVersion') !=
        other._$data.containsKey('subscriptionVersion')) {
      return false;
    }
    if (l$subscriptionVersion != lOther$subscriptionVersion) {
      return false;
    }
    final l$subscriptionAmount = subscriptionAmount;
    final lOther$subscriptionAmount = other.subscriptionAmount;
    if (_$data.containsKey('subscriptionAmount') !=
        other._$data.containsKey('subscriptionAmount')) {
      return false;
    }
    if (l$subscriptionAmount != lOther$subscriptionAmount) {
      return false;
    }
    final l$subscriptionCurrency = subscriptionCurrency;
    final lOther$subscriptionCurrency = other.subscriptionCurrency;
    if (_$data.containsKey('subscriptionCurrency') !=
        other._$data.containsKey('subscriptionCurrency')) {
      return false;
    }
    if (l$subscriptionCurrency != lOther$subscriptionCurrency) {
      return false;
    }
    final l$subscriptionTier = subscriptionTier;
    final lOther$subscriptionTier = other.subscriptionTier;
    if (_$data.containsKey('subscriptionTier') !=
        other._$data.containsKey('subscriptionTier')) {
      return false;
    }
    if (l$subscriptionTier != lOther$subscriptionTier) {
      return false;
    }
    final l$subscriptionStatus = subscriptionStatus;
    final lOther$subscriptionStatus = other.subscriptionStatus;
    if (_$data.containsKey('subscriptionStatus') !=
        other._$data.containsKey('subscriptionStatus')) {
      return false;
    }
    if (l$subscriptionStatus != lOther$subscriptionStatus) {
      return false;
    }
    final l$stripeProductId = stripeProductId;
    final lOther$stripeProductId = other.stripeProductId;
    if (_$data.containsKey('stripeProductId') !=
        other._$data.containsKey('stripeProductId')) {
      return false;
    }
    if (l$stripeProductId != lOther$stripeProductId) {
      return false;
    }
    final l$stripeProductActive = stripeProductActive;
    final lOther$stripeProductActive = other.stripeProductActive;
    if (_$data.containsKey('stripeProductActive') !=
        other._$data.containsKey('stripeProductActive')) {
      return false;
    }
    if (l$stripeProductActive != lOther$stripeProductActive) {
      return false;
    }
    final l$stripeProductName = stripeProductName;
    final lOther$stripeProductName = other.stripeProductName;
    if (_$data.containsKey('stripeProductName') !=
        other._$data.containsKey('stripeProductName')) {
      return false;
    }
    if (l$stripeProductName != lOther$stripeProductName) {
      return false;
    }
    final l$stripeProductType = stripeProductType;
    final lOther$stripeProductType = other.stripeProductType;
    if (_$data.containsKey('stripeProductType') !=
        other._$data.containsKey('stripeProductType')) {
      return false;
    }
    if (l$stripeProductType != lOther$stripeProductType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subscriptionName = subscriptionName;
    final l$subscriptionDescription = subscriptionDescription;
    final l$subscriptionCode = subscriptionCode;
    final l$subscriptionVersion = subscriptionVersion;
    final l$subscriptionAmount = subscriptionAmount;
    final l$subscriptionCurrency = subscriptionCurrency;
    final l$subscriptionTier = subscriptionTier;
    final l$subscriptionStatus = subscriptionStatus;
    final l$stripeProductId = stripeProductId;
    final l$stripeProductActive = stripeProductActive;
    final l$stripeProductName = stripeProductName;
    final l$stripeProductType = stripeProductType;
    return Object.hashAll([
      _$data.containsKey('subscriptionName') ? l$subscriptionName : const {},
      _$data.containsKey('subscriptionDescription')
          ? l$subscriptionDescription
          : const {},
      _$data.containsKey('subscriptionCode') ? l$subscriptionCode : const {},
      _$data.containsKey('subscriptionVersion')
          ? l$subscriptionVersion
          : const {},
      _$data.containsKey('subscriptionAmount')
          ? l$subscriptionAmount
          : const {},
      _$data.containsKey('subscriptionCurrency')
          ? l$subscriptionCurrency
          : const {},
      _$data.containsKey('subscriptionTier') ? l$subscriptionTier : const {},
      _$data.containsKey('subscriptionStatus')
          ? l$subscriptionStatus
          : const {},
      _$data.containsKey('stripeProductId') ? l$stripeProductId : const {},
      _$data.containsKey('stripeProductActive')
          ? l$stripeProductActive
          : const {},
      _$data.containsKey('stripeProductName') ? l$stripeProductName : const {},
      _$data.containsKey('stripeProductType') ? l$stripeProductType : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubscriptionSnapshotSortInput<TRes> {
  factory CopyWith$Input$SubscriptionSnapshotSortInput(
    Input$SubscriptionSnapshotSortInput instance,
    TRes Function(Input$SubscriptionSnapshotSortInput) then,
  ) = _CopyWithImpl$Input$SubscriptionSnapshotSortInput;

  factory CopyWith$Input$SubscriptionSnapshotSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubscriptionSnapshotSortInput;

  TRes call({
    Enum$SortEnumType? subscriptionName,
    Enum$SortEnumType? subscriptionDescription,
    Enum$SortEnumType? subscriptionCode,
    Enum$SortEnumType? subscriptionVersion,
    Enum$SortEnumType? subscriptionAmount,
    Enum$SortEnumType? subscriptionCurrency,
    Enum$SortEnumType? subscriptionTier,
    Enum$SortEnumType? subscriptionStatus,
    Enum$SortEnumType? stripeProductId,
    Enum$SortEnumType? stripeProductActive,
    Enum$SortEnumType? stripeProductName,
    Enum$SortEnumType? stripeProductType,
  });
}

class _CopyWithImpl$Input$SubscriptionSnapshotSortInput<TRes>
    implements CopyWith$Input$SubscriptionSnapshotSortInput<TRes> {
  _CopyWithImpl$Input$SubscriptionSnapshotSortInput(this._instance, this._then);

  final Input$SubscriptionSnapshotSortInput _instance;

  final TRes Function(Input$SubscriptionSnapshotSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? subscriptionName = _undefined,
    Object? subscriptionDescription = _undefined,
    Object? subscriptionCode = _undefined,
    Object? subscriptionVersion = _undefined,
    Object? subscriptionAmount = _undefined,
    Object? subscriptionCurrency = _undefined,
    Object? subscriptionTier = _undefined,
    Object? subscriptionStatus = _undefined,
    Object? stripeProductId = _undefined,
    Object? stripeProductActive = _undefined,
    Object? stripeProductName = _undefined,
    Object? stripeProductType = _undefined,
  }) => _then(
    Input$SubscriptionSnapshotSortInput._({
      ..._instance._$data,
      if (subscriptionName != _undefined)
        'subscriptionName': (subscriptionName as Enum$SortEnumType?),
      if (subscriptionDescription != _undefined)
        'subscriptionDescription':
            (subscriptionDescription as Enum$SortEnumType?),
      if (subscriptionCode != _undefined)
        'subscriptionCode': (subscriptionCode as Enum$SortEnumType?),
      if (subscriptionVersion != _undefined)
        'subscriptionVersion': (subscriptionVersion as Enum$SortEnumType?),
      if (subscriptionAmount != _undefined)
        'subscriptionAmount': (subscriptionAmount as Enum$SortEnumType?),
      if (subscriptionCurrency != _undefined)
        'subscriptionCurrency': (subscriptionCurrency as Enum$SortEnumType?),
      if (subscriptionTier != _undefined)
        'subscriptionTier': (subscriptionTier as Enum$SortEnumType?),
      if (subscriptionStatus != _undefined)
        'subscriptionStatus': (subscriptionStatus as Enum$SortEnumType?),
      if (stripeProductId != _undefined)
        'stripeProductId': (stripeProductId as Enum$SortEnumType?),
      if (stripeProductActive != _undefined)
        'stripeProductActive': (stripeProductActive as Enum$SortEnumType?),
      if (stripeProductName != _undefined)
        'stripeProductName': (stripeProductName as Enum$SortEnumType?),
      if (stripeProductType != _undefined)
        'stripeProductType': (stripeProductType as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$SubscriptionSnapshotSortInput<TRes>
    implements CopyWith$Input$SubscriptionSnapshotSortInput<TRes> {
  _CopyWithStubImpl$Input$SubscriptionSnapshotSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? subscriptionName,
    Enum$SortEnumType? subscriptionDescription,
    Enum$SortEnumType? subscriptionCode,
    Enum$SortEnumType? subscriptionVersion,
    Enum$SortEnumType? subscriptionAmount,
    Enum$SortEnumType? subscriptionCurrency,
    Enum$SortEnumType? subscriptionTier,
    Enum$SortEnumType? subscriptionStatus,
    Enum$SortEnumType? stripeProductId,
    Enum$SortEnumType? stripeProductActive,
    Enum$SortEnumType? stripeProductName,
    Enum$SortEnumType? stripeProductType,
  }) => _res;
}

class Input$SubscriptionSortInput {
  factory Input$SubscriptionSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? description,
    Enum$SortEnumType? code,
    Enum$SortEnumType? version,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? tier,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$SubscriptionSortInput._({
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (description != null) r'description': description,
    if (code != null) r'code': code,
    if (version != null) r'version': version,
    if (amount != null) r'amount': amount,
    if (currency != null) r'currency': currency,
    if (tier != null) r'tier': tier,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$SubscriptionSortInput._(this._$data);

  factory Input$SubscriptionSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('code')) {
      final l$code = data['code'];
      result$data['code'] = l$code == null
          ? null
          : fromJson$Enum$SortEnumType((l$code as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$SortEnumType((l$version as String));
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = l$amount == null
          ? null
          : fromJson$Enum$SortEnumType((l$amount as String));
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$SortEnumType((l$currency as String));
    }
    if (data.containsKey('tier')) {
      final l$tier = data['tier'];
      result$data['tier'] = l$tier == null
          ? null
          : fromJson$Enum$SortEnumType((l$tier as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$SubscriptionSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get code => (_$data['code'] as Enum$SortEnumType?);

  Enum$SortEnumType? get version => (_$data['version'] as Enum$SortEnumType?);

  Enum$SortEnumType? get amount => (_$data['amount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get currency => (_$data['currency'] as Enum$SortEnumType?);

  Enum$SortEnumType? get tier => (_$data['tier'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null
          ? null
          : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('code')) {
      final l$code = code;
      result$data['code'] = l$code == null
          ? null
          : toJson$Enum$SortEnumType(l$code);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version == null
          ? null
          : toJson$Enum$SortEnumType(l$version);
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount == null
          ? null
          : toJson$Enum$SortEnumType(l$amount);
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$SortEnumType(l$currency);
    }
    if (_$data.containsKey('tier')) {
      final l$tier = tier;
      result$data['tier'] = l$tier == null
          ? null
          : toJson$Enum$SortEnumType(l$tier);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$SubscriptionSortInput<Input$SubscriptionSortInput>
  get copyWith => CopyWith$Input$SubscriptionSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SubscriptionSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (_$data.containsKey('code') != other._$data.containsKey('code')) {
      return false;
    }
    if (l$code != lOther$code) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$tier = tier;
    final lOther$tier = other.tier;
    if (_$data.containsKey('tier') != other._$data.containsKey('tier')) {
      return false;
    }
    if (l$tier != lOther$tier) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$description = description;
    final l$code = code;
    final l$version = version;
    final l$amount = amount;
    final l$currency = currency;
    final l$tier = tier;
    final l$status = status;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('code') ? l$code : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('tier') ? l$tier : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubscriptionSortInput<TRes> {
  factory CopyWith$Input$SubscriptionSortInput(
    Input$SubscriptionSortInput instance,
    TRes Function(Input$SubscriptionSortInput) then,
  ) = _CopyWithImpl$Input$SubscriptionSortInput;

  factory CopyWith$Input$SubscriptionSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubscriptionSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? description,
    Enum$SortEnumType? code,
    Enum$SortEnumType? version,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? tier,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$SubscriptionSortInput<TRes>
    implements CopyWith$Input$SubscriptionSortInput<TRes> {
  _CopyWithImpl$Input$SubscriptionSortInput(this._instance, this._then);

  final Input$SubscriptionSortInput _instance;

  final TRes Function(Input$SubscriptionSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? code = _undefined,
    Object? version = _undefined,
    Object? amount = _undefined,
    Object? currency = _undefined,
    Object? tier = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$SubscriptionSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (code != _undefined) 'code': (code as Enum$SortEnumType?),
      if (version != _undefined) 'version': (version as Enum$SortEnumType?),
      if (amount != _undefined) 'amount': (amount as Enum$SortEnumType?),
      if (currency != _undefined) 'currency': (currency as Enum$SortEnumType?),
      if (tier != _undefined) 'tier': (tier as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$SubscriptionSortInput<TRes>
    implements CopyWith$Input$SubscriptionSortInput<TRes> {
  _CopyWithStubImpl$Input$SubscriptionSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? description,
    Enum$SortEnumType? code,
    Enum$SortEnumType? version,
    Enum$SortEnumType? amount,
    Enum$SortEnumType? currency,
    Enum$SortEnumType? tier,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$SubscriptionStatusOperationFilterInput {
  factory Input$SubscriptionStatusOperationFilterInput({
    Enum$SubscriptionStatus? eq,
    Enum$SubscriptionStatus? neq,
    List<Enum$SubscriptionStatus>? $in,
    List<Enum$SubscriptionStatus>? nin,
  }) => Input$SubscriptionStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$SubscriptionStatusOperationFilterInput._(this._$data);

  factory Input$SubscriptionStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$SubscriptionStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$SubscriptionStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$SubscriptionStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$SubscriptionStatus((e as String)))
          .toList();
    }
    return Input$SubscriptionStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SubscriptionStatus? get eq => (_$data['eq'] as Enum$SubscriptionStatus?);

  Enum$SubscriptionStatus? get neq =>
      (_$data['neq'] as Enum$SubscriptionStatus?);

  List<Enum$SubscriptionStatus>? get $in =>
      (_$data['in'] as List<Enum$SubscriptionStatus>?);

  List<Enum$SubscriptionStatus>? get nin =>
      (_$data['nin'] as List<Enum$SubscriptionStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$SubscriptionStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$SubscriptionStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$SubscriptionStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$SubscriptionStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$SubscriptionStatusOperationFilterInput<
    Input$SubscriptionStatusOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$SubscriptionStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SubscriptionStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubscriptionStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$SubscriptionStatusOperationFilterInput(
    Input$SubscriptionStatusOperationFilterInput instance,
    TRes Function(Input$SubscriptionStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$SubscriptionStatusOperationFilterInput;

  factory CopyWith$Input$SubscriptionStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubscriptionStatusOperationFilterInput;

  TRes call({
    Enum$SubscriptionStatus? eq,
    Enum$SubscriptionStatus? neq,
    List<Enum$SubscriptionStatus>? $in,
    List<Enum$SubscriptionStatus>? nin,
  });
}

class _CopyWithImpl$Input$SubscriptionStatusOperationFilterInput<TRes>
    implements CopyWith$Input$SubscriptionStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$SubscriptionStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$SubscriptionStatusOperationFilterInput _instance;

  final TRes Function(Input$SubscriptionStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$SubscriptionStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$SubscriptionStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$SubscriptionStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$SubscriptionStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$SubscriptionStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$SubscriptionStatusOperationFilterInput<TRes>
    implements CopyWith$Input$SubscriptionStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$SubscriptionStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$SubscriptionStatus? eq,
    Enum$SubscriptionStatus? neq,
    List<Enum$SubscriptionStatus>? $in,
    List<Enum$SubscriptionStatus>? nin,
  }) => _res;
}

class Input$SubscriptionTierOperationFilterInput {
  factory Input$SubscriptionTierOperationFilterInput({
    Enum$SubscriptionTier? eq,
    Enum$SubscriptionTier? neq,
    List<Enum$SubscriptionTier>? $in,
    List<Enum$SubscriptionTier>? nin,
  }) => Input$SubscriptionTierOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$SubscriptionTierOperationFilterInput._(this._$data);

  factory Input$SubscriptionTierOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$SubscriptionTier((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$SubscriptionTier((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$SubscriptionTier((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$SubscriptionTier((e as String)))
          .toList();
    }
    return Input$SubscriptionTierOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SubscriptionTier? get eq => (_$data['eq'] as Enum$SubscriptionTier?);

  Enum$SubscriptionTier? get neq => (_$data['neq'] as Enum$SubscriptionTier?);

  List<Enum$SubscriptionTier>? get $in =>
      (_$data['in'] as List<Enum$SubscriptionTier>?);

  List<Enum$SubscriptionTier>? get nin =>
      (_$data['nin'] as List<Enum$SubscriptionTier>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$SubscriptionTier(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$SubscriptionTier(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$SubscriptionTier(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$SubscriptionTier(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$SubscriptionTierOperationFilterInput<
    Input$SubscriptionTierOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$SubscriptionTierOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SubscriptionTierOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubscriptionTierOperationFilterInput<TRes> {
  factory CopyWith$Input$SubscriptionTierOperationFilterInput(
    Input$SubscriptionTierOperationFilterInput instance,
    TRes Function(Input$SubscriptionTierOperationFilterInput) then,
  ) = _CopyWithImpl$Input$SubscriptionTierOperationFilterInput;

  factory CopyWith$Input$SubscriptionTierOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubscriptionTierOperationFilterInput;

  TRes call({
    Enum$SubscriptionTier? eq,
    Enum$SubscriptionTier? neq,
    List<Enum$SubscriptionTier>? $in,
    List<Enum$SubscriptionTier>? nin,
  });
}

class _CopyWithImpl$Input$SubscriptionTierOperationFilterInput<TRes>
    implements CopyWith$Input$SubscriptionTierOperationFilterInput<TRes> {
  _CopyWithImpl$Input$SubscriptionTierOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$SubscriptionTierOperationFilterInput _instance;

  final TRes Function(Input$SubscriptionTierOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$SubscriptionTierOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$SubscriptionTier?),
      if (neq != _undefined) 'neq': (neq as Enum$SubscriptionTier?),
      if ($in != _undefined) 'in': ($in as List<Enum$SubscriptionTier>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$SubscriptionTier>?),
    }),
  );
}

class _CopyWithStubImpl$Input$SubscriptionTierOperationFilterInput<TRes>
    implements CopyWith$Input$SubscriptionTierOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$SubscriptionTierOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$SubscriptionTier? eq,
    Enum$SubscriptionTier? neq,
    List<Enum$SubscriptionTier>? $in,
    List<Enum$SubscriptionTier>? nin,
  }) => _res;
}

class Input$SyncedLineFilterInput {
  factory Input$SyncedLineFilterInput({
    List<Input$SyncedLineFilterInput>? and,
    List<Input$SyncedLineFilterInput>? or,
    Input$StringOperationFilterInput? text,
    Input$FloatOperationFilterInput? time,
  }) => Input$SyncedLineFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (text != null) r'text': text,
    if (time != null) r'time': time,
  });

  Input$SyncedLineFilterInput._(this._$data);

  factory Input$SyncedLineFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$SyncedLineFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$SyncedLineFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('text')) {
      final l$text = data['text'];
      result$data['text'] = l$text == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$text as Map<String, dynamic>),
            );
    }
    if (data.containsKey('time')) {
      final l$time = data['time'];
      result$data['time'] = l$time == null
          ? null
          : Input$FloatOperationFilterInput.fromJson(
              (l$time as Map<String, dynamic>),
            );
    }
    return Input$SyncedLineFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SyncedLineFilterInput>? get and =>
      (_$data['and'] as List<Input$SyncedLineFilterInput>?);

  List<Input$SyncedLineFilterInput>? get or =>
      (_$data['or'] as List<Input$SyncedLineFilterInput>?);

  Input$StringOperationFilterInput? get text =>
      (_$data['text'] as Input$StringOperationFilterInput?);

  Input$FloatOperationFilterInput? get time =>
      (_$data['time'] as Input$FloatOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('text')) {
      final l$text = text;
      result$data['text'] = l$text?.toJson();
    }
    if (_$data.containsKey('time')) {
      final l$time = time;
      result$data['time'] = l$time?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SyncedLineFilterInput<Input$SyncedLineFilterInput>
  get copyWith => CopyWith$Input$SyncedLineFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SyncedLineFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$text = text;
    final lOther$text = other.text;
    if (_$data.containsKey('text') != other._$data.containsKey('text')) {
      return false;
    }
    if (l$text != lOther$text) {
      return false;
    }
    final l$time = time;
    final lOther$time = other.time;
    if (_$data.containsKey('time') != other._$data.containsKey('time')) {
      return false;
    }
    if (l$time != lOther$time) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$text = text;
    final l$time = time;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('text') ? l$text : const {},
      _$data.containsKey('time') ? l$time : const {},
    ]);
  }
}

abstract class CopyWith$Input$SyncedLineFilterInput<TRes> {
  factory CopyWith$Input$SyncedLineFilterInput(
    Input$SyncedLineFilterInput instance,
    TRes Function(Input$SyncedLineFilterInput) then,
  ) = _CopyWithImpl$Input$SyncedLineFilterInput;

  factory CopyWith$Input$SyncedLineFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SyncedLineFilterInput;

  TRes call({
    List<Input$SyncedLineFilterInput>? and,
    List<Input$SyncedLineFilterInput>? or,
    Input$StringOperationFilterInput? text,
    Input$FloatOperationFilterInput? time,
  });
  TRes and(
    Iterable<Input$SyncedLineFilterInput>? Function(
      Iterable<
        CopyWith$Input$SyncedLineFilterInput<Input$SyncedLineFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$SyncedLineFilterInput>? Function(
      Iterable<
        CopyWith$Input$SyncedLineFilterInput<Input$SyncedLineFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get text;
  CopyWith$Input$FloatOperationFilterInput<TRes> get time;
}

class _CopyWithImpl$Input$SyncedLineFilterInput<TRes>
    implements CopyWith$Input$SyncedLineFilterInput<TRes> {
  _CopyWithImpl$Input$SyncedLineFilterInput(this._instance, this._then);

  final Input$SyncedLineFilterInput _instance;

  final TRes Function(Input$SyncedLineFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? text = _undefined,
    Object? time = _undefined,
  }) => _then(
    Input$SyncedLineFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$SyncedLineFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$SyncedLineFilterInput>?),
      if (text != _undefined)
        'text': (text as Input$StringOperationFilterInput?),
      if (time != _undefined)
        'time': (time as Input$FloatOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$SyncedLineFilterInput>? Function(
      Iterable<
        CopyWith$Input$SyncedLineFilterInput<Input$SyncedLineFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$SyncedLineFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$SyncedLineFilterInput>? Function(
      Iterable<
        CopyWith$Input$SyncedLineFilterInput<Input$SyncedLineFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$SyncedLineFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get text {
    final local$text = _instance.text;
    return local$text == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$text,
            (e) => call(text: e),
          );
  }

  CopyWith$Input$FloatOperationFilterInput<TRes> get time {
    final local$time = _instance.time;
    return local$time == null
        ? CopyWith$Input$FloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$FloatOperationFilterInput(
            local$time,
            (e) => call(time: e),
          );
  }
}

class _CopyWithStubImpl$Input$SyncedLineFilterInput<TRes>
    implements CopyWith$Input$SyncedLineFilterInput<TRes> {
  _CopyWithStubImpl$Input$SyncedLineFilterInput(this._res);

  TRes _res;

  call({
    List<Input$SyncedLineFilterInput>? and,
    List<Input$SyncedLineFilterInput>? or,
    Input$StringOperationFilterInput? text,
    Input$FloatOperationFilterInput? time,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get text =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$FloatOperationFilterInput<TRes> get time =>
      CopyWith$Input$FloatOperationFilterInput.stub(_res);
}

class Input$ThreadedCommentsRequestInput {
  factory Input$ThreadedCommentsRequestInput({
    required String targetId,
    required Enum$CommentType commentType,
    required int page,
    required int pageSize,
    required Enum$CommentSortOrder sortOrder,
  }) => Input$ThreadedCommentsRequestInput._({
    r'targetId': targetId,
    r'commentType': commentType,
    r'page': page,
    r'pageSize': pageSize,
    r'sortOrder': sortOrder,
  });

  Input$ThreadedCommentsRequestInput._(this._$data);

  factory Input$ThreadedCommentsRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$targetId = data['targetId'];
    result$data['targetId'] = (l$targetId as String);
    final l$commentType = data['commentType'];
    result$data['commentType'] = fromJson$Enum$CommentType(
      (l$commentType as String),
    );
    final l$page = data['page'];
    result$data['page'] = (l$page as int);
    final l$pageSize = data['pageSize'];
    result$data['pageSize'] = (l$pageSize as int);
    final l$sortOrder = data['sortOrder'];
    result$data['sortOrder'] = fromJson$Enum$CommentSortOrder(
      (l$sortOrder as String),
    );
    return Input$ThreadedCommentsRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get targetId => (_$data['targetId'] as String);

  Enum$CommentType get commentType =>
      (_$data['commentType'] as Enum$CommentType);

  int get page => (_$data['page'] as int);

  int get pageSize => (_$data['pageSize'] as int);

  Enum$CommentSortOrder get sortOrder =>
      (_$data['sortOrder'] as Enum$CommentSortOrder);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$targetId = targetId;
    result$data['targetId'] = l$targetId;
    final l$commentType = commentType;
    result$data['commentType'] = toJson$Enum$CommentType(l$commentType);
    final l$page = page;
    result$data['page'] = l$page;
    final l$pageSize = pageSize;
    result$data['pageSize'] = l$pageSize;
    final l$sortOrder = sortOrder;
    result$data['sortOrder'] = toJson$Enum$CommentSortOrder(l$sortOrder);
    return result$data;
  }

  CopyWith$Input$ThreadedCommentsRequestInput<
    Input$ThreadedCommentsRequestInput
  >
  get copyWith => CopyWith$Input$ThreadedCommentsRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ThreadedCommentsRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (l$targetId != lOther$targetId) {
      return false;
    }
    final l$commentType = commentType;
    final lOther$commentType = other.commentType;
    if (l$commentType != lOther$commentType) {
      return false;
    }
    final l$page = page;
    final lOther$page = other.page;
    if (l$page != lOther$page) {
      return false;
    }
    final l$pageSize = pageSize;
    final lOther$pageSize = other.pageSize;
    if (l$pageSize != lOther$pageSize) {
      return false;
    }
    final l$sortOrder = sortOrder;
    final lOther$sortOrder = other.sortOrder;
    if (l$sortOrder != lOther$sortOrder) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$targetId = targetId;
    final l$commentType = commentType;
    final l$page = page;
    final l$pageSize = pageSize;
    final l$sortOrder = sortOrder;
    return Object.hashAll([
      l$targetId,
      l$commentType,
      l$page,
      l$pageSize,
      l$sortOrder,
    ]);
  }
}

abstract class CopyWith$Input$ThreadedCommentsRequestInput<TRes> {
  factory CopyWith$Input$ThreadedCommentsRequestInput(
    Input$ThreadedCommentsRequestInput instance,
    TRes Function(Input$ThreadedCommentsRequestInput) then,
  ) = _CopyWithImpl$Input$ThreadedCommentsRequestInput;

  factory CopyWith$Input$ThreadedCommentsRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ThreadedCommentsRequestInput;

  TRes call({
    String? targetId,
    Enum$CommentType? commentType,
    int? page,
    int? pageSize,
    Enum$CommentSortOrder? sortOrder,
  });
}

class _CopyWithImpl$Input$ThreadedCommentsRequestInput<TRes>
    implements CopyWith$Input$ThreadedCommentsRequestInput<TRes> {
  _CopyWithImpl$Input$ThreadedCommentsRequestInput(this._instance, this._then);

  final Input$ThreadedCommentsRequestInput _instance;

  final TRes Function(Input$ThreadedCommentsRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? targetId = _undefined,
    Object? commentType = _undefined,
    Object? page = _undefined,
    Object? pageSize = _undefined,
    Object? sortOrder = _undefined,
  }) => _then(
    Input$ThreadedCommentsRequestInput._({
      ..._instance._$data,
      if (targetId != _undefined && targetId != null)
        'targetId': (targetId as String),
      if (commentType != _undefined && commentType != null)
        'commentType': (commentType as Enum$CommentType),
      if (page != _undefined && page != null) 'page': (page as int),
      if (pageSize != _undefined && pageSize != null)
        'pageSize': (pageSize as int),
      if (sortOrder != _undefined && sortOrder != null)
        'sortOrder': (sortOrder as Enum$CommentSortOrder),
    }),
  );
}

class _CopyWithStubImpl$Input$ThreadedCommentsRequestInput<TRes>
    implements CopyWith$Input$ThreadedCommentsRequestInput<TRes> {
  _CopyWithStubImpl$Input$ThreadedCommentsRequestInput(this._res);

  TRes _res;

  call({
    String? targetId,
    Enum$CommentType? commentType,
    int? page,
    int? pageSize,
    Enum$CommentSortOrder? sortOrder,
  }) => _res;
}

class Input$TrackFilterInput {
  factory Input$TrackFilterInput({
    List<Input$TrackFilterInput>? and,
    List<Input$TrackFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? nameUnsigned,
    Input$StringOperationFilterInput? description,
    Input$TrackTypeOperationFilterInput? type,
    Input$ListStringOperationFilterInput? categoryIds,
    Input$ListStringOperationFilterInput? tags,
    Input$ListStringOperationFilterInput? mainArtistIds,
    Input$ListStringOperationFilterInput? featuredArtistIds,
    Input$AudioFeatureFilterInput? audioFeature,
    Input$StringOperationFilterInput? alternativeDescription,
    Input$AudioFingerprintFilterInput? audioFingerprint,
    Input$LongOperationFilterInput? streamCount,
    Input$LongOperationFilterInput? favoriteCount,
    Input$StringOperationFilterInput? coverImage,
    Input$StringOperationFilterInput? previewVideo,
    Input$BooleanOperationFilterInput? isExplicit,
    Input$StringOperationFilterInput? lyrics,
    Input$ListFilterInputTypeOfSyncedLineFilterInput? syncedLyrics,
    Input$DecimalOperationFilterInput? popularity,
    Input$ReleaseInfoFilterInput? releaseInfo,
    Input$RestrictionFilterInput? restriction,
    Input$ListFilterInputTypeOfLegalDocumentFilterInput? legalDocuments,
    Input$ListFloatOperationFilterInput? embeddingVector,
    Input$StringOperationFilterInput? createdBy,
    Input$StringOperationFilterInput? updatedBy,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$TrackFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (nameUnsigned != null) r'nameUnsigned': nameUnsigned,
    if (description != null) r'description': description,
    if (type != null) r'type': type,
    if (categoryIds != null) r'categoryIds': categoryIds,
    if (tags != null) r'tags': tags,
    if (mainArtistIds != null) r'mainArtistIds': mainArtistIds,
    if (featuredArtistIds != null) r'featuredArtistIds': featuredArtistIds,
    if (audioFeature != null) r'audioFeature': audioFeature,
    if (alternativeDescription != null)
      r'alternativeDescription': alternativeDescription,
    if (audioFingerprint != null) r'audioFingerprint': audioFingerprint,
    if (streamCount != null) r'streamCount': streamCount,
    if (favoriteCount != null) r'favoriteCount': favoriteCount,
    if (coverImage != null) r'coverImage': coverImage,
    if (previewVideo != null) r'previewVideo': previewVideo,
    if (isExplicit != null) r'isExplicit': isExplicit,
    if (lyrics != null) r'lyrics': lyrics,
    if (syncedLyrics != null) r'syncedLyrics': syncedLyrics,
    if (popularity != null) r'popularity': popularity,
    if (releaseInfo != null) r'releaseInfo': releaseInfo,
    if (restriction != null) r'restriction': restriction,
    if (legalDocuments != null) r'legalDocuments': legalDocuments,
    if (embeddingVector != null) r'embeddingVector': embeddingVector,
    if (createdBy != null) r'createdBy': createdBy,
    if (updatedBy != null) r'updatedBy': updatedBy,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$TrackFilterInput._(this._$data);

  factory Input$TrackFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$TrackFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$TrackFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$name as Map<String, dynamic>),
            );
    }
    if (data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = data['nameUnsigned'];
      result$data['nameUnsigned'] = l$nameUnsigned == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$nameUnsigned as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : Input$TrackTypeOperationFilterInput.fromJson(
              (l$type as Map<String, dynamic>),
            );
    }
    if (data.containsKey('categoryIds')) {
      final l$categoryIds = data['categoryIds'];
      result$data['categoryIds'] = l$categoryIds == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$categoryIds as Map<String, dynamic>),
            );
    }
    if (data.containsKey('tags')) {
      final l$tags = data['tags'];
      result$data['tags'] = l$tags == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$tags as Map<String, dynamic>),
            );
    }
    if (data.containsKey('mainArtistIds')) {
      final l$mainArtistIds = data['mainArtistIds'];
      result$data['mainArtistIds'] = l$mainArtistIds == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$mainArtistIds as Map<String, dynamic>),
            );
    }
    if (data.containsKey('featuredArtistIds')) {
      final l$featuredArtistIds = data['featuredArtistIds'];
      result$data['featuredArtistIds'] = l$featuredArtistIds == null
          ? null
          : Input$ListStringOperationFilterInput.fromJson(
              (l$featuredArtistIds as Map<String, dynamic>),
            );
    }
    if (data.containsKey('audioFeature')) {
      final l$audioFeature = data['audioFeature'];
      result$data['audioFeature'] = l$audioFeature == null
          ? null
          : Input$AudioFeatureFilterInput.fromJson(
              (l$audioFeature as Map<String, dynamic>),
            );
    }
    if (data.containsKey('alternativeDescription')) {
      final l$alternativeDescription = data['alternativeDescription'];
      result$data['alternativeDescription'] = l$alternativeDescription == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$alternativeDescription as Map<String, dynamic>),
            );
    }
    if (data.containsKey('audioFingerprint')) {
      final l$audioFingerprint = data['audioFingerprint'];
      result$data['audioFingerprint'] = l$audioFingerprint == null
          ? null
          : Input$AudioFingerprintFilterInput.fromJson(
              (l$audioFingerprint as Map<String, dynamic>),
            );
    }
    if (data.containsKey('streamCount')) {
      final l$streamCount = data['streamCount'];
      result$data['streamCount'] = l$streamCount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$streamCount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('favoriteCount')) {
      final l$favoriteCount = data['favoriteCount'];
      result$data['favoriteCount'] = l$favoriteCount == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$favoriteCount as Map<String, dynamic>),
            );
    }
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = l$coverImage == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$coverImage as Map<String, dynamic>),
            );
    }
    if (data.containsKey('previewVideo')) {
      final l$previewVideo = data['previewVideo'];
      result$data['previewVideo'] = l$previewVideo == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$previewVideo as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isExplicit')) {
      final l$isExplicit = data['isExplicit'];
      result$data['isExplicit'] = l$isExplicit == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isExplicit as Map<String, dynamic>),
            );
    }
    if (data.containsKey('lyrics')) {
      final l$lyrics = data['lyrics'];
      result$data['lyrics'] = l$lyrics == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$lyrics as Map<String, dynamic>),
            );
    }
    if (data.containsKey('syncedLyrics')) {
      final l$syncedLyrics = data['syncedLyrics'];
      result$data['syncedLyrics'] = l$syncedLyrics == null
          ? null
          : Input$ListFilterInputTypeOfSyncedLineFilterInput.fromJson(
              (l$syncedLyrics as Map<String, dynamic>),
            );
    }
    if (data.containsKey('popularity')) {
      final l$popularity = data['popularity'];
      result$data['popularity'] = l$popularity == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$popularity as Map<String, dynamic>),
            );
    }
    if (data.containsKey('releaseInfo')) {
      final l$releaseInfo = data['releaseInfo'];
      result$data['releaseInfo'] = l$releaseInfo == null
          ? null
          : Input$ReleaseInfoFilterInput.fromJson(
              (l$releaseInfo as Map<String, dynamic>),
            );
    }
    if (data.containsKey('restriction')) {
      final l$restriction = data['restriction'];
      result$data['restriction'] = l$restriction == null
          ? null
          : Input$RestrictionFilterInput.fromJson(
              (l$restriction as Map<String, dynamic>),
            );
    }
    if (data.containsKey('legalDocuments')) {
      final l$legalDocuments = data['legalDocuments'];
      result$data['legalDocuments'] = l$legalDocuments == null
          ? null
          : Input$ListFilterInputTypeOfLegalDocumentFilterInput.fromJson(
              (l$legalDocuments as Map<String, dynamic>),
            );
    }
    if (data.containsKey('embeddingVector')) {
      final l$embeddingVector = data['embeddingVector'];
      result$data['embeddingVector'] = l$embeddingVector == null
          ? null
          : Input$ListFloatOperationFilterInput.fromJson(
              (l$embeddingVector as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdBy')) {
      final l$createdBy = data['createdBy'];
      result$data['createdBy'] = l$createdBy == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$createdBy as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedBy')) {
      final l$updatedBy = data['updatedBy'];
      result$data['updatedBy'] = l$updatedBy == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$updatedBy as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$TrackFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TrackFilterInput>? get and =>
      (_$data['and'] as List<Input$TrackFilterInput>?);

  List<Input$TrackFilterInput>? get or =>
      (_$data['or'] as List<Input$TrackFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get name =>
      (_$data['name'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get nameUnsigned =>
      (_$data['nameUnsigned'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$TrackTypeOperationFilterInput? get type =>
      (_$data['type'] as Input$TrackTypeOperationFilterInput?);

  Input$ListStringOperationFilterInput? get categoryIds =>
      (_$data['categoryIds'] as Input$ListStringOperationFilterInput?);

  Input$ListStringOperationFilterInput? get tags =>
      (_$data['tags'] as Input$ListStringOperationFilterInput?);

  Input$ListStringOperationFilterInput? get mainArtistIds =>
      (_$data['mainArtistIds'] as Input$ListStringOperationFilterInput?);

  Input$ListStringOperationFilterInput? get featuredArtistIds =>
      (_$data['featuredArtistIds'] as Input$ListStringOperationFilterInput?);

  Input$AudioFeatureFilterInput? get audioFeature =>
      (_$data['audioFeature'] as Input$AudioFeatureFilterInput?);

  Input$StringOperationFilterInput? get alternativeDescription =>
      (_$data['alternativeDescription'] as Input$StringOperationFilterInput?);

  Input$AudioFingerprintFilterInput? get audioFingerprint =>
      (_$data['audioFingerprint'] as Input$AudioFingerprintFilterInput?);

  Input$LongOperationFilterInput? get streamCount =>
      (_$data['streamCount'] as Input$LongOperationFilterInput?);

  Input$LongOperationFilterInput? get favoriteCount =>
      (_$data['favoriteCount'] as Input$LongOperationFilterInput?);

  Input$StringOperationFilterInput? get coverImage =>
      (_$data['coverImage'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get previewVideo =>
      (_$data['previewVideo'] as Input$StringOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isExplicit =>
      (_$data['isExplicit'] as Input$BooleanOperationFilterInput?);

  Input$StringOperationFilterInput? get lyrics =>
      (_$data['lyrics'] as Input$StringOperationFilterInput?);

  Input$ListFilterInputTypeOfSyncedLineFilterInput? get syncedLyrics =>
      (_$data['syncedLyrics']
          as Input$ListFilterInputTypeOfSyncedLineFilterInput?);

  Input$DecimalOperationFilterInput? get popularity =>
      (_$data['popularity'] as Input$DecimalOperationFilterInput?);

  Input$ReleaseInfoFilterInput? get releaseInfo =>
      (_$data['releaseInfo'] as Input$ReleaseInfoFilterInput?);

  Input$RestrictionFilterInput? get restriction =>
      (_$data['restriction'] as Input$RestrictionFilterInput?);

  Input$ListFilterInputTypeOfLegalDocumentFilterInput? get legalDocuments =>
      (_$data['legalDocuments']
          as Input$ListFilterInputTypeOfLegalDocumentFilterInput?);

  Input$ListFloatOperationFilterInput? get embeddingVector =>
      (_$data['embeddingVector'] as Input$ListFloatOperationFilterInput?);

  Input$StringOperationFilterInput? get createdBy =>
      (_$data['createdBy'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get updatedBy =>
      (_$data['updatedBy'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = nameUnsigned;
      result$data['nameUnsigned'] = l$nameUnsigned?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.toJson();
    }
    if (_$data.containsKey('categoryIds')) {
      final l$categoryIds = categoryIds;
      result$data['categoryIds'] = l$categoryIds?.toJson();
    }
    if (_$data.containsKey('tags')) {
      final l$tags = tags;
      result$data['tags'] = l$tags?.toJson();
    }
    if (_$data.containsKey('mainArtistIds')) {
      final l$mainArtistIds = mainArtistIds;
      result$data['mainArtistIds'] = l$mainArtistIds?.toJson();
    }
    if (_$data.containsKey('featuredArtistIds')) {
      final l$featuredArtistIds = featuredArtistIds;
      result$data['featuredArtistIds'] = l$featuredArtistIds?.toJson();
    }
    if (_$data.containsKey('audioFeature')) {
      final l$audioFeature = audioFeature;
      result$data['audioFeature'] = l$audioFeature?.toJson();
    }
    if (_$data.containsKey('alternativeDescription')) {
      final l$alternativeDescription = alternativeDescription;
      result$data['alternativeDescription'] = l$alternativeDescription
          ?.toJson();
    }
    if (_$data.containsKey('audioFingerprint')) {
      final l$audioFingerprint = audioFingerprint;
      result$data['audioFingerprint'] = l$audioFingerprint?.toJson();
    }
    if (_$data.containsKey('streamCount')) {
      final l$streamCount = streamCount;
      result$data['streamCount'] = l$streamCount?.toJson();
    }
    if (_$data.containsKey('favoriteCount')) {
      final l$favoriteCount = favoriteCount;
      result$data['favoriteCount'] = l$favoriteCount?.toJson();
    }
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage?.toJson();
    }
    if (_$data.containsKey('previewVideo')) {
      final l$previewVideo = previewVideo;
      result$data['previewVideo'] = l$previewVideo?.toJson();
    }
    if (_$data.containsKey('isExplicit')) {
      final l$isExplicit = isExplicit;
      result$data['isExplicit'] = l$isExplicit?.toJson();
    }
    if (_$data.containsKey('lyrics')) {
      final l$lyrics = lyrics;
      result$data['lyrics'] = l$lyrics?.toJson();
    }
    if (_$data.containsKey('syncedLyrics')) {
      final l$syncedLyrics = syncedLyrics;
      result$data['syncedLyrics'] = l$syncedLyrics?.toJson();
    }
    if (_$data.containsKey('popularity')) {
      final l$popularity = popularity;
      result$data['popularity'] = l$popularity?.toJson();
    }
    if (_$data.containsKey('releaseInfo')) {
      final l$releaseInfo = releaseInfo;
      result$data['releaseInfo'] = l$releaseInfo?.toJson();
    }
    if (_$data.containsKey('restriction')) {
      final l$restriction = restriction;
      result$data['restriction'] = l$restriction?.toJson();
    }
    if (_$data.containsKey('legalDocuments')) {
      final l$legalDocuments = legalDocuments;
      result$data['legalDocuments'] = l$legalDocuments?.toJson();
    }
    if (_$data.containsKey('embeddingVector')) {
      final l$embeddingVector = embeddingVector;
      result$data['embeddingVector'] = l$embeddingVector?.toJson();
    }
    if (_$data.containsKey('createdBy')) {
      final l$createdBy = createdBy;
      result$data['createdBy'] = l$createdBy?.toJson();
    }
    if (_$data.containsKey('updatedBy')) {
      final l$updatedBy = updatedBy;
      result$data['updatedBy'] = l$updatedBy?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TrackFilterInput<Input$TrackFilterInput> get copyWith =>
      CopyWith$Input$TrackFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TrackFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$nameUnsigned = nameUnsigned;
    final lOther$nameUnsigned = other.nameUnsigned;
    if (_$data.containsKey('nameUnsigned') !=
        other._$data.containsKey('nameUnsigned')) {
      return false;
    }
    if (l$nameUnsigned != lOther$nameUnsigned) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$categoryIds = categoryIds;
    final lOther$categoryIds = other.categoryIds;
    if (_$data.containsKey('categoryIds') !=
        other._$data.containsKey('categoryIds')) {
      return false;
    }
    if (l$categoryIds != lOther$categoryIds) {
      return false;
    }
    final l$tags = tags;
    final lOther$tags = other.tags;
    if (_$data.containsKey('tags') != other._$data.containsKey('tags')) {
      return false;
    }
    if (l$tags != lOther$tags) {
      return false;
    }
    final l$mainArtistIds = mainArtistIds;
    final lOther$mainArtistIds = other.mainArtistIds;
    if (_$data.containsKey('mainArtistIds') !=
        other._$data.containsKey('mainArtistIds')) {
      return false;
    }
    if (l$mainArtistIds != lOther$mainArtistIds) {
      return false;
    }
    final l$featuredArtistIds = featuredArtistIds;
    final lOther$featuredArtistIds = other.featuredArtistIds;
    if (_$data.containsKey('featuredArtistIds') !=
        other._$data.containsKey('featuredArtistIds')) {
      return false;
    }
    if (l$featuredArtistIds != lOther$featuredArtistIds) {
      return false;
    }
    final l$audioFeature = audioFeature;
    final lOther$audioFeature = other.audioFeature;
    if (_$data.containsKey('audioFeature') !=
        other._$data.containsKey('audioFeature')) {
      return false;
    }
    if (l$audioFeature != lOther$audioFeature) {
      return false;
    }
    final l$alternativeDescription = alternativeDescription;
    final lOther$alternativeDescription = other.alternativeDescription;
    if (_$data.containsKey('alternativeDescription') !=
        other._$data.containsKey('alternativeDescription')) {
      return false;
    }
    if (l$alternativeDescription != lOther$alternativeDescription) {
      return false;
    }
    final l$audioFingerprint = audioFingerprint;
    final lOther$audioFingerprint = other.audioFingerprint;
    if (_$data.containsKey('audioFingerprint') !=
        other._$data.containsKey('audioFingerprint')) {
      return false;
    }
    if (l$audioFingerprint != lOther$audioFingerprint) {
      return false;
    }
    final l$streamCount = streamCount;
    final lOther$streamCount = other.streamCount;
    if (_$data.containsKey('streamCount') !=
        other._$data.containsKey('streamCount')) {
      return false;
    }
    if (l$streamCount != lOther$streamCount) {
      return false;
    }
    final l$favoriteCount = favoriteCount;
    final lOther$favoriteCount = other.favoriteCount;
    if (_$data.containsKey('favoriteCount') !=
        other._$data.containsKey('favoriteCount')) {
      return false;
    }
    if (l$favoriteCount != lOther$favoriteCount) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$previewVideo = previewVideo;
    final lOther$previewVideo = other.previewVideo;
    if (_$data.containsKey('previewVideo') !=
        other._$data.containsKey('previewVideo')) {
      return false;
    }
    if (l$previewVideo != lOther$previewVideo) {
      return false;
    }
    final l$isExplicit = isExplicit;
    final lOther$isExplicit = other.isExplicit;
    if (_$data.containsKey('isExplicit') !=
        other._$data.containsKey('isExplicit')) {
      return false;
    }
    if (l$isExplicit != lOther$isExplicit) {
      return false;
    }
    final l$lyrics = lyrics;
    final lOther$lyrics = other.lyrics;
    if (_$data.containsKey('lyrics') != other._$data.containsKey('lyrics')) {
      return false;
    }
    if (l$lyrics != lOther$lyrics) {
      return false;
    }
    final l$syncedLyrics = syncedLyrics;
    final lOther$syncedLyrics = other.syncedLyrics;
    if (_$data.containsKey('syncedLyrics') !=
        other._$data.containsKey('syncedLyrics')) {
      return false;
    }
    if (l$syncedLyrics != lOther$syncedLyrics) {
      return false;
    }
    final l$popularity = popularity;
    final lOther$popularity = other.popularity;
    if (_$data.containsKey('popularity') !=
        other._$data.containsKey('popularity')) {
      return false;
    }
    if (l$popularity != lOther$popularity) {
      return false;
    }
    final l$releaseInfo = releaseInfo;
    final lOther$releaseInfo = other.releaseInfo;
    if (_$data.containsKey('releaseInfo') !=
        other._$data.containsKey('releaseInfo')) {
      return false;
    }
    if (l$releaseInfo != lOther$releaseInfo) {
      return false;
    }
    final l$restriction = restriction;
    final lOther$restriction = other.restriction;
    if (_$data.containsKey('restriction') !=
        other._$data.containsKey('restriction')) {
      return false;
    }
    if (l$restriction != lOther$restriction) {
      return false;
    }
    final l$legalDocuments = legalDocuments;
    final lOther$legalDocuments = other.legalDocuments;
    if (_$data.containsKey('legalDocuments') !=
        other._$data.containsKey('legalDocuments')) {
      return false;
    }
    if (l$legalDocuments != lOther$legalDocuments) {
      return false;
    }
    final l$embeddingVector = embeddingVector;
    final lOther$embeddingVector = other.embeddingVector;
    if (_$data.containsKey('embeddingVector') !=
        other._$data.containsKey('embeddingVector')) {
      return false;
    }
    if (l$embeddingVector != lOther$embeddingVector) {
      return false;
    }
    final l$createdBy = createdBy;
    final lOther$createdBy = other.createdBy;
    if (_$data.containsKey('createdBy') !=
        other._$data.containsKey('createdBy')) {
      return false;
    }
    if (l$createdBy != lOther$createdBy) {
      return false;
    }
    final l$updatedBy = updatedBy;
    final lOther$updatedBy = other.updatedBy;
    if (_$data.containsKey('updatedBy') !=
        other._$data.containsKey('updatedBy')) {
      return false;
    }
    if (l$updatedBy != lOther$updatedBy) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$name = name;
    final l$nameUnsigned = nameUnsigned;
    final l$description = description;
    final l$type = type;
    final l$categoryIds = categoryIds;
    final l$tags = tags;
    final l$mainArtistIds = mainArtistIds;
    final l$featuredArtistIds = featuredArtistIds;
    final l$audioFeature = audioFeature;
    final l$alternativeDescription = alternativeDescription;
    final l$audioFingerprint = audioFingerprint;
    final l$streamCount = streamCount;
    final l$favoriteCount = favoriteCount;
    final l$coverImage = coverImage;
    final l$previewVideo = previewVideo;
    final l$isExplicit = isExplicit;
    final l$lyrics = lyrics;
    final l$syncedLyrics = syncedLyrics;
    final l$popularity = popularity;
    final l$releaseInfo = releaseInfo;
    final l$restriction = restriction;
    final l$legalDocuments = legalDocuments;
    final l$embeddingVector = embeddingVector;
    final l$createdBy = createdBy;
    final l$updatedBy = updatedBy;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('nameUnsigned') ? l$nameUnsigned : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('categoryIds') ? l$categoryIds : const {},
      _$data.containsKey('tags') ? l$tags : const {},
      _$data.containsKey('mainArtistIds') ? l$mainArtistIds : const {},
      _$data.containsKey('featuredArtistIds') ? l$featuredArtistIds : const {},
      _$data.containsKey('audioFeature') ? l$audioFeature : const {},
      _$data.containsKey('alternativeDescription')
          ? l$alternativeDescription
          : const {},
      _$data.containsKey('audioFingerprint') ? l$audioFingerprint : const {},
      _$data.containsKey('streamCount') ? l$streamCount : const {},
      _$data.containsKey('favoriteCount') ? l$favoriteCount : const {},
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('previewVideo') ? l$previewVideo : const {},
      _$data.containsKey('isExplicit') ? l$isExplicit : const {},
      _$data.containsKey('lyrics') ? l$lyrics : const {},
      _$data.containsKey('syncedLyrics') ? l$syncedLyrics : const {},
      _$data.containsKey('popularity') ? l$popularity : const {},
      _$data.containsKey('releaseInfo') ? l$releaseInfo : const {},
      _$data.containsKey('restriction') ? l$restriction : const {},
      _$data.containsKey('legalDocuments') ? l$legalDocuments : const {},
      _$data.containsKey('embeddingVector') ? l$embeddingVector : const {},
      _$data.containsKey('createdBy') ? l$createdBy : const {},
      _$data.containsKey('updatedBy') ? l$updatedBy : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$TrackFilterInput<TRes> {
  factory CopyWith$Input$TrackFilterInput(
    Input$TrackFilterInput instance,
    TRes Function(Input$TrackFilterInput) then,
  ) = _CopyWithImpl$Input$TrackFilterInput;

  factory CopyWith$Input$TrackFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TrackFilterInput;

  TRes call({
    List<Input$TrackFilterInput>? and,
    List<Input$TrackFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? nameUnsigned,
    Input$StringOperationFilterInput? description,
    Input$TrackTypeOperationFilterInput? type,
    Input$ListStringOperationFilterInput? categoryIds,
    Input$ListStringOperationFilterInput? tags,
    Input$ListStringOperationFilterInput? mainArtistIds,
    Input$ListStringOperationFilterInput? featuredArtistIds,
    Input$AudioFeatureFilterInput? audioFeature,
    Input$StringOperationFilterInput? alternativeDescription,
    Input$AudioFingerprintFilterInput? audioFingerprint,
    Input$LongOperationFilterInput? streamCount,
    Input$LongOperationFilterInput? favoriteCount,
    Input$StringOperationFilterInput? coverImage,
    Input$StringOperationFilterInput? previewVideo,
    Input$BooleanOperationFilterInput? isExplicit,
    Input$StringOperationFilterInput? lyrics,
    Input$ListFilterInputTypeOfSyncedLineFilterInput? syncedLyrics,
    Input$DecimalOperationFilterInput? popularity,
    Input$ReleaseInfoFilterInput? releaseInfo,
    Input$RestrictionFilterInput? restriction,
    Input$ListFilterInputTypeOfLegalDocumentFilterInput? legalDocuments,
    Input$ListFloatOperationFilterInput? embeddingVector,
    Input$StringOperationFilterInput? createdBy,
    Input$StringOperationFilterInput? updatedBy,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$TrackFilterInput>? Function(
      Iterable<CopyWith$Input$TrackFilterInput<Input$TrackFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$TrackFilterInput>? Function(
      Iterable<CopyWith$Input$TrackFilterInput<Input$TrackFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get name;
  CopyWith$Input$StringOperationFilterInput<TRes> get nameUnsigned;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$TrackTypeOperationFilterInput<TRes> get type;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get categoryIds;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get tags;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get mainArtistIds;
  CopyWith$Input$ListStringOperationFilterInput<TRes> get featuredArtistIds;
  CopyWith$Input$AudioFeatureFilterInput<TRes> get audioFeature;
  CopyWith$Input$StringOperationFilterInput<TRes> get alternativeDescription;
  CopyWith$Input$AudioFingerprintFilterInput<TRes> get audioFingerprint;
  CopyWith$Input$LongOperationFilterInput<TRes> get streamCount;
  CopyWith$Input$LongOperationFilterInput<TRes> get favoriteCount;
  CopyWith$Input$StringOperationFilterInput<TRes> get coverImage;
  CopyWith$Input$StringOperationFilterInput<TRes> get previewVideo;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isExplicit;
  CopyWith$Input$StringOperationFilterInput<TRes> get lyrics;
  CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput<TRes>
  get syncedLyrics;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get popularity;
  CopyWith$Input$ReleaseInfoFilterInput<TRes> get releaseInfo;
  CopyWith$Input$RestrictionFilterInput<TRes> get restriction;
  CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput<TRes>
  get legalDocuments;
  CopyWith$Input$ListFloatOperationFilterInput<TRes> get embeddingVector;
  CopyWith$Input$StringOperationFilterInput<TRes> get createdBy;
  CopyWith$Input$StringOperationFilterInput<TRes> get updatedBy;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$TrackFilterInput<TRes>
    implements CopyWith$Input$TrackFilterInput<TRes> {
  _CopyWithImpl$Input$TrackFilterInput(this._instance, this._then);

  final Input$TrackFilterInput _instance;

  final TRes Function(Input$TrackFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? nameUnsigned = _undefined,
    Object? description = _undefined,
    Object? type = _undefined,
    Object? categoryIds = _undefined,
    Object? tags = _undefined,
    Object? mainArtistIds = _undefined,
    Object? featuredArtistIds = _undefined,
    Object? audioFeature = _undefined,
    Object? alternativeDescription = _undefined,
    Object? audioFingerprint = _undefined,
    Object? streamCount = _undefined,
    Object? favoriteCount = _undefined,
    Object? coverImage = _undefined,
    Object? previewVideo = _undefined,
    Object? isExplicit = _undefined,
    Object? lyrics = _undefined,
    Object? syncedLyrics = _undefined,
    Object? popularity = _undefined,
    Object? releaseInfo = _undefined,
    Object? restriction = _undefined,
    Object? legalDocuments = _undefined,
    Object? embeddingVector = _undefined,
    Object? createdBy = _undefined,
    Object? updatedBy = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$TrackFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$TrackFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$TrackFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (name != _undefined)
        'name': (name as Input$StringOperationFilterInput?),
      if (nameUnsigned != _undefined)
        'nameUnsigned': (nameUnsigned as Input$StringOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (type != _undefined)
        'type': (type as Input$TrackTypeOperationFilterInput?),
      if (categoryIds != _undefined)
        'categoryIds': (categoryIds as Input$ListStringOperationFilterInput?),
      if (tags != _undefined)
        'tags': (tags as Input$ListStringOperationFilterInput?),
      if (mainArtistIds != _undefined)
        'mainArtistIds':
            (mainArtistIds as Input$ListStringOperationFilterInput?),
      if (featuredArtistIds != _undefined)
        'featuredArtistIds':
            (featuredArtistIds as Input$ListStringOperationFilterInput?),
      if (audioFeature != _undefined)
        'audioFeature': (audioFeature as Input$AudioFeatureFilterInput?),
      if (alternativeDescription != _undefined)
        'alternativeDescription':
            (alternativeDescription as Input$StringOperationFilterInput?),
      if (audioFingerprint != _undefined)
        'audioFingerprint':
            (audioFingerprint as Input$AudioFingerprintFilterInput?),
      if (streamCount != _undefined)
        'streamCount': (streamCount as Input$LongOperationFilterInput?),
      if (favoriteCount != _undefined)
        'favoriteCount': (favoriteCount as Input$LongOperationFilterInput?),
      if (coverImage != _undefined)
        'coverImage': (coverImage as Input$StringOperationFilterInput?),
      if (previewVideo != _undefined)
        'previewVideo': (previewVideo as Input$StringOperationFilterInput?),
      if (isExplicit != _undefined)
        'isExplicit': (isExplicit as Input$BooleanOperationFilterInput?),
      if (lyrics != _undefined)
        'lyrics': (lyrics as Input$StringOperationFilterInput?),
      if (syncedLyrics != _undefined)
        'syncedLyrics':
            (syncedLyrics as Input$ListFilterInputTypeOfSyncedLineFilterInput?),
      if (popularity != _undefined)
        'popularity': (popularity as Input$DecimalOperationFilterInput?),
      if (releaseInfo != _undefined)
        'releaseInfo': (releaseInfo as Input$ReleaseInfoFilterInput?),
      if (restriction != _undefined)
        'restriction': (restriction as Input$RestrictionFilterInput?),
      if (legalDocuments != _undefined)
        'legalDocuments':
            (legalDocuments
                as Input$ListFilterInputTypeOfLegalDocumentFilterInput?),
      if (embeddingVector != _undefined)
        'embeddingVector':
            (embeddingVector as Input$ListFloatOperationFilterInput?),
      if (createdBy != _undefined)
        'createdBy': (createdBy as Input$StringOperationFilterInput?),
      if (updatedBy != _undefined)
        'updatedBy': (updatedBy as Input$StringOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$TrackFilterInput>? Function(
      Iterable<CopyWith$Input$TrackFilterInput<Input$TrackFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$TrackFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$TrackFilterInput>? Function(
      Iterable<CopyWith$Input$TrackFilterInput<Input$TrackFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$TrackFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$name,
            (e) => call(name: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get nameUnsigned {
    final local$nameUnsigned = _instance.nameUnsigned;
    return local$nameUnsigned == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$nameUnsigned,
            (e) => call(nameUnsigned: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$TrackTypeOperationFilterInput<TRes> get type {
    final local$type = _instance.type;
    return local$type == null
        ? CopyWith$Input$TrackTypeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$TrackTypeOperationFilterInput(
            local$type,
            (e) => call(type: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get categoryIds {
    final local$categoryIds = _instance.categoryIds;
    return local$categoryIds == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$categoryIds,
            (e) => call(categoryIds: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get tags {
    final local$tags = _instance.tags;
    return local$tags == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$tags,
            (e) => call(tags: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get mainArtistIds {
    final local$mainArtistIds = _instance.mainArtistIds;
    return local$mainArtistIds == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$mainArtistIds,
            (e) => call(mainArtistIds: e),
          );
  }

  CopyWith$Input$ListStringOperationFilterInput<TRes> get featuredArtistIds {
    final local$featuredArtistIds = _instance.featuredArtistIds;
    return local$featuredArtistIds == null
        ? CopyWith$Input$ListStringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListStringOperationFilterInput(
            local$featuredArtistIds,
            (e) => call(featuredArtistIds: e),
          );
  }

  CopyWith$Input$AudioFeatureFilterInput<TRes> get audioFeature {
    final local$audioFeature = _instance.audioFeature;
    return local$audioFeature == null
        ? CopyWith$Input$AudioFeatureFilterInput.stub(_then(_instance))
        : CopyWith$Input$AudioFeatureFilterInput(
            local$audioFeature,
            (e) => call(audioFeature: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get alternativeDescription {
    final local$alternativeDescription = _instance.alternativeDescription;
    return local$alternativeDescription == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$alternativeDescription,
            (e) => call(alternativeDescription: e),
          );
  }

  CopyWith$Input$AudioFingerprintFilterInput<TRes> get audioFingerprint {
    final local$audioFingerprint = _instance.audioFingerprint;
    return local$audioFingerprint == null
        ? CopyWith$Input$AudioFingerprintFilterInput.stub(_then(_instance))
        : CopyWith$Input$AudioFingerprintFilterInput(
            local$audioFingerprint,
            (e) => call(audioFingerprint: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get streamCount {
    final local$streamCount = _instance.streamCount;
    return local$streamCount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$streamCount,
            (e) => call(streamCount: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get favoriteCount {
    final local$favoriteCount = _instance.favoriteCount;
    return local$favoriteCount == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$favoriteCount,
            (e) => call(favoriteCount: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get coverImage {
    final local$coverImage = _instance.coverImage;
    return local$coverImage == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$coverImage,
            (e) => call(coverImage: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get previewVideo {
    final local$previewVideo = _instance.previewVideo;
    return local$previewVideo == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$previewVideo,
            (e) => call(previewVideo: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isExplicit {
    final local$isExplicit = _instance.isExplicit;
    return local$isExplicit == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isExplicit,
            (e) => call(isExplicit: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get lyrics {
    final local$lyrics = _instance.lyrics;
    return local$lyrics == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$lyrics,
            (e) => call(lyrics: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput<TRes>
  get syncedLyrics {
    final local$syncedLyrics = _instance.syncedLyrics;
    return local$syncedLyrics == null
        ? CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput(
            local$syncedLyrics,
            (e) => call(syncedLyrics: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get popularity {
    final local$popularity = _instance.popularity;
    return local$popularity == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$popularity,
            (e) => call(popularity: e),
          );
  }

  CopyWith$Input$ReleaseInfoFilterInput<TRes> get releaseInfo {
    final local$releaseInfo = _instance.releaseInfo;
    return local$releaseInfo == null
        ? CopyWith$Input$ReleaseInfoFilterInput.stub(_then(_instance))
        : CopyWith$Input$ReleaseInfoFilterInput(
            local$releaseInfo,
            (e) => call(releaseInfo: e),
          );
  }

  CopyWith$Input$RestrictionFilterInput<TRes> get restriction {
    final local$restriction = _instance.restriction;
    return local$restriction == null
        ? CopyWith$Input$RestrictionFilterInput.stub(_then(_instance))
        : CopyWith$Input$RestrictionFilterInput(
            local$restriction,
            (e) => call(restriction: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput<TRes>
  get legalDocuments {
    final local$legalDocuments = _instance.legalDocuments;
    return local$legalDocuments == null
        ? CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput(
            local$legalDocuments,
            (e) => call(legalDocuments: e),
          );
  }

  CopyWith$Input$ListFloatOperationFilterInput<TRes> get embeddingVector {
    final local$embeddingVector = _instance.embeddingVector;
    return local$embeddingVector == null
        ? CopyWith$Input$ListFloatOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ListFloatOperationFilterInput(
            local$embeddingVector,
            (e) => call(embeddingVector: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get createdBy {
    final local$createdBy = _instance.createdBy;
    return local$createdBy == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$createdBy,
            (e) => call(createdBy: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get updatedBy {
    final local$updatedBy = _instance.updatedBy;
    return local$updatedBy == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$updatedBy,
            (e) => call(updatedBy: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$TrackFilterInput<TRes>
    implements CopyWith$Input$TrackFilterInput<TRes> {
  _CopyWithStubImpl$Input$TrackFilterInput(this._res);

  TRes _res;

  call({
    List<Input$TrackFilterInput>? and,
    List<Input$TrackFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? name,
    Input$StringOperationFilterInput? nameUnsigned,
    Input$StringOperationFilterInput? description,
    Input$TrackTypeOperationFilterInput? type,
    Input$ListStringOperationFilterInput? categoryIds,
    Input$ListStringOperationFilterInput? tags,
    Input$ListStringOperationFilterInput? mainArtistIds,
    Input$ListStringOperationFilterInput? featuredArtistIds,
    Input$AudioFeatureFilterInput? audioFeature,
    Input$StringOperationFilterInput? alternativeDescription,
    Input$AudioFingerprintFilterInput? audioFingerprint,
    Input$LongOperationFilterInput? streamCount,
    Input$LongOperationFilterInput? favoriteCount,
    Input$StringOperationFilterInput? coverImage,
    Input$StringOperationFilterInput? previewVideo,
    Input$BooleanOperationFilterInput? isExplicit,
    Input$StringOperationFilterInput? lyrics,
    Input$ListFilterInputTypeOfSyncedLineFilterInput? syncedLyrics,
    Input$DecimalOperationFilterInput? popularity,
    Input$ReleaseInfoFilterInput? releaseInfo,
    Input$RestrictionFilterInput? restriction,
    Input$ListFilterInputTypeOfLegalDocumentFilterInput? legalDocuments,
    Input$ListFloatOperationFilterInput? embeddingVector,
    Input$StringOperationFilterInput? createdBy,
    Input$StringOperationFilterInput? updatedBy,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get name =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get nameUnsigned =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$TrackTypeOperationFilterInput<TRes> get type =>
      CopyWith$Input$TrackTypeOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get categoryIds =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get tags =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get mainArtistIds =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$ListStringOperationFilterInput<TRes> get featuredArtistIds =>
      CopyWith$Input$ListStringOperationFilterInput.stub(_res);

  CopyWith$Input$AudioFeatureFilterInput<TRes> get audioFeature =>
      CopyWith$Input$AudioFeatureFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get alternativeDescription =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$AudioFingerprintFilterInput<TRes> get audioFingerprint =>
      CopyWith$Input$AudioFingerprintFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get streamCount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get favoriteCount =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get coverImage =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get previewVideo =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isExplicit =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get lyrics =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput<TRes>
  get syncedLyrics =>
      CopyWith$Input$ListFilterInputTypeOfSyncedLineFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get popularity =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);

  CopyWith$Input$ReleaseInfoFilterInput<TRes> get releaseInfo =>
      CopyWith$Input$ReleaseInfoFilterInput.stub(_res);

  CopyWith$Input$RestrictionFilterInput<TRes> get restriction =>
      CopyWith$Input$RestrictionFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput<TRes>
  get legalDocuments =>
      CopyWith$Input$ListFilterInputTypeOfLegalDocumentFilterInput.stub(_res);

  CopyWith$Input$ListFloatOperationFilterInput<TRes> get embeddingVector =>
      CopyWith$Input$ListFloatOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get createdBy =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get updatedBy =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$TrackSortInput {
  factory Input$TrackSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? nameUnsigned,
    Enum$SortEnumType? description,
    Enum$SortEnumType? type,
    Input$AudioFeatureSortInput? audioFeature,
    Enum$SortEnumType? alternativeDescription,
    Input$AudioFingerprintSortInput? audioFingerprint,
    Enum$SortEnumType? streamCount,
    Enum$SortEnumType? favoriteCount,
    Enum$SortEnumType? coverImage,
    Enum$SortEnumType? previewVideo,
    Enum$SortEnumType? isExplicit,
    Enum$SortEnumType? lyrics,
    Enum$SortEnumType? popularity,
    Input$ReleaseInfoSortInput? releaseInfo,
    Input$RestrictionSortInput? restriction,
    Enum$SortEnumType? createdBy,
    Enum$SortEnumType? updatedBy,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$TrackSortInput._({
    if (id != null) r'id': id,
    if (name != null) r'name': name,
    if (nameUnsigned != null) r'nameUnsigned': nameUnsigned,
    if (description != null) r'description': description,
    if (type != null) r'type': type,
    if (audioFeature != null) r'audioFeature': audioFeature,
    if (alternativeDescription != null)
      r'alternativeDescription': alternativeDescription,
    if (audioFingerprint != null) r'audioFingerprint': audioFingerprint,
    if (streamCount != null) r'streamCount': streamCount,
    if (favoriteCount != null) r'favoriteCount': favoriteCount,
    if (coverImage != null) r'coverImage': coverImage,
    if (previewVideo != null) r'previewVideo': previewVideo,
    if (isExplicit != null) r'isExplicit': isExplicit,
    if (lyrics != null) r'lyrics': lyrics,
    if (popularity != null) r'popularity': popularity,
    if (releaseInfo != null) r'releaseInfo': releaseInfo,
    if (restriction != null) r'restriction': restriction,
    if (createdBy != null) r'createdBy': createdBy,
    if (updatedBy != null) r'updatedBy': updatedBy,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$TrackSortInput._(this._$data);

  factory Input$TrackSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : fromJson$Enum$SortEnumType((l$name as String));
    }
    if (data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = data['nameUnsigned'];
      result$data['nameUnsigned'] = l$nameUnsigned == null
          ? null
          : fromJson$Enum$SortEnumType((l$nameUnsigned as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = l$type == null
          ? null
          : fromJson$Enum$SortEnumType((l$type as String));
    }
    if (data.containsKey('audioFeature')) {
      final l$audioFeature = data['audioFeature'];
      result$data['audioFeature'] = l$audioFeature == null
          ? null
          : Input$AudioFeatureSortInput.fromJson(
              (l$audioFeature as Map<String, dynamic>),
            );
    }
    if (data.containsKey('alternativeDescription')) {
      final l$alternativeDescription = data['alternativeDescription'];
      result$data['alternativeDescription'] = l$alternativeDescription == null
          ? null
          : fromJson$Enum$SortEnumType((l$alternativeDescription as String));
    }
    if (data.containsKey('audioFingerprint')) {
      final l$audioFingerprint = data['audioFingerprint'];
      result$data['audioFingerprint'] = l$audioFingerprint == null
          ? null
          : Input$AudioFingerprintSortInput.fromJson(
              (l$audioFingerprint as Map<String, dynamic>),
            );
    }
    if (data.containsKey('streamCount')) {
      final l$streamCount = data['streamCount'];
      result$data['streamCount'] = l$streamCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$streamCount as String));
    }
    if (data.containsKey('favoriteCount')) {
      final l$favoriteCount = data['favoriteCount'];
      result$data['favoriteCount'] = l$favoriteCount == null
          ? null
          : fromJson$Enum$SortEnumType((l$favoriteCount as String));
    }
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = l$coverImage == null
          ? null
          : fromJson$Enum$SortEnumType((l$coverImage as String));
    }
    if (data.containsKey('previewVideo')) {
      final l$previewVideo = data['previewVideo'];
      result$data['previewVideo'] = l$previewVideo == null
          ? null
          : fromJson$Enum$SortEnumType((l$previewVideo as String));
    }
    if (data.containsKey('isExplicit')) {
      final l$isExplicit = data['isExplicit'];
      result$data['isExplicit'] = l$isExplicit == null
          ? null
          : fromJson$Enum$SortEnumType((l$isExplicit as String));
    }
    if (data.containsKey('lyrics')) {
      final l$lyrics = data['lyrics'];
      result$data['lyrics'] = l$lyrics == null
          ? null
          : fromJson$Enum$SortEnumType((l$lyrics as String));
    }
    if (data.containsKey('popularity')) {
      final l$popularity = data['popularity'];
      result$data['popularity'] = l$popularity == null
          ? null
          : fromJson$Enum$SortEnumType((l$popularity as String));
    }
    if (data.containsKey('releaseInfo')) {
      final l$releaseInfo = data['releaseInfo'];
      result$data['releaseInfo'] = l$releaseInfo == null
          ? null
          : Input$ReleaseInfoSortInput.fromJson(
              (l$releaseInfo as Map<String, dynamic>),
            );
    }
    if (data.containsKey('restriction')) {
      final l$restriction = data['restriction'];
      result$data['restriction'] = l$restriction == null
          ? null
          : Input$RestrictionSortInput.fromJson(
              (l$restriction as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdBy')) {
      final l$createdBy = data['createdBy'];
      result$data['createdBy'] = l$createdBy == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdBy as String));
    }
    if (data.containsKey('updatedBy')) {
      final l$updatedBy = data['updatedBy'];
      result$data['updatedBy'] = l$updatedBy == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedBy as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$TrackSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get name => (_$data['name'] as Enum$SortEnumType?);

  Enum$SortEnumType? get nameUnsigned =>
      (_$data['nameUnsigned'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get type => (_$data['type'] as Enum$SortEnumType?);

  Input$AudioFeatureSortInput? get audioFeature =>
      (_$data['audioFeature'] as Input$AudioFeatureSortInput?);

  Enum$SortEnumType? get alternativeDescription =>
      (_$data['alternativeDescription'] as Enum$SortEnumType?);

  Input$AudioFingerprintSortInput? get audioFingerprint =>
      (_$data['audioFingerprint'] as Input$AudioFingerprintSortInput?);

  Enum$SortEnumType? get streamCount =>
      (_$data['streamCount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get favoriteCount =>
      (_$data['favoriteCount'] as Enum$SortEnumType?);

  Enum$SortEnumType? get coverImage =>
      (_$data['coverImage'] as Enum$SortEnumType?);

  Enum$SortEnumType? get previewVideo =>
      (_$data['previewVideo'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isExplicit =>
      (_$data['isExplicit'] as Enum$SortEnumType?);

  Enum$SortEnumType? get lyrics => (_$data['lyrics'] as Enum$SortEnumType?);

  Enum$SortEnumType? get popularity =>
      (_$data['popularity'] as Enum$SortEnumType?);

  Input$ReleaseInfoSortInput? get releaseInfo =>
      (_$data['releaseInfo'] as Input$ReleaseInfoSortInput?);

  Input$RestrictionSortInput? get restriction =>
      (_$data['restriction'] as Input$RestrictionSortInput?);

  Enum$SortEnumType? get createdBy =>
      (_$data['createdBy'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedBy =>
      (_$data['updatedBy'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null
          ? null
          : toJson$Enum$SortEnumType(l$name);
    }
    if (_$data.containsKey('nameUnsigned')) {
      final l$nameUnsigned = nameUnsigned;
      result$data['nameUnsigned'] = l$nameUnsigned == null
          ? null
          : toJson$Enum$SortEnumType(l$nameUnsigned);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type == null
          ? null
          : toJson$Enum$SortEnumType(l$type);
    }
    if (_$data.containsKey('audioFeature')) {
      final l$audioFeature = audioFeature;
      result$data['audioFeature'] = l$audioFeature?.toJson();
    }
    if (_$data.containsKey('alternativeDescription')) {
      final l$alternativeDescription = alternativeDescription;
      result$data['alternativeDescription'] = l$alternativeDescription == null
          ? null
          : toJson$Enum$SortEnumType(l$alternativeDescription);
    }
    if (_$data.containsKey('audioFingerprint')) {
      final l$audioFingerprint = audioFingerprint;
      result$data['audioFingerprint'] = l$audioFingerprint?.toJson();
    }
    if (_$data.containsKey('streamCount')) {
      final l$streamCount = streamCount;
      result$data['streamCount'] = l$streamCount == null
          ? null
          : toJson$Enum$SortEnumType(l$streamCount);
    }
    if (_$data.containsKey('favoriteCount')) {
      final l$favoriteCount = favoriteCount;
      result$data['favoriteCount'] = l$favoriteCount == null
          ? null
          : toJson$Enum$SortEnumType(l$favoriteCount);
    }
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage == null
          ? null
          : toJson$Enum$SortEnumType(l$coverImage);
    }
    if (_$data.containsKey('previewVideo')) {
      final l$previewVideo = previewVideo;
      result$data['previewVideo'] = l$previewVideo == null
          ? null
          : toJson$Enum$SortEnumType(l$previewVideo);
    }
    if (_$data.containsKey('isExplicit')) {
      final l$isExplicit = isExplicit;
      result$data['isExplicit'] = l$isExplicit == null
          ? null
          : toJson$Enum$SortEnumType(l$isExplicit);
    }
    if (_$data.containsKey('lyrics')) {
      final l$lyrics = lyrics;
      result$data['lyrics'] = l$lyrics == null
          ? null
          : toJson$Enum$SortEnumType(l$lyrics);
    }
    if (_$data.containsKey('popularity')) {
      final l$popularity = popularity;
      result$data['popularity'] = l$popularity == null
          ? null
          : toJson$Enum$SortEnumType(l$popularity);
    }
    if (_$data.containsKey('releaseInfo')) {
      final l$releaseInfo = releaseInfo;
      result$data['releaseInfo'] = l$releaseInfo?.toJson();
    }
    if (_$data.containsKey('restriction')) {
      final l$restriction = restriction;
      result$data['restriction'] = l$restriction?.toJson();
    }
    if (_$data.containsKey('createdBy')) {
      final l$createdBy = createdBy;
      result$data['createdBy'] = l$createdBy == null
          ? null
          : toJson$Enum$SortEnumType(l$createdBy);
    }
    if (_$data.containsKey('updatedBy')) {
      final l$updatedBy = updatedBy;
      result$data['updatedBy'] = l$updatedBy == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedBy);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$TrackSortInput<Input$TrackSortInput> get copyWith =>
      CopyWith$Input$TrackSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TrackSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$nameUnsigned = nameUnsigned;
    final lOther$nameUnsigned = other.nameUnsigned;
    if (_$data.containsKey('nameUnsigned') !=
        other._$data.containsKey('nameUnsigned')) {
      return false;
    }
    if (l$nameUnsigned != lOther$nameUnsigned) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$audioFeature = audioFeature;
    final lOther$audioFeature = other.audioFeature;
    if (_$data.containsKey('audioFeature') !=
        other._$data.containsKey('audioFeature')) {
      return false;
    }
    if (l$audioFeature != lOther$audioFeature) {
      return false;
    }
    final l$alternativeDescription = alternativeDescription;
    final lOther$alternativeDescription = other.alternativeDescription;
    if (_$data.containsKey('alternativeDescription') !=
        other._$data.containsKey('alternativeDescription')) {
      return false;
    }
    if (l$alternativeDescription != lOther$alternativeDescription) {
      return false;
    }
    final l$audioFingerprint = audioFingerprint;
    final lOther$audioFingerprint = other.audioFingerprint;
    if (_$data.containsKey('audioFingerprint') !=
        other._$data.containsKey('audioFingerprint')) {
      return false;
    }
    if (l$audioFingerprint != lOther$audioFingerprint) {
      return false;
    }
    final l$streamCount = streamCount;
    final lOther$streamCount = other.streamCount;
    if (_$data.containsKey('streamCount') !=
        other._$data.containsKey('streamCount')) {
      return false;
    }
    if (l$streamCount != lOther$streamCount) {
      return false;
    }
    final l$favoriteCount = favoriteCount;
    final lOther$favoriteCount = other.favoriteCount;
    if (_$data.containsKey('favoriteCount') !=
        other._$data.containsKey('favoriteCount')) {
      return false;
    }
    if (l$favoriteCount != lOther$favoriteCount) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$previewVideo = previewVideo;
    final lOther$previewVideo = other.previewVideo;
    if (_$data.containsKey('previewVideo') !=
        other._$data.containsKey('previewVideo')) {
      return false;
    }
    if (l$previewVideo != lOther$previewVideo) {
      return false;
    }
    final l$isExplicit = isExplicit;
    final lOther$isExplicit = other.isExplicit;
    if (_$data.containsKey('isExplicit') !=
        other._$data.containsKey('isExplicit')) {
      return false;
    }
    if (l$isExplicit != lOther$isExplicit) {
      return false;
    }
    final l$lyrics = lyrics;
    final lOther$lyrics = other.lyrics;
    if (_$data.containsKey('lyrics') != other._$data.containsKey('lyrics')) {
      return false;
    }
    if (l$lyrics != lOther$lyrics) {
      return false;
    }
    final l$popularity = popularity;
    final lOther$popularity = other.popularity;
    if (_$data.containsKey('popularity') !=
        other._$data.containsKey('popularity')) {
      return false;
    }
    if (l$popularity != lOther$popularity) {
      return false;
    }
    final l$releaseInfo = releaseInfo;
    final lOther$releaseInfo = other.releaseInfo;
    if (_$data.containsKey('releaseInfo') !=
        other._$data.containsKey('releaseInfo')) {
      return false;
    }
    if (l$releaseInfo != lOther$releaseInfo) {
      return false;
    }
    final l$restriction = restriction;
    final lOther$restriction = other.restriction;
    if (_$data.containsKey('restriction') !=
        other._$data.containsKey('restriction')) {
      return false;
    }
    if (l$restriction != lOther$restriction) {
      return false;
    }
    final l$createdBy = createdBy;
    final lOther$createdBy = other.createdBy;
    if (_$data.containsKey('createdBy') !=
        other._$data.containsKey('createdBy')) {
      return false;
    }
    if (l$createdBy != lOther$createdBy) {
      return false;
    }
    final l$updatedBy = updatedBy;
    final lOther$updatedBy = other.updatedBy;
    if (_$data.containsKey('updatedBy') !=
        other._$data.containsKey('updatedBy')) {
      return false;
    }
    if (l$updatedBy != lOther$updatedBy) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$nameUnsigned = nameUnsigned;
    final l$description = description;
    final l$type = type;
    final l$audioFeature = audioFeature;
    final l$alternativeDescription = alternativeDescription;
    final l$audioFingerprint = audioFingerprint;
    final l$streamCount = streamCount;
    final l$favoriteCount = favoriteCount;
    final l$coverImage = coverImage;
    final l$previewVideo = previewVideo;
    final l$isExplicit = isExplicit;
    final l$lyrics = lyrics;
    final l$popularity = popularity;
    final l$releaseInfo = releaseInfo;
    final l$restriction = restriction;
    final l$createdBy = createdBy;
    final l$updatedBy = updatedBy;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('nameUnsigned') ? l$nameUnsigned : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('audioFeature') ? l$audioFeature : const {},
      _$data.containsKey('alternativeDescription')
          ? l$alternativeDescription
          : const {},
      _$data.containsKey('audioFingerprint') ? l$audioFingerprint : const {},
      _$data.containsKey('streamCount') ? l$streamCount : const {},
      _$data.containsKey('favoriteCount') ? l$favoriteCount : const {},
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('previewVideo') ? l$previewVideo : const {},
      _$data.containsKey('isExplicit') ? l$isExplicit : const {},
      _$data.containsKey('lyrics') ? l$lyrics : const {},
      _$data.containsKey('popularity') ? l$popularity : const {},
      _$data.containsKey('releaseInfo') ? l$releaseInfo : const {},
      _$data.containsKey('restriction') ? l$restriction : const {},
      _$data.containsKey('createdBy') ? l$createdBy : const {},
      _$data.containsKey('updatedBy') ? l$updatedBy : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$TrackSortInput<TRes> {
  factory CopyWith$Input$TrackSortInput(
    Input$TrackSortInput instance,
    TRes Function(Input$TrackSortInput) then,
  ) = _CopyWithImpl$Input$TrackSortInput;

  factory CopyWith$Input$TrackSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TrackSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? nameUnsigned,
    Enum$SortEnumType? description,
    Enum$SortEnumType? type,
    Input$AudioFeatureSortInput? audioFeature,
    Enum$SortEnumType? alternativeDescription,
    Input$AudioFingerprintSortInput? audioFingerprint,
    Enum$SortEnumType? streamCount,
    Enum$SortEnumType? favoriteCount,
    Enum$SortEnumType? coverImage,
    Enum$SortEnumType? previewVideo,
    Enum$SortEnumType? isExplicit,
    Enum$SortEnumType? lyrics,
    Enum$SortEnumType? popularity,
    Input$ReleaseInfoSortInput? releaseInfo,
    Input$RestrictionSortInput? restriction,
    Enum$SortEnumType? createdBy,
    Enum$SortEnumType? updatedBy,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
  CopyWith$Input$AudioFeatureSortInput<TRes> get audioFeature;
  CopyWith$Input$AudioFingerprintSortInput<TRes> get audioFingerprint;
  CopyWith$Input$ReleaseInfoSortInput<TRes> get releaseInfo;
  CopyWith$Input$RestrictionSortInput<TRes> get restriction;
}

class _CopyWithImpl$Input$TrackSortInput<TRes>
    implements CopyWith$Input$TrackSortInput<TRes> {
  _CopyWithImpl$Input$TrackSortInput(this._instance, this._then);

  final Input$TrackSortInput _instance;

  final TRes Function(Input$TrackSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? nameUnsigned = _undefined,
    Object? description = _undefined,
    Object? type = _undefined,
    Object? audioFeature = _undefined,
    Object? alternativeDescription = _undefined,
    Object? audioFingerprint = _undefined,
    Object? streamCount = _undefined,
    Object? favoriteCount = _undefined,
    Object? coverImage = _undefined,
    Object? previewVideo = _undefined,
    Object? isExplicit = _undefined,
    Object? lyrics = _undefined,
    Object? popularity = _undefined,
    Object? releaseInfo = _undefined,
    Object? restriction = _undefined,
    Object? createdBy = _undefined,
    Object? updatedBy = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$TrackSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (name != _undefined) 'name': (name as Enum$SortEnumType?),
      if (nameUnsigned != _undefined)
        'nameUnsigned': (nameUnsigned as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (type != _undefined) 'type': (type as Enum$SortEnumType?),
      if (audioFeature != _undefined)
        'audioFeature': (audioFeature as Input$AudioFeatureSortInput?),
      if (alternativeDescription != _undefined)
        'alternativeDescription':
            (alternativeDescription as Enum$SortEnumType?),
      if (audioFingerprint != _undefined)
        'audioFingerprint':
            (audioFingerprint as Input$AudioFingerprintSortInput?),
      if (streamCount != _undefined)
        'streamCount': (streamCount as Enum$SortEnumType?),
      if (favoriteCount != _undefined)
        'favoriteCount': (favoriteCount as Enum$SortEnumType?),
      if (coverImage != _undefined)
        'coverImage': (coverImage as Enum$SortEnumType?),
      if (previewVideo != _undefined)
        'previewVideo': (previewVideo as Enum$SortEnumType?),
      if (isExplicit != _undefined)
        'isExplicit': (isExplicit as Enum$SortEnumType?),
      if (lyrics != _undefined) 'lyrics': (lyrics as Enum$SortEnumType?),
      if (popularity != _undefined)
        'popularity': (popularity as Enum$SortEnumType?),
      if (releaseInfo != _undefined)
        'releaseInfo': (releaseInfo as Input$ReleaseInfoSortInput?),
      if (restriction != _undefined)
        'restriction': (restriction as Input$RestrictionSortInput?),
      if (createdBy != _undefined)
        'createdBy': (createdBy as Enum$SortEnumType?),
      if (updatedBy != _undefined)
        'updatedBy': (updatedBy as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );

  CopyWith$Input$AudioFeatureSortInput<TRes> get audioFeature {
    final local$audioFeature = _instance.audioFeature;
    return local$audioFeature == null
        ? CopyWith$Input$AudioFeatureSortInput.stub(_then(_instance))
        : CopyWith$Input$AudioFeatureSortInput(
            local$audioFeature,
            (e) => call(audioFeature: e),
          );
  }

  CopyWith$Input$AudioFingerprintSortInput<TRes> get audioFingerprint {
    final local$audioFingerprint = _instance.audioFingerprint;
    return local$audioFingerprint == null
        ? CopyWith$Input$AudioFingerprintSortInput.stub(_then(_instance))
        : CopyWith$Input$AudioFingerprintSortInput(
            local$audioFingerprint,
            (e) => call(audioFingerprint: e),
          );
  }

  CopyWith$Input$ReleaseInfoSortInput<TRes> get releaseInfo {
    final local$releaseInfo = _instance.releaseInfo;
    return local$releaseInfo == null
        ? CopyWith$Input$ReleaseInfoSortInput.stub(_then(_instance))
        : CopyWith$Input$ReleaseInfoSortInput(
            local$releaseInfo,
            (e) => call(releaseInfo: e),
          );
  }

  CopyWith$Input$RestrictionSortInput<TRes> get restriction {
    final local$restriction = _instance.restriction;
    return local$restriction == null
        ? CopyWith$Input$RestrictionSortInput.stub(_then(_instance))
        : CopyWith$Input$RestrictionSortInput(
            local$restriction,
            (e) => call(restriction: e),
          );
  }
}

class _CopyWithStubImpl$Input$TrackSortInput<TRes>
    implements CopyWith$Input$TrackSortInput<TRes> {
  _CopyWithStubImpl$Input$TrackSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? name,
    Enum$SortEnumType? nameUnsigned,
    Enum$SortEnumType? description,
    Enum$SortEnumType? type,
    Input$AudioFeatureSortInput? audioFeature,
    Enum$SortEnumType? alternativeDescription,
    Input$AudioFingerprintSortInput? audioFingerprint,
    Enum$SortEnumType? streamCount,
    Enum$SortEnumType? favoriteCount,
    Enum$SortEnumType? coverImage,
    Enum$SortEnumType? previewVideo,
    Enum$SortEnumType? isExplicit,
    Enum$SortEnumType? lyrics,
    Enum$SortEnumType? popularity,
    Input$ReleaseInfoSortInput? releaseInfo,
    Input$RestrictionSortInput? restriction,
    Enum$SortEnumType? createdBy,
    Enum$SortEnumType? updatedBy,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;

  CopyWith$Input$AudioFeatureSortInput<TRes> get audioFeature =>
      CopyWith$Input$AudioFeatureSortInput.stub(_res);

  CopyWith$Input$AudioFingerprintSortInput<TRes> get audioFingerprint =>
      CopyWith$Input$AudioFingerprintSortInput.stub(_res);

  CopyWith$Input$ReleaseInfoSortInput<TRes> get releaseInfo =>
      CopyWith$Input$ReleaseInfoSortInput.stub(_res);

  CopyWith$Input$RestrictionSortInput<TRes> get restriction =>
      CopyWith$Input$RestrictionSortInput.stub(_res);
}

class Input$TrackTypeOperationFilterInput {
  factory Input$TrackTypeOperationFilterInput({
    Enum$TrackType? eq,
    Enum$TrackType? neq,
    List<Enum$TrackType>? $in,
    List<Enum$TrackType>? nin,
  }) => Input$TrackTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$TrackTypeOperationFilterInput._(this._$data);

  factory Input$TrackTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$TrackType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$TrackType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$TrackType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$TrackType((e as String)))
          .toList();
    }
    return Input$TrackTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TrackType? get eq => (_$data['eq'] as Enum$TrackType?);

  Enum$TrackType? get neq => (_$data['neq'] as Enum$TrackType?);

  List<Enum$TrackType>? get $in => (_$data['in'] as List<Enum$TrackType>?);

  List<Enum$TrackType>? get nin => (_$data['nin'] as List<Enum$TrackType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$TrackType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$TrackType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$TrackType(e)).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => toJson$Enum$TrackType(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$TrackTypeOperationFilterInput<
    Input$TrackTypeOperationFilterInput
  >
  get copyWith => CopyWith$Input$TrackTypeOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TrackTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TrackTypeOperationFilterInput<TRes> {
  factory CopyWith$Input$TrackTypeOperationFilterInput(
    Input$TrackTypeOperationFilterInput instance,
    TRes Function(Input$TrackTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$TrackTypeOperationFilterInput;

  factory CopyWith$Input$TrackTypeOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TrackTypeOperationFilterInput;

  TRes call({
    Enum$TrackType? eq,
    Enum$TrackType? neq,
    List<Enum$TrackType>? $in,
    List<Enum$TrackType>? nin,
  });
}

class _CopyWithImpl$Input$TrackTypeOperationFilterInput<TRes>
    implements CopyWith$Input$TrackTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$TrackTypeOperationFilterInput(this._instance, this._then);

  final Input$TrackTypeOperationFilterInput _instance;

  final TRes Function(Input$TrackTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$TrackTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$TrackType?),
      if (neq != _undefined) 'neq': (neq as Enum$TrackType?),
      if ($in != _undefined) 'in': ($in as List<Enum$TrackType>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$TrackType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$TrackTypeOperationFilterInput<TRes>
    implements CopyWith$Input$TrackTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$TrackTypeOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$TrackType? eq,
    Enum$TrackType? neq,
    List<Enum$TrackType>? $in,
    List<Enum$TrackType>? nin,
  }) => _res;
}

class Input$TransactionStatusOperationFilterInput {
  factory Input$TransactionStatusOperationFilterInput({
    Enum$TransactionStatus? eq,
    Enum$TransactionStatus? neq,
    List<Enum$TransactionStatus>? $in,
    List<Enum$TransactionStatus>? nin,
  }) => Input$TransactionStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$TransactionStatusOperationFilterInput._(this._$data);

  factory Input$TransactionStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$TransactionStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$TransactionStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$TransactionStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$TransactionStatus((e as String)))
          .toList();
    }
    return Input$TransactionStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TransactionStatus? get eq => (_$data['eq'] as Enum$TransactionStatus?);

  Enum$TransactionStatus? get neq => (_$data['neq'] as Enum$TransactionStatus?);

  List<Enum$TransactionStatus>? get $in =>
      (_$data['in'] as List<Enum$TransactionStatus>?);

  List<Enum$TransactionStatus>? get nin =>
      (_$data['nin'] as List<Enum$TransactionStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$TransactionStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$TransactionStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$TransactionStatus(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$TransactionStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusOperationFilterInput<
    Input$TransactionStatusOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$TransactionStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TransactionStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$TransactionStatusOperationFilterInput(
    Input$TransactionStatusOperationFilterInput instance,
    TRes Function(Input$TransactionStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusOperationFilterInput;

  factory CopyWith$Input$TransactionStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusOperationFilterInput;

  TRes call({
    Enum$TransactionStatus? eq,
    Enum$TransactionStatus? neq,
    List<Enum$TransactionStatus>? $in,
    List<Enum$TransactionStatus>? nin,
  });
}

class _CopyWithImpl$Input$TransactionStatusOperationFilterInput<TRes>
    implements CopyWith$Input$TransactionStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusOperationFilterInput _instance;

  final TRes Function(Input$TransactionStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$TransactionStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$TransactionStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$TransactionStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$TransactionStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$TransactionStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$TransactionStatusOperationFilterInput<TRes>
    implements CopyWith$Input$TransactionStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$TransactionStatus? eq,
    Enum$TransactionStatus? neq,
    List<Enum$TransactionStatus>? $in,
    List<Enum$TransactionStatus>? nin,
  }) => _res;
}

class Input$UpdateArtistPackageRequestInput {
  factory Input$UpdateArtistPackageRequestInput({
    required String id,
    String? packageName,
    String? description,
  }) => Input$UpdateArtistPackageRequestInput._({
    r'id': id,
    if (packageName != null) r'packageName': packageName,
    if (description != null) r'description': description,
  });

  Input$UpdateArtistPackageRequestInput._(this._$data);

  factory Input$UpdateArtistPackageRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('packageName')) {
      final l$packageName = data['packageName'];
      result$data['packageName'] = (l$packageName as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$UpdateArtistPackageRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  String? get packageName => (_$data['packageName'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('packageName')) {
      final l$packageName = packageName;
      result$data['packageName'] = l$packageName;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$UpdateArtistPackageRequestInput<
    Input$UpdateArtistPackageRequestInput
  >
  get copyWith =>
      CopyWith$Input$UpdateArtistPackageRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateArtistPackageRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$packageName = packageName;
    final lOther$packageName = other.packageName;
    if (_$data.containsKey('packageName') !=
        other._$data.containsKey('packageName')) {
      return false;
    }
    if (l$packageName != lOther$packageName) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$packageName = packageName;
    final l$description = description;
    return Object.hashAll([
      l$id,
      _$data.containsKey('packageName') ? l$packageName : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateArtistPackageRequestInput<TRes> {
  factory CopyWith$Input$UpdateArtistPackageRequestInput(
    Input$UpdateArtistPackageRequestInput instance,
    TRes Function(Input$UpdateArtistPackageRequestInput) then,
  ) = _CopyWithImpl$Input$UpdateArtistPackageRequestInput;

  factory CopyWith$Input$UpdateArtistPackageRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateArtistPackageRequestInput;

  TRes call({String? id, String? packageName, String? description});
}

class _CopyWithImpl$Input$UpdateArtistPackageRequestInput<TRes>
    implements CopyWith$Input$UpdateArtistPackageRequestInput<TRes> {
  _CopyWithImpl$Input$UpdateArtistPackageRequestInput(
    this._instance,
    this._then,
  );

  final Input$UpdateArtistPackageRequestInput _instance;

  final TRes Function(Input$UpdateArtistPackageRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? packageName = _undefined,
    Object? description = _undefined,
  }) => _then(
    Input$UpdateArtistPackageRequestInput._({
      ..._instance._$data,
      if (id != _undefined && id != null) 'id': (id as String),
      if (packageName != _undefined) 'packageName': (packageName as String?),
      if (description != _undefined) 'description': (description as String?),
    }),
  );
}

class _CopyWithStubImpl$Input$UpdateArtistPackageRequestInput<TRes>
    implements CopyWith$Input$UpdateArtistPackageRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdateArtistPackageRequestInput(this._res);

  TRes _res;

  call({String? id, String? packageName, String? description}) => _res;
}

class Input$UpdateArtistRequestInput {
  factory Input$UpdateArtistRequestInput({
    String? stageName,
    String? biography,
    String? avatarImage,
    String? bannerImage,
    String? email,
    String? phoneNumber,
    String? fullName,
    Enum$UserGender? gender,
    DateTime? birthDate,
  }) => Input$UpdateArtistRequestInput._({
    if (stageName != null) r'stageName': stageName,
    if (biography != null) r'biography': biography,
    if (avatarImage != null) r'avatarImage': avatarImage,
    if (bannerImage != null) r'bannerImage': bannerImage,
    if (email != null) r'email': email,
    if (phoneNumber != null) r'phoneNumber': phoneNumber,
    if (fullName != null) r'fullName': fullName,
    if (gender != null) r'gender': gender,
    if (birthDate != null) r'birthDate': birthDate,
  });

  Input$UpdateArtistRequestInput._(this._$data);

  factory Input$UpdateArtistRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('stageName')) {
      final l$stageName = data['stageName'];
      result$data['stageName'] = (l$stageName as String?);
    }
    if (data.containsKey('biography')) {
      final l$biography = data['biography'];
      result$data['biography'] = (l$biography as String?);
    }
    if (data.containsKey('avatarImage')) {
      final l$avatarImage = data['avatarImage'];
      result$data['avatarImage'] = (l$avatarImage as String?);
    }
    if (data.containsKey('bannerImage')) {
      final l$bannerImage = data['bannerImage'];
      result$data['bannerImage'] = (l$bannerImage as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = (l$phoneNumber as String?);
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = (l$fullName as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = l$gender == null
          ? null
          : fromJson$Enum$UserGender((l$gender as String));
    }
    if (data.containsKey('birthDate')) {
      final l$birthDate = data['birthDate'];
      result$data['birthDate'] = l$birthDate == null
          ? null
          : DateTime.parse((l$birthDate as String));
    }
    return Input$UpdateArtistRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get stageName => (_$data['stageName'] as String?);

  String? get biography => (_$data['biography'] as String?);

  String? get avatarImage => (_$data['avatarImage'] as String?);

  String? get bannerImage => (_$data['bannerImage'] as String?);

  String? get email => (_$data['email'] as String?);

  String? get phoneNumber => (_$data['phoneNumber'] as String?);

  String? get fullName => (_$data['fullName'] as String?);

  Enum$UserGender? get gender => (_$data['gender'] as Enum$UserGender?);

  DateTime? get birthDate => (_$data['birthDate'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('stageName')) {
      final l$stageName = stageName;
      result$data['stageName'] = l$stageName;
    }
    if (_$data.containsKey('biography')) {
      final l$biography = biography;
      result$data['biography'] = l$biography;
    }
    if (_$data.containsKey('avatarImage')) {
      final l$avatarImage = avatarImage;
      result$data['avatarImage'] = l$avatarImage;
    }
    if (_$data.containsKey('bannerImage')) {
      final l$bannerImage = bannerImage;
      result$data['bannerImage'] = l$bannerImage;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] = l$phoneNumber;
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender == null
          ? null
          : toJson$Enum$UserGender(l$gender);
    }
    if (_$data.containsKey('birthDate')) {
      final l$birthDate = birthDate;
      result$data['birthDate'] = l$birthDate?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$UpdateArtistRequestInput<Input$UpdateArtistRequestInput>
  get copyWith => CopyWith$Input$UpdateArtistRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateArtistRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$stageName = stageName;
    final lOther$stageName = other.stageName;
    if (_$data.containsKey('stageName') !=
        other._$data.containsKey('stageName')) {
      return false;
    }
    if (l$stageName != lOther$stageName) {
      return false;
    }
    final l$biography = biography;
    final lOther$biography = other.biography;
    if (_$data.containsKey('biography') !=
        other._$data.containsKey('biography')) {
      return false;
    }
    if (l$biography != lOther$biography) {
      return false;
    }
    final l$avatarImage = avatarImage;
    final lOther$avatarImage = other.avatarImage;
    if (_$data.containsKey('avatarImage') !=
        other._$data.containsKey('avatarImage')) {
      return false;
    }
    if (l$avatarImage != lOther$avatarImage) {
      return false;
    }
    final l$bannerImage = bannerImage;
    final lOther$bannerImage = other.bannerImage;
    if (_$data.containsKey('bannerImage') !=
        other._$data.containsKey('bannerImage')) {
      return false;
    }
    if (l$bannerImage != lOther$bannerImage) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$birthDate = birthDate;
    final lOther$birthDate = other.birthDate;
    if (_$data.containsKey('birthDate') !=
        other._$data.containsKey('birthDate')) {
      return false;
    }
    if (l$birthDate != lOther$birthDate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$stageName = stageName;
    final l$biography = biography;
    final l$avatarImage = avatarImage;
    final l$bannerImage = bannerImage;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$fullName = fullName;
    final l$gender = gender;
    final l$birthDate = birthDate;
    return Object.hashAll([
      _$data.containsKey('stageName') ? l$stageName : const {},
      _$data.containsKey('biography') ? l$biography : const {},
      _$data.containsKey('avatarImage') ? l$avatarImage : const {},
      _$data.containsKey('bannerImage') ? l$bannerImage : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('birthDate') ? l$birthDate : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateArtistRequestInput<TRes> {
  factory CopyWith$Input$UpdateArtistRequestInput(
    Input$UpdateArtistRequestInput instance,
    TRes Function(Input$UpdateArtistRequestInput) then,
  ) = _CopyWithImpl$Input$UpdateArtistRequestInput;

  factory CopyWith$Input$UpdateArtistRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateArtistRequestInput;

  TRes call({
    String? stageName,
    String? biography,
    String? avatarImage,
    String? bannerImage,
    String? email,
    String? phoneNumber,
    String? fullName,
    Enum$UserGender? gender,
    DateTime? birthDate,
  });
}

class _CopyWithImpl$Input$UpdateArtistRequestInput<TRes>
    implements CopyWith$Input$UpdateArtistRequestInput<TRes> {
  _CopyWithImpl$Input$UpdateArtistRequestInput(this._instance, this._then);

  final Input$UpdateArtistRequestInput _instance;

  final TRes Function(Input$UpdateArtistRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? stageName = _undefined,
    Object? biography = _undefined,
    Object? avatarImage = _undefined,
    Object? bannerImage = _undefined,
    Object? email = _undefined,
    Object? phoneNumber = _undefined,
    Object? fullName = _undefined,
    Object? gender = _undefined,
    Object? birthDate = _undefined,
  }) => _then(
    Input$UpdateArtistRequestInput._({
      ..._instance._$data,
      if (stageName != _undefined) 'stageName': (stageName as String?),
      if (biography != _undefined) 'biography': (biography as String?),
      if (avatarImage != _undefined) 'avatarImage': (avatarImage as String?),
      if (bannerImage != _undefined) 'bannerImage': (bannerImage as String?),
      if (email != _undefined) 'email': (email as String?),
      if (phoneNumber != _undefined) 'phoneNumber': (phoneNumber as String?),
      if (fullName != _undefined) 'fullName': (fullName as String?),
      if (gender != _undefined) 'gender': (gender as Enum$UserGender?),
      if (birthDate != _undefined) 'birthDate': (birthDate as DateTime?),
    }),
  );
}

class _CopyWithStubImpl$Input$UpdateArtistRequestInput<TRes>
    implements CopyWith$Input$UpdateArtistRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdateArtistRequestInput(this._res);

  TRes _res;

  call({
    String? stageName,
    String? biography,
    String? avatarImage,
    String? bannerImage,
    String? email,
    String? phoneNumber,
    String? fullName,
    Enum$UserGender? gender,
    DateTime? birthDate,
  }) => _res;
}

class Input$UpdateEntitlementRequestInput {
  factory Input$UpdateEntitlementRequestInput({
    dynamic? value,
    String? name,
    required String code,
    String? description,
    Enum$EntitlementValueType? valueType,
    DateTime? expiredAt,
  }) => Input$UpdateEntitlementRequestInput._({
    if (value != null) r'value': value,
    if (name != null) r'name': name,
    r'code': code,
    if (description != null) r'description': description,
    if (valueType != null) r'valueType': valueType,
    if (expiredAt != null) r'expiredAt': expiredAt,
  });

  Input$UpdateEntitlementRequestInput._(this._$data);

  factory Input$UpdateEntitlementRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('value')) {
      final l$value = data['value'];
      result$data['value'] = (l$value as dynamic?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    final l$code = data['code'];
    result$data['code'] = (l$code as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('valueType')) {
      final l$valueType = data['valueType'];
      result$data['valueType'] = l$valueType == null
          ? null
          : fromJson$Enum$EntitlementValueType((l$valueType as String));
    }
    if (data.containsKey('expiredAt')) {
      final l$expiredAt = data['expiredAt'];
      result$data['expiredAt'] = l$expiredAt == null
          ? null
          : DateTime.parse((l$expiredAt as String));
    }
    return Input$UpdateEntitlementRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  dynamic? get value => (_$data['value'] as dynamic?);

  String? get name => (_$data['name'] as String?);

  String get code => (_$data['code'] as String);

  String? get description => (_$data['description'] as String?);

  Enum$EntitlementValueType? get valueType =>
      (_$data['valueType'] as Enum$EntitlementValueType?);

  DateTime? get expiredAt => (_$data['expiredAt'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('value')) {
      final l$value = value;
      result$data['value'] = l$value;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    final l$code = code;
    result$data['code'] = l$code;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('valueType')) {
      final l$valueType = valueType;
      result$data['valueType'] = l$valueType == null
          ? null
          : toJson$Enum$EntitlementValueType(l$valueType);
    }
    if (_$data.containsKey('expiredAt')) {
      final l$expiredAt = expiredAt;
      result$data['expiredAt'] = l$expiredAt?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$UpdateEntitlementRequestInput<
    Input$UpdateEntitlementRequestInput
  >
  get copyWith => CopyWith$Input$UpdateEntitlementRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEntitlementRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (_$data.containsKey('value') != other._$data.containsKey('value')) {
      return false;
    }
    if (l$value != lOther$value) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$code = code;
    final lOther$code = other.code;
    if (l$code != lOther$code) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$valueType = valueType;
    final lOther$valueType = other.valueType;
    if (_$data.containsKey('valueType') !=
        other._$data.containsKey('valueType')) {
      return false;
    }
    if (l$valueType != lOther$valueType) {
      return false;
    }
    final l$expiredAt = expiredAt;
    final lOther$expiredAt = other.expiredAt;
    if (_$data.containsKey('expiredAt') !=
        other._$data.containsKey('expiredAt')) {
      return false;
    }
    if (l$expiredAt != lOther$expiredAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$value = value;
    final l$name = name;
    final l$code = code;
    final l$description = description;
    final l$valueType = valueType;
    final l$expiredAt = expiredAt;
    return Object.hashAll([
      _$data.containsKey('value') ? l$value : const {},
      _$data.containsKey('name') ? l$name : const {},
      l$code,
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('valueType') ? l$valueType : const {},
      _$data.containsKey('expiredAt') ? l$expiredAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEntitlementRequestInput<TRes> {
  factory CopyWith$Input$UpdateEntitlementRequestInput(
    Input$UpdateEntitlementRequestInput instance,
    TRes Function(Input$UpdateEntitlementRequestInput) then,
  ) = _CopyWithImpl$Input$UpdateEntitlementRequestInput;

  factory CopyWith$Input$UpdateEntitlementRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEntitlementRequestInput;

  TRes call({
    dynamic? value,
    String? name,
    String? code,
    String? description,
    Enum$EntitlementValueType? valueType,
    DateTime? expiredAt,
  });
}

class _CopyWithImpl$Input$UpdateEntitlementRequestInput<TRes>
    implements CopyWith$Input$UpdateEntitlementRequestInput<TRes> {
  _CopyWithImpl$Input$UpdateEntitlementRequestInput(this._instance, this._then);

  final Input$UpdateEntitlementRequestInput _instance;

  final TRes Function(Input$UpdateEntitlementRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? value = _undefined,
    Object? name = _undefined,
    Object? code = _undefined,
    Object? description = _undefined,
    Object? valueType = _undefined,
    Object? expiredAt = _undefined,
  }) => _then(
    Input$UpdateEntitlementRequestInput._({
      ..._instance._$data,
      if (value != _undefined) 'value': (value as dynamic?),
      if (name != _undefined) 'name': (name as String?),
      if (code != _undefined && code != null) 'code': (code as String),
      if (description != _undefined) 'description': (description as String?),
      if (valueType != _undefined)
        'valueType': (valueType as Enum$EntitlementValueType?),
      if (expiredAt != _undefined) 'expiredAt': (expiredAt as DateTime?),
    }),
  );
}

class _CopyWithStubImpl$Input$UpdateEntitlementRequestInput<TRes>
    implements CopyWith$Input$UpdateEntitlementRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEntitlementRequestInput(this._res);

  TRes _res;

  call({
    dynamic? value,
    String? name,
    String? code,
    String? description,
    Enum$EntitlementValueType? valueType,
    DateTime? expiredAt,
  }) => _res;
}

class Input$UpdateEscrowCommissionPolicyRequestInput {
  factory Input$UpdateEscrowCommissionPolicyRequestInput({
    required int version,
    double? platformFeePercentage,
    Enum$CurrencyType? currency,
  }) => Input$UpdateEscrowCommissionPolicyRequestInput._({
    r'version': version,
    if (platformFeePercentage != null)
      r'platformFeePercentage': platformFeePercentage,
    if (currency != null) r'currency': currency,
  });

  Input$UpdateEscrowCommissionPolicyRequestInput._(this._$data);

  factory Input$UpdateEscrowCommissionPolicyRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$version = data['version'];
    result$data['version'] = (l$version as int);
    if (data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = data['platformFeePercentage'];
      result$data['platformFeePercentage'] = (l$platformFeePercentage as num?)
          ?.toDouble();
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$CurrencyType((l$currency as String));
    }
    return Input$UpdateEscrowCommissionPolicyRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get version => (_$data['version'] as int);

  double? get platformFeePercentage =>
      (_$data['platformFeePercentage'] as double?);

  Enum$CurrencyType? get currency => (_$data['currency'] as Enum$CurrencyType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$version = version;
    result$data['version'] = l$version;
    if (_$data.containsKey('platformFeePercentage')) {
      final l$platformFeePercentage = platformFeePercentage;
      result$data['platformFeePercentage'] = l$platformFeePercentage;
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$CurrencyType(l$currency);
    }
    return result$data;
  }

  CopyWith$Input$UpdateEscrowCommissionPolicyRequestInput<
    Input$UpdateEscrowCommissionPolicyRequestInput
  >
  get copyWith =>
      CopyWith$Input$UpdateEscrowCommissionPolicyRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEscrowCommissionPolicyRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) {
      return false;
    }
    final l$platformFeePercentage = platformFeePercentage;
    final lOther$platformFeePercentage = other.platformFeePercentage;
    if (_$data.containsKey('platformFeePercentage') !=
        other._$data.containsKey('platformFeePercentage')) {
      return false;
    }
    if (l$platformFeePercentage != lOther$platformFeePercentage) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platformFeePercentage = platformFeePercentage;
    final l$currency = currency;
    return Object.hashAll([
      l$version,
      _$data.containsKey('platformFeePercentage')
          ? l$platformFeePercentage
          : const {},
      _$data.containsKey('currency') ? l$currency : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEscrowCommissionPolicyRequestInput<TRes> {
  factory CopyWith$Input$UpdateEscrowCommissionPolicyRequestInput(
    Input$UpdateEscrowCommissionPolicyRequestInput instance,
    TRes Function(Input$UpdateEscrowCommissionPolicyRequestInput) then,
  ) = _CopyWithImpl$Input$UpdateEscrowCommissionPolicyRequestInput;

  factory CopyWith$Input$UpdateEscrowCommissionPolicyRequestInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$UpdateEscrowCommissionPolicyRequestInput;

  TRes call({
    int? version,
    double? platformFeePercentage,
    Enum$CurrencyType? currency,
  });
}

class _CopyWithImpl$Input$UpdateEscrowCommissionPolicyRequestInput<TRes>
    implements CopyWith$Input$UpdateEscrowCommissionPolicyRequestInput<TRes> {
  _CopyWithImpl$Input$UpdateEscrowCommissionPolicyRequestInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEscrowCommissionPolicyRequestInput _instance;

  final TRes Function(Input$UpdateEscrowCommissionPolicyRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platformFeePercentage = _undefined,
    Object? currency = _undefined,
  }) => _then(
    Input$UpdateEscrowCommissionPolicyRequestInput._({
      ..._instance._$data,
      if (version != _undefined && version != null) 'version': (version as int),
      if (platformFeePercentage != _undefined)
        'platformFeePercentage': (platformFeePercentage as double?),
      if (currency != _undefined) 'currency': (currency as Enum$CurrencyType?),
    }),
  );
}

class _CopyWithStubImpl$Input$UpdateEscrowCommissionPolicyRequestInput<TRes>
    implements CopyWith$Input$UpdateEscrowCommissionPolicyRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEscrowCommissionPolicyRequestInput(this._res);

  TRes _res;

  call({
    int? version,
    double? platformFeePercentage,
    Enum$CurrencyType? currency,
  }) => _res;
}

class Input$UpdateListenerRequestInput {
  factory Input$UpdateListenerRequestInput({
    String? displayName,
    String? avatarImage,
    String? bannerImage,
    String? email,
    String? phoneNumber,
    String? fullName,
    Enum$UserGender? gender,
    DateTime? birthDate,
  }) => Input$UpdateListenerRequestInput._({
    if (displayName != null) r'displayName': displayName,
    if (avatarImage != null) r'avatarImage': avatarImage,
    if (bannerImage != null) r'bannerImage': bannerImage,
    if (email != null) r'email': email,
    if (phoneNumber != null) r'phoneNumber': phoneNumber,
    if (fullName != null) r'fullName': fullName,
    if (gender != null) r'gender': gender,
    if (birthDate != null) r'birthDate': birthDate,
  });

  Input$UpdateListenerRequestInput._(this._$data);

  factory Input$UpdateListenerRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = (l$displayName as String?);
    }
    if (data.containsKey('avatarImage')) {
      final l$avatarImage = data['avatarImage'];
      result$data['avatarImage'] = (l$avatarImage as String?);
    }
    if (data.containsKey('bannerImage')) {
      final l$bannerImage = data['bannerImage'];
      result$data['bannerImage'] = (l$bannerImage as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = (l$phoneNumber as String?);
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = (l$fullName as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = l$gender == null
          ? null
          : fromJson$Enum$UserGender((l$gender as String));
    }
    if (data.containsKey('birthDate')) {
      final l$birthDate = data['birthDate'];
      result$data['birthDate'] = l$birthDate == null
          ? null
          : DateTime.parse((l$birthDate as String));
    }
    return Input$UpdateListenerRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get displayName => (_$data['displayName'] as String?);

  String? get avatarImage => (_$data['avatarImage'] as String?);

  String? get bannerImage => (_$data['bannerImage'] as String?);

  String? get email => (_$data['email'] as String?);

  String? get phoneNumber => (_$data['phoneNumber'] as String?);

  String? get fullName => (_$data['fullName'] as String?);

  Enum$UserGender? get gender => (_$data['gender'] as Enum$UserGender?);

  DateTime? get birthDate => (_$data['birthDate'] as DateTime?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] = l$displayName;
    }
    if (_$data.containsKey('avatarImage')) {
      final l$avatarImage = avatarImage;
      result$data['avatarImage'] = l$avatarImage;
    }
    if (_$data.containsKey('bannerImage')) {
      final l$bannerImage = bannerImage;
      result$data['bannerImage'] = l$bannerImage;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] = l$phoneNumber;
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender == null
          ? null
          : toJson$Enum$UserGender(l$gender);
    }
    if (_$data.containsKey('birthDate')) {
      final l$birthDate = birthDate;
      result$data['birthDate'] = l$birthDate?.toIso8601String();
    }
    return result$data;
  }

  CopyWith$Input$UpdateListenerRequestInput<Input$UpdateListenerRequestInput>
  get copyWith => CopyWith$Input$UpdateListenerRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateListenerRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$avatarImage = avatarImage;
    final lOther$avatarImage = other.avatarImage;
    if (_$data.containsKey('avatarImage') !=
        other._$data.containsKey('avatarImage')) {
      return false;
    }
    if (l$avatarImage != lOther$avatarImage) {
      return false;
    }
    final l$bannerImage = bannerImage;
    final lOther$bannerImage = other.bannerImage;
    if (_$data.containsKey('bannerImage') !=
        other._$data.containsKey('bannerImage')) {
      return false;
    }
    if (l$bannerImage != lOther$bannerImage) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$birthDate = birthDate;
    final lOther$birthDate = other.birthDate;
    if (_$data.containsKey('birthDate') !=
        other._$data.containsKey('birthDate')) {
      return false;
    }
    if (l$birthDate != lOther$birthDate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$displayName = displayName;
    final l$avatarImage = avatarImage;
    final l$bannerImage = bannerImage;
    final l$email = email;
    final l$phoneNumber = phoneNumber;
    final l$fullName = fullName;
    final l$gender = gender;
    final l$birthDate = birthDate;
    return Object.hashAll([
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('avatarImage') ? l$avatarImage : const {},
      _$data.containsKey('bannerImage') ? l$bannerImage : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('birthDate') ? l$birthDate : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateListenerRequestInput<TRes> {
  factory CopyWith$Input$UpdateListenerRequestInput(
    Input$UpdateListenerRequestInput instance,
    TRes Function(Input$UpdateListenerRequestInput) then,
  ) = _CopyWithImpl$Input$UpdateListenerRequestInput;

  factory CopyWith$Input$UpdateListenerRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateListenerRequestInput;

  TRes call({
    String? displayName,
    String? avatarImage,
    String? bannerImage,
    String? email,
    String? phoneNumber,
    String? fullName,
    Enum$UserGender? gender,
    DateTime? birthDate,
  });
}

class _CopyWithImpl$Input$UpdateListenerRequestInput<TRes>
    implements CopyWith$Input$UpdateListenerRequestInput<TRes> {
  _CopyWithImpl$Input$UpdateListenerRequestInput(this._instance, this._then);

  final Input$UpdateListenerRequestInput _instance;

  final TRes Function(Input$UpdateListenerRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? displayName = _undefined,
    Object? avatarImage = _undefined,
    Object? bannerImage = _undefined,
    Object? email = _undefined,
    Object? phoneNumber = _undefined,
    Object? fullName = _undefined,
    Object? gender = _undefined,
    Object? birthDate = _undefined,
  }) => _then(
    Input$UpdateListenerRequestInput._({
      ..._instance._$data,
      if (displayName != _undefined) 'displayName': (displayName as String?),
      if (avatarImage != _undefined) 'avatarImage': (avatarImage as String?),
      if (bannerImage != _undefined) 'bannerImage': (bannerImage as String?),
      if (email != _undefined) 'email': (email as String?),
      if (phoneNumber != _undefined) 'phoneNumber': (phoneNumber as String?),
      if (fullName != _undefined) 'fullName': (fullName as String?),
      if (gender != _undefined) 'gender': (gender as Enum$UserGender?),
      if (birthDate != _undefined) 'birthDate': (birthDate as DateTime?),
    }),
  );
}

class _CopyWithStubImpl$Input$UpdateListenerRequestInput<TRes>
    implements CopyWith$Input$UpdateListenerRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdateListenerRequestInput(this._res);

  TRes _res;

  call({
    String? displayName,
    String? avatarImage,
    String? bannerImage,
    String? email,
    String? phoneNumber,
    String? fullName,
    Enum$UserGender? gender,
    DateTime? birthDate,
  }) => _res;
}

class Input$UpdatePlaylistRequestInput {
  factory Input$UpdatePlaylistRequestInput({
    required String playlistId,
    String? name,
    String? description,
    String? coverImage,
    bool? isPublic,
  }) => Input$UpdatePlaylistRequestInput._({
    r'playlistId': playlistId,
    if (name != null) r'name': name,
    if (description != null) r'description': description,
    if (coverImage != null) r'coverImage': coverImage,
    if (isPublic != null) r'isPublic': isPublic,
  });

  Input$UpdatePlaylistRequestInput._(this._$data);

  factory Input$UpdatePlaylistRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$playlistId = data['playlistId'];
    result$data['playlistId'] = (l$playlistId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('coverImage')) {
      final l$coverImage = data['coverImage'];
      result$data['coverImage'] = (l$coverImage as String?);
    }
    if (data.containsKey('isPublic')) {
      final l$isPublic = data['isPublic'];
      result$data['isPublic'] = (l$isPublic as bool?);
    }
    return Input$UpdatePlaylistRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get playlistId => (_$data['playlistId'] as String);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get coverImage => (_$data['coverImage'] as String?);

  bool? get isPublic => (_$data['isPublic'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$playlistId = playlistId;
    result$data['playlistId'] = l$playlistId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('coverImage')) {
      final l$coverImage = coverImage;
      result$data['coverImage'] = l$coverImage;
    }
    if (_$data.containsKey('isPublic')) {
      final l$isPublic = isPublic;
      result$data['isPublic'] = l$isPublic;
    }
    return result$data;
  }

  CopyWith$Input$UpdatePlaylistRequestInput<Input$UpdatePlaylistRequestInput>
  get copyWith => CopyWith$Input$UpdatePlaylistRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdatePlaylistRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$playlistId = playlistId;
    final lOther$playlistId = other.playlistId;
    if (l$playlistId != lOther$playlistId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$coverImage = coverImage;
    final lOther$coverImage = other.coverImage;
    if (_$data.containsKey('coverImage') !=
        other._$data.containsKey('coverImage')) {
      return false;
    }
    if (l$coverImage != lOther$coverImage) {
      return false;
    }
    final l$isPublic = isPublic;
    final lOther$isPublic = other.isPublic;
    if (_$data.containsKey('isPublic') !=
        other._$data.containsKey('isPublic')) {
      return false;
    }
    if (l$isPublic != lOther$isPublic) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$playlistId = playlistId;
    final l$name = name;
    final l$description = description;
    final l$coverImage = coverImage;
    final l$isPublic = isPublic;
    return Object.hashAll([
      l$playlistId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('coverImage') ? l$coverImage : const {},
      _$data.containsKey('isPublic') ? l$isPublic : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdatePlaylistRequestInput<TRes> {
  factory CopyWith$Input$UpdatePlaylistRequestInput(
    Input$UpdatePlaylistRequestInput instance,
    TRes Function(Input$UpdatePlaylistRequestInput) then,
  ) = _CopyWithImpl$Input$UpdatePlaylistRequestInput;

  factory CopyWith$Input$UpdatePlaylistRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePlaylistRequestInput;

  TRes call({
    String? playlistId,
    String? name,
    String? description,
    String? coverImage,
    bool? isPublic,
  });
}

class _CopyWithImpl$Input$UpdatePlaylistRequestInput<TRes>
    implements CopyWith$Input$UpdatePlaylistRequestInput<TRes> {
  _CopyWithImpl$Input$UpdatePlaylistRequestInput(this._instance, this._then);

  final Input$UpdatePlaylistRequestInput _instance;

  final TRes Function(Input$UpdatePlaylistRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? playlistId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? coverImage = _undefined,
    Object? isPublic = _undefined,
  }) => _then(
    Input$UpdatePlaylistRequestInput._({
      ..._instance._$data,
      if (playlistId != _undefined && playlistId != null)
        'playlistId': (playlistId as String),
      if (name != _undefined) 'name': (name as String?),
      if (description != _undefined) 'description': (description as String?),
      if (coverImage != _undefined) 'coverImage': (coverImage as String?),
      if (isPublic != _undefined) 'isPublic': (isPublic as bool?),
    }),
  );
}

class _CopyWithStubImpl$Input$UpdatePlaylistRequestInput<TRes>
    implements CopyWith$Input$UpdatePlaylistRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePlaylistRequestInput(this._res);

  TRes _res;

  call({
    String? playlistId,
    String? name,
    String? description,
    String? coverImage,
    bool? isPublic,
  }) => _res;
}

class Input$UpdatePriceRequestInput {
  factory Input$UpdatePriceRequestInput({
    required String stripePriceId,
    String? lookupKey,
    bool? active,
    Enum$PeriodTime? interval,
    int? intervalCount,
    List<Input$KeyValuePairOfStringAndStringInput>? metadata,
  }) => Input$UpdatePriceRequestInput._({
    r'stripePriceId': stripePriceId,
    if (lookupKey != null) r'lookupKey': lookupKey,
    if (active != null) r'active': active,
    if (interval != null) r'interval': interval,
    if (intervalCount != null) r'intervalCount': intervalCount,
    if (metadata != null) r'metadata': metadata,
  });

  Input$UpdatePriceRequestInput._(this._$data);

  factory Input$UpdatePriceRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$stripePriceId = data['stripePriceId'];
    result$data['stripePriceId'] = (l$stripePriceId as String);
    if (data.containsKey('lookupKey')) {
      final l$lookupKey = data['lookupKey'];
      result$data['lookupKey'] = (l$lookupKey as String?);
    }
    if (data.containsKey('active')) {
      final l$active = data['active'];
      result$data['active'] = (l$active as bool?);
    }
    if (data.containsKey('interval')) {
      final l$interval = data['interval'];
      result$data['interval'] = l$interval == null
          ? null
          : fromJson$Enum$PeriodTime((l$interval as String));
    }
    if (data.containsKey('intervalCount')) {
      final l$intervalCount = data['intervalCount'];
      result$data['intervalCount'] = (l$intervalCount as int?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
            (e) => Input$KeyValuePairOfStringAndStringInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    return Input$UpdatePriceRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get stripePriceId => (_$data['stripePriceId'] as String);

  String? get lookupKey => (_$data['lookupKey'] as String?);

  bool? get active => (_$data['active'] as bool?);

  Enum$PeriodTime? get interval => (_$data['interval'] as Enum$PeriodTime?);

  int? get intervalCount => (_$data['intervalCount'] as int?);

  List<Input$KeyValuePairOfStringAndStringInput>? get metadata =>
      (_$data['metadata'] as List<Input$KeyValuePairOfStringAndStringInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$stripePriceId = stripePriceId;
    result$data['stripePriceId'] = l$stripePriceId;
    if (_$data.containsKey('lookupKey')) {
      final l$lookupKey = lookupKey;
      result$data['lookupKey'] = l$lookupKey;
    }
    if (_$data.containsKey('active')) {
      final l$active = active;
      result$data['active'] = l$active;
    }
    if (_$data.containsKey('interval')) {
      final l$interval = interval;
      result$data['interval'] = l$interval == null
          ? null
          : toJson$Enum$PeriodTime(l$interval);
    }
    if (_$data.containsKey('intervalCount')) {
      final l$intervalCount = intervalCount;
      result$data['intervalCount'] = l$intervalCount;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdatePriceRequestInput<Input$UpdatePriceRequestInput>
  get copyWith => CopyWith$Input$UpdatePriceRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdatePriceRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$stripePriceId = stripePriceId;
    final lOther$stripePriceId = other.stripePriceId;
    if (l$stripePriceId != lOther$stripePriceId) {
      return false;
    }
    final l$lookupKey = lookupKey;
    final lOther$lookupKey = other.lookupKey;
    if (_$data.containsKey('lookupKey') !=
        other._$data.containsKey('lookupKey')) {
      return false;
    }
    if (l$lookupKey != lOther$lookupKey) {
      return false;
    }
    final l$active = active;
    final lOther$active = other.active;
    if (_$data.containsKey('active') != other._$data.containsKey('active')) {
      return false;
    }
    if (l$active != lOther$active) {
      return false;
    }
    final l$interval = interval;
    final lOther$interval = other.interval;
    if (_$data.containsKey('interval') !=
        other._$data.containsKey('interval')) {
      return false;
    }
    if (l$interval != lOther$interval) {
      return false;
    }
    final l$intervalCount = intervalCount;
    final lOther$intervalCount = other.intervalCount;
    if (_$data.containsKey('intervalCount') !=
        other._$data.containsKey('intervalCount')) {
      return false;
    }
    if (l$intervalCount != lOther$intervalCount) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$stripePriceId = stripePriceId;
    final l$lookupKey = lookupKey;
    final l$active = active;
    final l$interval = interval;
    final l$intervalCount = intervalCount;
    final l$metadata = metadata;
    return Object.hashAll([
      l$stripePriceId,
      _$data.containsKey('lookupKey') ? l$lookupKey : const {},
      _$data.containsKey('active') ? l$active : const {},
      _$data.containsKey('interval') ? l$interval : const {},
      _$data.containsKey('intervalCount') ? l$intervalCount : const {},
      _$data.containsKey('metadata')
          ? l$metadata == null
                ? null
                : Object.hashAll(l$metadata.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdatePriceRequestInput<TRes> {
  factory CopyWith$Input$UpdatePriceRequestInput(
    Input$UpdatePriceRequestInput instance,
    TRes Function(Input$UpdatePriceRequestInput) then,
  ) = _CopyWithImpl$Input$UpdatePriceRequestInput;

  factory CopyWith$Input$UpdatePriceRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePriceRequestInput;

  TRes call({
    String? stripePriceId,
    String? lookupKey,
    bool? active,
    Enum$PeriodTime? interval,
    int? intervalCount,
    List<Input$KeyValuePairOfStringAndStringInput>? metadata,
  });
  TRes metadata(
    Iterable<Input$KeyValuePairOfStringAndStringInput>? Function(
      Iterable<
        CopyWith$Input$KeyValuePairOfStringAndStringInput<
          Input$KeyValuePairOfStringAndStringInput
        >
      >?,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$UpdatePriceRequestInput<TRes>
    implements CopyWith$Input$UpdatePriceRequestInput<TRes> {
  _CopyWithImpl$Input$UpdatePriceRequestInput(this._instance, this._then);

  final Input$UpdatePriceRequestInput _instance;

  final TRes Function(Input$UpdatePriceRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? stripePriceId = _undefined,
    Object? lookupKey = _undefined,
    Object? active = _undefined,
    Object? interval = _undefined,
    Object? intervalCount = _undefined,
    Object? metadata = _undefined,
  }) => _then(
    Input$UpdatePriceRequestInput._({
      ..._instance._$data,
      if (stripePriceId != _undefined && stripePriceId != null)
        'stripePriceId': (stripePriceId as String),
      if (lookupKey != _undefined) 'lookupKey': (lookupKey as String?),
      if (active != _undefined) 'active': (active as bool?),
      if (interval != _undefined) 'interval': (interval as Enum$PeriodTime?),
      if (intervalCount != _undefined) 'intervalCount': (intervalCount as int?),
      if (metadata != _undefined)
        'metadata':
            (metadata as List<Input$KeyValuePairOfStringAndStringInput>?),
    }),
  );

  TRes metadata(
    Iterable<Input$KeyValuePairOfStringAndStringInput>? Function(
      Iterable<
        CopyWith$Input$KeyValuePairOfStringAndStringInput<
          Input$KeyValuePairOfStringAndStringInput
        >
      >?,
    )
    _fn,
  ) => call(
    metadata: _fn(
      _instance.metadata?.map(
        (e) => CopyWith$Input$KeyValuePairOfStringAndStringInput(e, (i) => i),
      ),
    )?.toList(),
  );
}

class _CopyWithStubImpl$Input$UpdatePriceRequestInput<TRes>
    implements CopyWith$Input$UpdatePriceRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePriceRequestInput(this._res);

  TRes _res;

  call({
    String? stripePriceId,
    String? lookupKey,
    bool? active,
    Enum$PeriodTime? interval,
    int? intervalCount,
    List<Input$KeyValuePairOfStringAndStringInput>? metadata,
  }) => _res;

  metadata(_fn) => _res;
}

class Input$UpdateReviewRequestInput {
  factory Input$UpdateReviewRequestInput({
    required String packageOrderId,
    int? rating,
    String? comment,
  }) => Input$UpdateReviewRequestInput._({
    r'packageOrderId': packageOrderId,
    if (rating != null) r'rating': rating,
    if (comment != null) r'comment': comment,
  });

  Input$UpdateReviewRequestInput._(this._$data);

  factory Input$UpdateReviewRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$packageOrderId = data['packageOrderId'];
    result$data['packageOrderId'] = (l$packageOrderId as String);
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as int?);
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    return Input$UpdateReviewRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get packageOrderId => (_$data['packageOrderId'] as String);

  int? get rating => (_$data['rating'] as int?);

  String? get comment => (_$data['comment'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$packageOrderId = packageOrderId;
    result$data['packageOrderId'] = l$packageOrderId;
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    return result$data;
  }

  CopyWith$Input$UpdateReviewRequestInput<Input$UpdateReviewRequestInput>
  get copyWith => CopyWith$Input$UpdateReviewRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateReviewRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$packageOrderId = packageOrderId;
    final lOther$packageOrderId = other.packageOrderId;
    if (l$packageOrderId != lOther$packageOrderId) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$packageOrderId = packageOrderId;
    final l$rating = rating;
    final l$comment = comment;
    return Object.hashAll([
      l$packageOrderId,
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('comment') ? l$comment : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateReviewRequestInput<TRes> {
  factory CopyWith$Input$UpdateReviewRequestInput(
    Input$UpdateReviewRequestInput instance,
    TRes Function(Input$UpdateReviewRequestInput) then,
  ) = _CopyWithImpl$Input$UpdateReviewRequestInput;

  factory CopyWith$Input$UpdateReviewRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateReviewRequestInput;

  TRes call({String? packageOrderId, int? rating, String? comment});
}

class _CopyWithImpl$Input$UpdateReviewRequestInput<TRes>
    implements CopyWith$Input$UpdateReviewRequestInput<TRes> {
  _CopyWithImpl$Input$UpdateReviewRequestInput(this._instance, this._then);

  final Input$UpdateReviewRequestInput _instance;

  final TRes Function(Input$UpdateReviewRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? packageOrderId = _undefined,
    Object? rating = _undefined,
    Object? comment = _undefined,
  }) => _then(
    Input$UpdateReviewRequestInput._({
      ..._instance._$data,
      if (packageOrderId != _undefined && packageOrderId != null)
        'packageOrderId': (packageOrderId as String),
      if (rating != _undefined) 'rating': (rating as int?),
      if (comment != _undefined) 'comment': (comment as String?),
    }),
  );
}

class _CopyWithStubImpl$Input$UpdateReviewRequestInput<TRes>
    implements CopyWith$Input$UpdateReviewRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdateReviewRequestInput(this._res);

  TRes _res;

  call({String? packageOrderId, int? rating, String? comment}) => _res;
}

class Input$UpdateRoyalPolicyRequestInput {
  factory Input$UpdateRoyalPolicyRequestInput({
    required int version,
    double? ratePerStream,
    Enum$CurrencyType? currency,
    double? recordingPercentage,
    double? workPercentage,
  }) => Input$UpdateRoyalPolicyRequestInput._({
    r'version': version,
    if (ratePerStream != null) r'ratePerStream': ratePerStream,
    if (currency != null) r'currency': currency,
    if (recordingPercentage != null)
      r'recordingPercentage': recordingPercentage,
    if (workPercentage != null) r'workPercentage': workPercentage,
  });

  Input$UpdateRoyalPolicyRequestInput._(this._$data);

  factory Input$UpdateRoyalPolicyRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$version = data['version'];
    result$data['version'] = (l$version as int);
    if (data.containsKey('ratePerStream')) {
      final l$ratePerStream = data['ratePerStream'];
      result$data['ratePerStream'] = (l$ratePerStream as num?)?.toDouble();
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = l$currency == null
          ? null
          : fromJson$Enum$CurrencyType((l$currency as String));
    }
    if (data.containsKey('recordingPercentage')) {
      final l$recordingPercentage = data['recordingPercentage'];
      result$data['recordingPercentage'] = (l$recordingPercentage as num?)
          ?.toDouble();
    }
    if (data.containsKey('workPercentage')) {
      final l$workPercentage = data['workPercentage'];
      result$data['workPercentage'] = (l$workPercentage as num?)?.toDouble();
    }
    return Input$UpdateRoyalPolicyRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get version => (_$data['version'] as int);

  double? get ratePerStream => (_$data['ratePerStream'] as double?);

  Enum$CurrencyType? get currency => (_$data['currency'] as Enum$CurrencyType?);

  double? get recordingPercentage => (_$data['recordingPercentage'] as double?);

  double? get workPercentage => (_$data['workPercentage'] as double?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$version = version;
    result$data['version'] = l$version;
    if (_$data.containsKey('ratePerStream')) {
      final l$ratePerStream = ratePerStream;
      result$data['ratePerStream'] = l$ratePerStream;
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency == null
          ? null
          : toJson$Enum$CurrencyType(l$currency);
    }
    if (_$data.containsKey('recordingPercentage')) {
      final l$recordingPercentage = recordingPercentage;
      result$data['recordingPercentage'] = l$recordingPercentage;
    }
    if (_$data.containsKey('workPercentage')) {
      final l$workPercentage = workPercentage;
      result$data['workPercentage'] = l$workPercentage;
    }
    return result$data;
  }

  CopyWith$Input$UpdateRoyalPolicyRequestInput<
    Input$UpdateRoyalPolicyRequestInput
  >
  get copyWith => CopyWith$Input$UpdateRoyalPolicyRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateRoyalPolicyRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) {
      return false;
    }
    final l$ratePerStream = ratePerStream;
    final lOther$ratePerStream = other.ratePerStream;
    if (_$data.containsKey('ratePerStream') !=
        other._$data.containsKey('ratePerStream')) {
      return false;
    }
    if (l$ratePerStream != lOther$ratePerStream) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$recordingPercentage = recordingPercentage;
    final lOther$recordingPercentage = other.recordingPercentage;
    if (_$data.containsKey('recordingPercentage') !=
        other._$data.containsKey('recordingPercentage')) {
      return false;
    }
    if (l$recordingPercentage != lOther$recordingPercentage) {
      return false;
    }
    final l$workPercentage = workPercentage;
    final lOther$workPercentage = other.workPercentage;
    if (_$data.containsKey('workPercentage') !=
        other._$data.containsKey('workPercentage')) {
      return false;
    }
    if (l$workPercentage != lOther$workPercentage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$ratePerStream = ratePerStream;
    final l$currency = currency;
    final l$recordingPercentage = recordingPercentage;
    final l$workPercentage = workPercentage;
    return Object.hashAll([
      l$version,
      _$data.containsKey('ratePerStream') ? l$ratePerStream : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('recordingPercentage')
          ? l$recordingPercentage
          : const {},
      _$data.containsKey('workPercentage') ? l$workPercentage : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateRoyalPolicyRequestInput<TRes> {
  factory CopyWith$Input$UpdateRoyalPolicyRequestInput(
    Input$UpdateRoyalPolicyRequestInput instance,
    TRes Function(Input$UpdateRoyalPolicyRequestInput) then,
  ) = _CopyWithImpl$Input$UpdateRoyalPolicyRequestInput;

  factory CopyWith$Input$UpdateRoyalPolicyRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRoyalPolicyRequestInput;

  TRes call({
    int? version,
    double? ratePerStream,
    Enum$CurrencyType? currency,
    double? recordingPercentage,
    double? workPercentage,
  });
}

class _CopyWithImpl$Input$UpdateRoyalPolicyRequestInput<TRes>
    implements CopyWith$Input$UpdateRoyalPolicyRequestInput<TRes> {
  _CopyWithImpl$Input$UpdateRoyalPolicyRequestInput(this._instance, this._then);

  final Input$UpdateRoyalPolicyRequestInput _instance;

  final TRes Function(Input$UpdateRoyalPolicyRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? ratePerStream = _undefined,
    Object? currency = _undefined,
    Object? recordingPercentage = _undefined,
    Object? workPercentage = _undefined,
  }) => _then(
    Input$UpdateRoyalPolicyRequestInput._({
      ..._instance._$data,
      if (version != _undefined && version != null) 'version': (version as int),
      if (ratePerStream != _undefined)
        'ratePerStream': (ratePerStream as double?),
      if (currency != _undefined) 'currency': (currency as Enum$CurrencyType?),
      if (recordingPercentage != _undefined)
        'recordingPercentage': (recordingPercentage as double?),
      if (workPercentage != _undefined)
        'workPercentage': (workPercentage as double?),
    }),
  );
}

class _CopyWithStubImpl$Input$UpdateRoyalPolicyRequestInput<TRes>
    implements CopyWith$Input$UpdateRoyalPolicyRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRoyalPolicyRequestInput(this._res);

  TRes _res;

  call({
    int? version,
    double? ratePerStream,
    Enum$CurrencyType? currency,
    double? recordingPercentage,
    double? workPercentage,
  }) => _res;
}

class Input$UpdateStatusArtistPackageRequestInput {
  factory Input$UpdateStatusArtistPackageRequestInput({
    required String id,
    required Enum$ArtistPackageStatus status,
  }) => Input$UpdateStatusArtistPackageRequestInput._({
    r'id': id,
    r'status': status,
  });

  Input$UpdateStatusArtistPackageRequestInput._(this._$data);

  factory Input$UpdateStatusArtistPackageRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$status = data['status'];
    result$data['status'] = fromJson$Enum$ArtistPackageStatus(
      (l$status as String),
    );
    return Input$UpdateStatusArtistPackageRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);

  Enum$ArtistPackageStatus get status =>
      (_$data['status'] as Enum$ArtistPackageStatus);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$status = status;
    result$data['status'] = toJson$Enum$ArtistPackageStatus(l$status);
    return result$data;
  }

  CopyWith$Input$UpdateStatusArtistPackageRequestInput<
    Input$UpdateStatusArtistPackageRequestInput
  >
  get copyWith =>
      CopyWith$Input$UpdateStatusArtistPackageRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateStatusArtistPackageRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$status = status;
    return Object.hashAll([l$id, l$status]);
  }
}

abstract class CopyWith$Input$UpdateStatusArtistPackageRequestInput<TRes> {
  factory CopyWith$Input$UpdateStatusArtistPackageRequestInput(
    Input$UpdateStatusArtistPackageRequestInput instance,
    TRes Function(Input$UpdateStatusArtistPackageRequestInput) then,
  ) = _CopyWithImpl$Input$UpdateStatusArtistPackageRequestInput;

  factory CopyWith$Input$UpdateStatusArtistPackageRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateStatusArtistPackageRequestInput;

  TRes call({String? id, Enum$ArtistPackageStatus? status});
}

class _CopyWithImpl$Input$UpdateStatusArtistPackageRequestInput<TRes>
    implements CopyWith$Input$UpdateStatusArtistPackageRequestInput<TRes> {
  _CopyWithImpl$Input$UpdateStatusArtistPackageRequestInput(
    this._instance,
    this._then,
  );

  final Input$UpdateStatusArtistPackageRequestInput _instance;

  final TRes Function(Input$UpdateStatusArtistPackageRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined, Object? status = _undefined}) => _then(
    Input$UpdateStatusArtistPackageRequestInput._({
      ..._instance._$data,
      if (id != _undefined && id != null) 'id': (id as String),
      if (status != _undefined && status != null)
        'status': (status as Enum$ArtistPackageStatus),
    }),
  );
}

class _CopyWithStubImpl$Input$UpdateStatusArtistPackageRequestInput<TRes>
    implements CopyWith$Input$UpdateStatusArtistPackageRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdateStatusArtistPackageRequestInput(this._res);

  TRes _res;

  call({String? id, Enum$ArtistPackageStatus? status}) => _res;
}

class Input$UpdateSubscriptionPlanRequestInput {
  factory Input$UpdateSubscriptionPlanRequestInput({
    required String subscriptionPlanId,
    required List<Input$CreatePriceRequestInput> newPrices,
    required List<Input$UpdatePriceRequestInput> updatePrices,
    List<Input$KeyValuePairOfStringAndStringInput>? metadata,
    List<String>? images,
    String? name,
  }) => Input$UpdateSubscriptionPlanRequestInput._({
    r'subscriptionPlanId': subscriptionPlanId,
    r'newPrices': newPrices,
    r'updatePrices': updatePrices,
    if (metadata != null) r'metadata': metadata,
    if (images != null) r'images': images,
    if (name != null) r'name': name,
  });

  Input$UpdateSubscriptionPlanRequestInput._(this._$data);

  factory Input$UpdateSubscriptionPlanRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$subscriptionPlanId = data['subscriptionPlanId'];
    result$data['subscriptionPlanId'] = (l$subscriptionPlanId as String);
    final l$newPrices = data['newPrices'];
    result$data['newPrices'] = (l$newPrices as List<dynamic>)
        .map(
          (e) => Input$CreatePriceRequestInput.fromJson(
            (e as Map<String, dynamic>),
          ),
        )
        .toList();
    final l$updatePrices = data['updatePrices'];
    result$data['updatePrices'] = (l$updatePrices as List<dynamic>)
        .map(
          (e) => Input$UpdatePriceRequestInput.fromJson(
            (e as Map<String, dynamic>),
          ),
        )
        .toList();
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as List<dynamic>?)
          ?.map(
            (e) => Input$KeyValuePairOfStringAndStringInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('images')) {
      final l$images = data['images'];
      result$data['images'] = (l$images as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$UpdateSubscriptionPlanRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get subscriptionPlanId => (_$data['subscriptionPlanId'] as String);

  List<Input$CreatePriceRequestInput> get newPrices =>
      (_$data['newPrices'] as List<Input$CreatePriceRequestInput>);

  List<Input$UpdatePriceRequestInput> get updatePrices =>
      (_$data['updatePrices'] as List<Input$UpdatePriceRequestInput>);

  List<Input$KeyValuePairOfStringAndStringInput>? get metadata =>
      (_$data['metadata'] as List<Input$KeyValuePairOfStringAndStringInput>?);

  List<String>? get images => (_$data['images'] as List<String>?);

  String? get name => (_$data['name'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$subscriptionPlanId = subscriptionPlanId;
    result$data['subscriptionPlanId'] = l$subscriptionPlanId;
    final l$newPrices = newPrices;
    result$data['newPrices'] = l$newPrices.map((e) => e.toJson()).toList();
    final l$updatePrices = updatePrices;
    result$data['updatePrices'] = l$updatePrices
        .map((e) => e.toJson())
        .toList();
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('images')) {
      final l$images = images;
      result$data['images'] = l$images?.map((e) => e).toList();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$UpdateSubscriptionPlanRequestInput<
    Input$UpdateSubscriptionPlanRequestInput
  >
  get copyWith =>
      CopyWith$Input$UpdateSubscriptionPlanRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateSubscriptionPlanRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$subscriptionPlanId = subscriptionPlanId;
    final lOther$subscriptionPlanId = other.subscriptionPlanId;
    if (l$subscriptionPlanId != lOther$subscriptionPlanId) {
      return false;
    }
    final l$newPrices = newPrices;
    final lOther$newPrices = other.newPrices;
    if (l$newPrices.length != lOther$newPrices.length) {
      return false;
    }
    for (int i = 0; i < l$newPrices.length; i++) {
      final l$newPrices$entry = l$newPrices[i];
      final lOther$newPrices$entry = lOther$newPrices[i];
      if (l$newPrices$entry != lOther$newPrices$entry) {
        return false;
      }
    }
    final l$updatePrices = updatePrices;
    final lOther$updatePrices = other.updatePrices;
    if (l$updatePrices.length != lOther$updatePrices.length) {
      return false;
    }
    for (int i = 0; i < l$updatePrices.length; i++) {
      final l$updatePrices$entry = l$updatePrices[i];
      final lOther$updatePrices$entry = lOther$updatePrices[i];
      if (l$updatePrices$entry != lOther$updatePrices$entry) {
        return false;
      }
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$images = images;
    final lOther$images = other.images;
    if (_$data.containsKey('images') != other._$data.containsKey('images')) {
      return false;
    }
    if (l$images != null && lOther$images != null) {
      if (l$images.length != lOther$images.length) {
        return false;
      }
      for (int i = 0; i < l$images.length; i++) {
        final l$images$entry = l$images[i];
        final lOther$images$entry = lOther$images[i];
        if (l$images$entry != lOther$images$entry) {
          return false;
        }
      }
    } else if (l$images != lOther$images) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subscriptionPlanId = subscriptionPlanId;
    final l$newPrices = newPrices;
    final l$updatePrices = updatePrices;
    final l$metadata = metadata;
    final l$images = images;
    final l$name = name;
    return Object.hashAll([
      l$subscriptionPlanId,
      Object.hashAll(l$newPrices.map((v) => v)),
      Object.hashAll(l$updatePrices.map((v) => v)),
      _$data.containsKey('metadata')
          ? l$metadata == null
                ? null
                : Object.hashAll(l$metadata.map((v) => v))
          : const {},
      _$data.containsKey('images')
          ? l$images == null
                ? null
                : Object.hashAll(l$images.map((v) => v))
          : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateSubscriptionPlanRequestInput<TRes> {
  factory CopyWith$Input$UpdateSubscriptionPlanRequestInput(
    Input$UpdateSubscriptionPlanRequestInput instance,
    TRes Function(Input$UpdateSubscriptionPlanRequestInput) then,
  ) = _CopyWithImpl$Input$UpdateSubscriptionPlanRequestInput;

  factory CopyWith$Input$UpdateSubscriptionPlanRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateSubscriptionPlanRequestInput;

  TRes call({
    String? subscriptionPlanId,
    List<Input$CreatePriceRequestInput>? newPrices,
    List<Input$UpdatePriceRequestInput>? updatePrices,
    List<Input$KeyValuePairOfStringAndStringInput>? metadata,
    List<String>? images,
    String? name,
  });
  TRes newPrices(
    Iterable<Input$CreatePriceRequestInput> Function(
      Iterable<
        CopyWith$Input$CreatePriceRequestInput<Input$CreatePriceRequestInput>
      >,
    )
    _fn,
  );
  TRes updatePrices(
    Iterable<Input$UpdatePriceRequestInput> Function(
      Iterable<
        CopyWith$Input$UpdatePriceRequestInput<Input$UpdatePriceRequestInput>
      >,
    )
    _fn,
  );
  TRes metadata(
    Iterable<Input$KeyValuePairOfStringAndStringInput>? Function(
      Iterable<
        CopyWith$Input$KeyValuePairOfStringAndStringInput<
          Input$KeyValuePairOfStringAndStringInput
        >
      >?,
    )
    _fn,
  );
}

class _CopyWithImpl$Input$UpdateSubscriptionPlanRequestInput<TRes>
    implements CopyWith$Input$UpdateSubscriptionPlanRequestInput<TRes> {
  _CopyWithImpl$Input$UpdateSubscriptionPlanRequestInput(
    this._instance,
    this._then,
  );

  final Input$UpdateSubscriptionPlanRequestInput _instance;

  final TRes Function(Input$UpdateSubscriptionPlanRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? subscriptionPlanId = _undefined,
    Object? newPrices = _undefined,
    Object? updatePrices = _undefined,
    Object? metadata = _undefined,
    Object? images = _undefined,
    Object? name = _undefined,
  }) => _then(
    Input$UpdateSubscriptionPlanRequestInput._({
      ..._instance._$data,
      if (subscriptionPlanId != _undefined && subscriptionPlanId != null)
        'subscriptionPlanId': (subscriptionPlanId as String),
      if (newPrices != _undefined && newPrices != null)
        'newPrices': (newPrices as List<Input$CreatePriceRequestInput>),
      if (updatePrices != _undefined && updatePrices != null)
        'updatePrices': (updatePrices as List<Input$UpdatePriceRequestInput>),
      if (metadata != _undefined)
        'metadata':
            (metadata as List<Input$KeyValuePairOfStringAndStringInput>?),
      if (images != _undefined) 'images': (images as List<String>?),
      if (name != _undefined) 'name': (name as String?),
    }),
  );

  TRes newPrices(
    Iterable<Input$CreatePriceRequestInput> Function(
      Iterable<
        CopyWith$Input$CreatePriceRequestInput<Input$CreatePriceRequestInput>
      >,
    )
    _fn,
  ) => call(
    newPrices: _fn(
      _instance.newPrices.map(
        (e) => CopyWith$Input$CreatePriceRequestInput(e, (i) => i),
      ),
    ).toList(),
  );

  TRes updatePrices(
    Iterable<Input$UpdatePriceRequestInput> Function(
      Iterable<
        CopyWith$Input$UpdatePriceRequestInput<Input$UpdatePriceRequestInput>
      >,
    )
    _fn,
  ) => call(
    updatePrices: _fn(
      _instance.updatePrices.map(
        (e) => CopyWith$Input$UpdatePriceRequestInput(e, (i) => i),
      ),
    ).toList(),
  );

  TRes metadata(
    Iterable<Input$KeyValuePairOfStringAndStringInput>? Function(
      Iterable<
        CopyWith$Input$KeyValuePairOfStringAndStringInput<
          Input$KeyValuePairOfStringAndStringInput
        >
      >?,
    )
    _fn,
  ) => call(
    metadata: _fn(
      _instance.metadata?.map(
        (e) => CopyWith$Input$KeyValuePairOfStringAndStringInput(e, (i) => i),
      ),
    )?.toList(),
  );
}

class _CopyWithStubImpl$Input$UpdateSubscriptionPlanRequestInput<TRes>
    implements CopyWith$Input$UpdateSubscriptionPlanRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdateSubscriptionPlanRequestInput(this._res);

  TRes _res;

  call({
    String? subscriptionPlanId,
    List<Input$CreatePriceRequestInput>? newPrices,
    List<Input$UpdatePriceRequestInput>? updatePrices,
    List<Input$KeyValuePairOfStringAndStringInput>? metadata,
    List<String>? images,
    String? name,
  }) => _res;

  newPrices(_fn) => _res;

  updatePrices(_fn) => _res;

  metadata(_fn) => _res;
}

class Input$UpdateTrackCommentRequestInput {
  factory Input$UpdateTrackCommentRequestInput({
    required String commentId,
    required String content,
  }) => Input$UpdateTrackCommentRequestInput._({
    r'commentId': commentId,
    r'content': content,
  });

  Input$UpdateTrackCommentRequestInput._(this._$data);

  factory Input$UpdateTrackCommentRequestInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    final l$commentId = data['commentId'];
    result$data['commentId'] = (l$commentId as String);
    final l$content = data['content'];
    result$data['content'] = (l$content as String);
    return Input$UpdateTrackCommentRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get commentId => (_$data['commentId'] as String);

  String get content => (_$data['content'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$commentId = commentId;
    result$data['commentId'] = l$commentId;
    final l$content = content;
    result$data['content'] = l$content;
    return result$data;
  }

  CopyWith$Input$UpdateTrackCommentRequestInput<
    Input$UpdateTrackCommentRequestInput
  >
  get copyWith => CopyWith$Input$UpdateTrackCommentRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateTrackCommentRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$commentId = commentId;
    final lOther$commentId = other.commentId;
    if (l$commentId != lOther$commentId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$commentId = commentId;
    final l$content = content;
    return Object.hashAll([l$commentId, l$content]);
  }
}

abstract class CopyWith$Input$UpdateTrackCommentRequestInput<TRes> {
  factory CopyWith$Input$UpdateTrackCommentRequestInput(
    Input$UpdateTrackCommentRequestInput instance,
    TRes Function(Input$UpdateTrackCommentRequestInput) then,
  ) = _CopyWithImpl$Input$UpdateTrackCommentRequestInput;

  factory CopyWith$Input$UpdateTrackCommentRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTrackCommentRequestInput;

  TRes call({String? commentId, String? content});
}

class _CopyWithImpl$Input$UpdateTrackCommentRequestInput<TRes>
    implements CopyWith$Input$UpdateTrackCommentRequestInput<TRes> {
  _CopyWithImpl$Input$UpdateTrackCommentRequestInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTrackCommentRequestInput _instance;

  final TRes Function(Input$UpdateTrackCommentRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? commentId = _undefined, Object? content = _undefined}) =>
      _then(
        Input$UpdateTrackCommentRequestInput._({
          ..._instance._$data,
          if (commentId != _undefined && commentId != null)
            'commentId': (commentId as String),
          if (content != _undefined && content != null)
            'content': (content as String),
        }),
      );
}

class _CopyWithStubImpl$Input$UpdateTrackCommentRequestInput<TRes>
    implements CopyWith$Input$UpdateTrackCommentRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTrackCommentRequestInput(this._res);

  TRes _res;

  call({String? commentId, String? content}) => _res;
}

class Input$UserEngagementActionOperationFilterInput {
  factory Input$UserEngagementActionOperationFilterInput({
    Enum$UserEngagementAction? eq,
    Enum$UserEngagementAction? neq,
    List<Enum$UserEngagementAction>? $in,
    List<Enum$UserEngagementAction>? nin,
  }) => Input$UserEngagementActionOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$UserEngagementActionOperationFilterInput._(this._$data);

  factory Input$UserEngagementActionOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$UserEngagementAction((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$UserEngagementAction((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserEngagementAction((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserEngagementAction((e as String)))
          .toList();
    }
    return Input$UserEngagementActionOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserEngagementAction? get eq =>
      (_$data['eq'] as Enum$UserEngagementAction?);

  Enum$UserEngagementAction? get neq =>
      (_$data['neq'] as Enum$UserEngagementAction?);

  List<Enum$UserEngagementAction>? get $in =>
      (_$data['in'] as List<Enum$UserEngagementAction>?);

  List<Enum$UserEngagementAction>? get nin =>
      (_$data['nin'] as List<Enum$UserEngagementAction>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$UserEngagementAction(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$UserEngagementAction(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$UserEngagementAction(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$UserEngagementAction(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$UserEngagementActionOperationFilterInput<
    Input$UserEngagementActionOperationFilterInput
  >
  get copyWith =>
      CopyWith$Input$UserEngagementActionOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserEngagementActionOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserEngagementActionOperationFilterInput<TRes> {
  factory CopyWith$Input$UserEngagementActionOperationFilterInput(
    Input$UserEngagementActionOperationFilterInput instance,
    TRes Function(Input$UserEngagementActionOperationFilterInput) then,
  ) = _CopyWithImpl$Input$UserEngagementActionOperationFilterInput;

  factory CopyWith$Input$UserEngagementActionOperationFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$UserEngagementActionOperationFilterInput;

  TRes call({
    Enum$UserEngagementAction? eq,
    Enum$UserEngagementAction? neq,
    List<Enum$UserEngagementAction>? $in,
    List<Enum$UserEngagementAction>? nin,
  });
}

class _CopyWithImpl$Input$UserEngagementActionOperationFilterInput<TRes>
    implements CopyWith$Input$UserEngagementActionOperationFilterInput<TRes> {
  _CopyWithImpl$Input$UserEngagementActionOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$UserEngagementActionOperationFilterInput _instance;

  final TRes Function(Input$UserEngagementActionOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$UserEngagementActionOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$UserEngagementAction?),
      if (neq != _undefined) 'neq': (neq as Enum$UserEngagementAction?),
      if ($in != _undefined) 'in': ($in as List<Enum$UserEngagementAction>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$UserEngagementAction>?),
    }),
  );
}

class _CopyWithStubImpl$Input$UserEngagementActionOperationFilterInput<TRes>
    implements CopyWith$Input$UserEngagementActionOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$UserEngagementActionOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$UserEngagementAction? eq,
    Enum$UserEngagementAction? neq,
    List<Enum$UserEngagementAction>? $in,
    List<Enum$UserEngagementAction>? nin,
  }) => _res;
}

class Input$UserEngagementFilterInput {
  factory Input$UserEngagementFilterInput({
    List<Input$UserEngagementFilterInput>? and,
    List<Input$UserEngagementFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? actorId,
    Input$UserEngagementTargetTypeOperationFilterInput? actorType,
    Input$StringOperationFilterInput? targetId,
    Input$UserEngagementTargetTypeOperationFilterInput? targetType,
    Input$UserEngagementActionOperationFilterInput? action,
    Input$DateTimeOperationFilterInput? createdAt,
  }) => Input$UserEngagementFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (actorId != null) r'actorId': actorId,
    if (actorType != null) r'actorType': actorType,
    if (targetId != null) r'targetId': targetId,
    if (targetType != null) r'targetType': targetType,
    if (action != null) r'action': action,
    if (createdAt != null) r'createdAt': createdAt,
  });

  Input$UserEngagementFilterInput._(this._$data);

  factory Input$UserEngagementFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$UserEngagementFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$UserEngagementFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('actorId')) {
      final l$actorId = data['actorId'];
      result$data['actorId'] = l$actorId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$actorId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('actorType')) {
      final l$actorType = data['actorType'];
      result$data['actorType'] = l$actorType == null
          ? null
          : Input$UserEngagementTargetTypeOperationFilterInput.fromJson(
              (l$actorType as Map<String, dynamic>),
            );
    }
    if (data.containsKey('targetId')) {
      final l$targetId = data['targetId'];
      result$data['targetId'] = l$targetId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$targetId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('targetType')) {
      final l$targetType = data['targetType'];
      result$data['targetType'] = l$targetType == null
          ? null
          : Input$UserEngagementTargetTypeOperationFilterInput.fromJson(
              (l$targetType as Map<String, dynamic>),
            );
    }
    if (data.containsKey('action')) {
      final l$action = data['action'];
      result$data['action'] = l$action == null
          ? null
          : Input$UserEngagementActionOperationFilterInput.fromJson(
              (l$action as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    return Input$UserEngagementFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$UserEngagementFilterInput>? get and =>
      (_$data['and'] as List<Input$UserEngagementFilterInput>?);

  List<Input$UserEngagementFilterInput>? get or =>
      (_$data['or'] as List<Input$UserEngagementFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get actorId =>
      (_$data['actorId'] as Input$StringOperationFilterInput?);

  Input$UserEngagementTargetTypeOperationFilterInput? get actorType =>
      (_$data['actorType']
          as Input$UserEngagementTargetTypeOperationFilterInput?);

  Input$StringOperationFilterInput? get targetId =>
      (_$data['targetId'] as Input$StringOperationFilterInput?);

  Input$UserEngagementTargetTypeOperationFilterInput? get targetType =>
      (_$data['targetType']
          as Input$UserEngagementTargetTypeOperationFilterInput?);

  Input$UserEngagementActionOperationFilterInput? get action =>
      (_$data['action'] as Input$UserEngagementActionOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('actorId')) {
      final l$actorId = actorId;
      result$data['actorId'] = l$actorId?.toJson();
    }
    if (_$data.containsKey('actorType')) {
      final l$actorType = actorType;
      result$data['actorType'] = l$actorType?.toJson();
    }
    if (_$data.containsKey('targetId')) {
      final l$targetId = targetId;
      result$data['targetId'] = l$targetId?.toJson();
    }
    if (_$data.containsKey('targetType')) {
      final l$targetType = targetType;
      result$data['targetType'] = l$targetType?.toJson();
    }
    if (_$data.containsKey('action')) {
      final l$action = action;
      result$data['action'] = l$action?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserEngagementFilterInput<Input$UserEngagementFilterInput>
  get copyWith => CopyWith$Input$UserEngagementFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserEngagementFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$actorId = actorId;
    final lOther$actorId = other.actorId;
    if (_$data.containsKey('actorId') != other._$data.containsKey('actorId')) {
      return false;
    }
    if (l$actorId != lOther$actorId) {
      return false;
    }
    final l$actorType = actorType;
    final lOther$actorType = other.actorType;
    if (_$data.containsKey('actorType') !=
        other._$data.containsKey('actorType')) {
      return false;
    }
    if (l$actorType != lOther$actorType) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (_$data.containsKey('targetId') !=
        other._$data.containsKey('targetId')) {
      return false;
    }
    if (l$targetId != lOther$targetId) {
      return false;
    }
    final l$targetType = targetType;
    final lOther$targetType = other.targetType;
    if (_$data.containsKey('targetType') !=
        other._$data.containsKey('targetType')) {
      return false;
    }
    if (l$targetType != lOther$targetType) {
      return false;
    }
    final l$action = action;
    final lOther$action = other.action;
    if (_$data.containsKey('action') != other._$data.containsKey('action')) {
      return false;
    }
    if (l$action != lOther$action) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$actorId = actorId;
    final l$actorType = actorType;
    final l$targetId = targetId;
    final l$targetType = targetType;
    final l$action = action;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('actorId') ? l$actorId : const {},
      _$data.containsKey('actorType') ? l$actorType : const {},
      _$data.containsKey('targetId') ? l$targetId : const {},
      _$data.containsKey('targetType') ? l$targetType : const {},
      _$data.containsKey('action') ? l$action : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserEngagementFilterInput<TRes> {
  factory CopyWith$Input$UserEngagementFilterInput(
    Input$UserEngagementFilterInput instance,
    TRes Function(Input$UserEngagementFilterInput) then,
  ) = _CopyWithImpl$Input$UserEngagementFilterInput;

  factory CopyWith$Input$UserEngagementFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserEngagementFilterInput;

  TRes call({
    List<Input$UserEngagementFilterInput>? and,
    List<Input$UserEngagementFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? actorId,
    Input$UserEngagementTargetTypeOperationFilterInput? actorType,
    Input$StringOperationFilterInput? targetId,
    Input$UserEngagementTargetTypeOperationFilterInput? targetType,
    Input$UserEngagementActionOperationFilterInput? action,
    Input$DateTimeOperationFilterInput? createdAt,
  });
  TRes and(
    Iterable<Input$UserEngagementFilterInput>? Function(
      Iterable<
        CopyWith$Input$UserEngagementFilterInput<
          Input$UserEngagementFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$UserEngagementFilterInput>? Function(
      Iterable<
        CopyWith$Input$UserEngagementFilterInput<
          Input$UserEngagementFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get actorId;
  CopyWith$Input$UserEngagementTargetTypeOperationFilterInput<TRes>
  get actorType;
  CopyWith$Input$StringOperationFilterInput<TRes> get targetId;
  CopyWith$Input$UserEngagementTargetTypeOperationFilterInput<TRes>
  get targetType;
  CopyWith$Input$UserEngagementActionOperationFilterInput<TRes> get action;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
}

class _CopyWithImpl$Input$UserEngagementFilterInput<TRes>
    implements CopyWith$Input$UserEngagementFilterInput<TRes> {
  _CopyWithImpl$Input$UserEngagementFilterInput(this._instance, this._then);

  final Input$UserEngagementFilterInput _instance;

  final TRes Function(Input$UserEngagementFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? actorId = _undefined,
    Object? actorType = _undefined,
    Object? targetId = _undefined,
    Object? targetType = _undefined,
    Object? action = _undefined,
    Object? createdAt = _undefined,
  }) => _then(
    Input$UserEngagementFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$UserEngagementFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$UserEngagementFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (actorId != _undefined)
        'actorId': (actorId as Input$StringOperationFilterInput?),
      if (actorType != _undefined)
        'actorType':
            (actorType as Input$UserEngagementTargetTypeOperationFilterInput?),
      if (targetId != _undefined)
        'targetId': (targetId as Input$StringOperationFilterInput?),
      if (targetType != _undefined)
        'targetType':
            (targetType as Input$UserEngagementTargetTypeOperationFilterInput?),
      if (action != _undefined)
        'action': (action as Input$UserEngagementActionOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$UserEngagementFilterInput>? Function(
      Iterable<
        CopyWith$Input$UserEngagementFilterInput<
          Input$UserEngagementFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$UserEngagementFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$UserEngagementFilterInput>? Function(
      Iterable<
        CopyWith$Input$UserEngagementFilterInput<
          Input$UserEngagementFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$UserEngagementFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get actorId {
    final local$actorId = _instance.actorId;
    return local$actorId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$actorId,
            (e) => call(actorId: e),
          );
  }

  CopyWith$Input$UserEngagementTargetTypeOperationFilterInput<TRes>
  get actorType {
    final local$actorType = _instance.actorType;
    return local$actorType == null
        ? CopyWith$Input$UserEngagementTargetTypeOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$UserEngagementTargetTypeOperationFilterInput(
            local$actorType,
            (e) => call(actorType: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get targetId {
    final local$targetId = _instance.targetId;
    return local$targetId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$targetId,
            (e) => call(targetId: e),
          );
  }

  CopyWith$Input$UserEngagementTargetTypeOperationFilterInput<TRes>
  get targetType {
    final local$targetType = _instance.targetType;
    return local$targetType == null
        ? CopyWith$Input$UserEngagementTargetTypeOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$UserEngagementTargetTypeOperationFilterInput(
            local$targetType,
            (e) => call(targetType: e),
          );
  }

  CopyWith$Input$UserEngagementActionOperationFilterInput<TRes> get action {
    final local$action = _instance.action;
    return local$action == null
        ? CopyWith$Input$UserEngagementActionOperationFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$UserEngagementActionOperationFilterInput(
            local$action,
            (e) => call(action: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$UserEngagementFilterInput<TRes>
    implements CopyWith$Input$UserEngagementFilterInput<TRes> {
  _CopyWithStubImpl$Input$UserEngagementFilterInput(this._res);

  TRes _res;

  call({
    List<Input$UserEngagementFilterInput>? and,
    List<Input$UserEngagementFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? actorId,
    Input$UserEngagementTargetTypeOperationFilterInput? actorType,
    Input$StringOperationFilterInput? targetId,
    Input$UserEngagementTargetTypeOperationFilterInput? targetType,
    Input$UserEngagementActionOperationFilterInput? action,
    Input$DateTimeOperationFilterInput? createdAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get actorId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$UserEngagementTargetTypeOperationFilterInput<TRes>
  get actorType =>
      CopyWith$Input$UserEngagementTargetTypeOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get targetId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$UserEngagementTargetTypeOperationFilterInput<TRes>
  get targetType =>
      CopyWith$Input$UserEngagementTargetTypeOperationFilterInput.stub(_res);

  CopyWith$Input$UserEngagementActionOperationFilterInput<TRes> get action =>
      CopyWith$Input$UserEngagementActionOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$UserEngagementRequestInput {
  factory Input$UserEngagementRequestInput({required String targetId}) =>
      Input$UserEngagementRequestInput._({r'targetId': targetId});

  Input$UserEngagementRequestInput._(this._$data);

  factory Input$UserEngagementRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$targetId = data['targetId'];
    result$data['targetId'] = (l$targetId as String);
    return Input$UserEngagementRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get targetId => (_$data['targetId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$targetId = targetId;
    result$data['targetId'] = l$targetId;
    return result$data;
  }

  CopyWith$Input$UserEngagementRequestInput<Input$UserEngagementRequestInput>
  get copyWith => CopyWith$Input$UserEngagementRequestInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserEngagementRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (l$targetId != lOther$targetId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$targetId = targetId;
    return Object.hashAll([l$targetId]);
  }
}

abstract class CopyWith$Input$UserEngagementRequestInput<TRes> {
  factory CopyWith$Input$UserEngagementRequestInput(
    Input$UserEngagementRequestInput instance,
    TRes Function(Input$UserEngagementRequestInput) then,
  ) = _CopyWithImpl$Input$UserEngagementRequestInput;

  factory CopyWith$Input$UserEngagementRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserEngagementRequestInput;

  TRes call({String? targetId});
}

class _CopyWithImpl$Input$UserEngagementRequestInput<TRes>
    implements CopyWith$Input$UserEngagementRequestInput<TRes> {
  _CopyWithImpl$Input$UserEngagementRequestInput(this._instance, this._then);

  final Input$UserEngagementRequestInput _instance;

  final TRes Function(Input$UserEngagementRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? targetId = _undefined}) => _then(
    Input$UserEngagementRequestInput._({
      ..._instance._$data,
      if (targetId != _undefined && targetId != null)
        'targetId': (targetId as String),
    }),
  );
}

class _CopyWithStubImpl$Input$UserEngagementRequestInput<TRes>
    implements CopyWith$Input$UserEngagementRequestInput<TRes> {
  _CopyWithStubImpl$Input$UserEngagementRequestInput(this._res);

  TRes _res;

  call({String? targetId}) => _res;
}

class Input$UserEngagementSortInput {
  factory Input$UserEngagementSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? actorId,
    Enum$SortEnumType? actorType,
    Enum$SortEnumType? targetId,
    Enum$SortEnumType? targetType,
    Enum$SortEnumType? action,
    Enum$SortEnumType? createdAt,
  }) => Input$UserEngagementSortInput._({
    if (id != null) r'id': id,
    if (actorId != null) r'actorId': actorId,
    if (actorType != null) r'actorType': actorType,
    if (targetId != null) r'targetId': targetId,
    if (targetType != null) r'targetType': targetType,
    if (action != null) r'action': action,
    if (createdAt != null) r'createdAt': createdAt,
  });

  Input$UserEngagementSortInput._(this._$data);

  factory Input$UserEngagementSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('actorId')) {
      final l$actorId = data['actorId'];
      result$data['actorId'] = l$actorId == null
          ? null
          : fromJson$Enum$SortEnumType((l$actorId as String));
    }
    if (data.containsKey('actorType')) {
      final l$actorType = data['actorType'];
      result$data['actorType'] = l$actorType == null
          ? null
          : fromJson$Enum$SortEnumType((l$actorType as String));
    }
    if (data.containsKey('targetId')) {
      final l$targetId = data['targetId'];
      result$data['targetId'] = l$targetId == null
          ? null
          : fromJson$Enum$SortEnumType((l$targetId as String));
    }
    if (data.containsKey('targetType')) {
      final l$targetType = data['targetType'];
      result$data['targetType'] = l$targetType == null
          ? null
          : fromJson$Enum$SortEnumType((l$targetType as String));
    }
    if (data.containsKey('action')) {
      final l$action = data['action'];
      result$data['action'] = l$action == null
          ? null
          : fromJson$Enum$SortEnumType((l$action as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    return Input$UserEngagementSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get actorId => (_$data['actorId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get actorType =>
      (_$data['actorType'] as Enum$SortEnumType?);

  Enum$SortEnumType? get targetId => (_$data['targetId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get targetType =>
      (_$data['targetType'] as Enum$SortEnumType?);

  Enum$SortEnumType? get action => (_$data['action'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('actorId')) {
      final l$actorId = actorId;
      result$data['actorId'] = l$actorId == null
          ? null
          : toJson$Enum$SortEnumType(l$actorId);
    }
    if (_$data.containsKey('actorType')) {
      final l$actorType = actorType;
      result$data['actorType'] = l$actorType == null
          ? null
          : toJson$Enum$SortEnumType(l$actorType);
    }
    if (_$data.containsKey('targetId')) {
      final l$targetId = targetId;
      result$data['targetId'] = l$targetId == null
          ? null
          : toJson$Enum$SortEnumType(l$targetId);
    }
    if (_$data.containsKey('targetType')) {
      final l$targetType = targetType;
      result$data['targetType'] = l$targetType == null
          ? null
          : toJson$Enum$SortEnumType(l$targetType);
    }
    if (_$data.containsKey('action')) {
      final l$action = action;
      result$data['action'] = l$action == null
          ? null
          : toJson$Enum$SortEnumType(l$action);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$UserEngagementSortInput<Input$UserEngagementSortInput>
  get copyWith => CopyWith$Input$UserEngagementSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserEngagementSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$actorId = actorId;
    final lOther$actorId = other.actorId;
    if (_$data.containsKey('actorId') != other._$data.containsKey('actorId')) {
      return false;
    }
    if (l$actorId != lOther$actorId) {
      return false;
    }
    final l$actorType = actorType;
    final lOther$actorType = other.actorType;
    if (_$data.containsKey('actorType') !=
        other._$data.containsKey('actorType')) {
      return false;
    }
    if (l$actorType != lOther$actorType) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (_$data.containsKey('targetId') !=
        other._$data.containsKey('targetId')) {
      return false;
    }
    if (l$targetId != lOther$targetId) {
      return false;
    }
    final l$targetType = targetType;
    final lOther$targetType = other.targetType;
    if (_$data.containsKey('targetType') !=
        other._$data.containsKey('targetType')) {
      return false;
    }
    if (l$targetType != lOther$targetType) {
      return false;
    }
    final l$action = action;
    final lOther$action = other.action;
    if (_$data.containsKey('action') != other._$data.containsKey('action')) {
      return false;
    }
    if (l$action != lOther$action) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$actorId = actorId;
    final l$actorType = actorType;
    final l$targetId = targetId;
    final l$targetType = targetType;
    final l$action = action;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('actorId') ? l$actorId : const {},
      _$data.containsKey('actorType') ? l$actorType : const {},
      _$data.containsKey('targetId') ? l$targetId : const {},
      _$data.containsKey('targetType') ? l$targetType : const {},
      _$data.containsKey('action') ? l$action : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserEngagementSortInput<TRes> {
  factory CopyWith$Input$UserEngagementSortInput(
    Input$UserEngagementSortInput instance,
    TRes Function(Input$UserEngagementSortInput) then,
  ) = _CopyWithImpl$Input$UserEngagementSortInput;

  factory CopyWith$Input$UserEngagementSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserEngagementSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? actorId,
    Enum$SortEnumType? actorType,
    Enum$SortEnumType? targetId,
    Enum$SortEnumType? targetType,
    Enum$SortEnumType? action,
    Enum$SortEnumType? createdAt,
  });
}

class _CopyWithImpl$Input$UserEngagementSortInput<TRes>
    implements CopyWith$Input$UserEngagementSortInput<TRes> {
  _CopyWithImpl$Input$UserEngagementSortInput(this._instance, this._then);

  final Input$UserEngagementSortInput _instance;

  final TRes Function(Input$UserEngagementSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? actorId = _undefined,
    Object? actorType = _undefined,
    Object? targetId = _undefined,
    Object? targetType = _undefined,
    Object? action = _undefined,
    Object? createdAt = _undefined,
  }) => _then(
    Input$UserEngagementSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (actorId != _undefined) 'actorId': (actorId as Enum$SortEnumType?),
      if (actorType != _undefined)
        'actorType': (actorType as Enum$SortEnumType?),
      if (targetId != _undefined) 'targetId': (targetId as Enum$SortEnumType?),
      if (targetType != _undefined)
        'targetType': (targetType as Enum$SortEnumType?),
      if (action != _undefined) 'action': (action as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$UserEngagementSortInput<TRes>
    implements CopyWith$Input$UserEngagementSortInput<TRes> {
  _CopyWithStubImpl$Input$UserEngagementSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? actorId,
    Enum$SortEnumType? actorType,
    Enum$SortEnumType? targetId,
    Enum$SortEnumType? targetType,
    Enum$SortEnumType? action,
    Enum$SortEnumType? createdAt,
  }) => _res;
}

class Input$UserEngagementTargetTypeOperationFilterInput {
  factory Input$UserEngagementTargetTypeOperationFilterInput({
    Enum$UserEngagementTargetType? eq,
    Enum$UserEngagementTargetType? neq,
    List<Enum$UserEngagementTargetType>? $in,
    List<Enum$UserEngagementTargetType>? nin,
  }) => Input$UserEngagementTargetTypeOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$UserEngagementTargetTypeOperationFilterInput._(this._$data);

  factory Input$UserEngagementTargetTypeOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$UserEngagementTargetType((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$UserEngagementTargetType((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserEngagementTargetType((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserEngagementTargetType((e as String)))
          .toList();
    }
    return Input$UserEngagementTargetTypeOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserEngagementTargetType? get eq =>
      (_$data['eq'] as Enum$UserEngagementTargetType?);

  Enum$UserEngagementTargetType? get neq =>
      (_$data['neq'] as Enum$UserEngagementTargetType?);

  List<Enum$UserEngagementTargetType>? get $in =>
      (_$data['in'] as List<Enum$UserEngagementTargetType>?);

  List<Enum$UserEngagementTargetType>? get nin =>
      (_$data['nin'] as List<Enum$UserEngagementTargetType>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null
          ? null
          : toJson$Enum$UserEngagementTargetType(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null
          ? null
          : toJson$Enum$UserEngagementTargetType(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in
          ?.map((e) => toJson$Enum$UserEngagementTargetType(e))
          .toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$UserEngagementTargetType(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$UserEngagementTargetTypeOperationFilterInput<
    Input$UserEngagementTargetTypeOperationFilterInput
  >
  get copyWith => CopyWith$Input$UserEngagementTargetTypeOperationFilterInput(
    this,
    (i) => i,
  );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserEngagementTargetTypeOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserEngagementTargetTypeOperationFilterInput<
  TRes
> {
  factory CopyWith$Input$UserEngagementTargetTypeOperationFilterInput(
    Input$UserEngagementTargetTypeOperationFilterInput instance,
    TRes Function(Input$UserEngagementTargetTypeOperationFilterInput) then,
  ) = _CopyWithImpl$Input$UserEngagementTargetTypeOperationFilterInput;

  factory CopyWith$Input$UserEngagementTargetTypeOperationFilterInput.stub(
    TRes res,
  ) = _CopyWithStubImpl$Input$UserEngagementTargetTypeOperationFilterInput;

  TRes call({
    Enum$UserEngagementTargetType? eq,
    Enum$UserEngagementTargetType? neq,
    List<Enum$UserEngagementTargetType>? $in,
    List<Enum$UserEngagementTargetType>? nin,
  });
}

class _CopyWithImpl$Input$UserEngagementTargetTypeOperationFilterInput<TRes>
    implements
        CopyWith$Input$UserEngagementTargetTypeOperationFilterInput<TRes> {
  _CopyWithImpl$Input$UserEngagementTargetTypeOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$UserEngagementTargetTypeOperationFilterInput _instance;

  final TRes Function(Input$UserEngagementTargetTypeOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$UserEngagementTargetTypeOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$UserEngagementTargetType?),
      if (neq != _undefined) 'neq': (neq as Enum$UserEngagementTargetType?),
      if ($in != _undefined)
        'in': ($in as List<Enum$UserEngagementTargetType>?),
      if (nin != _undefined)
        'nin': (nin as List<Enum$UserEngagementTargetType>?),
    }),
  );
}

class _CopyWithStubImpl$Input$UserEngagementTargetTypeOperationFilterInput<TRes>
    implements
        CopyWith$Input$UserEngagementTargetTypeOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$UserEngagementTargetTypeOperationFilterInput(
    this._res,
  );

  TRes _res;

  call({
    Enum$UserEngagementTargetType? eq,
    Enum$UserEngagementTargetType? neq,
    List<Enum$UserEngagementTargetType>? $in,
    List<Enum$UserEngagementTargetType>? nin,
  }) => _res;
}

class Input$UserFilterInput {
  factory Input$UserFilterInput({
    List<Input$UserFilterInput>? and,
    List<Input$UserFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? passwordHash,
    Input$StringOperationFilterInput? fullName,
    Input$UserGenderOperationFilterInput? gender,
    Input$DateTimeOperationFilterInput? birthDate,
    Input$UserRoleOperationFilterInput? role,
    Input$StringOperationFilterInput? phoneNumber,
    Input$UserStatusOperationFilterInput? status,
    Input$BooleanOperationFilterInput? isLinkedWithGoogle,
    Input$StringOperationFilterInput? stripeCustomerId,
    Input$StringOperationFilterInput? stripeAccountId,
    Input$StringOperationFilterInput? fcmToken,
    Input$DateTimeOperationFilterInput? lastLoginAt,
    Input$ListFilterInputTypeOfRestrictionFilterInput? restrictions,
    Input$StringOperationFilterInput? createdBy,
    Input$StringOperationFilterInput? updatedBy,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$UserFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (email != null) r'email': email,
    if (passwordHash != null) r'passwordHash': passwordHash,
    if (fullName != null) r'fullName': fullName,
    if (gender != null) r'gender': gender,
    if (birthDate != null) r'birthDate': birthDate,
    if (role != null) r'role': role,
    if (phoneNumber != null) r'phoneNumber': phoneNumber,
    if (status != null) r'status': status,
    if (isLinkedWithGoogle != null) r'isLinkedWithGoogle': isLinkedWithGoogle,
    if (stripeCustomerId != null) r'stripeCustomerId': stripeCustomerId,
    if (stripeAccountId != null) r'stripeAccountId': stripeAccountId,
    if (fcmToken != null) r'fcmToken': fcmToken,
    if (lastLoginAt != null) r'lastLoginAt': lastLoginAt,
    if (restrictions != null) r'restrictions': restrictions,
    if (createdBy != null) r'createdBy': createdBy,
    if (updatedBy != null) r'updatedBy': updatedBy,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$UserFilterInput._(this._$data);

  factory Input$UserFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$UserFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$UserFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$email as Map<String, dynamic>),
            );
    }
    if (data.containsKey('passwordHash')) {
      final l$passwordHash = data['passwordHash'];
      result$data['passwordHash'] = l$passwordHash == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$passwordHash as Map<String, dynamic>),
            );
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$fullName as Map<String, dynamic>),
            );
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = l$gender == null
          ? null
          : Input$UserGenderOperationFilterInput.fromJson(
              (l$gender as Map<String, dynamic>),
            );
    }
    if (data.containsKey('birthDate')) {
      final l$birthDate = data['birthDate'];
      result$data['birthDate'] = l$birthDate == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$birthDate as Map<String, dynamic>),
            );
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$UserRoleOperationFilterInput.fromJson(
              (l$role as Map<String, dynamic>),
            );
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = l$phoneNumber == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$phoneNumber as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$UserStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isLinkedWithGoogle')) {
      final l$isLinkedWithGoogle = data['isLinkedWithGoogle'];
      result$data['isLinkedWithGoogle'] = l$isLinkedWithGoogle == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isLinkedWithGoogle as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeCustomerId')) {
      final l$stripeCustomerId = data['stripeCustomerId'];
      result$data['stripeCustomerId'] = l$stripeCustomerId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeCustomerId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeAccountId')) {
      final l$stripeAccountId = data['stripeAccountId'];
      result$data['stripeAccountId'] = l$stripeAccountId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeAccountId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('fcmToken')) {
      final l$fcmToken = data['fcmToken'];
      result$data['fcmToken'] = l$fcmToken == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$fcmToken as Map<String, dynamic>),
            );
    }
    if (data.containsKey('lastLoginAt')) {
      final l$lastLoginAt = data['lastLoginAt'];
      result$data['lastLoginAt'] = l$lastLoginAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$lastLoginAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('restrictions')) {
      final l$restrictions = data['restrictions'];
      result$data['restrictions'] = l$restrictions == null
          ? null
          : Input$ListFilterInputTypeOfRestrictionFilterInput.fromJson(
              (l$restrictions as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdBy')) {
      final l$createdBy = data['createdBy'];
      result$data['createdBy'] = l$createdBy == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$createdBy as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedBy')) {
      final l$updatedBy = data['updatedBy'];
      result$data['updatedBy'] = l$updatedBy == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$updatedBy as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$UserFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$UserFilterInput>? get and =>
      (_$data['and'] as List<Input$UserFilterInput>?);

  List<Input$UserFilterInput>? get or =>
      (_$data['or'] as List<Input$UserFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get email =>
      (_$data['email'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get passwordHash =>
      (_$data['passwordHash'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get fullName =>
      (_$data['fullName'] as Input$StringOperationFilterInput?);

  Input$UserGenderOperationFilterInput? get gender =>
      (_$data['gender'] as Input$UserGenderOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get birthDate =>
      (_$data['birthDate'] as Input$DateTimeOperationFilterInput?);

  Input$UserRoleOperationFilterInput? get role =>
      (_$data['role'] as Input$UserRoleOperationFilterInput?);

  Input$StringOperationFilterInput? get phoneNumber =>
      (_$data['phoneNumber'] as Input$StringOperationFilterInput?);

  Input$UserStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$UserStatusOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isLinkedWithGoogle =>
      (_$data['isLinkedWithGoogle'] as Input$BooleanOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeCustomerId =>
      (_$data['stripeCustomerId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeAccountId =>
      (_$data['stripeAccountId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get fcmToken =>
      (_$data['fcmToken'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get lastLoginAt =>
      (_$data['lastLoginAt'] as Input$DateTimeOperationFilterInput?);

  Input$ListFilterInputTypeOfRestrictionFilterInput? get restrictions =>
      (_$data['restrictions']
          as Input$ListFilterInputTypeOfRestrictionFilterInput?);

  Input$StringOperationFilterInput? get createdBy =>
      (_$data['createdBy'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get updatedBy =>
      (_$data['updatedBy'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('passwordHash')) {
      final l$passwordHash = passwordHash;
      result$data['passwordHash'] = l$passwordHash?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender?.toJson();
    }
    if (_$data.containsKey('birthDate')) {
      final l$birthDate = birthDate;
      result$data['birthDate'] = l$birthDate?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] = l$phoneNumber?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('isLinkedWithGoogle')) {
      final l$isLinkedWithGoogle = isLinkedWithGoogle;
      result$data['isLinkedWithGoogle'] = l$isLinkedWithGoogle?.toJson();
    }
    if (_$data.containsKey('stripeCustomerId')) {
      final l$stripeCustomerId = stripeCustomerId;
      result$data['stripeCustomerId'] = l$stripeCustomerId?.toJson();
    }
    if (_$data.containsKey('stripeAccountId')) {
      final l$stripeAccountId = stripeAccountId;
      result$data['stripeAccountId'] = l$stripeAccountId?.toJson();
    }
    if (_$data.containsKey('fcmToken')) {
      final l$fcmToken = fcmToken;
      result$data['fcmToken'] = l$fcmToken?.toJson();
    }
    if (_$data.containsKey('lastLoginAt')) {
      final l$lastLoginAt = lastLoginAt;
      result$data['lastLoginAt'] = l$lastLoginAt?.toJson();
    }
    if (_$data.containsKey('restrictions')) {
      final l$restrictions = restrictions;
      result$data['restrictions'] = l$restrictions?.toJson();
    }
    if (_$data.containsKey('createdBy')) {
      final l$createdBy = createdBy;
      result$data['createdBy'] = l$createdBy?.toJson();
    }
    if (_$data.containsKey('updatedBy')) {
      final l$updatedBy = updatedBy;
      result$data['updatedBy'] = l$updatedBy?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserFilterInput<Input$UserFilterInput> get copyWith =>
      CopyWith$Input$UserFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$passwordHash = passwordHash;
    final lOther$passwordHash = other.passwordHash;
    if (_$data.containsKey('passwordHash') !=
        other._$data.containsKey('passwordHash')) {
      return false;
    }
    if (l$passwordHash != lOther$passwordHash) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$birthDate = birthDate;
    final lOther$birthDate = other.birthDate;
    if (_$data.containsKey('birthDate') !=
        other._$data.containsKey('birthDate')) {
      return false;
    }
    if (l$birthDate != lOther$birthDate) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$isLinkedWithGoogle = isLinkedWithGoogle;
    final lOther$isLinkedWithGoogle = other.isLinkedWithGoogle;
    if (_$data.containsKey('isLinkedWithGoogle') !=
        other._$data.containsKey('isLinkedWithGoogle')) {
      return false;
    }
    if (l$isLinkedWithGoogle != lOther$isLinkedWithGoogle) {
      return false;
    }
    final l$stripeCustomerId = stripeCustomerId;
    final lOther$stripeCustomerId = other.stripeCustomerId;
    if (_$data.containsKey('stripeCustomerId') !=
        other._$data.containsKey('stripeCustomerId')) {
      return false;
    }
    if (l$stripeCustomerId != lOther$stripeCustomerId) {
      return false;
    }
    final l$stripeAccountId = stripeAccountId;
    final lOther$stripeAccountId = other.stripeAccountId;
    if (_$data.containsKey('stripeAccountId') !=
        other._$data.containsKey('stripeAccountId')) {
      return false;
    }
    if (l$stripeAccountId != lOther$stripeAccountId) {
      return false;
    }
    final l$fcmToken = fcmToken;
    final lOther$fcmToken = other.fcmToken;
    if (_$data.containsKey('fcmToken') !=
        other._$data.containsKey('fcmToken')) {
      return false;
    }
    if (l$fcmToken != lOther$fcmToken) {
      return false;
    }
    final l$lastLoginAt = lastLoginAt;
    final lOther$lastLoginAt = other.lastLoginAt;
    if (_$data.containsKey('lastLoginAt') !=
        other._$data.containsKey('lastLoginAt')) {
      return false;
    }
    if (l$lastLoginAt != lOther$lastLoginAt) {
      return false;
    }
    final l$restrictions = restrictions;
    final lOther$restrictions = other.restrictions;
    if (_$data.containsKey('restrictions') !=
        other._$data.containsKey('restrictions')) {
      return false;
    }
    if (l$restrictions != lOther$restrictions) {
      return false;
    }
    final l$createdBy = createdBy;
    final lOther$createdBy = other.createdBy;
    if (_$data.containsKey('createdBy') !=
        other._$data.containsKey('createdBy')) {
      return false;
    }
    if (l$createdBy != lOther$createdBy) {
      return false;
    }
    final l$updatedBy = updatedBy;
    final lOther$updatedBy = other.updatedBy;
    if (_$data.containsKey('updatedBy') !=
        other._$data.containsKey('updatedBy')) {
      return false;
    }
    if (l$updatedBy != lOther$updatedBy) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$email = email;
    final l$passwordHash = passwordHash;
    final l$fullName = fullName;
    final l$gender = gender;
    final l$birthDate = birthDate;
    final l$role = role;
    final l$phoneNumber = phoneNumber;
    final l$status = status;
    final l$isLinkedWithGoogle = isLinkedWithGoogle;
    final l$stripeCustomerId = stripeCustomerId;
    final l$stripeAccountId = stripeAccountId;
    final l$fcmToken = fcmToken;
    final l$lastLoginAt = lastLoginAt;
    final l$restrictions = restrictions;
    final l$createdBy = createdBy;
    final l$updatedBy = updatedBy;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('passwordHash') ? l$passwordHash : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('birthDate') ? l$birthDate : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('isLinkedWithGoogle')
          ? l$isLinkedWithGoogle
          : const {},
      _$data.containsKey('stripeCustomerId') ? l$stripeCustomerId : const {},
      _$data.containsKey('stripeAccountId') ? l$stripeAccountId : const {},
      _$data.containsKey('fcmToken') ? l$fcmToken : const {},
      _$data.containsKey('lastLoginAt') ? l$lastLoginAt : const {},
      _$data.containsKey('restrictions') ? l$restrictions : const {},
      _$data.containsKey('createdBy') ? l$createdBy : const {},
      _$data.containsKey('updatedBy') ? l$updatedBy : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserFilterInput<TRes> {
  factory CopyWith$Input$UserFilterInput(
    Input$UserFilterInput instance,
    TRes Function(Input$UserFilterInput) then,
  ) = _CopyWithImpl$Input$UserFilterInput;

  factory CopyWith$Input$UserFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserFilterInput;

  TRes call({
    List<Input$UserFilterInput>? and,
    List<Input$UserFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? passwordHash,
    Input$StringOperationFilterInput? fullName,
    Input$UserGenderOperationFilterInput? gender,
    Input$DateTimeOperationFilterInput? birthDate,
    Input$UserRoleOperationFilterInput? role,
    Input$StringOperationFilterInput? phoneNumber,
    Input$UserStatusOperationFilterInput? status,
    Input$BooleanOperationFilterInput? isLinkedWithGoogle,
    Input$StringOperationFilterInput? stripeCustomerId,
    Input$StringOperationFilterInput? stripeAccountId,
    Input$StringOperationFilterInput? fcmToken,
    Input$DateTimeOperationFilterInput? lastLoginAt,
    Input$ListFilterInputTypeOfRestrictionFilterInput? restrictions,
    Input$StringOperationFilterInput? createdBy,
    Input$StringOperationFilterInput? updatedBy,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$UserFilterInput>? Function(
      Iterable<CopyWith$Input$UserFilterInput<Input$UserFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$UserFilterInput>? Function(
      Iterable<CopyWith$Input$UserFilterInput<Input$UserFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get email;
  CopyWith$Input$StringOperationFilterInput<TRes> get passwordHash;
  CopyWith$Input$StringOperationFilterInput<TRes> get fullName;
  CopyWith$Input$UserGenderOperationFilterInput<TRes> get gender;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get birthDate;
  CopyWith$Input$UserRoleOperationFilterInput<TRes> get role;
  CopyWith$Input$StringOperationFilterInput<TRes> get phoneNumber;
  CopyWith$Input$UserStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isLinkedWithGoogle;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeCustomerId;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeAccountId;
  CopyWith$Input$StringOperationFilterInput<TRes> get fcmToken;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get lastLoginAt;
  CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput<TRes>
  get restrictions;
  CopyWith$Input$StringOperationFilterInput<TRes> get createdBy;
  CopyWith$Input$StringOperationFilterInput<TRes> get updatedBy;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$UserFilterInput<TRes>
    implements CopyWith$Input$UserFilterInput<TRes> {
  _CopyWithImpl$Input$UserFilterInput(this._instance, this._then);

  final Input$UserFilterInput _instance;

  final TRes Function(Input$UserFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? email = _undefined,
    Object? passwordHash = _undefined,
    Object? fullName = _undefined,
    Object? gender = _undefined,
    Object? birthDate = _undefined,
    Object? role = _undefined,
    Object? phoneNumber = _undefined,
    Object? status = _undefined,
    Object? isLinkedWithGoogle = _undefined,
    Object? stripeCustomerId = _undefined,
    Object? stripeAccountId = _undefined,
    Object? fcmToken = _undefined,
    Object? lastLoginAt = _undefined,
    Object? restrictions = _undefined,
    Object? createdBy = _undefined,
    Object? updatedBy = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$UserFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$UserFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$UserFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (email != _undefined)
        'email': (email as Input$StringOperationFilterInput?),
      if (passwordHash != _undefined)
        'passwordHash': (passwordHash as Input$StringOperationFilterInput?),
      if (fullName != _undefined)
        'fullName': (fullName as Input$StringOperationFilterInput?),
      if (gender != _undefined)
        'gender': (gender as Input$UserGenderOperationFilterInput?),
      if (birthDate != _undefined)
        'birthDate': (birthDate as Input$DateTimeOperationFilterInput?),
      if (role != _undefined)
        'role': (role as Input$UserRoleOperationFilterInput?),
      if (phoneNumber != _undefined)
        'phoneNumber': (phoneNumber as Input$StringOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$UserStatusOperationFilterInput?),
      if (isLinkedWithGoogle != _undefined)
        'isLinkedWithGoogle':
            (isLinkedWithGoogle as Input$BooleanOperationFilterInput?),
      if (stripeCustomerId != _undefined)
        'stripeCustomerId':
            (stripeCustomerId as Input$StringOperationFilterInput?),
      if (stripeAccountId != _undefined)
        'stripeAccountId':
            (stripeAccountId as Input$StringOperationFilterInput?),
      if (fcmToken != _undefined)
        'fcmToken': (fcmToken as Input$StringOperationFilterInput?),
      if (lastLoginAt != _undefined)
        'lastLoginAt': (lastLoginAt as Input$DateTimeOperationFilterInput?),
      if (restrictions != _undefined)
        'restrictions':
            (restrictions
                as Input$ListFilterInputTypeOfRestrictionFilterInput?),
      if (createdBy != _undefined)
        'createdBy': (createdBy as Input$StringOperationFilterInput?),
      if (updatedBy != _undefined)
        'updatedBy': (updatedBy as Input$StringOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$UserFilterInput>? Function(
      Iterable<CopyWith$Input$UserFilterInput<Input$UserFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$UserFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$UserFilterInput>? Function(
      Iterable<CopyWith$Input$UserFilterInput<Input$UserFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$UserFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$email,
            (e) => call(email: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get passwordHash {
    final local$passwordHash = _instance.passwordHash;
    return local$passwordHash == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$passwordHash,
            (e) => call(passwordHash: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$fullName,
            (e) => call(fullName: e),
          );
  }

  CopyWith$Input$UserGenderOperationFilterInput<TRes> get gender {
    final local$gender = _instance.gender;
    return local$gender == null
        ? CopyWith$Input$UserGenderOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserGenderOperationFilterInput(
            local$gender,
            (e) => call(gender: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get birthDate {
    final local$birthDate = _instance.birthDate;
    return local$birthDate == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$birthDate,
            (e) => call(birthDate: e),
          );
  }

  CopyWith$Input$UserRoleOperationFilterInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$UserRoleOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserRoleOperationFilterInput(
            local$role,
            (e) => call(role: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get phoneNumber {
    final local$phoneNumber = _instance.phoneNumber;
    return local$phoneNumber == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$phoneNumber,
            (e) => call(phoneNumber: e),
          );
  }

  CopyWith$Input$UserStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$UserStatusOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$UserStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isLinkedWithGoogle {
    final local$isLinkedWithGoogle = _instance.isLinkedWithGoogle;
    return local$isLinkedWithGoogle == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isLinkedWithGoogle,
            (e) => call(isLinkedWithGoogle: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeCustomerId {
    final local$stripeCustomerId = _instance.stripeCustomerId;
    return local$stripeCustomerId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeCustomerId,
            (e) => call(stripeCustomerId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeAccountId {
    final local$stripeAccountId = _instance.stripeAccountId;
    return local$stripeAccountId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeAccountId,
            (e) => call(stripeAccountId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get fcmToken {
    final local$fcmToken = _instance.fcmToken;
    return local$fcmToken == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$fcmToken,
            (e) => call(fcmToken: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get lastLoginAt {
    final local$lastLoginAt = _instance.lastLoginAt;
    return local$lastLoginAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$lastLoginAt,
            (e) => call(lastLoginAt: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput<TRes>
  get restrictions {
    final local$restrictions = _instance.restrictions;
    return local$restrictions == null
        ? CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput(
            local$restrictions,
            (e) => call(restrictions: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get createdBy {
    final local$createdBy = _instance.createdBy;
    return local$createdBy == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$createdBy,
            (e) => call(createdBy: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get updatedBy {
    final local$updatedBy = _instance.updatedBy;
    return local$updatedBy == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$updatedBy,
            (e) => call(updatedBy: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$UserFilterInput<TRes>
    implements CopyWith$Input$UserFilterInput<TRes> {
  _CopyWithStubImpl$Input$UserFilterInput(this._res);

  TRes _res;

  call({
    List<Input$UserFilterInput>? and,
    List<Input$UserFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? email,
    Input$StringOperationFilterInput? passwordHash,
    Input$StringOperationFilterInput? fullName,
    Input$UserGenderOperationFilterInput? gender,
    Input$DateTimeOperationFilterInput? birthDate,
    Input$UserRoleOperationFilterInput? role,
    Input$StringOperationFilterInput? phoneNumber,
    Input$UserStatusOperationFilterInput? status,
    Input$BooleanOperationFilterInput? isLinkedWithGoogle,
    Input$StringOperationFilterInput? stripeCustomerId,
    Input$StringOperationFilterInput? stripeAccountId,
    Input$StringOperationFilterInput? fcmToken,
    Input$DateTimeOperationFilterInput? lastLoginAt,
    Input$ListFilterInputTypeOfRestrictionFilterInput? restrictions,
    Input$StringOperationFilterInput? createdBy,
    Input$StringOperationFilterInput? updatedBy,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get email =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get passwordHash =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get fullName =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$UserGenderOperationFilterInput<TRes> get gender =>
      CopyWith$Input$UserGenderOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get birthDate =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$UserRoleOperationFilterInput<TRes> get role =>
      CopyWith$Input$UserRoleOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get phoneNumber =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$UserStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$UserStatusOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isLinkedWithGoogle =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeCustomerId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeAccountId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get fcmToken =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get lastLoginAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput<TRes>
  get restrictions =>
      CopyWith$Input$ListFilterInputTypeOfRestrictionFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get createdBy =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get updatedBy =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$UserGenderOperationFilterInput {
  factory Input$UserGenderOperationFilterInput({
    Enum$UserGender? eq,
    Enum$UserGender? neq,
    List<Enum$UserGender>? $in,
    List<Enum$UserGender>? nin,
  }) => Input$UserGenderOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$UserGenderOperationFilterInput._(this._$data);

  factory Input$UserGenderOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$UserGender((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$UserGender((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserGender((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserGender((e as String)))
          .toList();
    }
    return Input$UserGenderOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserGender? get eq => (_$data['eq'] as Enum$UserGender?);

  Enum$UserGender? get neq => (_$data['neq'] as Enum$UserGender?);

  List<Enum$UserGender>? get $in => (_$data['in'] as List<Enum$UserGender>?);

  List<Enum$UserGender>? get nin => (_$data['nin'] as List<Enum$UserGender>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$UserGender(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$UserGender(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$UserGender(e)).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$UserGender(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$UserGenderOperationFilterInput<
    Input$UserGenderOperationFilterInput
  >
  get copyWith => CopyWith$Input$UserGenderOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserGenderOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserGenderOperationFilterInput<TRes> {
  factory CopyWith$Input$UserGenderOperationFilterInput(
    Input$UserGenderOperationFilterInput instance,
    TRes Function(Input$UserGenderOperationFilterInput) then,
  ) = _CopyWithImpl$Input$UserGenderOperationFilterInput;

  factory CopyWith$Input$UserGenderOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserGenderOperationFilterInput;

  TRes call({
    Enum$UserGender? eq,
    Enum$UserGender? neq,
    List<Enum$UserGender>? $in,
    List<Enum$UserGender>? nin,
  });
}

class _CopyWithImpl$Input$UserGenderOperationFilterInput<TRes>
    implements CopyWith$Input$UserGenderOperationFilterInput<TRes> {
  _CopyWithImpl$Input$UserGenderOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$UserGenderOperationFilterInput _instance;

  final TRes Function(Input$UserGenderOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$UserGenderOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$UserGender?),
      if (neq != _undefined) 'neq': (neq as Enum$UserGender?),
      if ($in != _undefined) 'in': ($in as List<Enum$UserGender>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$UserGender>?),
    }),
  );
}

class _CopyWithStubImpl$Input$UserGenderOperationFilterInput<TRes>
    implements CopyWith$Input$UserGenderOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$UserGenderOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$UserGender? eq,
    Enum$UserGender? neq,
    List<Enum$UserGender>? $in,
    List<Enum$UserGender>? nin,
  }) => _res;
}

class Input$UserRoleOperationFilterInput {
  factory Input$UserRoleOperationFilterInput({
    Enum$UserRole? eq,
    Enum$UserRole? neq,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? nin,
  }) => Input$UserRoleOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$UserRoleOperationFilterInput._(this._$data);

  factory Input$UserRoleOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$UserRole((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$UserRole((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserRole((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserRole((e as String)))
          .toList();
    }
    return Input$UserRoleOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserRole? get eq => (_$data['eq'] as Enum$UserRole?);

  Enum$UserRole? get neq => (_$data['neq'] as Enum$UserRole?);

  List<Enum$UserRole>? get $in => (_$data['in'] as List<Enum$UserRole>?);

  List<Enum$UserRole>? get nin => (_$data['nin'] as List<Enum$UserRole>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$UserRole(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$UserRole(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$UserRole(e)).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin?.map((e) => toJson$Enum$UserRole(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$UserRoleOperationFilterInput<
    Input$UserRoleOperationFilterInput
  >
  get copyWith => CopyWith$Input$UserRoleOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserRoleOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserRoleOperationFilterInput<TRes> {
  factory CopyWith$Input$UserRoleOperationFilterInput(
    Input$UserRoleOperationFilterInput instance,
    TRes Function(Input$UserRoleOperationFilterInput) then,
  ) = _CopyWithImpl$Input$UserRoleOperationFilterInput;

  factory CopyWith$Input$UserRoleOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserRoleOperationFilterInput;

  TRes call({
    Enum$UserRole? eq,
    Enum$UserRole? neq,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? nin,
  });
}

class _CopyWithImpl$Input$UserRoleOperationFilterInput<TRes>
    implements CopyWith$Input$UserRoleOperationFilterInput<TRes> {
  _CopyWithImpl$Input$UserRoleOperationFilterInput(this._instance, this._then);

  final Input$UserRoleOperationFilterInput _instance;

  final TRes Function(Input$UserRoleOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$UserRoleOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$UserRole?),
      if (neq != _undefined) 'neq': (neq as Enum$UserRole?),
      if ($in != _undefined) 'in': ($in as List<Enum$UserRole>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$UserRole>?),
    }),
  );
}

class _CopyWithStubImpl$Input$UserRoleOperationFilterInput<TRes>
    implements CopyWith$Input$UserRoleOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$UserRoleOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$UserRole? eq,
    Enum$UserRole? neq,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? nin,
  }) => _res;
}

class Input$UserSortInput {
  factory Input$UserSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? email,
    Enum$SortEnumType? passwordHash,
    Enum$SortEnumType? fullName,
    Enum$SortEnumType? gender,
    Enum$SortEnumType? birthDate,
    Enum$SortEnumType? role,
    Enum$SortEnumType? phoneNumber,
    Enum$SortEnumType? status,
    Enum$SortEnumType? isLinkedWithGoogle,
    Enum$SortEnumType? stripeCustomerId,
    Enum$SortEnumType? stripeAccountId,
    Enum$SortEnumType? fcmToken,
    Enum$SortEnumType? lastLoginAt,
    Enum$SortEnumType? createdBy,
    Enum$SortEnumType? updatedBy,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$UserSortInput._({
    if (id != null) r'id': id,
    if (email != null) r'email': email,
    if (passwordHash != null) r'passwordHash': passwordHash,
    if (fullName != null) r'fullName': fullName,
    if (gender != null) r'gender': gender,
    if (birthDate != null) r'birthDate': birthDate,
    if (role != null) r'role': role,
    if (phoneNumber != null) r'phoneNumber': phoneNumber,
    if (status != null) r'status': status,
    if (isLinkedWithGoogle != null) r'isLinkedWithGoogle': isLinkedWithGoogle,
    if (stripeCustomerId != null) r'stripeCustomerId': stripeCustomerId,
    if (stripeAccountId != null) r'stripeAccountId': stripeAccountId,
    if (fcmToken != null) r'fcmToken': fcmToken,
    if (lastLoginAt != null) r'lastLoginAt': lastLoginAt,
    if (createdBy != null) r'createdBy': createdBy,
    if (updatedBy != null) r'updatedBy': updatedBy,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$UserSortInput._(this._$data);

  factory Input$UserSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : fromJson$Enum$SortEnumType((l$email as String));
    }
    if (data.containsKey('passwordHash')) {
      final l$passwordHash = data['passwordHash'];
      result$data['passwordHash'] = l$passwordHash == null
          ? null
          : fromJson$Enum$SortEnumType((l$passwordHash as String));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : fromJson$Enum$SortEnumType((l$fullName as String));
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = l$gender == null
          ? null
          : fromJson$Enum$SortEnumType((l$gender as String));
    }
    if (data.containsKey('birthDate')) {
      final l$birthDate = data['birthDate'];
      result$data['birthDate'] = l$birthDate == null
          ? null
          : fromJson$Enum$SortEnumType((l$birthDate as String));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : fromJson$Enum$SortEnumType((l$role as String));
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = l$phoneNumber == null
          ? null
          : fromJson$Enum$SortEnumType((l$phoneNumber as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('isLinkedWithGoogle')) {
      final l$isLinkedWithGoogle = data['isLinkedWithGoogle'];
      result$data['isLinkedWithGoogle'] = l$isLinkedWithGoogle == null
          ? null
          : fromJson$Enum$SortEnumType((l$isLinkedWithGoogle as String));
    }
    if (data.containsKey('stripeCustomerId')) {
      final l$stripeCustomerId = data['stripeCustomerId'];
      result$data['stripeCustomerId'] = l$stripeCustomerId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeCustomerId as String));
    }
    if (data.containsKey('stripeAccountId')) {
      final l$stripeAccountId = data['stripeAccountId'];
      result$data['stripeAccountId'] = l$stripeAccountId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeAccountId as String));
    }
    if (data.containsKey('fcmToken')) {
      final l$fcmToken = data['fcmToken'];
      result$data['fcmToken'] = l$fcmToken == null
          ? null
          : fromJson$Enum$SortEnumType((l$fcmToken as String));
    }
    if (data.containsKey('lastLoginAt')) {
      final l$lastLoginAt = data['lastLoginAt'];
      result$data['lastLoginAt'] = l$lastLoginAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$lastLoginAt as String));
    }
    if (data.containsKey('createdBy')) {
      final l$createdBy = data['createdBy'];
      result$data['createdBy'] = l$createdBy == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdBy as String));
    }
    if (data.containsKey('updatedBy')) {
      final l$updatedBy = data['updatedBy'];
      result$data['updatedBy'] = l$updatedBy == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedBy as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$UserSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get email => (_$data['email'] as Enum$SortEnumType?);

  Enum$SortEnumType? get passwordHash =>
      (_$data['passwordHash'] as Enum$SortEnumType?);

  Enum$SortEnumType? get fullName => (_$data['fullName'] as Enum$SortEnumType?);

  Enum$SortEnumType? get gender => (_$data['gender'] as Enum$SortEnumType?);

  Enum$SortEnumType? get birthDate =>
      (_$data['birthDate'] as Enum$SortEnumType?);

  Enum$SortEnumType? get role => (_$data['role'] as Enum$SortEnumType?);

  Enum$SortEnumType? get phoneNumber =>
      (_$data['phoneNumber'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isLinkedWithGoogle =>
      (_$data['isLinkedWithGoogle'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeCustomerId =>
      (_$data['stripeCustomerId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeAccountId =>
      (_$data['stripeAccountId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get fcmToken => (_$data['fcmToken'] as Enum$SortEnumType?);

  Enum$SortEnumType? get lastLoginAt =>
      (_$data['lastLoginAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdBy =>
      (_$data['createdBy'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedBy =>
      (_$data['updatedBy'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email == null
          ? null
          : toJson$Enum$SortEnumType(l$email);
    }
    if (_$data.containsKey('passwordHash')) {
      final l$passwordHash = passwordHash;
      result$data['passwordHash'] = l$passwordHash == null
          ? null
          : toJson$Enum$SortEnumType(l$passwordHash);
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName == null
          ? null
          : toJson$Enum$SortEnumType(l$fullName);
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender == null
          ? null
          : toJson$Enum$SortEnumType(l$gender);
    }
    if (_$data.containsKey('birthDate')) {
      final l$birthDate = birthDate;
      result$data['birthDate'] = l$birthDate == null
          ? null
          : toJson$Enum$SortEnumType(l$birthDate);
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role == null
          ? null
          : toJson$Enum$SortEnumType(l$role);
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] = l$phoneNumber == null
          ? null
          : toJson$Enum$SortEnumType(l$phoneNumber);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('isLinkedWithGoogle')) {
      final l$isLinkedWithGoogle = isLinkedWithGoogle;
      result$data['isLinkedWithGoogle'] = l$isLinkedWithGoogle == null
          ? null
          : toJson$Enum$SortEnumType(l$isLinkedWithGoogle);
    }
    if (_$data.containsKey('stripeCustomerId')) {
      final l$stripeCustomerId = stripeCustomerId;
      result$data['stripeCustomerId'] = l$stripeCustomerId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeCustomerId);
    }
    if (_$data.containsKey('stripeAccountId')) {
      final l$stripeAccountId = stripeAccountId;
      result$data['stripeAccountId'] = l$stripeAccountId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeAccountId);
    }
    if (_$data.containsKey('fcmToken')) {
      final l$fcmToken = fcmToken;
      result$data['fcmToken'] = l$fcmToken == null
          ? null
          : toJson$Enum$SortEnumType(l$fcmToken);
    }
    if (_$data.containsKey('lastLoginAt')) {
      final l$lastLoginAt = lastLoginAt;
      result$data['lastLoginAt'] = l$lastLoginAt == null
          ? null
          : toJson$Enum$SortEnumType(l$lastLoginAt);
    }
    if (_$data.containsKey('createdBy')) {
      final l$createdBy = createdBy;
      result$data['createdBy'] = l$createdBy == null
          ? null
          : toJson$Enum$SortEnumType(l$createdBy);
    }
    if (_$data.containsKey('updatedBy')) {
      final l$updatedBy = updatedBy;
      result$data['updatedBy'] = l$updatedBy == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedBy);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$UserSortInput<Input$UserSortInput> get copyWith =>
      CopyWith$Input$UserSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$passwordHash = passwordHash;
    final lOther$passwordHash = other.passwordHash;
    if (_$data.containsKey('passwordHash') !=
        other._$data.containsKey('passwordHash')) {
      return false;
    }
    if (l$passwordHash != lOther$passwordHash) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$birthDate = birthDate;
    final lOther$birthDate = other.birthDate;
    if (_$data.containsKey('birthDate') !=
        other._$data.containsKey('birthDate')) {
      return false;
    }
    if (l$birthDate != lOther$birthDate) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$isLinkedWithGoogle = isLinkedWithGoogle;
    final lOther$isLinkedWithGoogle = other.isLinkedWithGoogle;
    if (_$data.containsKey('isLinkedWithGoogle') !=
        other._$data.containsKey('isLinkedWithGoogle')) {
      return false;
    }
    if (l$isLinkedWithGoogle != lOther$isLinkedWithGoogle) {
      return false;
    }
    final l$stripeCustomerId = stripeCustomerId;
    final lOther$stripeCustomerId = other.stripeCustomerId;
    if (_$data.containsKey('stripeCustomerId') !=
        other._$data.containsKey('stripeCustomerId')) {
      return false;
    }
    if (l$stripeCustomerId != lOther$stripeCustomerId) {
      return false;
    }
    final l$stripeAccountId = stripeAccountId;
    final lOther$stripeAccountId = other.stripeAccountId;
    if (_$data.containsKey('stripeAccountId') !=
        other._$data.containsKey('stripeAccountId')) {
      return false;
    }
    if (l$stripeAccountId != lOther$stripeAccountId) {
      return false;
    }
    final l$fcmToken = fcmToken;
    final lOther$fcmToken = other.fcmToken;
    if (_$data.containsKey('fcmToken') !=
        other._$data.containsKey('fcmToken')) {
      return false;
    }
    if (l$fcmToken != lOther$fcmToken) {
      return false;
    }
    final l$lastLoginAt = lastLoginAt;
    final lOther$lastLoginAt = other.lastLoginAt;
    if (_$data.containsKey('lastLoginAt') !=
        other._$data.containsKey('lastLoginAt')) {
      return false;
    }
    if (l$lastLoginAt != lOther$lastLoginAt) {
      return false;
    }
    final l$createdBy = createdBy;
    final lOther$createdBy = other.createdBy;
    if (_$data.containsKey('createdBy') !=
        other._$data.containsKey('createdBy')) {
      return false;
    }
    if (l$createdBy != lOther$createdBy) {
      return false;
    }
    final l$updatedBy = updatedBy;
    final lOther$updatedBy = other.updatedBy;
    if (_$data.containsKey('updatedBy') !=
        other._$data.containsKey('updatedBy')) {
      return false;
    }
    if (l$updatedBy != lOther$updatedBy) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$passwordHash = passwordHash;
    final l$fullName = fullName;
    final l$gender = gender;
    final l$birthDate = birthDate;
    final l$role = role;
    final l$phoneNumber = phoneNumber;
    final l$status = status;
    final l$isLinkedWithGoogle = isLinkedWithGoogle;
    final l$stripeCustomerId = stripeCustomerId;
    final l$stripeAccountId = stripeAccountId;
    final l$fcmToken = fcmToken;
    final l$lastLoginAt = lastLoginAt;
    final l$createdBy = createdBy;
    final l$updatedBy = updatedBy;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('passwordHash') ? l$passwordHash : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('birthDate') ? l$birthDate : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('isLinkedWithGoogle')
          ? l$isLinkedWithGoogle
          : const {},
      _$data.containsKey('stripeCustomerId') ? l$stripeCustomerId : const {},
      _$data.containsKey('stripeAccountId') ? l$stripeAccountId : const {},
      _$data.containsKey('fcmToken') ? l$fcmToken : const {},
      _$data.containsKey('lastLoginAt') ? l$lastLoginAt : const {},
      _$data.containsKey('createdBy') ? l$createdBy : const {},
      _$data.containsKey('updatedBy') ? l$updatedBy : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserSortInput<TRes> {
  factory CopyWith$Input$UserSortInput(
    Input$UserSortInput instance,
    TRes Function(Input$UserSortInput) then,
  ) = _CopyWithImpl$Input$UserSortInput;

  factory CopyWith$Input$UserSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? email,
    Enum$SortEnumType? passwordHash,
    Enum$SortEnumType? fullName,
    Enum$SortEnumType? gender,
    Enum$SortEnumType? birthDate,
    Enum$SortEnumType? role,
    Enum$SortEnumType? phoneNumber,
    Enum$SortEnumType? status,
    Enum$SortEnumType? isLinkedWithGoogle,
    Enum$SortEnumType? stripeCustomerId,
    Enum$SortEnumType? stripeAccountId,
    Enum$SortEnumType? fcmToken,
    Enum$SortEnumType? lastLoginAt,
    Enum$SortEnumType? createdBy,
    Enum$SortEnumType? updatedBy,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$UserSortInput<TRes>
    implements CopyWith$Input$UserSortInput<TRes> {
  _CopyWithImpl$Input$UserSortInput(this._instance, this._then);

  final Input$UserSortInput _instance;

  final TRes Function(Input$UserSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? email = _undefined,
    Object? passwordHash = _undefined,
    Object? fullName = _undefined,
    Object? gender = _undefined,
    Object? birthDate = _undefined,
    Object? role = _undefined,
    Object? phoneNumber = _undefined,
    Object? status = _undefined,
    Object? isLinkedWithGoogle = _undefined,
    Object? stripeCustomerId = _undefined,
    Object? stripeAccountId = _undefined,
    Object? fcmToken = _undefined,
    Object? lastLoginAt = _undefined,
    Object? createdBy = _undefined,
    Object? updatedBy = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$UserSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (email != _undefined) 'email': (email as Enum$SortEnumType?),
      if (passwordHash != _undefined)
        'passwordHash': (passwordHash as Enum$SortEnumType?),
      if (fullName != _undefined) 'fullName': (fullName as Enum$SortEnumType?),
      if (gender != _undefined) 'gender': (gender as Enum$SortEnumType?),
      if (birthDate != _undefined)
        'birthDate': (birthDate as Enum$SortEnumType?),
      if (role != _undefined) 'role': (role as Enum$SortEnumType?),
      if (phoneNumber != _undefined)
        'phoneNumber': (phoneNumber as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (isLinkedWithGoogle != _undefined)
        'isLinkedWithGoogle': (isLinkedWithGoogle as Enum$SortEnumType?),
      if (stripeCustomerId != _undefined)
        'stripeCustomerId': (stripeCustomerId as Enum$SortEnumType?),
      if (stripeAccountId != _undefined)
        'stripeAccountId': (stripeAccountId as Enum$SortEnumType?),
      if (fcmToken != _undefined) 'fcmToken': (fcmToken as Enum$SortEnumType?),
      if (lastLoginAt != _undefined)
        'lastLoginAt': (lastLoginAt as Enum$SortEnumType?),
      if (createdBy != _undefined)
        'createdBy': (createdBy as Enum$SortEnumType?),
      if (updatedBy != _undefined)
        'updatedBy': (updatedBy as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$UserSortInput<TRes>
    implements CopyWith$Input$UserSortInput<TRes> {
  _CopyWithStubImpl$Input$UserSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? email,
    Enum$SortEnumType? passwordHash,
    Enum$SortEnumType? fullName,
    Enum$SortEnumType? gender,
    Enum$SortEnumType? birthDate,
    Enum$SortEnumType? role,
    Enum$SortEnumType? phoneNumber,
    Enum$SortEnumType? status,
    Enum$SortEnumType? isLinkedWithGoogle,
    Enum$SortEnumType? stripeCustomerId,
    Enum$SortEnumType? stripeAccountId,
    Enum$SortEnumType? fcmToken,
    Enum$SortEnumType? lastLoginAt,
    Enum$SortEnumType? createdBy,
    Enum$SortEnumType? updatedBy,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$UserStatusOperationFilterInput {
  factory Input$UserStatusOperationFilterInput({
    Enum$UserStatus? eq,
    Enum$UserStatus? neq,
    List<Enum$UserStatus>? $in,
    List<Enum$UserStatus>? nin,
  }) => Input$UserStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$UserStatusOperationFilterInput._(this._$data);

  factory Input$UserStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$UserStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$UserStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserStatus((e as String)))
          .toList();
    }
    return Input$UserStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserStatus? get eq => (_$data['eq'] as Enum$UserStatus?);

  Enum$UserStatus? get neq => (_$data['neq'] as Enum$UserStatus?);

  List<Enum$UserStatus>? get $in => (_$data['in'] as List<Enum$UserStatus>?);

  List<Enum$UserStatus>? get nin => (_$data['nin'] as List<Enum$UserStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$UserStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$UserStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$UserStatus(e)).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$UserStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$UserStatusOperationFilterInput<
    Input$UserStatusOperationFilterInput
  >
  get copyWith => CopyWith$Input$UserStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$UserStatusOperationFilterInput(
    Input$UserStatusOperationFilterInput instance,
    TRes Function(Input$UserStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$UserStatusOperationFilterInput;

  factory CopyWith$Input$UserStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserStatusOperationFilterInput;

  TRes call({
    Enum$UserStatus? eq,
    Enum$UserStatus? neq,
    List<Enum$UserStatus>? $in,
    List<Enum$UserStatus>? nin,
  });
}

class _CopyWithImpl$Input$UserStatusOperationFilterInput<TRes>
    implements CopyWith$Input$UserStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$UserStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$UserStatusOperationFilterInput _instance;

  final TRes Function(Input$UserStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$UserStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$UserStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$UserStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$UserStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$UserStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$UserStatusOperationFilterInput<TRes>
    implements CopyWith$Input$UserStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$UserStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$UserStatus? eq,
    Enum$UserStatus? neq,
    List<Enum$UserStatus>? $in,
    List<Enum$UserStatus>? nin,
  }) => _res;
}

class Input$UserSubscriptionFilterInput {
  factory Input$UserSubscriptionFilterInput({
    List<Input$UserSubscriptionFilterInput>? and,
    List<Input$UserSubscriptionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? subscriptionId,
    Input$StringOperationFilterInput? stripeSubscriptionId,
    Input$DateTimeOperationFilterInput? periodStart,
    Input$DateTimeOperationFilterInput? periodEnd,
    Input$BooleanOperationFilterInput? autoRenew,
    Input$BooleanOperationFilterInput? cancelAtEndOfPeriod,
    Input$DateTimeOperationFilterInput? canceledAt,
    Input$BooleanOperationFilterInput? isActive,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => Input$UserSubscriptionFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (subscriptionId != null) r'subscriptionId': subscriptionId,
    if (stripeSubscriptionId != null)
      r'stripeSubscriptionId': stripeSubscriptionId,
    if (periodStart != null) r'periodStart': periodStart,
    if (periodEnd != null) r'periodEnd': periodEnd,
    if (autoRenew != null) r'autoRenew': autoRenew,
    if (cancelAtEndOfPeriod != null)
      r'cancelAtEndOfPeriod': cancelAtEndOfPeriod,
    if (canceledAt != null) r'canceledAt': canceledAt,
    if (isActive != null) r'isActive': isActive,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$UserSubscriptionFilterInput._(this._$data);

  factory Input$UserSubscriptionFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$UserSubscriptionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$UserSubscriptionFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('subscriptionId')) {
      final l$subscriptionId = data['subscriptionId'];
      result$data['subscriptionId'] = l$subscriptionId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$subscriptionId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('stripeSubscriptionId')) {
      final l$stripeSubscriptionId = data['stripeSubscriptionId'];
      result$data['stripeSubscriptionId'] = l$stripeSubscriptionId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$stripeSubscriptionId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('periodStart')) {
      final l$periodStart = data['periodStart'];
      result$data['periodStart'] = l$periodStart == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$periodStart as Map<String, dynamic>),
            );
    }
    if (data.containsKey('periodEnd')) {
      final l$periodEnd = data['periodEnd'];
      result$data['periodEnd'] = l$periodEnd == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$periodEnd as Map<String, dynamic>),
            );
    }
    if (data.containsKey('autoRenew')) {
      final l$autoRenew = data['autoRenew'];
      result$data['autoRenew'] = l$autoRenew == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$autoRenew as Map<String, dynamic>),
            );
    }
    if (data.containsKey('cancelAtEndOfPeriod')) {
      final l$cancelAtEndOfPeriod = data['cancelAtEndOfPeriod'];
      result$data['cancelAtEndOfPeriod'] = l$cancelAtEndOfPeriod == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$cancelAtEndOfPeriod as Map<String, dynamic>),
            );
    }
    if (data.containsKey('canceledAt')) {
      final l$canceledAt = data['canceledAt'];
      result$data['canceledAt'] = l$canceledAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$canceledAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = l$isActive == null
          ? null
          : Input$BooleanOperationFilterInput.fromJson(
              (l$isActive as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$updatedAt as Map<String, dynamic>),
            );
    }
    return Input$UserSubscriptionFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$UserSubscriptionFilterInput>? get and =>
      (_$data['and'] as List<Input$UserSubscriptionFilterInput>?);

  List<Input$UserSubscriptionFilterInput>? get or =>
      (_$data['or'] as List<Input$UserSubscriptionFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get userId =>
      (_$data['userId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get subscriptionId =>
      (_$data['subscriptionId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get stripeSubscriptionId =>
      (_$data['stripeSubscriptionId'] as Input$StringOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get periodStart =>
      (_$data['periodStart'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get periodEnd =>
      (_$data['periodEnd'] as Input$DateTimeOperationFilterInput?);

  Input$BooleanOperationFilterInput? get autoRenew =>
      (_$data['autoRenew'] as Input$BooleanOperationFilterInput?);

  Input$BooleanOperationFilterInput? get cancelAtEndOfPeriod =>
      (_$data['cancelAtEndOfPeriod'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get canceledAt =>
      (_$data['canceledAt'] as Input$DateTimeOperationFilterInput?);

  Input$BooleanOperationFilterInput? get isActive =>
      (_$data['isActive'] as Input$BooleanOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('subscriptionId')) {
      final l$subscriptionId = subscriptionId;
      result$data['subscriptionId'] = l$subscriptionId?.toJson();
    }
    if (_$data.containsKey('stripeSubscriptionId')) {
      final l$stripeSubscriptionId = stripeSubscriptionId;
      result$data['stripeSubscriptionId'] = l$stripeSubscriptionId?.toJson();
    }
    if (_$data.containsKey('periodStart')) {
      final l$periodStart = periodStart;
      result$data['periodStart'] = l$periodStart?.toJson();
    }
    if (_$data.containsKey('periodEnd')) {
      final l$periodEnd = periodEnd;
      result$data['periodEnd'] = l$periodEnd?.toJson();
    }
    if (_$data.containsKey('autoRenew')) {
      final l$autoRenew = autoRenew;
      result$data['autoRenew'] = l$autoRenew?.toJson();
    }
    if (_$data.containsKey('cancelAtEndOfPeriod')) {
      final l$cancelAtEndOfPeriod = cancelAtEndOfPeriod;
      result$data['cancelAtEndOfPeriod'] = l$cancelAtEndOfPeriod?.toJson();
    }
    if (_$data.containsKey('canceledAt')) {
      final l$canceledAt = canceledAt;
      result$data['canceledAt'] = l$canceledAt?.toJson();
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserSubscriptionFilterInput<Input$UserSubscriptionFilterInput>
  get copyWith => CopyWith$Input$UserSubscriptionFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserSubscriptionFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$subscriptionId = subscriptionId;
    final lOther$subscriptionId = other.subscriptionId;
    if (_$data.containsKey('subscriptionId') !=
        other._$data.containsKey('subscriptionId')) {
      return false;
    }
    if (l$subscriptionId != lOther$subscriptionId) {
      return false;
    }
    final l$stripeSubscriptionId = stripeSubscriptionId;
    final lOther$stripeSubscriptionId = other.stripeSubscriptionId;
    if (_$data.containsKey('stripeSubscriptionId') !=
        other._$data.containsKey('stripeSubscriptionId')) {
      return false;
    }
    if (l$stripeSubscriptionId != lOther$stripeSubscriptionId) {
      return false;
    }
    final l$periodStart = periodStart;
    final lOther$periodStart = other.periodStart;
    if (_$data.containsKey('periodStart') !=
        other._$data.containsKey('periodStart')) {
      return false;
    }
    if (l$periodStart != lOther$periodStart) {
      return false;
    }
    final l$periodEnd = periodEnd;
    final lOther$periodEnd = other.periodEnd;
    if (_$data.containsKey('periodEnd') !=
        other._$data.containsKey('periodEnd')) {
      return false;
    }
    if (l$periodEnd != lOther$periodEnd) {
      return false;
    }
    final l$autoRenew = autoRenew;
    final lOther$autoRenew = other.autoRenew;
    if (_$data.containsKey('autoRenew') !=
        other._$data.containsKey('autoRenew')) {
      return false;
    }
    if (l$autoRenew != lOther$autoRenew) {
      return false;
    }
    final l$cancelAtEndOfPeriod = cancelAtEndOfPeriod;
    final lOther$cancelAtEndOfPeriod = other.cancelAtEndOfPeriod;
    if (_$data.containsKey('cancelAtEndOfPeriod') !=
        other._$data.containsKey('cancelAtEndOfPeriod')) {
      return false;
    }
    if (l$cancelAtEndOfPeriod != lOther$cancelAtEndOfPeriod) {
      return false;
    }
    final l$canceledAt = canceledAt;
    final lOther$canceledAt = other.canceledAt;
    if (_$data.containsKey('canceledAt') !=
        other._$data.containsKey('canceledAt')) {
      return false;
    }
    if (l$canceledAt != lOther$canceledAt) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$userId = userId;
    final l$subscriptionId = subscriptionId;
    final l$stripeSubscriptionId = stripeSubscriptionId;
    final l$periodStart = periodStart;
    final l$periodEnd = periodEnd;
    final l$autoRenew = autoRenew;
    final l$cancelAtEndOfPeriod = cancelAtEndOfPeriod;
    final l$canceledAt = canceledAt;
    final l$isActive = isActive;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('subscriptionId') ? l$subscriptionId : const {},
      _$data.containsKey('stripeSubscriptionId')
          ? l$stripeSubscriptionId
          : const {},
      _$data.containsKey('periodStart') ? l$periodStart : const {},
      _$data.containsKey('periodEnd') ? l$periodEnd : const {},
      _$data.containsKey('autoRenew') ? l$autoRenew : const {},
      _$data.containsKey('cancelAtEndOfPeriod')
          ? l$cancelAtEndOfPeriod
          : const {},
      _$data.containsKey('canceledAt') ? l$canceledAt : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserSubscriptionFilterInput<TRes> {
  factory CopyWith$Input$UserSubscriptionFilterInput(
    Input$UserSubscriptionFilterInput instance,
    TRes Function(Input$UserSubscriptionFilterInput) then,
  ) = _CopyWithImpl$Input$UserSubscriptionFilterInput;

  factory CopyWith$Input$UserSubscriptionFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSubscriptionFilterInput;

  TRes call({
    List<Input$UserSubscriptionFilterInput>? and,
    List<Input$UserSubscriptionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? subscriptionId,
    Input$StringOperationFilterInput? stripeSubscriptionId,
    Input$DateTimeOperationFilterInput? periodStart,
    Input$DateTimeOperationFilterInput? periodEnd,
    Input$BooleanOperationFilterInput? autoRenew,
    Input$BooleanOperationFilterInput? cancelAtEndOfPeriod,
    Input$DateTimeOperationFilterInput? canceledAt,
    Input$BooleanOperationFilterInput? isActive,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  });
  TRes and(
    Iterable<Input$UserSubscriptionFilterInput>? Function(
      Iterable<
        CopyWith$Input$UserSubscriptionFilterInput<
          Input$UserSubscriptionFilterInput
        >
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$UserSubscriptionFilterInput>? Function(
      Iterable<
        CopyWith$Input$UserSubscriptionFilterInput<
          Input$UserSubscriptionFilterInput
        >
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get userId;
  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionId;
  CopyWith$Input$StringOperationFilterInput<TRes> get stripeSubscriptionId;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get periodStart;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get periodEnd;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get autoRenew;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get cancelAtEndOfPeriod;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get canceledAt;
  CopyWith$Input$BooleanOperationFilterInput<TRes> get isActive;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt;
}

class _CopyWithImpl$Input$UserSubscriptionFilterInput<TRes>
    implements CopyWith$Input$UserSubscriptionFilterInput<TRes> {
  _CopyWithImpl$Input$UserSubscriptionFilterInput(this._instance, this._then);

  final Input$UserSubscriptionFilterInput _instance;

  final TRes Function(Input$UserSubscriptionFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? subscriptionId = _undefined,
    Object? stripeSubscriptionId = _undefined,
    Object? periodStart = _undefined,
    Object? periodEnd = _undefined,
    Object? autoRenew = _undefined,
    Object? cancelAtEndOfPeriod = _undefined,
    Object? canceledAt = _undefined,
    Object? isActive = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$UserSubscriptionFilterInput._({
      ..._instance._$data,
      if (and != _undefined)
        'and': (and as List<Input$UserSubscriptionFilterInput>?),
      if (or != _undefined)
        'or': (or as List<Input$UserSubscriptionFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (userId != _undefined)
        'userId': (userId as Input$StringOperationFilterInput?),
      if (subscriptionId != _undefined)
        'subscriptionId': (subscriptionId as Input$StringOperationFilterInput?),
      if (stripeSubscriptionId != _undefined)
        'stripeSubscriptionId':
            (stripeSubscriptionId as Input$StringOperationFilterInput?),
      if (periodStart != _undefined)
        'periodStart': (periodStart as Input$DateTimeOperationFilterInput?),
      if (periodEnd != _undefined)
        'periodEnd': (periodEnd as Input$DateTimeOperationFilterInput?),
      if (autoRenew != _undefined)
        'autoRenew': (autoRenew as Input$BooleanOperationFilterInput?),
      if (cancelAtEndOfPeriod != _undefined)
        'cancelAtEndOfPeriod':
            (cancelAtEndOfPeriod as Input$BooleanOperationFilterInput?),
      if (canceledAt != _undefined)
        'canceledAt': (canceledAt as Input$DateTimeOperationFilterInput?),
      if (isActive != _undefined)
        'isActive': (isActive as Input$BooleanOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$UserSubscriptionFilterInput>? Function(
      Iterable<
        CopyWith$Input$UserSubscriptionFilterInput<
          Input$UserSubscriptionFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$UserSubscriptionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$UserSubscriptionFilterInput>? Function(
      Iterable<
        CopyWith$Input$UserSubscriptionFilterInput<
          Input$UserSubscriptionFilterInput
        >
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$UserSubscriptionFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userId,
            (e) => call(userId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionId {
    final local$subscriptionId = _instance.subscriptionId;
    return local$subscriptionId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$subscriptionId,
            (e) => call(subscriptionId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeSubscriptionId {
    final local$stripeSubscriptionId = _instance.stripeSubscriptionId;
    return local$stripeSubscriptionId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$stripeSubscriptionId,
            (e) => call(stripeSubscriptionId: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get periodStart {
    final local$periodStart = _instance.periodStart;
    return local$periodStart == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$periodStart,
            (e) => call(periodStart: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get periodEnd {
    final local$periodEnd = _instance.periodEnd;
    return local$periodEnd == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$periodEnd,
            (e) => call(periodEnd: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get autoRenew {
    final local$autoRenew = _instance.autoRenew;
    return local$autoRenew == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$autoRenew,
            (e) => call(autoRenew: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get cancelAtEndOfPeriod {
    final local$cancelAtEndOfPeriod = _instance.cancelAtEndOfPeriod;
    return local$cancelAtEndOfPeriod == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$cancelAtEndOfPeriod,
            (e) => call(cancelAtEndOfPeriod: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get canceledAt {
    final local$canceledAt = _instance.canceledAt;
    return local$canceledAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$canceledAt,
            (e) => call(canceledAt: e),
          );
  }

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isActive {
    final local$isActive = _instance.isActive;
    return local$isActive == null
        ? CopyWith$Input$BooleanOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$BooleanOperationFilterInput(
            local$isActive,
            (e) => call(isActive: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$updatedAt,
            (e) => call(updatedAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$UserSubscriptionFilterInput<TRes>
    implements CopyWith$Input$UserSubscriptionFilterInput<TRes> {
  _CopyWithStubImpl$Input$UserSubscriptionFilterInput(this._res);

  TRes _res;

  call({
    List<Input$UserSubscriptionFilterInput>? and,
    List<Input$UserSubscriptionFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? userId,
    Input$StringOperationFilterInput? subscriptionId,
    Input$StringOperationFilterInput? stripeSubscriptionId,
    Input$DateTimeOperationFilterInput? periodStart,
    Input$DateTimeOperationFilterInput? periodEnd,
    Input$BooleanOperationFilterInput? autoRenew,
    Input$BooleanOperationFilterInput? cancelAtEndOfPeriod,
    Input$DateTimeOperationFilterInput? canceledAt,
    Input$BooleanOperationFilterInput? isActive,
    Input$DateTimeOperationFilterInput? createdAt,
    Input$DateTimeOperationFilterInput? updatedAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get userId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get subscriptionId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get stripeSubscriptionId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get periodStart =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get periodEnd =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get autoRenew =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get cancelAtEndOfPeriod =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get canceledAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$BooleanOperationFilterInput<TRes> get isActive =>
      CopyWith$Input$BooleanOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$UserSubscriptionSortInput {
  factory Input$UserSubscriptionSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? subscriptionId,
    Enum$SortEnumType? stripeSubscriptionId,
    Enum$SortEnumType? periodStart,
    Enum$SortEnumType? periodEnd,
    Enum$SortEnumType? autoRenew,
    Enum$SortEnumType? cancelAtEndOfPeriod,
    Enum$SortEnumType? canceledAt,
    Enum$SortEnumType? isActive,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => Input$UserSubscriptionSortInput._({
    if (id != null) r'id': id,
    if (userId != null) r'userId': userId,
    if (subscriptionId != null) r'subscriptionId': subscriptionId,
    if (stripeSubscriptionId != null)
      r'stripeSubscriptionId': stripeSubscriptionId,
    if (periodStart != null) r'periodStart': periodStart,
    if (periodEnd != null) r'periodEnd': periodEnd,
    if (autoRenew != null) r'autoRenew': autoRenew,
    if (cancelAtEndOfPeriod != null)
      r'cancelAtEndOfPeriod': cancelAtEndOfPeriod,
    if (canceledAt != null) r'canceledAt': canceledAt,
    if (isActive != null) r'isActive': isActive,
    if (createdAt != null) r'createdAt': createdAt,
    if (updatedAt != null) r'updatedAt': updatedAt,
  });

  Input$UserSubscriptionSortInput._(this._$data);

  factory Input$UserSubscriptionSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$SortEnumType((l$userId as String));
    }
    if (data.containsKey('subscriptionId')) {
      final l$subscriptionId = data['subscriptionId'];
      result$data['subscriptionId'] = l$subscriptionId == null
          ? null
          : fromJson$Enum$SortEnumType((l$subscriptionId as String));
    }
    if (data.containsKey('stripeSubscriptionId')) {
      final l$stripeSubscriptionId = data['stripeSubscriptionId'];
      result$data['stripeSubscriptionId'] = l$stripeSubscriptionId == null
          ? null
          : fromJson$Enum$SortEnumType((l$stripeSubscriptionId as String));
    }
    if (data.containsKey('periodStart')) {
      final l$periodStart = data['periodStart'];
      result$data['periodStart'] = l$periodStart == null
          ? null
          : fromJson$Enum$SortEnumType((l$periodStart as String));
    }
    if (data.containsKey('periodEnd')) {
      final l$periodEnd = data['periodEnd'];
      result$data['periodEnd'] = l$periodEnd == null
          ? null
          : fromJson$Enum$SortEnumType((l$periodEnd as String));
    }
    if (data.containsKey('autoRenew')) {
      final l$autoRenew = data['autoRenew'];
      result$data['autoRenew'] = l$autoRenew == null
          ? null
          : fromJson$Enum$SortEnumType((l$autoRenew as String));
    }
    if (data.containsKey('cancelAtEndOfPeriod')) {
      final l$cancelAtEndOfPeriod = data['cancelAtEndOfPeriod'];
      result$data['cancelAtEndOfPeriod'] = l$cancelAtEndOfPeriod == null
          ? null
          : fromJson$Enum$SortEnumType((l$cancelAtEndOfPeriod as String));
    }
    if (data.containsKey('canceledAt')) {
      final l$canceledAt = data['canceledAt'];
      result$data['canceledAt'] = l$canceledAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$canceledAt as String));
    }
    if (data.containsKey('isActive')) {
      final l$isActive = data['isActive'];
      result$data['isActive'] = l$isActive == null
          ? null
          : fromJson$Enum$SortEnumType((l$isActive as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$updatedAt as String));
    }
    return Input$UserSubscriptionSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get userId => (_$data['userId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get subscriptionId =>
      (_$data['subscriptionId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get stripeSubscriptionId =>
      (_$data['stripeSubscriptionId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get periodStart =>
      (_$data['periodStart'] as Enum$SortEnumType?);

  Enum$SortEnumType? get periodEnd =>
      (_$data['periodEnd'] as Enum$SortEnumType?);

  Enum$SortEnumType? get autoRenew =>
      (_$data['autoRenew'] as Enum$SortEnumType?);

  Enum$SortEnumType? get cancelAtEndOfPeriod =>
      (_$data['cancelAtEndOfPeriod'] as Enum$SortEnumType?);

  Enum$SortEnumType? get canceledAt =>
      (_$data['canceledAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get isActive => (_$data['isActive'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Enum$SortEnumType? get updatedAt =>
      (_$data['updatedAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId == null
          ? null
          : toJson$Enum$SortEnumType(l$userId);
    }
    if (_$data.containsKey('subscriptionId')) {
      final l$subscriptionId = subscriptionId;
      result$data['subscriptionId'] = l$subscriptionId == null
          ? null
          : toJson$Enum$SortEnumType(l$subscriptionId);
    }
    if (_$data.containsKey('stripeSubscriptionId')) {
      final l$stripeSubscriptionId = stripeSubscriptionId;
      result$data['stripeSubscriptionId'] = l$stripeSubscriptionId == null
          ? null
          : toJson$Enum$SortEnumType(l$stripeSubscriptionId);
    }
    if (_$data.containsKey('periodStart')) {
      final l$periodStart = periodStart;
      result$data['periodStart'] = l$periodStart == null
          ? null
          : toJson$Enum$SortEnumType(l$periodStart);
    }
    if (_$data.containsKey('periodEnd')) {
      final l$periodEnd = periodEnd;
      result$data['periodEnd'] = l$periodEnd == null
          ? null
          : toJson$Enum$SortEnumType(l$periodEnd);
    }
    if (_$data.containsKey('autoRenew')) {
      final l$autoRenew = autoRenew;
      result$data['autoRenew'] = l$autoRenew == null
          ? null
          : toJson$Enum$SortEnumType(l$autoRenew);
    }
    if (_$data.containsKey('cancelAtEndOfPeriod')) {
      final l$cancelAtEndOfPeriod = cancelAtEndOfPeriod;
      result$data['cancelAtEndOfPeriod'] = l$cancelAtEndOfPeriod == null
          ? null
          : toJson$Enum$SortEnumType(l$cancelAtEndOfPeriod);
    }
    if (_$data.containsKey('canceledAt')) {
      final l$canceledAt = canceledAt;
      result$data['canceledAt'] = l$canceledAt == null
          ? null
          : toJson$Enum$SortEnumType(l$canceledAt);
    }
    if (_$data.containsKey('isActive')) {
      final l$isActive = isActive;
      result$data['isActive'] = l$isActive == null
          ? null
          : toJson$Enum$SortEnumType(l$isActive);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : toJson$Enum$SortEnumType(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Input$UserSubscriptionSortInput<Input$UserSubscriptionSortInput>
  get copyWith => CopyWith$Input$UserSubscriptionSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserSubscriptionSortInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$subscriptionId = subscriptionId;
    final lOther$subscriptionId = other.subscriptionId;
    if (_$data.containsKey('subscriptionId') !=
        other._$data.containsKey('subscriptionId')) {
      return false;
    }
    if (l$subscriptionId != lOther$subscriptionId) {
      return false;
    }
    final l$stripeSubscriptionId = stripeSubscriptionId;
    final lOther$stripeSubscriptionId = other.stripeSubscriptionId;
    if (_$data.containsKey('stripeSubscriptionId') !=
        other._$data.containsKey('stripeSubscriptionId')) {
      return false;
    }
    if (l$stripeSubscriptionId != lOther$stripeSubscriptionId) {
      return false;
    }
    final l$periodStart = periodStart;
    final lOther$periodStart = other.periodStart;
    if (_$data.containsKey('periodStart') !=
        other._$data.containsKey('periodStart')) {
      return false;
    }
    if (l$periodStart != lOther$periodStart) {
      return false;
    }
    final l$periodEnd = periodEnd;
    final lOther$periodEnd = other.periodEnd;
    if (_$data.containsKey('periodEnd') !=
        other._$data.containsKey('periodEnd')) {
      return false;
    }
    if (l$periodEnd != lOther$periodEnd) {
      return false;
    }
    final l$autoRenew = autoRenew;
    final lOther$autoRenew = other.autoRenew;
    if (_$data.containsKey('autoRenew') !=
        other._$data.containsKey('autoRenew')) {
      return false;
    }
    if (l$autoRenew != lOther$autoRenew) {
      return false;
    }
    final l$cancelAtEndOfPeriod = cancelAtEndOfPeriod;
    final lOther$cancelAtEndOfPeriod = other.cancelAtEndOfPeriod;
    if (_$data.containsKey('cancelAtEndOfPeriod') !=
        other._$data.containsKey('cancelAtEndOfPeriod')) {
      return false;
    }
    if (l$cancelAtEndOfPeriod != lOther$cancelAtEndOfPeriod) {
      return false;
    }
    final l$canceledAt = canceledAt;
    final lOther$canceledAt = other.canceledAt;
    if (_$data.containsKey('canceledAt') !=
        other._$data.containsKey('canceledAt')) {
      return false;
    }
    if (l$canceledAt != lOther$canceledAt) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (_$data.containsKey('isActive') !=
        other._$data.containsKey('isActive')) {
      return false;
    }
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userId = userId;
    final l$subscriptionId = subscriptionId;
    final l$stripeSubscriptionId = stripeSubscriptionId;
    final l$periodStart = periodStart;
    final l$periodEnd = periodEnd;
    final l$autoRenew = autoRenew;
    final l$cancelAtEndOfPeriod = cancelAtEndOfPeriod;
    final l$canceledAt = canceledAt;
    final l$isActive = isActive;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('subscriptionId') ? l$subscriptionId : const {},
      _$data.containsKey('stripeSubscriptionId')
          ? l$stripeSubscriptionId
          : const {},
      _$data.containsKey('periodStart') ? l$periodStart : const {},
      _$data.containsKey('periodEnd') ? l$periodEnd : const {},
      _$data.containsKey('autoRenew') ? l$autoRenew : const {},
      _$data.containsKey('cancelAtEndOfPeriod')
          ? l$cancelAtEndOfPeriod
          : const {},
      _$data.containsKey('canceledAt') ? l$canceledAt : const {},
      _$data.containsKey('isActive') ? l$isActive : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserSubscriptionSortInput<TRes> {
  factory CopyWith$Input$UserSubscriptionSortInput(
    Input$UserSubscriptionSortInput instance,
    TRes Function(Input$UserSubscriptionSortInput) then,
  ) = _CopyWithImpl$Input$UserSubscriptionSortInput;

  factory CopyWith$Input$UserSubscriptionSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserSubscriptionSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? subscriptionId,
    Enum$SortEnumType? stripeSubscriptionId,
    Enum$SortEnumType? periodStart,
    Enum$SortEnumType? periodEnd,
    Enum$SortEnumType? autoRenew,
    Enum$SortEnumType? cancelAtEndOfPeriod,
    Enum$SortEnumType? canceledAt,
    Enum$SortEnumType? isActive,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  });
}

class _CopyWithImpl$Input$UserSubscriptionSortInput<TRes>
    implements CopyWith$Input$UserSubscriptionSortInput<TRes> {
  _CopyWithImpl$Input$UserSubscriptionSortInput(this._instance, this._then);

  final Input$UserSubscriptionSortInput _instance;

  final TRes Function(Input$UserSubscriptionSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? userId = _undefined,
    Object? subscriptionId = _undefined,
    Object? stripeSubscriptionId = _undefined,
    Object? periodStart = _undefined,
    Object? periodEnd = _undefined,
    Object? autoRenew = _undefined,
    Object? cancelAtEndOfPeriod = _undefined,
    Object? canceledAt = _undefined,
    Object? isActive = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
  }) => _then(
    Input$UserSubscriptionSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (userId != _undefined) 'userId': (userId as Enum$SortEnumType?),
      if (subscriptionId != _undefined)
        'subscriptionId': (subscriptionId as Enum$SortEnumType?),
      if (stripeSubscriptionId != _undefined)
        'stripeSubscriptionId': (stripeSubscriptionId as Enum$SortEnumType?),
      if (periodStart != _undefined)
        'periodStart': (periodStart as Enum$SortEnumType?),
      if (periodEnd != _undefined)
        'periodEnd': (periodEnd as Enum$SortEnumType?),
      if (autoRenew != _undefined)
        'autoRenew': (autoRenew as Enum$SortEnumType?),
      if (cancelAtEndOfPeriod != _undefined)
        'cancelAtEndOfPeriod': (cancelAtEndOfPeriod as Enum$SortEnumType?),
      if (canceledAt != _undefined)
        'canceledAt': (canceledAt as Enum$SortEnumType?),
      if (isActive != _undefined) 'isActive': (isActive as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
      if (updatedAt != _undefined)
        'updatedAt': (updatedAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$UserSubscriptionSortInput<TRes>
    implements CopyWith$Input$UserSubscriptionSortInput<TRes> {
  _CopyWithStubImpl$Input$UserSubscriptionSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? userId,
    Enum$SortEnumType? subscriptionId,
    Enum$SortEnumType? stripeSubscriptionId,
    Enum$SortEnumType? periodStart,
    Enum$SortEnumType? periodEnd,
    Enum$SortEnumType? autoRenew,
    Enum$SortEnumType? cancelAtEndOfPeriod,
    Enum$SortEnumType? canceledAt,
    Enum$SortEnumType? isActive,
    Enum$SortEnumType? createdAt,
    Enum$SortEnumType? updatedAt,
  }) => _res;
}

class Input$WorkFilterInput {
  factory Input$WorkFilterInput({
    List<Input$WorkFilterInput>? and,
    List<Input$WorkFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$StringOperationFilterInput? description,
    Input$ListFilterInputTypeOfWorkSplitFilterInput? workSplits,
    Input$LongOperationFilterInput? version,
    Input$WorkStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
  }) => Input$WorkFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (id != null) r'id': id,
    if (trackId != null) r'trackId': trackId,
    if (description != null) r'description': description,
    if (workSplits != null) r'workSplits': workSplits,
    if (version != null) r'version': version,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
  });

  Input$WorkFilterInput._(this._$data);

  factory Input$WorkFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$WorkFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$WorkFilterInput.fromJson((e as Map<String, dynamic>)),
          )
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$id as Map<String, dynamic>),
            );
    }
    if (data.containsKey('trackId')) {
      final l$trackId = data['trackId'];
      result$data['trackId'] = l$trackId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$trackId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$description as Map<String, dynamic>),
            );
    }
    if (data.containsKey('workSplits')) {
      final l$workSplits = data['workSplits'];
      result$data['workSplits'] = l$workSplits == null
          ? null
          : Input$ListFilterInputTypeOfWorkSplitFilterInput.fromJson(
              (l$workSplits as Map<String, dynamic>),
            );
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : Input$LongOperationFilterInput.fromJson(
              (l$version as Map<String, dynamic>),
            );
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$WorkStatusOperationFilterInput.fromJson(
              (l$status as Map<String, dynamic>),
            );
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeOperationFilterInput.fromJson(
              (l$createdAt as Map<String, dynamic>),
            );
    }
    return Input$WorkFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WorkFilterInput>? get and =>
      (_$data['and'] as List<Input$WorkFilterInput>?);

  List<Input$WorkFilterInput>? get or =>
      (_$data['or'] as List<Input$WorkFilterInput>?);

  Input$StringOperationFilterInput? get id =>
      (_$data['id'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get trackId =>
      (_$data['trackId'] as Input$StringOperationFilterInput?);

  Input$StringOperationFilterInput? get description =>
      (_$data['description'] as Input$StringOperationFilterInput?);

  Input$ListFilterInputTypeOfWorkSplitFilterInput? get workSplits =>
      (_$data['workSplits']
          as Input$ListFilterInputTypeOfWorkSplitFilterInput?);

  Input$LongOperationFilterInput? get version =>
      (_$data['version'] as Input$LongOperationFilterInput?);

  Input$WorkStatusOperationFilterInput? get status =>
      (_$data['status'] as Input$WorkStatusOperationFilterInput?);

  Input$DateTimeOperationFilterInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('trackId')) {
      final l$trackId = trackId;
      result$data['trackId'] = l$trackId?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('workSplits')) {
      final l$workSplits = workSplits;
      result$data['workSplits'] = l$workSplits?.toJson();
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WorkFilterInput<Input$WorkFilterInput> get copyWith =>
      CopyWith$Input$WorkFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WorkFilterInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (_$data.containsKey('trackId') != other._$data.containsKey('trackId')) {
      return false;
    }
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$workSplits = workSplits;
    final lOther$workSplits = other.workSplits;
    if (_$data.containsKey('workSplits') !=
        other._$data.containsKey('workSplits')) {
      return false;
    }
    if (l$workSplits != lOther$workSplits) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$id = id;
    final l$trackId = trackId;
    final l$description = description;
    final l$workSplits = workSplits;
    final l$version = version;
    final l$status = status;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('trackId') ? l$trackId : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('workSplits') ? l$workSplits : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$WorkFilterInput<TRes> {
  factory CopyWith$Input$WorkFilterInput(
    Input$WorkFilterInput instance,
    TRes Function(Input$WorkFilterInput) then,
  ) = _CopyWithImpl$Input$WorkFilterInput;

  factory CopyWith$Input$WorkFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkFilterInput;

  TRes call({
    List<Input$WorkFilterInput>? and,
    List<Input$WorkFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$StringOperationFilterInput? description,
    Input$ListFilterInputTypeOfWorkSplitFilterInput? workSplits,
    Input$LongOperationFilterInput? version,
    Input$WorkStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
  });
  TRes and(
    Iterable<Input$WorkFilterInput>? Function(
      Iterable<CopyWith$Input$WorkFilterInput<Input$WorkFilterInput>>?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$WorkFilterInput>? Function(
      Iterable<CopyWith$Input$WorkFilterInput<Input$WorkFilterInput>>?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get id;
  CopyWith$Input$StringOperationFilterInput<TRes> get trackId;
  CopyWith$Input$StringOperationFilterInput<TRes> get description;
  CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput<TRes> get workSplits;
  CopyWith$Input$LongOperationFilterInput<TRes> get version;
  CopyWith$Input$WorkStatusOperationFilterInput<TRes> get status;
  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt;
}

class _CopyWithImpl$Input$WorkFilterInput<TRes>
    implements CopyWith$Input$WorkFilterInput<TRes> {
  _CopyWithImpl$Input$WorkFilterInput(this._instance, this._then);

  final Input$WorkFilterInput _instance;

  final TRes Function(Input$WorkFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? id = _undefined,
    Object? trackId = _undefined,
    Object? description = _undefined,
    Object? workSplits = _undefined,
    Object? version = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
  }) => _then(
    Input$WorkFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$WorkFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$WorkFilterInput>?),
      if (id != _undefined) 'id': (id as Input$StringOperationFilterInput?),
      if (trackId != _undefined)
        'trackId': (trackId as Input$StringOperationFilterInput?),
      if (description != _undefined)
        'description': (description as Input$StringOperationFilterInput?),
      if (workSplits != _undefined)
        'workSplits':
            (workSplits as Input$ListFilterInputTypeOfWorkSplitFilterInput?),
      if (version != _undefined)
        'version': (version as Input$LongOperationFilterInput?),
      if (status != _undefined)
        'status': (status as Input$WorkStatusOperationFilterInput?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Input$DateTimeOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$WorkFilterInput>? Function(
      Iterable<CopyWith$Input$WorkFilterInput<Input$WorkFilterInput>>?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map((e) => CopyWith$Input$WorkFilterInput(e, (i) => i)),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$WorkFilterInput>? Function(
      Iterable<CopyWith$Input$WorkFilterInput<Input$WorkFilterInput>>?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map((e) => CopyWith$Input$WorkFilterInput(e, (i) => i)),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$id,
            (e) => call(id: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get trackId {
    final local$trackId = _instance.trackId;
    return local$trackId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$trackId,
            (e) => call(trackId: e),
          );
  }

  CopyWith$Input$StringOperationFilterInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$description,
            (e) => call(description: e),
          );
  }

  CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput<TRes>
  get workSplits {
    final local$workSplits = _instance.workSplits;
    return local$workSplits == null
        ? CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput.stub(
            _then(_instance),
          )
        : CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput(
            local$workSplits,
            (e) => call(workSplits: e),
          );
  }

  CopyWith$Input$LongOperationFilterInput<TRes> get version {
    final local$version = _instance.version;
    return local$version == null
        ? CopyWith$Input$LongOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$LongOperationFilterInput(
            local$version,
            (e) => call(version: e),
          );
  }

  CopyWith$Input$WorkStatusOperationFilterInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$WorkStatusOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$WorkStatusOperationFilterInput(
            local$status,
            (e) => call(status: e),
          );
  }

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DateTimeOperationFilterInput(
            local$createdAt,
            (e) => call(createdAt: e),
          );
  }
}

class _CopyWithStubImpl$Input$WorkFilterInput<TRes>
    implements CopyWith$Input$WorkFilterInput<TRes> {
  _CopyWithStubImpl$Input$WorkFilterInput(this._res);

  TRes _res;

  call({
    List<Input$WorkFilterInput>? and,
    List<Input$WorkFilterInput>? or,
    Input$StringOperationFilterInput? id,
    Input$StringOperationFilterInput? trackId,
    Input$StringOperationFilterInput? description,
    Input$ListFilterInputTypeOfWorkSplitFilterInput? workSplits,
    Input$LongOperationFilterInput? version,
    Input$WorkStatusOperationFilterInput? status,
    Input$DateTimeOperationFilterInput? createdAt,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get id =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get trackId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$StringOperationFilterInput<TRes> get description =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput<TRes>
  get workSplits =>
      CopyWith$Input$ListFilterInputTypeOfWorkSplitFilterInput.stub(_res);

  CopyWith$Input$LongOperationFilterInput<TRes> get version =>
      CopyWith$Input$LongOperationFilterInput.stub(_res);

  CopyWith$Input$WorkStatusOperationFilterInput<TRes> get status =>
      CopyWith$Input$WorkStatusOperationFilterInput.stub(_res);

  CopyWith$Input$DateTimeOperationFilterInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeOperationFilterInput.stub(_res);
}

class Input$WorkSortInput {
  factory Input$WorkSortInput({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? description,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
  }) => Input$WorkSortInput._({
    if (id != null) r'id': id,
    if (trackId != null) r'trackId': trackId,
    if (description != null) r'description': description,
    if (version != null) r'version': version,
    if (status != null) r'status': status,
    if (createdAt != null) r'createdAt': createdAt,
  });

  Input$WorkSortInput._(this._$data);

  factory Input$WorkSortInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : fromJson$Enum$SortEnumType((l$id as String));
    }
    if (data.containsKey('trackId')) {
      final l$trackId = data['trackId'];
      result$data['trackId'] = l$trackId == null
          ? null
          : fromJson$Enum$SortEnumType((l$trackId as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortEnumType((l$description as String));
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = l$version == null
          ? null
          : fromJson$Enum$SortEnumType((l$version as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortEnumType((l$status as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortEnumType((l$createdAt as String));
    }
    return Input$WorkSortInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortEnumType? get id => (_$data['id'] as Enum$SortEnumType?);

  Enum$SortEnumType? get trackId => (_$data['trackId'] as Enum$SortEnumType?);

  Enum$SortEnumType? get description =>
      (_$data['description'] as Enum$SortEnumType?);

  Enum$SortEnumType? get version => (_$data['version'] as Enum$SortEnumType?);

  Enum$SortEnumType? get status => (_$data['status'] as Enum$SortEnumType?);

  Enum$SortEnumType? get createdAt =>
      (_$data['createdAt'] as Enum$SortEnumType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortEnumType(l$id);
    }
    if (_$data.containsKey('trackId')) {
      final l$trackId = trackId;
      result$data['trackId'] = l$trackId == null
          ? null
          : toJson$Enum$SortEnumType(l$trackId);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description == null
          ? null
          : toJson$Enum$SortEnumType(l$description);
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version == null
          ? null
          : toJson$Enum$SortEnumType(l$version);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$SortEnumType(l$status);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : toJson$Enum$SortEnumType(l$createdAt);
    }
    return result$data;
  }

  CopyWith$Input$WorkSortInput<Input$WorkSortInput> get copyWith =>
      CopyWith$Input$WorkSortInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WorkSortInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$trackId = trackId;
    final lOther$trackId = other.trackId;
    if (_$data.containsKey('trackId') != other._$data.containsKey('trackId')) {
      return false;
    }
    if (l$trackId != lOther$trackId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$trackId = trackId;
    final l$description = description;
    final l$version = version;
    final l$status = status;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('trackId') ? l$trackId : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$WorkSortInput<TRes> {
  factory CopyWith$Input$WorkSortInput(
    Input$WorkSortInput instance,
    TRes Function(Input$WorkSortInput) then,
  ) = _CopyWithImpl$Input$WorkSortInput;

  factory CopyWith$Input$WorkSortInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkSortInput;

  TRes call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? description,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
  });
}

class _CopyWithImpl$Input$WorkSortInput<TRes>
    implements CopyWith$Input$WorkSortInput<TRes> {
  _CopyWithImpl$Input$WorkSortInput(this._instance, this._then);

  final Input$WorkSortInput _instance;

  final TRes Function(Input$WorkSortInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? trackId = _undefined,
    Object? description = _undefined,
    Object? version = _undefined,
    Object? status = _undefined,
    Object? createdAt = _undefined,
  }) => _then(
    Input$WorkSortInput._({
      ..._instance._$data,
      if (id != _undefined) 'id': (id as Enum$SortEnumType?),
      if (trackId != _undefined) 'trackId': (trackId as Enum$SortEnumType?),
      if (description != _undefined)
        'description': (description as Enum$SortEnumType?),
      if (version != _undefined) 'version': (version as Enum$SortEnumType?),
      if (status != _undefined) 'status': (status as Enum$SortEnumType?),
      if (createdAt != _undefined)
        'createdAt': (createdAt as Enum$SortEnumType?),
    }),
  );
}

class _CopyWithStubImpl$Input$WorkSortInput<TRes>
    implements CopyWith$Input$WorkSortInput<TRes> {
  _CopyWithStubImpl$Input$WorkSortInput(this._res);

  TRes _res;

  call({
    Enum$SortEnumType? id,
    Enum$SortEnumType? trackId,
    Enum$SortEnumType? description,
    Enum$SortEnumType? version,
    Enum$SortEnumType? status,
    Enum$SortEnumType? createdAt,
  }) => _res;
}

class Input$WorkSplitFilterInput {
  factory Input$WorkSplitFilterInput({
    List<Input$WorkSplitFilterInput>? and,
    List<Input$WorkSplitFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$ArtistRoleOperationFilterInput? artistRole,
    Input$DecimalOperationFilterInput? percentage,
  }) => Input$WorkSplitFilterInput._({
    if (and != null) r'and': and,
    if (or != null) r'or': or,
    if (userId != null) r'userId': userId,
    if (artistRole != null) r'artistRole': artistRole,
    if (percentage != null) r'percentage': percentage,
  });

  Input$WorkSplitFilterInput._(this._$data);

  factory Input$WorkSplitFilterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('and')) {
      final l$and = data['and'];
      result$data['and'] = (l$and as List<dynamic>?)
          ?.map(
            (e) => Input$WorkSplitFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('or')) {
      final l$or = data['or'];
      result$data['or'] = (l$or as List<dynamic>?)
          ?.map(
            (e) => Input$WorkSplitFilterInput.fromJson(
              (e as Map<String, dynamic>),
            ),
          )
          .toList();
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringOperationFilterInput.fromJson(
              (l$userId as Map<String, dynamic>),
            );
    }
    if (data.containsKey('artistRole')) {
      final l$artistRole = data['artistRole'];
      result$data['artistRole'] = l$artistRole == null
          ? null
          : Input$ArtistRoleOperationFilterInput.fromJson(
              (l$artistRole as Map<String, dynamic>),
            );
    }
    if (data.containsKey('percentage')) {
      final l$percentage = data['percentage'];
      result$data['percentage'] = l$percentage == null
          ? null
          : Input$DecimalOperationFilterInput.fromJson(
              (l$percentage as Map<String, dynamic>),
            );
    }
    return Input$WorkSplitFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WorkSplitFilterInput>? get and =>
      (_$data['and'] as List<Input$WorkSplitFilterInput>?);

  List<Input$WorkSplitFilterInput>? get or =>
      (_$data['or'] as List<Input$WorkSplitFilterInput>?);

  Input$StringOperationFilterInput? get userId =>
      (_$data['userId'] as Input$StringOperationFilterInput?);

  Input$ArtistRoleOperationFilterInput? get artistRole =>
      (_$data['artistRole'] as Input$ArtistRoleOperationFilterInput?);

  Input$DecimalOperationFilterInput? get percentage =>
      (_$data['percentage'] as Input$DecimalOperationFilterInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('and')) {
      final l$and = and;
      result$data['and'] = l$and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('or')) {
      final l$or = or;
      result$data['or'] = l$or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('artistRole')) {
      final l$artistRole = artistRole;
      result$data['artistRole'] = l$artistRole?.toJson();
    }
    if (_$data.containsKey('percentage')) {
      final l$percentage = percentage;
      result$data['percentage'] = l$percentage?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WorkSplitFilterInput<Input$WorkSplitFilterInput>
  get copyWith => CopyWith$Input$WorkSplitFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WorkSplitFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$and = and;
    final lOther$and = other.and;
    if (_$data.containsKey('and') != other._$data.containsKey('and')) {
      return false;
    }
    if (l$and != null && lOther$and != null) {
      if (l$and.length != lOther$and.length) {
        return false;
      }
      for (int i = 0; i < l$and.length; i++) {
        final l$and$entry = l$and[i];
        final lOther$and$entry = lOther$and[i];
        if (l$and$entry != lOther$and$entry) {
          return false;
        }
      }
    } else if (l$and != lOther$and) {
      return false;
    }
    final l$or = or;
    final lOther$or = other.or;
    if (_$data.containsKey('or') != other._$data.containsKey('or')) {
      return false;
    }
    if (l$or != null && lOther$or != null) {
      if (l$or.length != lOther$or.length) {
        return false;
      }
      for (int i = 0; i < l$or.length; i++) {
        final l$or$entry = l$or[i];
        final lOther$or$entry = lOther$or[i];
        if (l$or$entry != lOther$or$entry) {
          return false;
        }
      }
    } else if (l$or != lOther$or) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$artistRole = artistRole;
    final lOther$artistRole = other.artistRole;
    if (_$data.containsKey('artistRole') !=
        other._$data.containsKey('artistRole')) {
      return false;
    }
    if (l$artistRole != lOther$artistRole) {
      return false;
    }
    final l$percentage = percentage;
    final lOther$percentage = other.percentage;
    if (_$data.containsKey('percentage') !=
        other._$data.containsKey('percentage')) {
      return false;
    }
    if (l$percentage != lOther$percentage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$and = and;
    final l$or = or;
    final l$userId = userId;
    final l$artistRole = artistRole;
    final l$percentage = percentage;
    return Object.hashAll([
      _$data.containsKey('and')
          ? l$and == null
                ? null
                : Object.hashAll(l$and.map((v) => v))
          : const {},
      _$data.containsKey('or')
          ? l$or == null
                ? null
                : Object.hashAll(l$or.map((v) => v))
          : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('artistRole') ? l$artistRole : const {},
      _$data.containsKey('percentage') ? l$percentage : const {},
    ]);
  }
}

abstract class CopyWith$Input$WorkSplitFilterInput<TRes> {
  factory CopyWith$Input$WorkSplitFilterInput(
    Input$WorkSplitFilterInput instance,
    TRes Function(Input$WorkSplitFilterInput) then,
  ) = _CopyWithImpl$Input$WorkSplitFilterInput;

  factory CopyWith$Input$WorkSplitFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkSplitFilterInput;

  TRes call({
    List<Input$WorkSplitFilterInput>? and,
    List<Input$WorkSplitFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$ArtistRoleOperationFilterInput? artistRole,
    Input$DecimalOperationFilterInput? percentage,
  });
  TRes and(
    Iterable<Input$WorkSplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$WorkSplitFilterInput<Input$WorkSplitFilterInput>
      >?,
    )
    _fn,
  );
  TRes or(
    Iterable<Input$WorkSplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$WorkSplitFilterInput<Input$WorkSplitFilterInput>
      >?,
    )
    _fn,
  );
  CopyWith$Input$StringOperationFilterInput<TRes> get userId;
  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get artistRole;
  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentage;
}

class _CopyWithImpl$Input$WorkSplitFilterInput<TRes>
    implements CopyWith$Input$WorkSplitFilterInput<TRes> {
  _CopyWithImpl$Input$WorkSplitFilterInput(this._instance, this._then);

  final Input$WorkSplitFilterInput _instance;

  final TRes Function(Input$WorkSplitFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? and = _undefined,
    Object? or = _undefined,
    Object? userId = _undefined,
    Object? artistRole = _undefined,
    Object? percentage = _undefined,
  }) => _then(
    Input$WorkSplitFilterInput._({
      ..._instance._$data,
      if (and != _undefined) 'and': (and as List<Input$WorkSplitFilterInput>?),
      if (or != _undefined) 'or': (or as List<Input$WorkSplitFilterInput>?),
      if (userId != _undefined)
        'userId': (userId as Input$StringOperationFilterInput?),
      if (artistRole != _undefined)
        'artistRole': (artistRole as Input$ArtistRoleOperationFilterInput?),
      if (percentage != _undefined)
        'percentage': (percentage as Input$DecimalOperationFilterInput?),
    }),
  );

  TRes and(
    Iterable<Input$WorkSplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$WorkSplitFilterInput<Input$WorkSplitFilterInput>
      >?,
    )
    _fn,
  ) => call(
    and: _fn(
      _instance.and?.map(
        (e) => CopyWith$Input$WorkSplitFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  TRes or(
    Iterable<Input$WorkSplitFilterInput>? Function(
      Iterable<
        CopyWith$Input$WorkSplitFilterInput<Input$WorkSplitFilterInput>
      >?,
    )
    _fn,
  ) => call(
    or: _fn(
      _instance.or?.map(
        (e) => CopyWith$Input$WorkSplitFilterInput(e, (i) => i),
      ),
    )?.toList(),
  );

  CopyWith$Input$StringOperationFilterInput<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$StringOperationFilterInput(
            local$userId,
            (e) => call(userId: e),
          );
  }

  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get artistRole {
    final local$artistRole = _instance.artistRole;
    return local$artistRole == null
        ? CopyWith$Input$ArtistRoleOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$ArtistRoleOperationFilterInput(
            local$artistRole,
            (e) => call(artistRole: e),
          );
  }

  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentage {
    final local$percentage = _instance.percentage;
    return local$percentage == null
        ? CopyWith$Input$DecimalOperationFilterInput.stub(_then(_instance))
        : CopyWith$Input$DecimalOperationFilterInput(
            local$percentage,
            (e) => call(percentage: e),
          );
  }
}

class _CopyWithStubImpl$Input$WorkSplitFilterInput<TRes>
    implements CopyWith$Input$WorkSplitFilterInput<TRes> {
  _CopyWithStubImpl$Input$WorkSplitFilterInput(this._res);

  TRes _res;

  call({
    List<Input$WorkSplitFilterInput>? and,
    List<Input$WorkSplitFilterInput>? or,
    Input$StringOperationFilterInput? userId,
    Input$ArtistRoleOperationFilterInput? artistRole,
    Input$DecimalOperationFilterInput? percentage,
  }) => _res;

  and(_fn) => _res;

  or(_fn) => _res;

  CopyWith$Input$StringOperationFilterInput<TRes> get userId =>
      CopyWith$Input$StringOperationFilterInput.stub(_res);

  CopyWith$Input$ArtistRoleOperationFilterInput<TRes> get artistRole =>
      CopyWith$Input$ArtistRoleOperationFilterInput.stub(_res);

  CopyWith$Input$DecimalOperationFilterInput<TRes> get percentage =>
      CopyWith$Input$DecimalOperationFilterInput.stub(_res);
}

class Input$WorkStatusOperationFilterInput {
  factory Input$WorkStatusOperationFilterInput({
    Enum$WorkStatus? eq,
    Enum$WorkStatus? neq,
    List<Enum$WorkStatus>? $in,
    List<Enum$WorkStatus>? nin,
  }) => Input$WorkStatusOperationFilterInput._({
    if (eq != null) r'eq': eq,
    if (neq != null) r'neq': neq,
    if ($in != null) r'in': $in,
    if (nin != null) r'nin': nin,
  });

  Input$WorkStatusOperationFilterInput._(this._$data);

  factory Input$WorkStatusOperationFilterInput.fromJson(
    Map<String, dynamic> data,
  ) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('eq')) {
      final l$eq = data['eq'];
      result$data['eq'] = l$eq == null
          ? null
          : fromJson$Enum$WorkStatus((l$eq as String));
    }
    if (data.containsKey('neq')) {
      final l$neq = data['neq'];
      result$data['neq'] = l$neq == null
          ? null
          : fromJson$Enum$WorkStatus((l$neq as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$WorkStatus((e as String)))
          .toList();
    }
    if (data.containsKey('nin')) {
      final l$nin = data['nin'];
      result$data['nin'] = (l$nin as List<dynamic>?)
          ?.map((e) => fromJson$Enum$WorkStatus((e as String)))
          .toList();
    }
    return Input$WorkStatusOperationFilterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$WorkStatus? get eq => (_$data['eq'] as Enum$WorkStatus?);

  Enum$WorkStatus? get neq => (_$data['neq'] as Enum$WorkStatus?);

  List<Enum$WorkStatus>? get $in => (_$data['in'] as List<Enum$WorkStatus>?);

  List<Enum$WorkStatus>? get nin => (_$data['nin'] as List<Enum$WorkStatus>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('eq')) {
      final l$eq = eq;
      result$data['eq'] = l$eq == null ? null : toJson$Enum$WorkStatus(l$eq);
    }
    if (_$data.containsKey('neq')) {
      final l$neq = neq;
      result$data['neq'] = l$neq == null ? null : toJson$Enum$WorkStatus(l$neq);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$WorkStatus(e)).toList();
    }
    if (_$data.containsKey('nin')) {
      final l$nin = nin;
      result$data['nin'] = l$nin
          ?.map((e) => toJson$Enum$WorkStatus(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$WorkStatusOperationFilterInput<
    Input$WorkStatusOperationFilterInput
  >
  get copyWith => CopyWith$Input$WorkStatusOperationFilterInput(this, (i) => i);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WorkStatusOperationFilterInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$eq = eq;
    final lOther$eq = other.eq;
    if (_$data.containsKey('eq') != other._$data.containsKey('eq')) {
      return false;
    }
    if (l$eq != lOther$eq) {
      return false;
    }
    final l$neq = neq;
    final lOther$neq = other.neq;
    if (_$data.containsKey('neq') != other._$data.containsKey('neq')) {
      return false;
    }
    if (l$neq != lOther$neq) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$nin = nin;
    final lOther$nin = other.nin;
    if (_$data.containsKey('nin') != other._$data.containsKey('nin')) {
      return false;
    }
    if (l$nin != null && lOther$nin != null) {
      if (l$nin.length != lOther$nin.length) {
        return false;
      }
      for (int i = 0; i < l$nin.length; i++) {
        final l$nin$entry = l$nin[i];
        final lOther$nin$entry = lOther$nin[i];
        if (l$nin$entry != lOther$nin$entry) {
          return false;
        }
      }
    } else if (l$nin != lOther$nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$eq = eq;
    final l$neq = neq;
    final l$$in = $in;
    final l$nin = nin;
    return Object.hashAll([
      _$data.containsKey('eq') ? l$eq : const {},
      _$data.containsKey('neq') ? l$neq : const {},
      _$data.containsKey('in')
          ? l$$in == null
                ? null
                : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('nin')
          ? l$nin == null
                ? null
                : Object.hashAll(l$nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$WorkStatusOperationFilterInput<TRes> {
  factory CopyWith$Input$WorkStatusOperationFilterInput(
    Input$WorkStatusOperationFilterInput instance,
    TRes Function(Input$WorkStatusOperationFilterInput) then,
  ) = _CopyWithImpl$Input$WorkStatusOperationFilterInput;

  factory CopyWith$Input$WorkStatusOperationFilterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkStatusOperationFilterInput;

  TRes call({
    Enum$WorkStatus? eq,
    Enum$WorkStatus? neq,
    List<Enum$WorkStatus>? $in,
    List<Enum$WorkStatus>? nin,
  });
}

class _CopyWithImpl$Input$WorkStatusOperationFilterInput<TRes>
    implements CopyWith$Input$WorkStatusOperationFilterInput<TRes> {
  _CopyWithImpl$Input$WorkStatusOperationFilterInput(
    this._instance,
    this._then,
  );

  final Input$WorkStatusOperationFilterInput _instance;

  final TRes Function(Input$WorkStatusOperationFilterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? eq = _undefined,
    Object? neq = _undefined,
    Object? $in = _undefined,
    Object? nin = _undefined,
  }) => _then(
    Input$WorkStatusOperationFilterInput._({
      ..._instance._$data,
      if (eq != _undefined) 'eq': (eq as Enum$WorkStatus?),
      if (neq != _undefined) 'neq': (neq as Enum$WorkStatus?),
      if ($in != _undefined) 'in': ($in as List<Enum$WorkStatus>?),
      if (nin != _undefined) 'nin': (nin as List<Enum$WorkStatus>?),
    }),
  );
}

class _CopyWithStubImpl$Input$WorkStatusOperationFilterInput<TRes>
    implements CopyWith$Input$WorkStatusOperationFilterInput<TRes> {
  _CopyWithStubImpl$Input$WorkStatusOperationFilterInput(this._res);

  TRes _res;

  call({
    Enum$WorkStatus? eq,
    Enum$WorkStatus? neq,
    List<Enum$WorkStatus>? $in,
    List<Enum$WorkStatus>? nin,
  }) => _res;
}

enum Enum$AggregationLevel {
  NONE,
  RECORDING,
  WORK,
  FULL,
  $unknown;

  factory Enum$AggregationLevel.fromJson(String value) =>
      fromJson$Enum$AggregationLevel(value);

  String toJson() => toJson$Enum$AggregationLevel(this);
}

String toJson$Enum$AggregationLevel(Enum$AggregationLevel e) {
  switch (e) {
    case Enum$AggregationLevel.NONE:
      return r'NONE';
    case Enum$AggregationLevel.RECORDING:
      return r'RECORDING';
    case Enum$AggregationLevel.WORK:
      return r'WORK';
    case Enum$AggregationLevel.FULL:
      return r'FULL';
    case Enum$AggregationLevel.$unknown:
      return r'$unknown';
  }
}

Enum$AggregationLevel fromJson$Enum$AggregationLevel(String value) {
  switch (value) {
    case r'NONE':
      return Enum$AggregationLevel.NONE;
    case r'RECORDING':
      return Enum$AggregationLevel.RECORDING;
    case r'WORK':
      return Enum$AggregationLevel.WORK;
    case r'FULL':
      return Enum$AggregationLevel.FULL;
    default:
      return Enum$AggregationLevel.$unknown;
  }
}

enum Enum$AlbumType {
  ALBUM,
  SINGLE,
  EP,
  COMPILATION,
  REMIX,
  LIVE,
  SOUNDTRACK,
  $unknown;

  factory Enum$AlbumType.fromJson(String value) =>
      fromJson$Enum$AlbumType(value);

  String toJson() => toJson$Enum$AlbumType(this);
}

String toJson$Enum$AlbumType(Enum$AlbumType e) {
  switch (e) {
    case Enum$AlbumType.ALBUM:
      return r'ALBUM';
    case Enum$AlbumType.SINGLE:
      return r'SINGLE';
    case Enum$AlbumType.EP:
      return r'EP';
    case Enum$AlbumType.COMPILATION:
      return r'COMPILATION';
    case Enum$AlbumType.REMIX:
      return r'REMIX';
    case Enum$AlbumType.LIVE:
      return r'LIVE';
    case Enum$AlbumType.SOUNDTRACK:
      return r'SOUNDTRACK';
    case Enum$AlbumType.$unknown:
      return r'$unknown';
  }
}

Enum$AlbumType fromJson$Enum$AlbumType(String value) {
  switch (value) {
    case r'ALBUM':
      return Enum$AlbumType.ALBUM;
    case r'SINGLE':
      return Enum$AlbumType.SINGLE;
    case r'EP':
      return Enum$AlbumType.EP;
    case r'COMPILATION':
      return Enum$AlbumType.COMPILATION;
    case r'REMIX':
      return Enum$AlbumType.REMIX;
    case r'LIVE':
      return Enum$AlbumType.LIVE;
    case r'SOUNDTRACK':
      return Enum$AlbumType.SOUNDTRACK;
    default:
      return Enum$AlbumType.$unknown;
  }
}

enum Enum$ApplyPolicy {
  BEFORE_RESOLVER,
  AFTER_RESOLVER,
  VALIDATION,
  $unknown;

  factory Enum$ApplyPolicy.fromJson(String value) =>
      fromJson$Enum$ApplyPolicy(value);

  String toJson() => toJson$Enum$ApplyPolicy(this);
}

String toJson$Enum$ApplyPolicy(Enum$ApplyPolicy e) {
  switch (e) {
    case Enum$ApplyPolicy.BEFORE_RESOLVER:
      return r'BEFORE_RESOLVER';
    case Enum$ApplyPolicy.AFTER_RESOLVER:
      return r'AFTER_RESOLVER';
    case Enum$ApplyPolicy.VALIDATION:
      return r'VALIDATION';
    case Enum$ApplyPolicy.$unknown:
      return r'$unknown';
  }
}

Enum$ApplyPolicy fromJson$Enum$ApplyPolicy(String value) {
  switch (value) {
    case r'BEFORE_RESOLVER':
      return Enum$ApplyPolicy.BEFORE_RESOLVER;
    case r'AFTER_RESOLVER':
      return Enum$ApplyPolicy.AFTER_RESOLVER;
    case r'VALIDATION':
      return Enum$ApplyPolicy.VALIDATION;
    default:
      return Enum$ApplyPolicy.$unknown;
  }
}

enum Enum$ApprovalType {
  TRACK_UPLOAD,
  WORK_UPLOAD,
  RECORDING_UPLOAD,
  ARTIST_REGISTRATION,
  $unknown;

  factory Enum$ApprovalType.fromJson(String value) =>
      fromJson$Enum$ApprovalType(value);

  String toJson() => toJson$Enum$ApprovalType(this);
}

String toJson$Enum$ApprovalType(Enum$ApprovalType e) {
  switch (e) {
    case Enum$ApprovalType.TRACK_UPLOAD:
      return r'TRACK_UPLOAD';
    case Enum$ApprovalType.WORK_UPLOAD:
      return r'WORK_UPLOAD';
    case Enum$ApprovalType.RECORDING_UPLOAD:
      return r'RECORDING_UPLOAD';
    case Enum$ApprovalType.ARTIST_REGISTRATION:
      return r'ARTIST_REGISTRATION';
    case Enum$ApprovalType.$unknown:
      return r'$unknown';
  }
}

Enum$ApprovalType fromJson$Enum$ApprovalType(String value) {
  switch (value) {
    case r'TRACK_UPLOAD':
      return Enum$ApprovalType.TRACK_UPLOAD;
    case r'WORK_UPLOAD':
      return Enum$ApprovalType.WORK_UPLOAD;
    case r'RECORDING_UPLOAD':
      return Enum$ApprovalType.RECORDING_UPLOAD;
    case r'ARTIST_REGISTRATION':
      return Enum$ApprovalType.ARTIST_REGISTRATION;
    default:
      return Enum$ApprovalType.$unknown;
  }
}

enum Enum$ArtistPackageStatus {
  ENABLED,
  DISABLED,
  $unknown;

  factory Enum$ArtistPackageStatus.fromJson(String value) =>
      fromJson$Enum$ArtistPackageStatus(value);

  String toJson() => toJson$Enum$ArtistPackageStatus(this);
}

String toJson$Enum$ArtistPackageStatus(Enum$ArtistPackageStatus e) {
  switch (e) {
    case Enum$ArtistPackageStatus.ENABLED:
      return r'ENABLED';
    case Enum$ArtistPackageStatus.DISABLED:
      return r'DISABLED';
    case Enum$ArtistPackageStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ArtistPackageStatus fromJson$Enum$ArtistPackageStatus(String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$ArtistPackageStatus.ENABLED;
    case r'DISABLED':
      return Enum$ArtistPackageStatus.DISABLED;
    default:
      return Enum$ArtistPackageStatus.$unknown;
  }
}

enum Enum$ArtistRole {
  MAIN,
  FEATURED,
  REMIXER,
  COMPOSER,
  $unknown;

  factory Enum$ArtistRole.fromJson(String value) =>
      fromJson$Enum$ArtistRole(value);

  String toJson() => toJson$Enum$ArtistRole(this);
}

String toJson$Enum$ArtistRole(Enum$ArtistRole e) {
  switch (e) {
    case Enum$ArtistRole.MAIN:
      return r'MAIN';
    case Enum$ArtistRole.FEATURED:
      return r'FEATURED';
    case Enum$ArtistRole.REMIXER:
      return r'REMIXER';
    case Enum$ArtistRole.COMPOSER:
      return r'COMPOSER';
    case Enum$ArtistRole.$unknown:
      return r'$unknown';
  }
}

Enum$ArtistRole fromJson$Enum$ArtistRole(String value) {
  switch (value) {
    case r'MAIN':
      return Enum$ArtistRole.MAIN;
    case r'FEATURED':
      return Enum$ArtistRole.FEATURED;
    case r'REMIXER':
      return Enum$ArtistRole.REMIXER;
    case r'COMPOSER':
      return Enum$ArtistRole.COMPOSER;
    default:
      return Enum$ArtistRole.$unknown;
  }
}

enum Enum$ArtistType {
  INDIVIDUAL,
  GROUP,
  BAND,
  $unknown;

  factory Enum$ArtistType.fromJson(String value) =>
      fromJson$Enum$ArtistType(value);

  String toJson() => toJson$Enum$ArtistType(this);
}

String toJson$Enum$ArtistType(Enum$ArtistType e) {
  switch (e) {
    case Enum$ArtistType.INDIVIDUAL:
      return r'INDIVIDUAL';
    case Enum$ArtistType.GROUP:
      return r'GROUP';
    case Enum$ArtistType.BAND:
      return r'BAND';
    case Enum$ArtistType.$unknown:
      return r'$unknown';
  }
}

Enum$ArtistType fromJson$Enum$ArtistType(String value) {
  switch (value) {
    case r'INDIVIDUAL':
      return Enum$ArtistType.INDIVIDUAL;
    case r'GROUP':
      return Enum$ArtistType.GROUP;
    case r'BAND':
      return Enum$ArtistType.BAND;
    default:
      return Enum$ArtistType.$unknown;
  }
}

enum Enum$AudioFormat {
  MP3,
  WAV,
  $unknown;

  factory Enum$AudioFormat.fromJson(String value) =>
      fromJson$Enum$AudioFormat(value);

  String toJson() => toJson$Enum$AudioFormat(this);
}

String toJson$Enum$AudioFormat(Enum$AudioFormat e) {
  switch (e) {
    case Enum$AudioFormat.MP3:
      return r'MP3';
    case Enum$AudioFormat.WAV:
      return r'WAV';
    case Enum$AudioFormat.$unknown:
      return r'$unknown';
  }
}

Enum$AudioFormat fromJson$Enum$AudioFormat(String value) {
  switch (value) {
    case r'MP3':
      return Enum$AudioFormat.MP3;
    case r'WAV':
      return Enum$AudioFormat.WAV;
    default:
      return Enum$AudioFormat.$unknown;
  }
}

enum Enum$BillingPortalConfigStatus {
  INACTIVE,
  ACTIVE,
  DEPRECATED,
  $unknown;

  factory Enum$BillingPortalConfigStatus.fromJson(String value) =>
      fromJson$Enum$BillingPortalConfigStatus(value);

  String toJson() => toJson$Enum$BillingPortalConfigStatus(this);
}

String toJson$Enum$BillingPortalConfigStatus(Enum$BillingPortalConfigStatus e) {
  switch (e) {
    case Enum$BillingPortalConfigStatus.INACTIVE:
      return r'INACTIVE';
    case Enum$BillingPortalConfigStatus.ACTIVE:
      return r'ACTIVE';
    case Enum$BillingPortalConfigStatus.DEPRECATED:
      return r'DEPRECATED';
    case Enum$BillingPortalConfigStatus.$unknown:
      return r'$unknown';
  }
}

Enum$BillingPortalConfigStatus fromJson$Enum$BillingPortalConfigStatus(
  String value,
) {
  switch (value) {
    case r'INACTIVE':
      return Enum$BillingPortalConfigStatus.INACTIVE;
    case r'ACTIVE':
      return Enum$BillingPortalConfigStatus.ACTIVE;
    case r'DEPRECATED':
      return Enum$BillingPortalConfigStatus.DEPRECATED;
    default:
      return Enum$BillingPortalConfigStatus.$unknown;
  }
}

enum Enum$CategoryType {
  GENRE,
  MOOD,
  $unknown;

  factory Enum$CategoryType.fromJson(String value) =>
      fromJson$Enum$CategoryType(value);

  String toJson() => toJson$Enum$CategoryType(this);
}

String toJson$Enum$CategoryType(Enum$CategoryType e) {
  switch (e) {
    case Enum$CategoryType.GENRE:
      return r'GENRE';
    case Enum$CategoryType.MOOD:
      return r'MOOD';
    case Enum$CategoryType.$unknown:
      return r'$unknown';
  }
}

Enum$CategoryType fromJson$Enum$CategoryType(String value) {
  switch (value) {
    case r'GENRE':
      return Enum$CategoryType.GENRE;
    case r'MOOD':
      return Enum$CategoryType.MOOD;
    default:
      return Enum$CategoryType.$unknown;
  }
}

enum Enum$CommentSortOrder {
  CHRONOLOGICAL,
  THREAD_ACTIVITY,
  POPULARITY_BASED,
  REVERSE_CHRONOLOGICAL,
  $unknown;

  factory Enum$CommentSortOrder.fromJson(String value) =>
      fromJson$Enum$CommentSortOrder(value);

  String toJson() => toJson$Enum$CommentSortOrder(this);
}

String toJson$Enum$CommentSortOrder(Enum$CommentSortOrder e) {
  switch (e) {
    case Enum$CommentSortOrder.CHRONOLOGICAL:
      return r'CHRONOLOGICAL';
    case Enum$CommentSortOrder.THREAD_ACTIVITY:
      return r'THREAD_ACTIVITY';
    case Enum$CommentSortOrder.POPULARITY_BASED:
      return r'POPULARITY_BASED';
    case Enum$CommentSortOrder.REVERSE_CHRONOLOGICAL:
      return r'REVERSE_CHRONOLOGICAL';
    case Enum$CommentSortOrder.$unknown:
      return r'$unknown';
  }
}

Enum$CommentSortOrder fromJson$Enum$CommentSortOrder(String value) {
  switch (value) {
    case r'CHRONOLOGICAL':
      return Enum$CommentSortOrder.CHRONOLOGICAL;
    case r'THREAD_ACTIVITY':
      return Enum$CommentSortOrder.THREAD_ACTIVITY;
    case r'POPULARITY_BASED':
      return Enum$CommentSortOrder.POPULARITY_BASED;
    case r'REVERSE_CHRONOLOGICAL':
      return Enum$CommentSortOrder.REVERSE_CHRONOLOGICAL;
    default:
      return Enum$CommentSortOrder.$unknown;
  }
}

enum Enum$CommentType {
  TRACK,
  PLAYLIST,
  ALBUM,
  REQUEST,
  $unknown;

  factory Enum$CommentType.fromJson(String value) =>
      fromJson$Enum$CommentType(value);

  String toJson() => toJson$Enum$CommentType(this);
}

String toJson$Enum$CommentType(Enum$CommentType e) {
  switch (e) {
    case Enum$CommentType.TRACK:
      return r'TRACK';
    case Enum$CommentType.PLAYLIST:
      return r'PLAYLIST';
    case Enum$CommentType.ALBUM:
      return r'ALBUM';
    case Enum$CommentType.REQUEST:
      return r'REQUEST';
    case Enum$CommentType.$unknown:
      return r'$unknown';
  }
}

Enum$CommentType fromJson$Enum$CommentType(String value) {
  switch (value) {
    case r'TRACK':
      return Enum$CommentType.TRACK;
    case r'PLAYLIST':
      return Enum$CommentType.PLAYLIST;
    case r'ALBUM':
      return Enum$CommentType.ALBUM;
    case r'REQUEST':
      return Enum$CommentType.REQUEST;
    default:
      return Enum$CommentType.$unknown;
  }
}

enum Enum$ConversationStatus {
  NONE,
  PENDING,
  CANCELLED,
  IN_PROGRESS,
  COMPLETED,
  $unknown;

  factory Enum$ConversationStatus.fromJson(String value) =>
      fromJson$Enum$ConversationStatus(value);

  String toJson() => toJson$Enum$ConversationStatus(this);
}

String toJson$Enum$ConversationStatus(Enum$ConversationStatus e) {
  switch (e) {
    case Enum$ConversationStatus.NONE:
      return r'NONE';
    case Enum$ConversationStatus.PENDING:
      return r'PENDING';
    case Enum$ConversationStatus.CANCELLED:
      return r'CANCELLED';
    case Enum$ConversationStatus.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$ConversationStatus.COMPLETED:
      return r'COMPLETED';
    case Enum$ConversationStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ConversationStatus fromJson$Enum$ConversationStatus(String value) {
  switch (value) {
    case r'NONE':
      return Enum$ConversationStatus.NONE;
    case r'PENDING':
      return Enum$ConversationStatus.PENDING;
    case r'CANCELLED':
      return Enum$ConversationStatus.CANCELLED;
    case r'IN_PROGRESS':
      return Enum$ConversationStatus.IN_PROGRESS;
    case r'COMPLETED':
      return Enum$ConversationStatus.COMPLETED;
    default:
      return Enum$ConversationStatus.$unknown;
  }
}

enum Enum$CouponDurationType {
  REPEATING,
  FOREVER,
  ONCE,
  $unknown;

  factory Enum$CouponDurationType.fromJson(String value) =>
      fromJson$Enum$CouponDurationType(value);

  String toJson() => toJson$Enum$CouponDurationType(this);
}

String toJson$Enum$CouponDurationType(Enum$CouponDurationType e) {
  switch (e) {
    case Enum$CouponDurationType.REPEATING:
      return r'REPEATING';
    case Enum$CouponDurationType.FOREVER:
      return r'FOREVER';
    case Enum$CouponDurationType.ONCE:
      return r'ONCE';
    case Enum$CouponDurationType.$unknown:
      return r'$unknown';
  }
}

Enum$CouponDurationType fromJson$Enum$CouponDurationType(String value) {
  switch (value) {
    case r'REPEATING':
      return Enum$CouponDurationType.REPEATING;
    case r'FOREVER':
      return Enum$CouponDurationType.FOREVER;
    case r'ONCE':
      return Enum$CouponDurationType.ONCE;
    default:
      return Enum$CouponDurationType.$unknown;
  }
}

enum Enum$CouponPurposeType {
  GENERAL,
  AUTO_SERVICE,
  ANNUAL_PLAN_DISCOUNT,
  $unknown;

  factory Enum$CouponPurposeType.fromJson(String value) =>
      fromJson$Enum$CouponPurposeType(value);

  String toJson() => toJson$Enum$CouponPurposeType(this);
}

String toJson$Enum$CouponPurposeType(Enum$CouponPurposeType e) {
  switch (e) {
    case Enum$CouponPurposeType.GENERAL:
      return r'GENERAL';
    case Enum$CouponPurposeType.AUTO_SERVICE:
      return r'AUTO_SERVICE';
    case Enum$CouponPurposeType.ANNUAL_PLAN_DISCOUNT:
      return r'ANNUAL_PLAN_DISCOUNT';
    case Enum$CouponPurposeType.$unknown:
      return r'$unknown';
  }
}

Enum$CouponPurposeType fromJson$Enum$CouponPurposeType(String value) {
  switch (value) {
    case r'GENERAL':
      return Enum$CouponPurposeType.GENERAL;
    case r'AUTO_SERVICE':
      return Enum$CouponPurposeType.AUTO_SERVICE;
    case r'ANNUAL_PLAN_DISCOUNT':
      return Enum$CouponPurposeType.ANNUAL_PLAN_DISCOUNT;
    default:
      return Enum$CouponPurposeType.$unknown;
  }
}

enum Enum$CouponStatus {
  ACTIVE,
  INACTIVE,
  EXPIRED,
  DEPRECATED,
  $unknown;

  factory Enum$CouponStatus.fromJson(String value) =>
      fromJson$Enum$CouponStatus(value);

  String toJson() => toJson$Enum$CouponStatus(this);
}

String toJson$Enum$CouponStatus(Enum$CouponStatus e) {
  switch (e) {
    case Enum$CouponStatus.ACTIVE:
      return r'ACTIVE';
    case Enum$CouponStatus.INACTIVE:
      return r'INACTIVE';
    case Enum$CouponStatus.EXPIRED:
      return r'EXPIRED';
    case Enum$CouponStatus.DEPRECATED:
      return r'DEPRECATED';
    case Enum$CouponStatus.$unknown:
      return r'$unknown';
  }
}

Enum$CouponStatus fromJson$Enum$CouponStatus(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$CouponStatus.ACTIVE;
    case r'INACTIVE':
      return Enum$CouponStatus.INACTIVE;
    case r'EXPIRED':
      return Enum$CouponStatus.EXPIRED;
    case r'DEPRECATED':
      return Enum$CouponStatus.DEPRECATED;
    default:
      return Enum$CouponStatus.$unknown;
  }
}

enum Enum$CurrencyType {
  VND,
  USD,
  SGP,
  SGD,
  EUR,
  GBP,
  JPY,
  AUD,
  CAD,
  CHF,
  CNY,
  SEK,
  NZD,
  $unknown;

  factory Enum$CurrencyType.fromJson(String value) =>
      fromJson$Enum$CurrencyType(value);

  String toJson() => toJson$Enum$CurrencyType(this);
}

String toJson$Enum$CurrencyType(Enum$CurrencyType e) {
  switch (e) {
    case Enum$CurrencyType.VND:
      return r'VND';
    case Enum$CurrencyType.USD:
      return r'USD';
    case Enum$CurrencyType.SGP:
      return r'SGP';
    case Enum$CurrencyType.SGD:
      return r'SGD';
    case Enum$CurrencyType.EUR:
      return r'EUR';
    case Enum$CurrencyType.GBP:
      return r'GBP';
    case Enum$CurrencyType.JPY:
      return r'JPY';
    case Enum$CurrencyType.AUD:
      return r'AUD';
    case Enum$CurrencyType.CAD:
      return r'CAD';
    case Enum$CurrencyType.CHF:
      return r'CHF';
    case Enum$CurrencyType.CNY:
      return r'CNY';
    case Enum$CurrencyType.SEK:
      return r'SEK';
    case Enum$CurrencyType.NZD:
      return r'NZD';
    case Enum$CurrencyType.$unknown:
      return r'$unknown';
  }
}

Enum$CurrencyType fromJson$Enum$CurrencyType(String value) {
  switch (value) {
    case r'VND':
      return Enum$CurrencyType.VND;
    case r'USD':
      return Enum$CurrencyType.USD;
    case r'SGP':
      return Enum$CurrencyType.SGP;
    case r'SGD':
      return Enum$CurrencyType.SGD;
    case r'EUR':
      return Enum$CurrencyType.EUR;
    case r'GBP':
      return Enum$CurrencyType.GBP;
    case r'JPY':
      return Enum$CurrencyType.JPY;
    case r'AUD':
      return Enum$CurrencyType.AUD;
    case r'CAD':
      return Enum$CurrencyType.CAD;
    case r'CHF':
      return Enum$CurrencyType.CHF;
    case r'CNY':
      return Enum$CurrencyType.CNY;
    case r'SEK':
      return Enum$CurrencyType.SEK;
    case r'NZD':
      return Enum$CurrencyType.NZD;
    default:
      return Enum$CurrencyType.$unknown;
  }
}

enum Enum$CustomerUpdate {
  ADDRESS,
  EMAIL,
  PHONE,
  SHIPPING,
  TAX_ID,
  $unknown;

  factory Enum$CustomerUpdate.fromJson(String value) =>
      fromJson$Enum$CustomerUpdate(value);

  String toJson() => toJson$Enum$CustomerUpdate(this);
}

String toJson$Enum$CustomerUpdate(Enum$CustomerUpdate e) {
  switch (e) {
    case Enum$CustomerUpdate.ADDRESS:
      return r'ADDRESS';
    case Enum$CustomerUpdate.EMAIL:
      return r'EMAIL';
    case Enum$CustomerUpdate.PHONE:
      return r'PHONE';
    case Enum$CustomerUpdate.SHIPPING:
      return r'SHIPPING';
    case Enum$CustomerUpdate.TAX_ID:
      return r'TAX_ID';
    case Enum$CustomerUpdate.$unknown:
      return r'$unknown';
  }
}

Enum$CustomerUpdate fromJson$Enum$CustomerUpdate(String value) {
  switch (value) {
    case r'ADDRESS':
      return Enum$CustomerUpdate.ADDRESS;
    case r'EMAIL':
      return Enum$CustomerUpdate.EMAIL;
    case r'PHONE':
      return Enum$CustomerUpdate.PHONE;
    case r'SHIPPING':
      return Enum$CustomerUpdate.SHIPPING;
    case r'TAX_ID':
      return Enum$CustomerUpdate.TAX_ID;
    default:
      return Enum$CustomerUpdate.$unknown;
  }
}

enum Enum$DocumentType {
  LICENSE,
  CONTRACT,
  CERTIFICATE,
  OTHER,
  $unknown;

  factory Enum$DocumentType.fromJson(String value) =>
      fromJson$Enum$DocumentType(value);

  String toJson() => toJson$Enum$DocumentType(this);
}

String toJson$Enum$DocumentType(Enum$DocumentType e) {
  switch (e) {
    case Enum$DocumentType.LICENSE:
      return r'LICENSE';
    case Enum$DocumentType.CONTRACT:
      return r'CONTRACT';
    case Enum$DocumentType.CERTIFICATE:
      return r'CERTIFICATE';
    case Enum$DocumentType.OTHER:
      return r'OTHER';
    case Enum$DocumentType.$unknown:
      return r'$unknown';
  }
}

Enum$DocumentType fromJson$Enum$DocumentType(String value) {
  switch (value) {
    case r'LICENSE':
      return Enum$DocumentType.LICENSE;
    case r'CONTRACT':
      return Enum$DocumentType.CONTRACT;
    case r'CERTIFICATE':
      return Enum$DocumentType.CERTIFICATE;
    case r'OTHER':
      return Enum$DocumentType.OTHER;
    default:
      return Enum$DocumentType.$unknown;
  }
}

enum Enum$EntitlementValueType {
  STRING,
  INT,
  DECIMAL,
  LONG,
  DOUBLE,
  BOOLEAN,
  DATE_TIME,
  OBJECT,
  ARRAY,
  $unknown;

  factory Enum$EntitlementValueType.fromJson(String value) =>
      fromJson$Enum$EntitlementValueType(value);

  String toJson() => toJson$Enum$EntitlementValueType(this);
}

String toJson$Enum$EntitlementValueType(Enum$EntitlementValueType e) {
  switch (e) {
    case Enum$EntitlementValueType.STRING:
      return r'STRING';
    case Enum$EntitlementValueType.INT:
      return r'INT';
    case Enum$EntitlementValueType.DECIMAL:
      return r'DECIMAL';
    case Enum$EntitlementValueType.LONG:
      return r'LONG';
    case Enum$EntitlementValueType.DOUBLE:
      return r'DOUBLE';
    case Enum$EntitlementValueType.BOOLEAN:
      return r'BOOLEAN';
    case Enum$EntitlementValueType.DATE_TIME:
      return r'DATE_TIME';
    case Enum$EntitlementValueType.OBJECT:
      return r'OBJECT';
    case Enum$EntitlementValueType.ARRAY:
      return r'ARRAY';
    case Enum$EntitlementValueType.$unknown:
      return r'$unknown';
  }
}

Enum$EntitlementValueType fromJson$Enum$EntitlementValueType(String value) {
  switch (value) {
    case r'STRING':
      return Enum$EntitlementValueType.STRING;
    case r'INT':
      return Enum$EntitlementValueType.INT;
    case r'DECIMAL':
      return Enum$EntitlementValueType.DECIMAL;
    case r'LONG':
      return Enum$EntitlementValueType.LONG;
    case r'DOUBLE':
      return Enum$EntitlementValueType.DOUBLE;
    case r'BOOLEAN':
      return Enum$EntitlementValueType.BOOLEAN;
    case r'DATE_TIME':
      return Enum$EntitlementValueType.DATE_TIME;
    case r'OBJECT':
      return Enum$EntitlementValueType.OBJECT;
    case r'ARRAY':
      return Enum$EntitlementValueType.ARRAY;
    default:
      return Enum$EntitlementValueType.$unknown;
  }
}

enum Enum$HistoryActionType {
  APPROVED,
  REJECTED,
  REQUEST_CHANGE,
  DISMISSED,
  $unknown;

  factory Enum$HistoryActionType.fromJson(String value) =>
      fromJson$Enum$HistoryActionType(value);

  String toJson() => toJson$Enum$HistoryActionType(this);
}

String toJson$Enum$HistoryActionType(Enum$HistoryActionType e) {
  switch (e) {
    case Enum$HistoryActionType.APPROVED:
      return r'APPROVED';
    case Enum$HistoryActionType.REJECTED:
      return r'REJECTED';
    case Enum$HistoryActionType.REQUEST_CHANGE:
      return r'REQUEST_CHANGE';
    case Enum$HistoryActionType.DISMISSED:
      return r'DISMISSED';
    case Enum$HistoryActionType.$unknown:
      return r'$unknown';
  }
}

Enum$HistoryActionType fromJson$Enum$HistoryActionType(String value) {
  switch (value) {
    case r'APPROVED':
      return Enum$HistoryActionType.APPROVED;
    case r'REJECTED':
      return Enum$HistoryActionType.REJECTED;
    case r'REQUEST_CHANGE':
      return Enum$HistoryActionType.REQUEST_CHANGE;
    case r'DISMISSED':
      return Enum$HistoryActionType.DISMISSED;
    default:
      return Enum$HistoryActionType.$unknown;
  }
}

enum Enum$ImageTag {
  USERS_PROFILE,
  $unknown;

  factory Enum$ImageTag.fromJson(String value) => fromJson$Enum$ImageTag(value);

  String toJson() => toJson$Enum$ImageTag(this);
}

String toJson$Enum$ImageTag(Enum$ImageTag e) {
  switch (e) {
    case Enum$ImageTag.USERS_PROFILE:
      return r'USERS_PROFILE';
    case Enum$ImageTag.$unknown:
      return r'$unknown';
  }
}

Enum$ImageTag fromJson$Enum$ImageTag(String value) {
  switch (value) {
    case r'USERS_PROFILE':
      return Enum$ImageTag.USERS_PROFILE;
    default:
      return Enum$ImageTag.$unknown;
  }
}

enum Enum$KeyTag {
  DELETE,
  $unknown;

  factory Enum$KeyTag.fromJson(String value) => fromJson$Enum$KeyTag(value);

  String toJson() => toJson$Enum$KeyTag(this);
}

String toJson$Enum$KeyTag(Enum$KeyTag e) {
  switch (e) {
    case Enum$KeyTag.DELETE:
      return r'DELETE';
    case Enum$KeyTag.$unknown:
      return r'$unknown';
  }
}

Enum$KeyTag fromJson$Enum$KeyTag(String value) {
  switch (value) {
    case r'DELETE':
      return Enum$KeyTag.DELETE;
    default:
      return Enum$KeyTag.$unknown;
  }
}

enum Enum$MoodType {
  HAPPY,
  CALM,
  SAD,
  ANGRY,
  RELAXED,
  ENERGETIC,
  DARK,
  ROMANTIC,
  CHILL,
  $unknown;

  factory Enum$MoodType.fromJson(String value) => fromJson$Enum$MoodType(value);

  String toJson() => toJson$Enum$MoodType(this);
}

String toJson$Enum$MoodType(Enum$MoodType e) {
  switch (e) {
    case Enum$MoodType.HAPPY:
      return r'HAPPY';
    case Enum$MoodType.CALM:
      return r'CALM';
    case Enum$MoodType.SAD:
      return r'SAD';
    case Enum$MoodType.ANGRY:
      return r'ANGRY';
    case Enum$MoodType.RELAXED:
      return r'RELAXED';
    case Enum$MoodType.ENERGETIC:
      return r'ENERGETIC';
    case Enum$MoodType.DARK:
      return r'DARK';
    case Enum$MoodType.ROMANTIC:
      return r'ROMANTIC';
    case Enum$MoodType.CHILL:
      return r'CHILL';
    case Enum$MoodType.$unknown:
      return r'$unknown';
  }
}

Enum$MoodType fromJson$Enum$MoodType(String value) {
  switch (value) {
    case r'HAPPY':
      return Enum$MoodType.HAPPY;
    case r'CALM':
      return Enum$MoodType.CALM;
    case r'SAD':
      return Enum$MoodType.SAD;
    case r'ANGRY':
      return Enum$MoodType.ANGRY;
    case r'RELAXED':
      return Enum$MoodType.RELAXED;
    case r'ENERGETIC':
      return Enum$MoodType.ENERGETIC;
    case r'DARK':
      return Enum$MoodType.DARK;
    case r'ROMANTIC':
      return Enum$MoodType.ROMANTIC;
    case r'CHILL':
      return Enum$MoodType.CHILL;
    default:
      return Enum$MoodType.$unknown;
  }
}

enum Enum$OneOffType {
  PAYMENT,
  REFUND,
  $unknown;

  factory Enum$OneOffType.fromJson(String value) =>
      fromJson$Enum$OneOffType(value);

  String toJson() => toJson$Enum$OneOffType(this);
}

String toJson$Enum$OneOffType(Enum$OneOffType e) {
  switch (e) {
    case Enum$OneOffType.PAYMENT:
      return r'PAYMENT';
    case Enum$OneOffType.REFUND:
      return r'REFUND';
    case Enum$OneOffType.$unknown:
      return r'$unknown';
  }
}

Enum$OneOffType fromJson$Enum$OneOffType(String value) {
  switch (value) {
    case r'PAYMENT':
      return Enum$OneOffType.PAYMENT;
    case r'REFUND':
      return Enum$OneOffType.REFUND;
    default:
      return Enum$OneOffType.$unknown;
  }
}

enum Enum$PackageOrderStatus {
  CANCELLED,
  REFUND,
  IN_PROGRESS,
  PAID,
  DISPUTED,
  DISPERSED,
  $unknown;

  factory Enum$PackageOrderStatus.fromJson(String value) =>
      fromJson$Enum$PackageOrderStatus(value);

  String toJson() => toJson$Enum$PackageOrderStatus(this);
}

String toJson$Enum$PackageOrderStatus(Enum$PackageOrderStatus e) {
  switch (e) {
    case Enum$PackageOrderStatus.CANCELLED:
      return r'CANCELLED';
    case Enum$PackageOrderStatus.REFUND:
      return r'REFUND';
    case Enum$PackageOrderStatus.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$PackageOrderStatus.PAID:
      return r'PAID';
    case Enum$PackageOrderStatus.DISPUTED:
      return r'DISPUTED';
    case Enum$PackageOrderStatus.DISPERSED:
      return r'DISPERSED';
    case Enum$PackageOrderStatus.$unknown:
      return r'$unknown';
  }
}

Enum$PackageOrderStatus fromJson$Enum$PackageOrderStatus(String value) {
  switch (value) {
    case r'CANCELLED':
      return Enum$PackageOrderStatus.CANCELLED;
    case r'REFUND':
      return Enum$PackageOrderStatus.REFUND;
    case r'IN_PROGRESS':
      return Enum$PackageOrderStatus.IN_PROGRESS;
    case r'PAID':
      return Enum$PackageOrderStatus.PAID;
    case r'DISPUTED':
      return Enum$PackageOrderStatus.DISPUTED;
    case r'DISPERSED':
      return Enum$PackageOrderStatus.DISPERSED;
    default:
      return Enum$PackageOrderStatus.$unknown;
  }
}

enum Enum$PathTag {
  BASE,
  API,
  TOOLS,
  PRIVATE_KEYS,
  BIN,
  $unknown;

  factory Enum$PathTag.fromJson(String value) => fromJson$Enum$PathTag(value);

  String toJson() => toJson$Enum$PathTag(this);
}

String toJson$Enum$PathTag(Enum$PathTag e) {
  switch (e) {
    case Enum$PathTag.BASE:
      return r'BASE';
    case Enum$PathTag.API:
      return r'API';
    case Enum$PathTag.TOOLS:
      return r'TOOLS';
    case Enum$PathTag.PRIVATE_KEYS:
      return r'PRIVATE_KEYS';
    case Enum$PathTag.BIN:
      return r'BIN';
    case Enum$PathTag.$unknown:
      return r'$unknown';
  }
}

Enum$PathTag fromJson$Enum$PathTag(String value) {
  switch (value) {
    case r'BASE':
      return Enum$PathTag.BASE;
    case r'API':
      return Enum$PathTag.API;
    case r'TOOLS':
      return Enum$PathTag.TOOLS;
    case r'PRIVATE_KEYS':
      return Enum$PathTag.PRIVATE_KEYS;
    case r'BIN':
      return Enum$PathTag.BIN;
    default:
      return Enum$PathTag.$unknown;
  }
}

enum Enum$PaymentMethodType {
  CARD,
  LINK,
  $unknown;

  factory Enum$PaymentMethodType.fromJson(String value) =>
      fromJson$Enum$PaymentMethodType(value);

  String toJson() => toJson$Enum$PaymentMethodType(this);
}

String toJson$Enum$PaymentMethodType(Enum$PaymentMethodType e) {
  switch (e) {
    case Enum$PaymentMethodType.CARD:
      return r'CARD';
    case Enum$PaymentMethodType.LINK:
      return r'LINK';
    case Enum$PaymentMethodType.$unknown:
      return r'$unknown';
  }
}

Enum$PaymentMethodType fromJson$Enum$PaymentMethodType(String value) {
  switch (value) {
    case r'CARD':
      return Enum$PaymentMethodType.CARD;
    case r'LINK':
      return Enum$PaymentMethodType.LINK;
    default:
      return Enum$PaymentMethodType.$unknown;
  }
}

enum Enum$PaymentTransactionStatus {
  PENDING,
  PAID,
  UNPAID,
  $unknown;

  factory Enum$PaymentTransactionStatus.fromJson(String value) =>
      fromJson$Enum$PaymentTransactionStatus(value);

  String toJson() => toJson$Enum$PaymentTransactionStatus(this);
}

String toJson$Enum$PaymentTransactionStatus(Enum$PaymentTransactionStatus e) {
  switch (e) {
    case Enum$PaymentTransactionStatus.PENDING:
      return r'PENDING';
    case Enum$PaymentTransactionStatus.PAID:
      return r'PAID';
    case Enum$PaymentTransactionStatus.UNPAID:
      return r'UNPAID';
    case Enum$PaymentTransactionStatus.$unknown:
      return r'$unknown';
  }
}

Enum$PaymentTransactionStatus fromJson$Enum$PaymentTransactionStatus(
  String value,
) {
  switch (value) {
    case r'PENDING':
      return Enum$PaymentTransactionStatus.PENDING;
    case r'PAID':
      return Enum$PaymentTransactionStatus.PAID;
    case r'UNPAID':
      return Enum$PaymentTransactionStatus.UNPAID;
    default:
      return Enum$PaymentTransactionStatus.$unknown;
  }
}

enum Enum$PayoutTransactionStatus {
  PENDING,
  PAID,
  FAILED,
  CANCELED,
  IN_TRANSIT,
  $unknown;

  factory Enum$PayoutTransactionStatus.fromJson(String value) =>
      fromJson$Enum$PayoutTransactionStatus(value);

  String toJson() => toJson$Enum$PayoutTransactionStatus(this);
}

String toJson$Enum$PayoutTransactionStatus(Enum$PayoutTransactionStatus e) {
  switch (e) {
    case Enum$PayoutTransactionStatus.PENDING:
      return r'PENDING';
    case Enum$PayoutTransactionStatus.PAID:
      return r'PAID';
    case Enum$PayoutTransactionStatus.FAILED:
      return r'FAILED';
    case Enum$PayoutTransactionStatus.CANCELED:
      return r'CANCELED';
    case Enum$PayoutTransactionStatus.IN_TRANSIT:
      return r'IN_TRANSIT';
    case Enum$PayoutTransactionStatus.$unknown:
      return r'$unknown';
  }
}

Enum$PayoutTransactionStatus fromJson$Enum$PayoutTransactionStatus(
  String value,
) {
  switch (value) {
    case r'PENDING':
      return Enum$PayoutTransactionStatus.PENDING;
    case r'PAID':
      return Enum$PayoutTransactionStatus.PAID;
    case r'FAILED':
      return Enum$PayoutTransactionStatus.FAILED;
    case r'CANCELED':
      return Enum$PayoutTransactionStatus.CANCELED;
    case r'IN_TRANSIT':
      return Enum$PayoutTransactionStatus.IN_TRANSIT;
    default:
      return Enum$PayoutTransactionStatus.$unknown;
  }
}

enum Enum$PeriodTime {
  DAY,
  WEEK,
  MONTH,
  YEAR,
  $unknown;

  factory Enum$PeriodTime.fromJson(String value) =>
      fromJson$Enum$PeriodTime(value);

  String toJson() => toJson$Enum$PeriodTime(this);
}

String toJson$Enum$PeriodTime(Enum$PeriodTime e) {
  switch (e) {
    case Enum$PeriodTime.DAY:
      return r'DAY';
    case Enum$PeriodTime.WEEK:
      return r'WEEK';
    case Enum$PeriodTime.MONTH:
      return r'MONTH';
    case Enum$PeriodTime.YEAR:
      return r'YEAR';
    case Enum$PeriodTime.$unknown:
      return r'$unknown';
  }
}

Enum$PeriodTime fromJson$Enum$PeriodTime(String value) {
  switch (value) {
    case r'DAY':
      return Enum$PeriodTime.DAY;
    case r'WEEK':
      return Enum$PeriodTime.WEEK;
    case r'MONTH':
      return Enum$PeriodTime.MONTH;
    case r'YEAR':
      return Enum$PeriodTime.YEAR;
    default:
      return Enum$PeriodTime.$unknown;
  }
}

enum Enum$PolicyStatus {
  ACTIVE,
  INACTIVE,
  PENDING,
  $unknown;

  factory Enum$PolicyStatus.fromJson(String value) =>
      fromJson$Enum$PolicyStatus(value);

  String toJson() => toJson$Enum$PolicyStatus(this);
}

String toJson$Enum$PolicyStatus(Enum$PolicyStatus e) {
  switch (e) {
    case Enum$PolicyStatus.ACTIVE:
      return r'ACTIVE';
    case Enum$PolicyStatus.INACTIVE:
      return r'INACTIVE';
    case Enum$PolicyStatus.PENDING:
      return r'PENDING';
    case Enum$PolicyStatus.$unknown:
      return r'$unknown';
  }
}

Enum$PolicyStatus fromJson$Enum$PolicyStatus(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$PolicyStatus.ACTIVE;
    case r'INACTIVE':
      return Enum$PolicyStatus.INACTIVE;
    case r'PENDING':
      return Enum$PolicyStatus.PENDING;
    default:
      return Enum$PolicyStatus.$unknown;
  }
}

enum Enum$PolicyType {
  PRIVACY,
  TERMS,
  COOKIE,
  ROYALTY,
  $unknown;

  factory Enum$PolicyType.fromJson(String value) =>
      fromJson$Enum$PolicyType(value);

  String toJson() => toJson$Enum$PolicyType(this);
}

String toJson$Enum$PolicyType(Enum$PolicyType e) {
  switch (e) {
    case Enum$PolicyType.PRIVACY:
      return r'PRIVACY';
    case Enum$PolicyType.TERMS:
      return r'TERMS';
    case Enum$PolicyType.COOKIE:
      return r'COOKIE';
    case Enum$PolicyType.ROYALTY:
      return r'ROYALTY';
    case Enum$PolicyType.$unknown:
      return r'$unknown';
  }
}

Enum$PolicyType fromJson$Enum$PolicyType(String value) {
  switch (value) {
    case r'PRIVACY':
      return Enum$PolicyType.PRIVACY;
    case r'TERMS':
      return Enum$PolicyType.TERMS;
    case r'COOKIE':
      return Enum$PolicyType.COOKIE;
    case r'ROYALTY':
      return Enum$PolicyType.ROYALTY;
    default:
      return Enum$PolicyType.$unknown;
  }
}

enum Enum$PopularityActionType {
  SKIP_STREAMING,
  STREAMING,
  COMPLETE_STREAMING,
  REPEAT_STREAMING,
  FAVORITE,
  UNFAVORITE,
  SHARE,
  ADD_TO_PLAYLIST,
  REMOVE_FROM_PLAYLIST,
  COMMENT,
  SEARCH,
  SEARCH_RESULT_CLICK,
  CLICK_FROM_RECOMMENDATION,
  FOLLOW,
  UNFOLLOW,
  $unknown;

  factory Enum$PopularityActionType.fromJson(String value) =>
      fromJson$Enum$PopularityActionType(value);

  String toJson() => toJson$Enum$PopularityActionType(this);
}

String toJson$Enum$PopularityActionType(Enum$PopularityActionType e) {
  switch (e) {
    case Enum$PopularityActionType.SKIP_STREAMING:
      return r'SKIP_STREAMING';
    case Enum$PopularityActionType.STREAMING:
      return r'STREAMING';
    case Enum$PopularityActionType.COMPLETE_STREAMING:
      return r'COMPLETE_STREAMING';
    case Enum$PopularityActionType.REPEAT_STREAMING:
      return r'REPEAT_STREAMING';
    case Enum$PopularityActionType.FAVORITE:
      return r'FAVORITE';
    case Enum$PopularityActionType.UNFAVORITE:
      return r'UNFAVORITE';
    case Enum$PopularityActionType.SHARE:
      return r'SHARE';
    case Enum$PopularityActionType.ADD_TO_PLAYLIST:
      return r'ADD_TO_PLAYLIST';
    case Enum$PopularityActionType.REMOVE_FROM_PLAYLIST:
      return r'REMOVE_FROM_PLAYLIST';
    case Enum$PopularityActionType.COMMENT:
      return r'COMMENT';
    case Enum$PopularityActionType.SEARCH:
      return r'SEARCH';
    case Enum$PopularityActionType.SEARCH_RESULT_CLICK:
      return r'SEARCH_RESULT_CLICK';
    case Enum$PopularityActionType.CLICK_FROM_RECOMMENDATION:
      return r'CLICK_FROM_RECOMMENDATION';
    case Enum$PopularityActionType.FOLLOW:
      return r'FOLLOW';
    case Enum$PopularityActionType.UNFOLLOW:
      return r'UNFOLLOW';
    case Enum$PopularityActionType.$unknown:
      return r'$unknown';
  }
}

Enum$PopularityActionType fromJson$Enum$PopularityActionType(String value) {
  switch (value) {
    case r'SKIP_STREAMING':
      return Enum$PopularityActionType.SKIP_STREAMING;
    case r'STREAMING':
      return Enum$PopularityActionType.STREAMING;
    case r'COMPLETE_STREAMING':
      return Enum$PopularityActionType.COMPLETE_STREAMING;
    case r'REPEAT_STREAMING':
      return Enum$PopularityActionType.REPEAT_STREAMING;
    case r'FAVORITE':
      return Enum$PopularityActionType.FAVORITE;
    case r'UNFAVORITE':
      return Enum$PopularityActionType.UNFAVORITE;
    case r'SHARE':
      return Enum$PopularityActionType.SHARE;
    case r'ADD_TO_PLAYLIST':
      return Enum$PopularityActionType.ADD_TO_PLAYLIST;
    case r'REMOVE_FROM_PLAYLIST':
      return Enum$PopularityActionType.REMOVE_FROM_PLAYLIST;
    case r'COMMENT':
      return Enum$PopularityActionType.COMMENT;
    case r'SEARCH':
      return Enum$PopularityActionType.SEARCH;
    case r'SEARCH_RESULT_CLICK':
      return Enum$PopularityActionType.SEARCH_RESULT_CLICK;
    case r'CLICK_FROM_RECOMMENDATION':
      return Enum$PopularityActionType.CLICK_FROM_RECOMMENDATION;
    case r'FOLLOW':
      return Enum$PopularityActionType.FOLLOW;
    case r'UNFOLLOW':
      return Enum$PopularityActionType.UNFOLLOW;
    default:
      return Enum$PopularityActionType.$unknown;
  }
}

enum Enum$RecommendationAlgorithm {
  EUCLIDEAN,
  COSINE,
  $unknown;

  factory Enum$RecommendationAlgorithm.fromJson(String value) =>
      fromJson$Enum$RecommendationAlgorithm(value);

  String toJson() => toJson$Enum$RecommendationAlgorithm(this);
}

String toJson$Enum$RecommendationAlgorithm(Enum$RecommendationAlgorithm e) {
  switch (e) {
    case Enum$RecommendationAlgorithm.EUCLIDEAN:
      return r'EUCLIDEAN';
    case Enum$RecommendationAlgorithm.COSINE:
      return r'COSINE';
    case Enum$RecommendationAlgorithm.$unknown:
      return r'$unknown';
  }
}

Enum$RecommendationAlgorithm fromJson$Enum$RecommendationAlgorithm(
  String value,
) {
  switch (value) {
    case r'EUCLIDEAN':
      return Enum$RecommendationAlgorithm.EUCLIDEAN;
    case r'COSINE':
      return Enum$RecommendationAlgorithm.COSINE;
    default:
      return Enum$RecommendationAlgorithm.$unknown;
  }
}

enum Enum$RecordingStatus {
  ACTIVE,
  INACTIVE,
  PENDING,
  $unknown;

  factory Enum$RecordingStatus.fromJson(String value) =>
      fromJson$Enum$RecordingStatus(value);

  String toJson() => toJson$Enum$RecordingStatus(this);
}

String toJson$Enum$RecordingStatus(Enum$RecordingStatus e) {
  switch (e) {
    case Enum$RecordingStatus.ACTIVE:
      return r'ACTIVE';
    case Enum$RecordingStatus.INACTIVE:
      return r'INACTIVE';
    case Enum$RecordingStatus.PENDING:
      return r'PENDING';
    case Enum$RecordingStatus.$unknown:
      return r'$unknown';
  }
}

Enum$RecordingStatus fromJson$Enum$RecordingStatus(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$RecordingStatus.ACTIVE;
    case r'INACTIVE':
      return Enum$RecordingStatus.INACTIVE;
    case r'PENDING':
      return Enum$RecordingStatus.PENDING;
    default:
      return Enum$RecordingStatus.$unknown;
  }
}

enum Enum$RefundReasonType {
  DUPLICATE,
  FRAUDULENT,
  REQUESTED_BY_CUSTOMER,
  $unknown;

  factory Enum$RefundReasonType.fromJson(String value) =>
      fromJson$Enum$RefundReasonType(value);

  String toJson() => toJson$Enum$RefundReasonType(this);
}

String toJson$Enum$RefundReasonType(Enum$RefundReasonType e) {
  switch (e) {
    case Enum$RefundReasonType.DUPLICATE:
      return r'DUPLICATE';
    case Enum$RefundReasonType.FRAUDULENT:
      return r'FRAUDULENT';
    case Enum$RefundReasonType.REQUESTED_BY_CUSTOMER:
      return r'REQUESTED_BY_CUSTOMER';
    case Enum$RefundReasonType.$unknown:
      return r'$unknown';
  }
}

Enum$RefundReasonType fromJson$Enum$RefundReasonType(String value) {
  switch (value) {
    case r'DUPLICATE':
      return Enum$RefundReasonType.DUPLICATE;
    case r'FRAUDULENT':
      return Enum$RefundReasonType.FRAUDULENT;
    case r'REQUESTED_BY_CUSTOMER':
      return Enum$RefundReasonType.REQUESTED_BY_CUSTOMER;
    default:
      return Enum$RefundReasonType.$unknown;
  }
}

enum Enum$RefundTransactionStatus {
  PENDING,
  SUCCEEDED,
  FAILED,
  REQUIRES_ACTION,
  CANCELED,
  $unknown;

  factory Enum$RefundTransactionStatus.fromJson(String value) =>
      fromJson$Enum$RefundTransactionStatus(value);

  String toJson() => toJson$Enum$RefundTransactionStatus(this);
}

String toJson$Enum$RefundTransactionStatus(Enum$RefundTransactionStatus e) {
  switch (e) {
    case Enum$RefundTransactionStatus.PENDING:
      return r'PENDING';
    case Enum$RefundTransactionStatus.SUCCEEDED:
      return r'SUCCEEDED';
    case Enum$RefundTransactionStatus.FAILED:
      return r'FAILED';
    case Enum$RefundTransactionStatus.REQUIRES_ACTION:
      return r'REQUIRES_ACTION';
    case Enum$RefundTransactionStatus.CANCELED:
      return r'CANCELED';
    case Enum$RefundTransactionStatus.$unknown:
      return r'$unknown';
  }
}

Enum$RefundTransactionStatus fromJson$Enum$RefundTransactionStatus(
  String value,
) {
  switch (value) {
    case r'PENDING':
      return Enum$RefundTransactionStatus.PENDING;
    case r'SUCCEEDED':
      return Enum$RefundTransactionStatus.SUCCEEDED;
    case r'FAILED':
      return Enum$RefundTransactionStatus.FAILED;
    case r'REQUIRES_ACTION':
      return Enum$RefundTransactionStatus.REQUIRES_ACTION;
    case r'CANCELED':
      return Enum$RefundTransactionStatus.CANCELED;
    default:
      return Enum$RefundTransactionStatus.$unknown;
  }
}

enum Enum$ReleaseStatus {
  NOT_ANNOUNCED,
  DELAYED,
  CANCELED,
  BANNED,
  OFFICIAL,
  $unknown;

  factory Enum$ReleaseStatus.fromJson(String value) =>
      fromJson$Enum$ReleaseStatus(value);

  String toJson() => toJson$Enum$ReleaseStatus(this);
}

String toJson$Enum$ReleaseStatus(Enum$ReleaseStatus e) {
  switch (e) {
    case Enum$ReleaseStatus.NOT_ANNOUNCED:
      return r'NOT_ANNOUNCED';
    case Enum$ReleaseStatus.DELAYED:
      return r'DELAYED';
    case Enum$ReleaseStatus.CANCELED:
      return r'CANCELED';
    case Enum$ReleaseStatus.BANNED:
      return r'BANNED';
    case Enum$ReleaseStatus.OFFICIAL:
      return r'OFFICIAL';
    case Enum$ReleaseStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ReleaseStatus fromJson$Enum$ReleaseStatus(String value) {
  switch (value) {
    case r'NOT_ANNOUNCED':
      return Enum$ReleaseStatus.NOT_ANNOUNCED;
    case r'DELAYED':
      return Enum$ReleaseStatus.DELAYED;
    case r'CANCELED':
      return Enum$ReleaseStatus.CANCELED;
    case r'BANNED':
      return Enum$ReleaseStatus.BANNED;
    case r'OFFICIAL':
      return Enum$ReleaseStatus.OFFICIAL;
    default:
      return Enum$ReleaseStatus.$unknown;
  }
}

enum Enum$ReportAction {
  NO_ACTION,
  WARNING,
  CONTENT_REMOVAL,
  SUSPENDED,
  PERMANENT_BAN,
  ENTITLEMENT_RESTRICTION,
  $unknown;

  factory Enum$ReportAction.fromJson(String value) =>
      fromJson$Enum$ReportAction(value);

  String toJson() => toJson$Enum$ReportAction(this);
}

String toJson$Enum$ReportAction(Enum$ReportAction e) {
  switch (e) {
    case Enum$ReportAction.NO_ACTION:
      return r'NO_ACTION';
    case Enum$ReportAction.WARNING:
      return r'WARNING';
    case Enum$ReportAction.CONTENT_REMOVAL:
      return r'CONTENT_REMOVAL';
    case Enum$ReportAction.SUSPENDED:
      return r'SUSPENDED';
    case Enum$ReportAction.PERMANENT_BAN:
      return r'PERMANENT_BAN';
    case Enum$ReportAction.ENTITLEMENT_RESTRICTION:
      return r'ENTITLEMENT_RESTRICTION';
    case Enum$ReportAction.$unknown:
      return r'$unknown';
  }
}

Enum$ReportAction fromJson$Enum$ReportAction(String value) {
  switch (value) {
    case r'NO_ACTION':
      return Enum$ReportAction.NO_ACTION;
    case r'WARNING':
      return Enum$ReportAction.WARNING;
    case r'CONTENT_REMOVAL':
      return Enum$ReportAction.CONTENT_REMOVAL;
    case r'SUSPENDED':
      return Enum$ReportAction.SUSPENDED;
    case r'PERMANENT_BAN':
      return Enum$ReportAction.PERMANENT_BAN;
    case r'ENTITLEMENT_RESTRICTION':
      return Enum$ReportAction.ENTITLEMENT_RESTRICTION;
    default:
      return Enum$ReportAction.$unknown;
  }
}

enum Enum$ReportPriority {
  LOW,
  MEDIUM,
  HIGH,
  CRITICAL,
  $unknown;

  factory Enum$ReportPriority.fromJson(String value) =>
      fromJson$Enum$ReportPriority(value);

  String toJson() => toJson$Enum$ReportPriority(this);
}

String toJson$Enum$ReportPriority(Enum$ReportPriority e) {
  switch (e) {
    case Enum$ReportPriority.LOW:
      return r'LOW';
    case Enum$ReportPriority.MEDIUM:
      return r'MEDIUM';
    case Enum$ReportPriority.HIGH:
      return r'HIGH';
    case Enum$ReportPriority.CRITICAL:
      return r'CRITICAL';
    case Enum$ReportPriority.$unknown:
      return r'$unknown';
  }
}

Enum$ReportPriority fromJson$Enum$ReportPriority(String value) {
  switch (value) {
    case r'LOW':
      return Enum$ReportPriority.LOW;
    case r'MEDIUM':
      return Enum$ReportPriority.MEDIUM;
    case r'HIGH':
      return Enum$ReportPriority.HIGH;
    case r'CRITICAL':
      return Enum$ReportPriority.CRITICAL;
    default:
      return Enum$ReportPriority.$unknown;
  }
}

enum Enum$ReportRelatedContentType {
  TRACK,
  ARTIST,
  LISTENER,
  COMMENT,
  REQUEST,
  $unknown;

  factory Enum$ReportRelatedContentType.fromJson(String value) =>
      fromJson$Enum$ReportRelatedContentType(value);

  String toJson() => toJson$Enum$ReportRelatedContentType(this);
}

String toJson$Enum$ReportRelatedContentType(Enum$ReportRelatedContentType e) {
  switch (e) {
    case Enum$ReportRelatedContentType.TRACK:
      return r'TRACK';
    case Enum$ReportRelatedContentType.ARTIST:
      return r'ARTIST';
    case Enum$ReportRelatedContentType.LISTENER:
      return r'LISTENER';
    case Enum$ReportRelatedContentType.COMMENT:
      return r'COMMENT';
    case Enum$ReportRelatedContentType.REQUEST:
      return r'REQUEST';
    case Enum$ReportRelatedContentType.$unknown:
      return r'$unknown';
  }
}

Enum$ReportRelatedContentType fromJson$Enum$ReportRelatedContentType(
  String value,
) {
  switch (value) {
    case r'TRACK':
      return Enum$ReportRelatedContentType.TRACK;
    case r'ARTIST':
      return Enum$ReportRelatedContentType.ARTIST;
    case r'LISTENER':
      return Enum$ReportRelatedContentType.LISTENER;
    case r'COMMENT':
      return Enum$ReportRelatedContentType.COMMENT;
    case r'REQUEST':
      return Enum$ReportRelatedContentType.REQUEST;
    default:
      return Enum$ReportRelatedContentType.$unknown;
  }
}

enum Enum$ReportStatus {
  PENDING,
  UNDER_REVIEW,
  APPROVED,
  REJECTED,
  RESTORED,
  ESCALATED,
  $unknown;

  factory Enum$ReportStatus.fromJson(String value) =>
      fromJson$Enum$ReportStatus(value);

  String toJson() => toJson$Enum$ReportStatus(this);
}

String toJson$Enum$ReportStatus(Enum$ReportStatus e) {
  switch (e) {
    case Enum$ReportStatus.PENDING:
      return r'PENDING';
    case Enum$ReportStatus.UNDER_REVIEW:
      return r'UNDER_REVIEW';
    case Enum$ReportStatus.APPROVED:
      return r'APPROVED';
    case Enum$ReportStatus.REJECTED:
      return r'REJECTED';
    case Enum$ReportStatus.RESTORED:
      return r'RESTORED';
    case Enum$ReportStatus.ESCALATED:
      return r'ESCALATED';
    case Enum$ReportStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ReportStatus fromJson$Enum$ReportStatus(String value) {
  switch (value) {
    case r'PENDING':
      return Enum$ReportStatus.PENDING;
    case r'UNDER_REVIEW':
      return Enum$ReportStatus.UNDER_REVIEW;
    case r'APPROVED':
      return Enum$ReportStatus.APPROVED;
    case r'REJECTED':
      return Enum$ReportStatus.REJECTED;
    case r'RESTORED':
      return Enum$ReportStatus.RESTORED;
    case r'ESCALATED':
      return Enum$ReportStatus.ESCALATED;
    default:
      return Enum$ReportStatus.$unknown;
  }
}

enum Enum$ReportType {
  SPAM,
  HARASSMENT,
  HATE_SPEECH,
  INAPPROPRIATE_CONTENT,
  IMPERSONATION,
  COPYRIGHT_VIOLATION,
  FAKE_ACCOUNT,
  SCAM_OR_FRAUD,
  SELF_HARM_OR_DANGEROUS_CONTENT,
  OTHER,
  $unknown;

  factory Enum$ReportType.fromJson(String value) =>
      fromJson$Enum$ReportType(value);

  String toJson() => toJson$Enum$ReportType(this);
}

String toJson$Enum$ReportType(Enum$ReportType e) {
  switch (e) {
    case Enum$ReportType.SPAM:
      return r'SPAM';
    case Enum$ReportType.HARASSMENT:
      return r'HARASSMENT';
    case Enum$ReportType.HATE_SPEECH:
      return r'HATE_SPEECH';
    case Enum$ReportType.INAPPROPRIATE_CONTENT:
      return r'INAPPROPRIATE_CONTENT';
    case Enum$ReportType.IMPERSONATION:
      return r'IMPERSONATION';
    case Enum$ReportType.COPYRIGHT_VIOLATION:
      return r'COPYRIGHT_VIOLATION';
    case Enum$ReportType.FAKE_ACCOUNT:
      return r'FAKE_ACCOUNT';
    case Enum$ReportType.SCAM_OR_FRAUD:
      return r'SCAM_OR_FRAUD';
    case Enum$ReportType.SELF_HARM_OR_DANGEROUS_CONTENT:
      return r'SELF_HARM_OR_DANGEROUS_CONTENT';
    case Enum$ReportType.OTHER:
      return r'OTHER';
    case Enum$ReportType.$unknown:
      return r'$unknown';
  }
}

Enum$ReportType fromJson$Enum$ReportType(String value) {
  switch (value) {
    case r'SPAM':
      return Enum$ReportType.SPAM;
    case r'HARASSMENT':
      return Enum$ReportType.HARASSMENT;
    case r'HATE_SPEECH':
      return Enum$ReportType.HATE_SPEECH;
    case r'INAPPROPRIATE_CONTENT':
      return Enum$ReportType.INAPPROPRIATE_CONTENT;
    case r'IMPERSONATION':
      return Enum$ReportType.IMPERSONATION;
    case r'COPYRIGHT_VIOLATION':
      return Enum$ReportType.COPYRIGHT_VIOLATION;
    case r'FAKE_ACCOUNT':
      return Enum$ReportType.FAKE_ACCOUNT;
    case r'SCAM_OR_FRAUD':
      return Enum$ReportType.SCAM_OR_FRAUD;
    case r'SELF_HARM_OR_DANGEROUS_CONTENT':
      return Enum$ReportType.SELF_HARM_OR_DANGEROUS_CONTENT;
    case r'OTHER':
      return Enum$ReportType.OTHER;
    default:
      return Enum$ReportType.$unknown;
  }
}

enum Enum$RequestStatus {
  BLOCKED,
  CLOSED,
  OPEN,
  DELETED,
  CONFIRMED,
  REJECTED,
  CANCELED,
  PENDING,
  $unknown;

  factory Enum$RequestStatus.fromJson(String value) =>
      fromJson$Enum$RequestStatus(value);

  String toJson() => toJson$Enum$RequestStatus(this);
}

String toJson$Enum$RequestStatus(Enum$RequestStatus e) {
  switch (e) {
    case Enum$RequestStatus.BLOCKED:
      return r'BLOCKED';
    case Enum$RequestStatus.CLOSED:
      return r'CLOSED';
    case Enum$RequestStatus.OPEN:
      return r'OPEN';
    case Enum$RequestStatus.DELETED:
      return r'DELETED';
    case Enum$RequestStatus.CONFIRMED:
      return r'CONFIRMED';
    case Enum$RequestStatus.REJECTED:
      return r'REJECTED';
    case Enum$RequestStatus.CANCELED:
      return r'CANCELED';
    case Enum$RequestStatus.PENDING:
      return r'PENDING';
    case Enum$RequestStatus.$unknown:
      return r'$unknown';
  }
}

Enum$RequestStatus fromJson$Enum$RequestStatus(String value) {
  switch (value) {
    case r'BLOCKED':
      return Enum$RequestStatus.BLOCKED;
    case r'CLOSED':
      return Enum$RequestStatus.CLOSED;
    case r'OPEN':
      return Enum$RequestStatus.OPEN;
    case r'DELETED':
      return Enum$RequestStatus.DELETED;
    case r'CONFIRMED':
      return Enum$RequestStatus.CONFIRMED;
    case r'REJECTED':
      return Enum$RequestStatus.REJECTED;
    case r'CANCELED':
      return Enum$RequestStatus.CANCELED;
    case r'PENDING':
      return Enum$RequestStatus.PENDING;
    default:
      return Enum$RequestStatus.$unknown;
  }
}

enum Enum$RequestType {
  PUBLIC_REQUEST,
  DIRECT_REQUEST,
  $unknown;

  factory Enum$RequestType.fromJson(String value) =>
      fromJson$Enum$RequestType(value);

  String toJson() => toJson$Enum$RequestType(this);
}

String toJson$Enum$RequestType(Enum$RequestType e) {
  switch (e) {
    case Enum$RequestType.PUBLIC_REQUEST:
      return r'PUBLIC_REQUEST';
    case Enum$RequestType.DIRECT_REQUEST:
      return r'DIRECT_REQUEST';
    case Enum$RequestType.$unknown:
      return r'$unknown';
  }
}

Enum$RequestType fromJson$Enum$RequestType(String value) {
  switch (value) {
    case r'PUBLIC_REQUEST':
      return Enum$RequestType.PUBLIC_REQUEST;
    case r'DIRECT_REQUEST':
      return Enum$RequestType.DIRECT_REQUEST;
    default:
      return Enum$RequestType.$unknown;
  }
}

enum Enum$RestrictionAction {
  NONE,
  REPORT,
  COMMENT,
  UPLOAD_TRACK,
  CREATE_PUBLIC_REQUEST,
  SEND_REQUEST,
  $unknown;

  factory Enum$RestrictionAction.fromJson(String value) =>
      fromJson$Enum$RestrictionAction(value);

  String toJson() => toJson$Enum$RestrictionAction(this);
}

String toJson$Enum$RestrictionAction(Enum$RestrictionAction e) {
  switch (e) {
    case Enum$RestrictionAction.NONE:
      return r'NONE';
    case Enum$RestrictionAction.REPORT:
      return r'REPORT';
    case Enum$RestrictionAction.COMMENT:
      return r'COMMENT';
    case Enum$RestrictionAction.UPLOAD_TRACK:
      return r'UPLOAD_TRACK';
    case Enum$RestrictionAction.CREATE_PUBLIC_REQUEST:
      return r'CREATE_PUBLIC_REQUEST';
    case Enum$RestrictionAction.SEND_REQUEST:
      return r'SEND_REQUEST';
    case Enum$RestrictionAction.$unknown:
      return r'$unknown';
  }
}

Enum$RestrictionAction fromJson$Enum$RestrictionAction(String value) {
  switch (value) {
    case r'NONE':
      return Enum$RestrictionAction.NONE;
    case r'REPORT':
      return Enum$RestrictionAction.REPORT;
    case r'COMMENT':
      return Enum$RestrictionAction.COMMENT;
    case r'UPLOAD_TRACK':
      return Enum$RestrictionAction.UPLOAD_TRACK;
    case r'CREATE_PUBLIC_REQUEST':
      return Enum$RestrictionAction.CREATE_PUBLIC_REQUEST;
    case r'SEND_REQUEST':
      return Enum$RestrictionAction.SEND_REQUEST;
    default:
      return Enum$RestrictionAction.$unknown;
  }
}

enum Enum$RestrictionType {
  NONE,
  BANNED,
  SUSPENDED,
  $unknown;

  factory Enum$RestrictionType.fromJson(String value) =>
      fromJson$Enum$RestrictionType(value);

  String toJson() => toJson$Enum$RestrictionType(this);
}

String toJson$Enum$RestrictionType(Enum$RestrictionType e) {
  switch (e) {
    case Enum$RestrictionType.NONE:
      return r'NONE';
    case Enum$RestrictionType.BANNED:
      return r'BANNED';
    case Enum$RestrictionType.SUSPENDED:
      return r'SUSPENDED';
    case Enum$RestrictionType.$unknown:
      return r'$unknown';
  }
}

Enum$RestrictionType fromJson$Enum$RestrictionType(String value) {
  switch (value) {
    case r'NONE':
      return Enum$RestrictionType.NONE;
    case r'BANNED':
      return Enum$RestrictionType.BANNED;
    case r'SUSPENDED':
      return Enum$RestrictionType.SUSPENDED;
    default:
      return Enum$RestrictionType.$unknown;
  }
}

enum Enum$SortEnumType {
  ASC,
  DESC,
  $unknown;

  factory Enum$SortEnumType.fromJson(String value) =>
      fromJson$Enum$SortEnumType(value);

  String toJson() => toJson$Enum$SortEnumType(this);
}

String toJson$Enum$SortEnumType(Enum$SortEnumType e) {
  switch (e) {
    case Enum$SortEnumType.ASC:
      return r'ASC';
    case Enum$SortEnumType.DESC:
      return r'DESC';
    case Enum$SortEnumType.$unknown:
      return r'$unknown';
  }
}

Enum$SortEnumType fromJson$Enum$SortEnumType(String value) {
  switch (value) {
    case r'ASC':
      return Enum$SortEnumType.ASC;
    case r'DESC':
      return Enum$SortEnumType.DESC;
    default:
      return Enum$SortEnumType.$unknown;
  }
}

enum Enum$StripeSubscriptionCancelMode {
  IMMEDIATELY,
  AT_PERIOD_END,
  $unknown;

  factory Enum$StripeSubscriptionCancelMode.fromJson(String value) =>
      fromJson$Enum$StripeSubscriptionCancelMode(value);

  String toJson() => toJson$Enum$StripeSubscriptionCancelMode(this);
}

String toJson$Enum$StripeSubscriptionCancelMode(
  Enum$StripeSubscriptionCancelMode e,
) {
  switch (e) {
    case Enum$StripeSubscriptionCancelMode.IMMEDIATELY:
      return r'IMMEDIATELY';
    case Enum$StripeSubscriptionCancelMode.AT_PERIOD_END:
      return r'AT_PERIOD_END';
    case Enum$StripeSubscriptionCancelMode.$unknown:
      return r'$unknown';
  }
}

Enum$StripeSubscriptionCancelMode fromJson$Enum$StripeSubscriptionCancelMode(
  String value,
) {
  switch (value) {
    case r'IMMEDIATELY':
      return Enum$StripeSubscriptionCancelMode.IMMEDIATELY;
    case r'AT_PERIOD_END':
      return Enum$StripeSubscriptionCancelMode.AT_PERIOD_END;
    default:
      return Enum$StripeSubscriptionCancelMode.$unknown;
  }
}

enum Enum$StripeSubscriptionUpdate {
  PRICE,
  PROMOTION_CODE,
  QUANTITY,
  $unknown;

  factory Enum$StripeSubscriptionUpdate.fromJson(String value) =>
      fromJson$Enum$StripeSubscriptionUpdate(value);

  String toJson() => toJson$Enum$StripeSubscriptionUpdate(this);
}

String toJson$Enum$StripeSubscriptionUpdate(Enum$StripeSubscriptionUpdate e) {
  switch (e) {
    case Enum$StripeSubscriptionUpdate.PRICE:
      return r'PRICE';
    case Enum$StripeSubscriptionUpdate.PROMOTION_CODE:
      return r'PROMOTION_CODE';
    case Enum$StripeSubscriptionUpdate.QUANTITY:
      return r'QUANTITY';
    case Enum$StripeSubscriptionUpdate.$unknown:
      return r'$unknown';
  }
}

Enum$StripeSubscriptionUpdate fromJson$Enum$StripeSubscriptionUpdate(
  String value,
) {
  switch (value) {
    case r'PRICE':
      return Enum$StripeSubscriptionUpdate.PRICE;
    case r'PROMOTION_CODE':
      return Enum$StripeSubscriptionUpdate.PROMOTION_CODE;
    case r'QUANTITY':
      return Enum$StripeSubscriptionUpdate.QUANTITY;
    default:
      return Enum$StripeSubscriptionUpdate.$unknown;
  }
}

enum Enum$SubscriptionCycle {
  WEEKLY,
  MONTHLY,
  YEARLY,
  LIFETIME,
  $unknown;

  factory Enum$SubscriptionCycle.fromJson(String value) =>
      fromJson$Enum$SubscriptionCycle(value);

  String toJson() => toJson$Enum$SubscriptionCycle(this);
}

String toJson$Enum$SubscriptionCycle(Enum$SubscriptionCycle e) {
  switch (e) {
    case Enum$SubscriptionCycle.WEEKLY:
      return r'WEEKLY';
    case Enum$SubscriptionCycle.MONTHLY:
      return r'MONTHLY';
    case Enum$SubscriptionCycle.YEARLY:
      return r'YEARLY';
    case Enum$SubscriptionCycle.LIFETIME:
      return r'LIFETIME';
    case Enum$SubscriptionCycle.$unknown:
      return r'$unknown';
  }
}

Enum$SubscriptionCycle fromJson$Enum$SubscriptionCycle(String value) {
  switch (value) {
    case r'WEEKLY':
      return Enum$SubscriptionCycle.WEEKLY;
    case r'MONTHLY':
      return Enum$SubscriptionCycle.MONTHLY;
    case r'YEARLY':
      return Enum$SubscriptionCycle.YEARLY;
    case r'LIFETIME':
      return Enum$SubscriptionCycle.LIFETIME;
    default:
      return Enum$SubscriptionCycle.$unknown;
  }
}

enum Enum$SubscriptionStatus {
  INACTIVE,
  ACTIVE,
  DEPRECATED,
  $unknown;

  factory Enum$SubscriptionStatus.fromJson(String value) =>
      fromJson$Enum$SubscriptionStatus(value);

  String toJson() => toJson$Enum$SubscriptionStatus(this);
}

String toJson$Enum$SubscriptionStatus(Enum$SubscriptionStatus e) {
  switch (e) {
    case Enum$SubscriptionStatus.INACTIVE:
      return r'INACTIVE';
    case Enum$SubscriptionStatus.ACTIVE:
      return r'ACTIVE';
    case Enum$SubscriptionStatus.DEPRECATED:
      return r'DEPRECATED';
    case Enum$SubscriptionStatus.$unknown:
      return r'$unknown';
  }
}

Enum$SubscriptionStatus fromJson$Enum$SubscriptionStatus(String value) {
  switch (value) {
    case r'INACTIVE':
      return Enum$SubscriptionStatus.INACTIVE;
    case r'ACTIVE':
      return Enum$SubscriptionStatus.ACTIVE;
    case r'DEPRECATED':
      return Enum$SubscriptionStatus.DEPRECATED;
    default:
      return Enum$SubscriptionStatus.$unknown;
  }
}

enum Enum$SubscriptionTier {
  FREE,
  PREMIUM,
  PRO,
  $unknown;

  factory Enum$SubscriptionTier.fromJson(String value) =>
      fromJson$Enum$SubscriptionTier(value);

  String toJson() => toJson$Enum$SubscriptionTier(this);
}

String toJson$Enum$SubscriptionTier(Enum$SubscriptionTier e) {
  switch (e) {
    case Enum$SubscriptionTier.FREE:
      return r'FREE';
    case Enum$SubscriptionTier.PREMIUM:
      return r'PREMIUM';
    case Enum$SubscriptionTier.PRO:
      return r'PRO';
    case Enum$SubscriptionTier.$unknown:
      return r'$unknown';
  }
}

Enum$SubscriptionTier fromJson$Enum$SubscriptionTier(String value) {
  switch (value) {
    case r'FREE':
      return Enum$SubscriptionTier.FREE;
    case r'PREMIUM':
      return Enum$SubscriptionTier.PREMIUM;
    case r'PRO':
      return Enum$SubscriptionTier.PRO;
    default:
      return Enum$SubscriptionTier.$unknown;
  }
}

enum Enum$TrackType {
  ORIGINAL,
  COVER,
  REMIX,
  LIVE,
  SAMPLE,
  $unknown;

  factory Enum$TrackType.fromJson(String value) =>
      fromJson$Enum$TrackType(value);

  String toJson() => toJson$Enum$TrackType(this);
}

String toJson$Enum$TrackType(Enum$TrackType e) {
  switch (e) {
    case Enum$TrackType.ORIGINAL:
      return r'ORIGINAL';
    case Enum$TrackType.COVER:
      return r'COVER';
    case Enum$TrackType.REMIX:
      return r'REMIX';
    case Enum$TrackType.LIVE:
      return r'LIVE';
    case Enum$TrackType.SAMPLE:
      return r'SAMPLE';
    case Enum$TrackType.$unknown:
      return r'$unknown';
  }
}

Enum$TrackType fromJson$Enum$TrackType(String value) {
  switch (value) {
    case r'ORIGINAL':
      return Enum$TrackType.ORIGINAL;
    case r'COVER':
      return Enum$TrackType.COVER;
    case r'REMIX':
      return Enum$TrackType.REMIX;
    case r'LIVE':
      return Enum$TrackType.LIVE;
    case r'SAMPLE':
      return Enum$TrackType.SAMPLE;
    default:
      return Enum$TrackType.$unknown;
  }
}

enum Enum$TransactionStatus {
  OPEN,
  COMPLETED,
  EXPIRED,
  $unknown;

  factory Enum$TransactionStatus.fromJson(String value) =>
      fromJson$Enum$TransactionStatus(value);

  String toJson() => toJson$Enum$TransactionStatus(this);
}

String toJson$Enum$TransactionStatus(Enum$TransactionStatus e) {
  switch (e) {
    case Enum$TransactionStatus.OPEN:
      return r'OPEN';
    case Enum$TransactionStatus.COMPLETED:
      return r'COMPLETED';
    case Enum$TransactionStatus.EXPIRED:
      return r'EXPIRED';
    case Enum$TransactionStatus.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionStatus fromJson$Enum$TransactionStatus(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$TransactionStatus.OPEN;
    case r'COMPLETED':
      return Enum$TransactionStatus.COMPLETED;
    case r'EXPIRED':
      return Enum$TransactionStatus.EXPIRED;
    default:
      return Enum$TransactionStatus.$unknown;
  }
}

enum Enum$UserEngagementAction {
  FOLLOW,
  LIKE,
  BOOKMARK,
  $unknown;

  factory Enum$UserEngagementAction.fromJson(String value) =>
      fromJson$Enum$UserEngagementAction(value);

  String toJson() => toJson$Enum$UserEngagementAction(this);
}

String toJson$Enum$UserEngagementAction(Enum$UserEngagementAction e) {
  switch (e) {
    case Enum$UserEngagementAction.FOLLOW:
      return r'FOLLOW';
    case Enum$UserEngagementAction.LIKE:
      return r'LIKE';
    case Enum$UserEngagementAction.BOOKMARK:
      return r'BOOKMARK';
    case Enum$UserEngagementAction.$unknown:
      return r'$unknown';
  }
}

Enum$UserEngagementAction fromJson$Enum$UserEngagementAction(String value) {
  switch (value) {
    case r'FOLLOW':
      return Enum$UserEngagementAction.FOLLOW;
    case r'LIKE':
      return Enum$UserEngagementAction.LIKE;
    case r'BOOKMARK':
      return Enum$UserEngagementAction.BOOKMARK;
    default:
      return Enum$UserEngagementAction.$unknown;
  }
}

enum Enum$UserEngagementTargetType {
  ARTIST,
  LISTENER,
  TRACK,
  PLAYLIST,
  ALBUM,
  $unknown;

  factory Enum$UserEngagementTargetType.fromJson(String value) =>
      fromJson$Enum$UserEngagementTargetType(value);

  String toJson() => toJson$Enum$UserEngagementTargetType(this);
}

String toJson$Enum$UserEngagementTargetType(Enum$UserEngagementTargetType e) {
  switch (e) {
    case Enum$UserEngagementTargetType.ARTIST:
      return r'ARTIST';
    case Enum$UserEngagementTargetType.LISTENER:
      return r'LISTENER';
    case Enum$UserEngagementTargetType.TRACK:
      return r'TRACK';
    case Enum$UserEngagementTargetType.PLAYLIST:
      return r'PLAYLIST';
    case Enum$UserEngagementTargetType.ALBUM:
      return r'ALBUM';
    case Enum$UserEngagementTargetType.$unknown:
      return r'$unknown';
  }
}

Enum$UserEngagementTargetType fromJson$Enum$UserEngagementTargetType(
  String value,
) {
  switch (value) {
    case r'ARTIST':
      return Enum$UserEngagementTargetType.ARTIST;
    case r'LISTENER':
      return Enum$UserEngagementTargetType.LISTENER;
    case r'TRACK':
      return Enum$UserEngagementTargetType.TRACK;
    case r'PLAYLIST':
      return Enum$UserEngagementTargetType.PLAYLIST;
    case r'ALBUM':
      return Enum$UserEngagementTargetType.ALBUM;
    default:
      return Enum$UserEngagementTargetType.$unknown;
  }
}

enum Enum$UserGender {
  MALE,
  FEMALE,
  OTHER,
  NOT_SPECIFIED,
  $unknown;

  factory Enum$UserGender.fromJson(String value) =>
      fromJson$Enum$UserGender(value);

  String toJson() => toJson$Enum$UserGender(this);
}

String toJson$Enum$UserGender(Enum$UserGender e) {
  switch (e) {
    case Enum$UserGender.MALE:
      return r'MALE';
    case Enum$UserGender.FEMALE:
      return r'FEMALE';
    case Enum$UserGender.OTHER:
      return r'OTHER';
    case Enum$UserGender.NOT_SPECIFIED:
      return r'NOT_SPECIFIED';
    case Enum$UserGender.$unknown:
      return r'$unknown';
  }
}

Enum$UserGender fromJson$Enum$UserGender(String value) {
  switch (value) {
    case r'MALE':
      return Enum$UserGender.MALE;
    case r'FEMALE':
      return Enum$UserGender.FEMALE;
    case r'OTHER':
      return Enum$UserGender.OTHER;
    case r'NOT_SPECIFIED':
      return Enum$UserGender.NOT_SPECIFIED;
    default:
      return Enum$UserGender.$unknown;
  }
}

enum Enum$UserRole {
  ADMIN,
  MODERATOR,
  ARTIST,
  LISTENER,
  GUEST,
  $unknown;

  factory Enum$UserRole.fromJson(String value) => fromJson$Enum$UserRole(value);

  String toJson() => toJson$Enum$UserRole(this);
}

String toJson$Enum$UserRole(Enum$UserRole e) {
  switch (e) {
    case Enum$UserRole.ADMIN:
      return r'ADMIN';
    case Enum$UserRole.MODERATOR:
      return r'MODERATOR';
    case Enum$UserRole.ARTIST:
      return r'ARTIST';
    case Enum$UserRole.LISTENER:
      return r'LISTENER';
    case Enum$UserRole.GUEST:
      return r'GUEST';
    case Enum$UserRole.$unknown:
      return r'$unknown';
  }
}

Enum$UserRole fromJson$Enum$UserRole(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$UserRole.ADMIN;
    case r'MODERATOR':
      return Enum$UserRole.MODERATOR;
    case r'ARTIST':
      return Enum$UserRole.ARTIST;
    case r'LISTENER':
      return Enum$UserRole.LISTENER;
    case r'GUEST':
      return Enum$UserRole.GUEST;
    default:
      return Enum$UserRole.$unknown;
  }
}

enum Enum$UserStatus {
  ACTIVE,
  INACTIVE,
  BANNED,
  SUSPENDED,
  $unknown;

  factory Enum$UserStatus.fromJson(String value) =>
      fromJson$Enum$UserStatus(value);

  String toJson() => toJson$Enum$UserStatus(this);
}

String toJson$Enum$UserStatus(Enum$UserStatus e) {
  switch (e) {
    case Enum$UserStatus.ACTIVE:
      return r'ACTIVE';
    case Enum$UserStatus.INACTIVE:
      return r'INACTIVE';
    case Enum$UserStatus.BANNED:
      return r'BANNED';
    case Enum$UserStatus.SUSPENDED:
      return r'SUSPENDED';
    case Enum$UserStatus.$unknown:
      return r'$unknown';
  }
}

Enum$UserStatus fromJson$Enum$UserStatus(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$UserStatus.ACTIVE;
    case r'INACTIVE':
      return Enum$UserStatus.INACTIVE;
    case r'BANNED':
      return Enum$UserStatus.BANNED;
    case r'SUSPENDED':
      return Enum$UserStatus.SUSPENDED;
    default:
      return Enum$UserStatus.$unknown;
  }
}

enum Enum$WorkStatus {
  ACTIVE,
  INACTIVE,
  PENDING,
  $unknown;

  factory Enum$WorkStatus.fromJson(String value) =>
      fromJson$Enum$WorkStatus(value);

  String toJson() => toJson$Enum$WorkStatus(this);
}

String toJson$Enum$WorkStatus(Enum$WorkStatus e) {
  switch (e) {
    case Enum$WorkStatus.ACTIVE:
      return r'ACTIVE';
    case Enum$WorkStatus.INACTIVE:
      return r'INACTIVE';
    case Enum$WorkStatus.PENDING:
      return r'PENDING';
    case Enum$WorkStatus.$unknown:
      return r'$unknown';
  }
}

Enum$WorkStatus fromJson$Enum$WorkStatus(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$WorkStatus.ACTIVE;
    case r'INACTIVE':
      return Enum$WorkStatus.INACTIVE;
    case r'PENDING':
      return Enum$WorkStatus.PENDING;
    default:
      return Enum$WorkStatus.$unknown;
  }
}

enum Enum$__TypeKind {
  SCALAR,
  OBJECT,
  INTERFACE,
  UNION,
  ENUM,
  INPUT_OBJECT,
  LIST,
  NON_NULL,
  $unknown;

  factory Enum$__TypeKind.fromJson(String value) =>
      fromJson$Enum$__TypeKind(value);

  String toJson() => toJson$Enum$__TypeKind(this);
}

String toJson$Enum$__TypeKind(Enum$__TypeKind e) {
  switch (e) {
    case Enum$__TypeKind.SCALAR:
      return r'SCALAR';
    case Enum$__TypeKind.OBJECT:
      return r'OBJECT';
    case Enum$__TypeKind.INTERFACE:
      return r'INTERFACE';
    case Enum$__TypeKind.UNION:
      return r'UNION';
    case Enum$__TypeKind.ENUM:
      return r'ENUM';
    case Enum$__TypeKind.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__TypeKind.LIST:
      return r'LIST';
    case Enum$__TypeKind.NON_NULL:
      return r'NON_NULL';
    case Enum$__TypeKind.$unknown:
      return r'$unknown';
  }
}

Enum$__TypeKind fromJson$Enum$__TypeKind(String value) {
  switch (value) {
    case r'SCALAR':
      return Enum$__TypeKind.SCALAR;
    case r'OBJECT':
      return Enum$__TypeKind.OBJECT;
    case r'INTERFACE':
      return Enum$__TypeKind.INTERFACE;
    case r'UNION':
      return Enum$__TypeKind.UNION;
    case r'ENUM':
      return Enum$__TypeKind.ENUM;
    case r'INPUT_OBJECT':
      return Enum$__TypeKind.INPUT_OBJECT;
    case r'LIST':
      return Enum$__TypeKind.LIST;
    case r'NON_NULL':
      return Enum$__TypeKind.NON_NULL;
    default:
      return Enum$__TypeKind.$unknown;
  }
}

enum Enum$__DirectiveLocation {
  QUERY,
  MUTATION,
  SUBSCRIPTION,
  FIELD,
  FRAGMENT_DEFINITION,
  FRAGMENT_SPREAD,
  INLINE_FRAGMENT,
  VARIABLE_DEFINITION,
  SCHEMA,
  SCALAR,
  OBJECT,
  FIELD_DEFINITION,
  ARGUMENT_DEFINITION,
  INTERFACE,
  UNION,
  ENUM,
  ENUM_VALUE,
  INPUT_OBJECT,
  INPUT_FIELD_DEFINITION,
  $unknown;

  factory Enum$__DirectiveLocation.fromJson(String value) =>
      fromJson$Enum$__DirectiveLocation(value);

  String toJson() => toJson$Enum$__DirectiveLocation(this);
}

String toJson$Enum$__DirectiveLocation(Enum$__DirectiveLocation e) {
  switch (e) {
    case Enum$__DirectiveLocation.QUERY:
      return r'QUERY';
    case Enum$__DirectiveLocation.MUTATION:
      return r'MUTATION';
    case Enum$__DirectiveLocation.SUBSCRIPTION:
      return r'SUBSCRIPTION';
    case Enum$__DirectiveLocation.FIELD:
      return r'FIELD';
    case Enum$__DirectiveLocation.FRAGMENT_DEFINITION:
      return r'FRAGMENT_DEFINITION';
    case Enum$__DirectiveLocation.FRAGMENT_SPREAD:
      return r'FRAGMENT_SPREAD';
    case Enum$__DirectiveLocation.INLINE_FRAGMENT:
      return r'INLINE_FRAGMENT';
    case Enum$__DirectiveLocation.VARIABLE_DEFINITION:
      return r'VARIABLE_DEFINITION';
    case Enum$__DirectiveLocation.SCHEMA:
      return r'SCHEMA';
    case Enum$__DirectiveLocation.SCALAR:
      return r'SCALAR';
    case Enum$__DirectiveLocation.OBJECT:
      return r'OBJECT';
    case Enum$__DirectiveLocation.FIELD_DEFINITION:
      return r'FIELD_DEFINITION';
    case Enum$__DirectiveLocation.ARGUMENT_DEFINITION:
      return r'ARGUMENT_DEFINITION';
    case Enum$__DirectiveLocation.INTERFACE:
      return r'INTERFACE';
    case Enum$__DirectiveLocation.UNION:
      return r'UNION';
    case Enum$__DirectiveLocation.ENUM:
      return r'ENUM';
    case Enum$__DirectiveLocation.ENUM_VALUE:
      return r'ENUM_VALUE';
    case Enum$__DirectiveLocation.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION:
      return r'INPUT_FIELD_DEFINITION';
    case Enum$__DirectiveLocation.$unknown:
      return r'$unknown';
  }
}

Enum$__DirectiveLocation fromJson$Enum$__DirectiveLocation(String value) {
  switch (value) {
    case r'QUERY':
      return Enum$__DirectiveLocation.QUERY;
    case r'MUTATION':
      return Enum$__DirectiveLocation.MUTATION;
    case r'SUBSCRIPTION':
      return Enum$__DirectiveLocation.SUBSCRIPTION;
    case r'FIELD':
      return Enum$__DirectiveLocation.FIELD;
    case r'FRAGMENT_DEFINITION':
      return Enum$__DirectiveLocation.FRAGMENT_DEFINITION;
    case r'FRAGMENT_SPREAD':
      return Enum$__DirectiveLocation.FRAGMENT_SPREAD;
    case r'INLINE_FRAGMENT':
      return Enum$__DirectiveLocation.INLINE_FRAGMENT;
    case r'VARIABLE_DEFINITION':
      return Enum$__DirectiveLocation.VARIABLE_DEFINITION;
    case r'SCHEMA':
      return Enum$__DirectiveLocation.SCHEMA;
    case r'SCALAR':
      return Enum$__DirectiveLocation.SCALAR;
    case r'OBJECT':
      return Enum$__DirectiveLocation.OBJECT;
    case r'FIELD_DEFINITION':
      return Enum$__DirectiveLocation.FIELD_DEFINITION;
    case r'ARGUMENT_DEFINITION':
      return Enum$__DirectiveLocation.ARGUMENT_DEFINITION;
    case r'INTERFACE':
      return Enum$__DirectiveLocation.INTERFACE;
    case r'UNION':
      return Enum$__DirectiveLocation.UNION;
    case r'ENUM':
      return Enum$__DirectiveLocation.ENUM;
    case r'ENUM_VALUE':
      return Enum$__DirectiveLocation.ENUM_VALUE;
    case r'INPUT_OBJECT':
      return Enum$__DirectiveLocation.INPUT_OBJECT;
    case r'INPUT_FIELD_DEFINITION':
      return Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION;
    default:
      return Enum$__DirectiveLocation.$unknown;
  }
}

const possibleTypesMap = <String, Set<String>>{};
